<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TAU Guides</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
       <?php include("../../header.php") ?>
       <div id="content">
    <div class="set" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauGuides"></a>TAU Guides</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">University of</span> <span class="surname">Oregon</span></h3></div></div></div><div><p class="copyright">Copyright &copy; 2021 University of Oregon</p></div><div><div class="legalnotice"><a name="d0e25"></a><p>Version 2.22.1</p><p>Copyright &copy; 1997-2012
      Department of Computer and Information Science, University of Oregon 
      Advanced Computing Laboratory, LANL, NM 
      Research Centre Julich, ZAM, Germany</p><p>Permission to use, copy, modify, and distribute this software and
	its documentation for any purpose and without fee is hereby granted,
	provided that the above copyright notice appear in all copies and that
	both that copyright notice and this permission notice appear in
	supporting documentation, and that the name of University of Oregon (UO)
	Research Centre Julich, (ZAM) and Los Alamos National Laboratory (LANL)
	not be used in advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.  The University of
	Oregon, ZAM and LANL make no representations about the suitability of
	this software for any purpose.  It is provided "as is" without express or
	implied warranty.</p><p>UO, ZAM AND LANL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
	SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF OREGON, ZAM OR LANL BE
	LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      </p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>TAU can be found on the web at: <a href="http://www.cs.uoregon.edu/research/tau" target="_top">http://www.cs.uoregon.edu/research/tau</a></p></div></div><div><p class="pubdate">2012-03-26</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="book"><a href="#TauUsersGuide">TAU User Guides</a></span></dt><dd><dl><dt><span class="preface"><a href="#d0e109"></a></span></dt><dt><span class="part"><a href="#TAUUSERMANUAL">I. Tau User Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tauInstrumentation">1. Tau Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e234">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e239">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e267">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Profiling">2. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Analysis">4. Analyzing Parallel Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></dd><dt><span class="chapter"><a href="#StartersGuide">5. Quick Reference</a></span></dt><dt><span class="chapter"><a href="#ApplicationScenario">6. Some Common Application Scenario</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e688">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e707">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e729">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e751">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e773">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e795">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e814">6.7. Q. How does my application scale?
</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#ParaProfDoc">II. ParaProf - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#paraprof.intro">7. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.views">8. Views and Sub-Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.trialmanagement">9. Profile Data Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.3d">10. 3-D Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.threaddisplays">11. Thread Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.functiondisplays">12. Function Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.phasedisplays">13. Phase Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.comparison">14. Comparative Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.otherdisplays">15. Miscellaneous Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.preferences">16. Preferences</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#PerfExplorerDoc">III. PerfExplorer - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#Introduction">17. Introduction</a></span></dt><dt><span class="chapter"><a href="#InstallPerfExplorer">18. Installation and Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RunningPerfExplorer">19. Running PerfExplorer</a></span></dt><dt><span class="chapter"><a href="#ClusterAnalysis">20. Cluster Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#CorrelationAnalysis">21. Correlation Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Charts">22. Charts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CustomCharts">23. Custom Charts</a></span></dt><dt><span class="chapter"><a href="#Visualization">24. Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Views">25. Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Scripting">26. Running PerfExplorer Scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Derived Metrics">27. Derived Metrics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#TAUdbDoc">IV. TAUdb</a></span></dt><dd><dl><dt><span class="chapter"><a href="#taudb.intro">28. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">29. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">30. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">31. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></dd></dl></dd><dt><span class="book"><a href="#TauInstallGuide">TAU Install Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tau.installation">1. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2951">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3016">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3107">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3164">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3446">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e3451">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e3461">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e3466">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></dd></dl></dd><dt><span class="book"><a href="#TauReferenceGuide">TAU Reference Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tau.installation">1. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3661">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3726">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3817">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3874">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e4156">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e4161">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e4171">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e4176">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#instrumentationOptions">2. TAU Instrumentation Options</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e4304">2.1. Selective Instrumentation Options</a></span></dt><dt><span class="sect1"><a href="#RunningDynInstAIP">2.2. Running an application using DynInstAPI</a></span></dt><dt><span class="sect1"><a href="#RewritingMaqao">2.3. Rewriting Binaries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Maqao">2.3.1. Using MAQAO</a></span></dt><dt><span class="sect2"><a href="#d0e4463">2.3.2. Using PEBIL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingParam">2.4. Profiling each call to a function</a></span></dt><dt><span class="sect1"><a href="#d0e4485">2.5. Profiling with Hardware counters</a></span></dt><dt><span class="sect1"><a href="#HardwarePerformanceCounters">2.6. Using Hardware Performance Counters</a></span></dt><dt><span class="sect1"><a href="#PerfLib">2.7. Profiling with PerfLib</a></span></dt><dt><span class="sect1"><a href="#RunningPython">2.8. Running a Python application with TAU</a></span></dt><dt><span class="sect1"><a href="#pprof">2.9. pprof</a></span></dt><dt><span class="sect1"><a href="#RunningJAVA">2.10. Running a JAVA application with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingTauConf">2.11. Using a tau.conf File</a></span></dt><dt><span class="sect1"><a href="#UsingScoreP">2.12. Using Score-P with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingUPC">2.13. Using UPC  with TAU</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tracingReference">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e5662">3.1. How to configure tracing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e5790">4. TAU Memory Profiling Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#memoryOptions">4.1. TAU's memory API options</a></span></dt><dt><span class="sect1"><a href="#tauExecMemory">4.2. Using tau_exec</a></span></dt><dt><span class="sect1"><a href="#profilingMemory">4.3. Evaluating Memory Utilization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5818">4.3.1. TAU_TRACK_MEMORY</a></span></dt><dt><span class="sect2"><a href="#d0e5842">4.3.2. TAU_TRACK_MEMORY_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5853">4.3.3. TAU_TRACK_MEMORY_FOOTPRINT</a></span></dt><dt><span class="sect2"><a href="#d0e5858">4.3.4. TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5863">4.3.5. -PROFILEMEMORY</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingHeadroom">4.4. Evaluating Memory Headroom</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5871">4.4.1. TAU_TRACK_MEMORY_HEADROOM()</a></span></dt><dt><span class="sect2"><a href="#d0e5892">4.4.2. TAU_TRACK_MEMORY_HEADROOM_HERE()</a></span></dt><dt><span class="sect2"><a href="#d0e5906">4.4.3. -PROFILEHEADROOM</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5925">4.5. DetectingMemoryLeaks</a></span></dt><dt><span class="sect1"><a href="#MemoryTrackingInFortran">4.6. Memory Tracking In Fortran</a></span></dt></dl></dd><dt><span class="chapter"><a href="#EclipseTauJava">5. Eclipse Tau Java System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Installation">5.1. Installation</a></span></dt><dt><span class="sect1"><a href="#Instrumentation">5.2. Instrumentation</a></span></dt><dt><span class="sect1"><a href="#Uninstrumentation">5.3. Uninstrumentation</a></span></dt><dt><span class="sect1"><a href="#RunningTauJava">5.4. Running Java with TAU</a></span></dt><dt><span class="sect1"><a href="#Options">5.5. Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#EclipsePlugin">6. Eclipse PTP / CDT plug-in System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#InstallEclipse">6.1. Installation</a></span></dt><dt><span class="sect1"><a href="#TauLaucher">6.2. Creating a Tau Launch Configuration</a></span></dt><dt><span class="sect1"><a href="#SelectiveLaunch">6.3. Selective Instrumentation</a></span></dt><dt><span class="sect1"><a href="#CollectingData">6.4. Launching a Program and Collecting Data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e6181">7. Tools</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#tau_compiler.sh">tau_compiler.sh</a></span><span class="refpurpose"> - Instrumenting source files.</span></dt><dt><span class="refentrytitle"><a href="#vtf2profile">vtf2profile</a></span><span class="refpurpose"> - Generate a TAU profile set from a vampir trace file</span></dt><dt><span class="refentrytitle"><a href="#tau2vtf">tau2vtf</a></span><span class="refpurpose"> - convert TAU tracefiles to vampir tracefiles</span></dt><dt><span class="refentrytitle"><a href="#trace2profile">trace2profile</a></span><span class="refpurpose"> - convert TAU tracefiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau2elg">tau2elg</a></span><span class="refpurpose"> - convert TAU tracefiles to Epilog tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2slog2">tau2slog2</a></span><span class="refpurpose"> - convert TAU tracefiles to SLOG2 tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2otf">tau2otf</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#tau2otf2">tau2otf2</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF2
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#perf2tau">perf2tau</a></span><span class="refpurpose"> - converts PerfLib profiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau_merge">tau_merge</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_treemerge.pl">tau_treemerge.pl</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_convert">tau_convert</a></span><span class="refpurpose"> - convert TAU tracefiles into various alternative trace formats</span></dt><dt><span class="refentrytitle"><a href="#tau_reduce">tau_reduce</a></span><span class="refpurpose"> - generates selective
    instrumentation rules based on profile data</span></dt><dt><span class="refentrytitle"><a href="#tau_ompcheck">tau_ompcheck</a></span><span class="refpurpose"> - Completes uncompleted do/for/parallel omp directives</span></dt><dt><span class="refentrytitle"><a href="#tau_poe">tau_poe</a></span><span class="refpurpose"> - Instruments a MPI application while it is being executed with poe.</span></dt><dt><span class="refentrytitle"><a href="#tau_validate">tau_validate</a></span><span class="refpurpose"> - Validates a TAU installation by performing
    various tests on each TAU stub Makefile</span></dt><dt><span class="refentrytitle"><a href="#tauex">tauex</a></span><span class="refpurpose"> - Allows you to choose a tau configuration at runtime</span></dt><dt><span class="refentrytitle"><a href="#tau_exec">tau_exec</a></span><span class="refpurpose"> - TAU execution wrapping script</span></dt><dt><span class="refentrytitle"><a href="#tau_timecorrect">tau_timecorrect</a></span><span class="refpurpose"> - Corrects and reorders the records of tau trace files.</span></dt><dt><span class="refentrytitle"><a href="#tau_throttle.sh">tau_throttle.sh</a></span><span class="refpurpose"> - This tool generates a selective instrumentation file (called
    throttle.tau) from a program output that has "Disabling"
    messages.</span></dt><dt><span class="refentrytitle"><a href="#tau_portal.py">tau_portal.py</a></span><span class="refpurpose"> - 
      This tool is design to interact with the TAU web portal (http://tau.nic.uoregon.edu). There are commands
      for uploading or downloading packed profile files form the TAU portal.
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_configure">taudb_configure</a></span><span class="refpurpose"> - 
     Configuration program for a PerfDMF database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createapp">perfdmf_createapp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a application in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createexp">perfdmf_createexp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a experiment in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_loadtrial">taudb_loadtrial</a></span><span class="refpurpose"> - 
      Command line tool to load a trial into the TAUdb database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer">perfexplorer</a></span><span class="refpurpose"> - 
      Launches TAU's Performance Data Mining Analyzer.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer_configure">perfexplorer_configure</a></span><span class="refpurpose"> - 
	Configures a TAUdb database for use with perfexplorer, and installs necessary JAR files.
    </span></dt><dt><span class="refentrytitle"><a href="#taucc.man">taucc</a></span><span class="refpurpose"> - 
      C compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauupc.man">tauupc</a></span><span class="refpurpose"> - 
      UPC wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#taucxx.man">taucxx</a></span><span class="refpurpose"> - 
      C++ compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauf90.man">tauf90</a></span><span class="refpurpose"> - 
      Fortran compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#paraprof.man">paraprof</a></span><span class="refpurpose"> - 
      Launches TAU's Java-based performance data viewer.
    </span></dt><dt><span class="refentrytitle"><a href="#pprof.man">pprof</a></span><span class="refpurpose"> - 
      Quickly diplays profile data.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_instrumentor">tau_instrumentor</a></span><span class="refpurpose"> - 
      automaticly instruments a source basied on information provided by pdt.
    </span></dt><dt><span class="refentrytitle"><a href="#vtfconverter">vtfconverter</a></span><span class="refpurpose"> - 
      
    </span></dt><dt><span class="refentrytitle"><a href="#tau_setup">tau_setup</a></span><span class="refpurpose"> - 
      Launches GUI interface to configure TAU.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_wrap">tau_wrap</a></span><span class="refpurpose"> - 
      Instruments an external library with TAU without needing to recompile
    </span></dt><dt><span class="refentrytitle"><a href="#tau_gen_wrapper">tau_gen_wrapper</a></span><span class="refpurpose"> - 
     Generates a wrapper library that can intercept 
 at link time or at runtime routines specified in a header file
    </span></dt><dt><span class="refentrytitle"><a href="#tau_pin">tau_pin</a></span><span class="refpurpose"> - 
      Instruments application at run time using Intel's PIN library
    </span></dt><dt><span class="refentrytitle"><a href="#tau_java">tau_java</a></span><span class="refpurpose"> - 
      Instruments java applications at runtime using JVMTI
    </span></dt><dt><span class="refentrytitle"><a href="#tau_cupti_avail">tau_cupti_avail</a></span><span class="refpurpose"> - 
			Detects the available CUPTI counters on the a each GPU device.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_run">tau_run</a></span><span class="refpurpose"> - 
 Instruments and executes binaries to generate performance data. (DyninstAPI based instrumentor)
    </span></dt><dt><span class="refentrytitle"><a href="#tau_rewrite">tau_rewrite</a></span><span class="refpurpose"> - 
           Rewrites binaries using Maqao if Tau is configured using PDT 3.17+ at the routine level. 
          If it doesn't find the Maqao package from PDT 3.17, it reverts to tau_run (DyninstAPI based instrumentor). 
    </span></dt></dl></dd><dt><span class="part"><a href="#TAUdbDoc">I. TAUdb</a></span></dt><dd><dl><dt><span class="chapter"><a href="#taudb.intro">8. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">8.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">8.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">9. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">9.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">9.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">9.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">9.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">10. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">10.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">11. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">11.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">11.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">11.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">11.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">11.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">11.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e10848">12. Windows</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TAUonWin">12.1. TAU on Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e10854">12.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#d0e10865">12.1.2. Instrumenting an application with Visual Studio C/C++</a></span></dt><dt><span class="sect2"><a href="#UsingMINGW">12.1.3. Using MINGW  with TAU</a></span></dt></dl></dd></dl></dd><dt><span class="reference"><a href="#d0e10925">I. TAU Instrumentation API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_START">TAU_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STOP">TAU_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE">TAU_PROFILE</a></span><span class="refpurpose"> - Profile a C++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PROFILE">TAU_DYNAMIC_PROFILE</a></span><span class="refpurpose"> - dynamic_profile a c++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_DYNAMIC">TAU_PROFILE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Creates a dynamic timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_DYNAMIC_AUTO">TAU_CREATE_DYNAMIC_AUTO</a></span><span class="refpurpose"> - Creates a dynamic timer for C/C++</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DYNAMIC_ITER">TAU_PROFILE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic timer in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_DYNAMIC_ITER">TAU_PHASE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic phase in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER">TAU_PROFILE_TIMER</a></span><span class="refpurpose"> - Defines a static timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_START">TAU_PROFILE_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STOP">TAU_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_START">TAU_STATIC_TIMER_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_STOP">TAU_STATIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_START">TAU_DYNAMIC_TIMER_START</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_STOP">TAU_DYNAMIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_DYNAMIC">TAU_PROFILE_TIMER_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DECLARE_TIMER">TAU_PROFILE_DECLARE_TIMER</a></span><span class="refpurpose"> - Declares a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_TIMER">TAU_PROFILE_CREATE_TIMER</a></span><span class="refpurpose"> - Creates a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER">TAU_GLOBAL_TIMER</a></span><span class="refpurpose"> - Declares a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_EXTERNAL">TAU_GLOBAL_TIMER_EXTERNAL</a></span><span class="refpurpose"> - Declares a global timer from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_START">TAU_GLOBAL_TIMER_START</a></span><span class="refpurpose"> - Starts a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_STOP">TAU_GLOBAL_TIMER_STOP</a></span><span class="refpurpose"> - Stops a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE">TAU_PHASE</a></span><span class="refpurpose"> - Profile a C++ function as a phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE">TAU_DYNAMIC_PHASE</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_DYNAMIC">TAU_PHASE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_STATIC">TAU_PHASE_CREATE_STATIC</a></span><span class="refpurpose"> - Defines a static phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_START">TAU_PHASE_START</a></span><span class="refpurpose"> - Enters a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_STOP">TAU_PHASE_STOP</a></span><span class="refpurpose"> - Exits a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_START">TAU_DYNAMIC_PHASE_START</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_STOP">TAU_DYNAMIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_START">TAU_STATIC_PHASE_START</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_STOP">TAU_STATIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE">TAU_GLOBAL_PHASE</a></span><span class="refpurpose"> - Declares a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_EXTERNAL">TAU_GLOBAL_PHASE_EXTERNAL</a></span><span class="refpurpose"> - Declares a global phase from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_START">TAU_GLOBAL_PHASE_START</a></span><span class="refpurpose"> - Starts a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_STOP">TAU_GLOBAL_PHASE_STOP</a></span><span class="refpurpose"> - Stops a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_EXIT">TAU_PROFILE_EXIT</a></span><span class="refpurpose"> - Alerts the profiling system to an exit call</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_THREAD">TAU_REGISTER_THREAD</a></span><span class="refpurpose"> - Register a thread with the profiling system</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_NODE">TAU_PROFILE_GET_NODE</a></span><span class="refpurpose"> - Returns the measurement system's node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_CONTEXT">TAU_PROFILE_GET_CONTEXT</a></span><span class="refpurpose"> - Gives the measurement system's context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_THREAD">TAU_PROFILE_SET_THREAD</a></span><span class="refpurpose"> - Informs the measurement system of the THREAD id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_THREAD">TAU_PROFILE_GET_THREAD</a></span><span class="refpurpose"> - Gives the measurement system's thread id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_NODE">TAU_PROFILE_SET_NODE</a></span><span class="refpurpose"> - Informs the measurement system of the node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_CONTEXT">TAU_PROFILE_SET_CONTEXT</a></span><span class="refpurpose"> - Informs the measurement system of the context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_FORK">TAU_REGISTER_FORK</a></span><span class="refpurpose"> - Informs the measurement system that a fork has taken place</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_EVENT">TAU_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_REGISTER_EVENT">TAU_PROFILER_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_THREAD">TAU_EVENT_THREAD</a></span><span class="refpurpose"> - Triggers a user event on a given thread</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_CONTEXT_EVENT">TAU_REGISTER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Registers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_CONTEXT_EVENT">TAU_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT">TAU_TRIGGER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a context user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_CONTEXT_EVENT">TAU_ENABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Enable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_CONTEXT_EVENT">TAU_DISABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Disable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_SET_NAME">TAU_EVENT_SET_NAME</a></span><span class="refpurpose"> - Sets the name of an event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MAX">TAU_EVENT_DISABLE_MAX</a></span><span class="refpurpose"> - Disables tracking of maximum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MEAN">TAU_EVENT_DISABLE_MEAN</a></span><span class="refpurpose"> - Disables tracking of mean statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MIN">TAU_EVENT_DISABLE_MIN</a></span><span class="refpurpose"> - Disables tracking of minimum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_STDDEV">TAU_EVENT_DISABLE_STDDEV</a></span><span class="refpurpose"> - Disables tracking of standard deviation statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_STATISTICS">TAU_REPORT_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_THREAD_STATISTICS">TAU_REPORT_THREAD_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics, plus thread statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_INSTRUMENTATION">TAU_ENABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Enables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_INSTRUMENTATION">TAU_DISABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Disables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP">TAU_ENABLE_GROUP</a></span><span class="refpurpose"> - Enables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP">TAU_DISABLE_GROUP</a></span><span class="refpurpose"> - Disables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP">TAU_PROFILE_TIMER_SET_GROUP</a></span><span class="refpurpose"> - Change the group of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME">TAU_PROFILE_TIMER_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name for a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_NAME">TAU_PROFILE_TIMER_SET_NAME</a></span><span class="refpurpose"> - Changes the name of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_TYPE">TAU_PROFILE_TIMER_SET_TYPE</a></span><span class="refpurpose"> - Changes the type of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_GROUP_NAME">TAU_PROFILE_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name of a profiled section</span></dt><dt><span class="refentrytitle"><a href="#TAU_INIT">TAU_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_INIT">TAU_PROFILE_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_PROFILE_GROUP">TAU_GET_PROFILE_GROUP</a></span><span class="refpurpose"> - Creates groups based on names</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP_NAME">TAU_ENABLE_GROUP_NAME</a></span><span class="refpurpose"> - Enables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP_NAME">TAU_DISABLE_GROUP_NAME</a></span><span class="refpurpose"> - Disables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_ALL_GROUPS">TAU_ENABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Enables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_ALL_GROUPS">TAU_DISABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Disables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_NAMES">TAU_GET_EVENT_NAMES</a></span><span class="refpurpose"> - Gets the registered user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_VALS">TAU_GET_EVENT_VALS</a></span><span class="refpurpose"> - Gets user event data for given user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_COUNTER_NAMES">TAU_GET_COUNTER_NAMES</a></span><span class="refpurpose"> - Gets the counter names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_NAMES">TAU_GET_FUNC_NAMES</a></span><span class="refpurpose"> - Gets the function names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_VALS">TAU_GET_FUNC_VALS</a></span><span class="refpurpose"> - Gets detailed performance data for given functions</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY">TAU_ENABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Enables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY">TAU_DISABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Disables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER">TAU_TRACK_POWER</a></span><span class="refpurpose"> - Initializes POWER tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER_HERE">TAU_TRACK_POWER_HERE</a></span><span class="refpurpose"> - Triggers power tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_POWER">TAU_ENABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Enables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_POWER">TAU_DISABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Disables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY">TAU_TRACK_MEMORY</a></span><span class="refpurpose"> - Initializes memory tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HERE">TAU_TRACK_MEMORY_HERE</a></span><span class="refpurpose"> - Triggers memory tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT">TAU_TRACK_MEMORY_FOOTPRINT</a></span><span class="refpurpose"> - Initializes memory footprint tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE">TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span><span class="refpurpose"> - Triggers memory footprint tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Enables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Disables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM">TAU_TRACK_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM_HERE">TAU_TRACK_MEMORY_HEADROOM_HERE</a></span><span class="refpurpose"> - Takes a sample of the amount of memory available at a given point.</span></dt><dt><span class="refentrytitle"><a href="#TAU_SET_INTERRUPT_INTERVAL">TAU_SET_INTERRUPT_INTERVAL</a></span><span class="refpurpose"> - Change the inter-interrupt interval for tracking memory and headroom</span></dt><dt><span class="refentrytitle"><a href="#CT">CT</a></span><span class="refpurpose"> - Returns the type information for a variable</span></dt><dt><span class="refentrytitle"><a href="#TAU_TYPE_STRING">TAU_TYPE_STRING</a></span><span class="refpurpose"> - Creates a type string</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP">TAU_DB_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_MERGED_DUMP">TAU_DB_MERGED_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_INCR">TAU_DB_DUMP_INCR</a></span><span class="refpurpose"> - Dumps profile database into timestamped profiles on disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX">TAU_DB_DUMP_PREFIX</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given prefix</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX_TASK">TAU_DB_DUMP_PREFIX_TASK</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given task</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_PURGE">TAU_DB_PURGE</a></span><span class="refpurpose"> - Purges the performance data.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_NAMES">TAU_DUMP_FUNC_NAMES</a></span><span class="refpurpose"> - Dumps function names to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS">TAU_DUMP_FUNC_VALS</a></span><span class="refpurpose"> - Dumps performance data for given functions to disk.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS_INCR">TAU_DUMP_FUNC_VALS_INCR</a></span><span class="refpurpose"> - Dumps function values with a timestamp</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STMT">TAU_PROFILE_STMT</a></span><span class="refpurpose"> - Executes a statement only when TAU is used.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CALLSTACK">TAU_PROFILE_CALLSTACK</a></span><span class="refpurpose"> - Generates a callstack trace at a given location.</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_RECVMSG">TAU_TRACE_RECVMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_SENDMSG">TAU_TRACE_SENDMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_PARAM1L">TAU_PROFILE_PARAM1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT">TAU_PROFILE_SNAPSHOT</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT_1L">TAU_PROFILE_SNAPSHOT_1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_CREATE">TAU_PROFILER_CREATE</a></span><span class="refpurpose"> - Creates a profiler object referenced as a standard pointer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_TASK">TAU_CREATE_TASK</a></span><span class="refpurpose"> - Creates a task id.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START">TAU_PROFILER_START</a></span><span class="refpurpose"> - starts a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START_TASK">TAU_PROFILER_START_TASK</a></span><span class="refpurpose"> - Starts a profiler object created by  on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP">TAU_PROFILER_STOP</a></span><span class="refpurpose"> - stops a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP_TASK">TAU_PROFILER_STOP_TASK</a></span><span class="refpurpose"> - Stops a profiler object on a task</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS">TAU_PROFILER_GET_CALLS</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS_TASK">TAU_PROFILER_GET_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS">TAU_PROFILER_GET_CHILD_CALLS</a></span><span class="refpurpose"> - Gets the number of calls made while this timer was running</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK">TAU_PROFILER_GET_CHILD_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of child call for this timer, created by , is started on a task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES">TAU_PROFILER_GET_INCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES">TAU_PROFILER_GET_EXCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO">TAU_PROFILER_GET_COUNTER_INFO</a></span><span class="refpurpose"> - Returns information about all the timers created.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK">TAU_PROFILER_GET_COUNTER_INFO_TASK</a></span><span class="refpurpose"> - Returns information about all the timers created on a task. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_DECLARE_EVENT">TAU_QUERY_DECLARE_EVENT</a></span><span class="refpurpose"> - Returns a event handle.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_CURRENT_EVENT">TAU_QUERY_GET_CURRENT_EVENT</a></span><span class="refpurpose"> - set event to be the current TAU event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_EVENT_NAME">TAU_QUERY_GET_EVENT_NAME</a></span><span class="refpurpose"> - Gets the name of a given event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_PARENT_EVENT">TAU_QUERY_GET_PARENT_EVENT</a></span><span class="refpurpose"> - gets the parent of the current event. 
	</span></dt></dl></dd><dt><span class="reference"><a href="#d0e19666">II. TAU Mapping API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_MAPPING">TAU_MAPPING</a></span><span class="refpurpose"> - Encapsulates a C++ statement for profiling</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_CREATE">TAU_MAPPING_CREATE</a></span><span class="refpurpose"> - Creates a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_LINK">TAU_MAPPING_LINK</a></span><span class="refpurpose"> - Creates a mapping link</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_OBJECT">TAU_MAPPING_OBJECT</a></span><span class="refpurpose"> - Declares a mapping object</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE">TAU_MAPPING_PROFILE</a></span><span class="refpurpose"> - Profiles a block based on a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_START">TAU_MAPPING_PROFILE_START</a></span><span class="refpurpose"> - Starts a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_STOP">TAU_MAPPING_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_TIMER">TAU_MAPPING_PROFILE_TIMER</a></span><span class="refpurpose"> - Declares a mapping timer</span></dt></dl></dd><dt><span class="appendix"><a href="#d0e20170">A. Environment Variables</a></span></dt></dl></dd></dl></div><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauUsersGuide"></a>TAU User Guides</h1></div><div><div class="legalnotice"><a name="d0e100"></a><p>Updated May 4th, 2015 for use with version 2.24.1 or greater.</p><p>Copyright &copy; 1997-2012
      Department of Computer and Information Science, University of Oregon 
      Advanced Computing Laboratory, LANL, NM 
      Research Centre Juelich, ZAM, Germany</p><p>Permission to use, copy, modify, and distribute this software and
	its documentation for any purpose and without fee is hereby granted,
	provided that the above copyright notice appear in all copies and that
	both that copyright notice and this permission notice appear in
	supporting documentation, and that the name of University of Oregon (UO)
	Research Centre Juelich, (ZAM) and Los Alamos National Laboratory (LANL)
	not be used in advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.  The University of
	Oregon, ZAM and LANL make no representations about the suitability of
	this software for any purpose.  It is provided "as is" without express or
	implied warranty.</p><p>UO, ZAM AND LANL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
	SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF OREGON, ZAM OR LANL BE
	LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d0e109"></a></span></dt><dt><span class="part"><a href="#TAUUSERMANUAL">I. Tau User Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tauInstrumentation">1. Tau Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e234">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e239">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e267">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Profiling">2. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Analysis">4. Analyzing Parallel Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></dd><dt><span class="chapter"><a href="#StartersGuide">5. Quick Reference</a></span></dt><dt><span class="chapter"><a href="#ApplicationScenario">6. Some Common Application Scenario</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e688">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e707">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e729">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e751">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e773">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e795">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e814">6.7. Q. How does my application scale?
</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#ParaProfDoc">II. ParaProf - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#paraprof.intro">7. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.views">8. Views and Sub-Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.trialmanagement">9. Profile Data Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.3d">10. 3-D Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.threaddisplays">11. Thread Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.functiondisplays">12. Function Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.phasedisplays">13. Phase Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.comparison">14. Comparative Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.otherdisplays">15. Miscellaneous Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.preferences">16. Preferences</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#PerfExplorerDoc">III. PerfExplorer - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#Introduction">17. Introduction</a></span></dt><dt><span class="chapter"><a href="#InstallPerfExplorer">18. Installation and Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RunningPerfExplorer">19. Running PerfExplorer</a></span></dt><dt><span class="chapter"><a href="#ClusterAnalysis">20. Cluster Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#CorrelationAnalysis">21. Correlation Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Charts">22. Charts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CustomCharts">23. Custom Charts</a></span></dt><dt><span class="chapter"><a href="#Visualization">24. Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Views">25. Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Scripting">26. Running PerfExplorer Scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Derived Metrics">27. Derived Metrics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#TAUdbDoc">IV. TAUdb</a></span></dt><dd><dl><dt><span class="chapter"><a href="#taudb.intro">28. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">29. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">30. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">31. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>4.1. <a href="#paraprof.maindatawindow1.figure">Main Data Window</a></dt><dt>4.2. <a href="#jumpshot.overview.figure">Main Data Window</a></dt><dt>6.1. <a href="#d0e693">Flat Profile</a></dt><dt>6.2. <a href="#d0e712">Flat Profile with Loops</a></dt><dt>6.3. <a href="#d0e734">MFlops per loop</a></dt><dt>6.4. <a href="#d0e756">Callpath Profile</a></dt><dt>6.5. <a href="#d0e800">Tracing with Vampir</a></dt><dt>6.6. <a href="#d0e819">Scalability chart</a></dt><dt>8.1. <a href="#d0e1021">Add View</a></dt><dt>8.2. <a href="#d0e1032">View Creator Window</a></dt><dt>9.1. <a href="#paraprof.mainwindow.figure">ParaProf Manager Window</a></dt><dt>9.2. <a href="#d0e1069">Loading Profile Data</a></dt><dt>9.3. <a href="#paraprof.derivedmetrics.figure">Creating Derived Metrics</a></dt><dt>9.4. <a href="#paraprof.maindatawindow.figure">Main Data Window</a></dt><dt>9.5. <a href="#d0e1128">Unstacked Bars</a></dt><dt>10.1. <a href="#d0e1148">Triangle Mesh Plot</a></dt><dt>10.2. <a href="#paraprof.3dbarplot.figure">3-D Mesh Plot</a></dt><dt>10.3. <a href="#d0e1189">3-D Scatter Plot</a></dt><dt>10.4. <a href="#d0e1202">3-D Topology Plot</a></dt><dt>10.5. <a href="#d0e1229">3-D Commication Matrix</a></dt><dt>11.1. <a href="#d0e1252">Thread Bar Graph</a></dt><dt>11.2. <a href="#d0e1266">Thread Statistics Text Window</a></dt><dt>11.3. <a href="#paraprof.thread.treetable1">Thread Statistics Table, inclusive and exclusive</a></dt><dt>11.4. <a href="#paraprof.thread.treetable2">Thread Statistics Table</a></dt><dt>11.5. <a href="#paraprof.thread.treetable3">Thread Statistics Table</a></dt><dt>11.6. <a href="#d0e1313">Call Graph Window</a></dt><dt>11.7. <a href="#paraprof.thread.callpathrelations">Thread Call Path Relations Window</a></dt><dt>11.8. <a href="#d0e1353">User Event Statistics Window</a></dt><dt>11.9. <a href="#d0e1368">User Event Thread Bar Chart Window</a></dt><dt>12.1. <a href="#d0e1387">Function Bar Graph</a></dt><dt>12.2. <a href="#d0e1401">Function Histogram</a></dt><dt>13.1. <a href="#d0e1430">Initial Phase Display</a></dt><dt>13.2. <a href="#d0e1441">Phase Ledger</a></dt><dt>13.3. <a href="#d0e1449">Function Data over Phases</a></dt><dt>14.1. <a href="#d0e1468">Comparison Window (initial)</a></dt><dt>14.2. <a href="#d0e1476">Comparison Window (2 trials)</a></dt><dt>14.3. <a href="#d0e1482">Comparison Window (3 threads)</a></dt><dt>15.1. <a href="#d0e1497">User Event Bar Graph</a></dt><dt>15.2. <a href="#d0e1513">Function Ledger</a></dt><dt>15.3. <a href="#d0e1524">Group Ledger</a></dt><dt>15.4. <a href="#d0e1541">User Event Ledger</a></dt><dt>15.5. <a href="#d0e1554">Selective Instrumentation Dialog</a></dt><dt>16.1. <a href="#d0e1577">ParaProf Preferences Window</a></dt><dt>16.2. <a href="#d0e1617">Edit Default Colors</a></dt><dt>16.3. <a href="#d0e1628">Color Map</a></dt><dt>20.1. <a href="#perfexplorer.mainwindow.dimensionreduction1">Selecting a dimension reduction method</a></dt><dt>20.2. <a href="#perfexplorer.mainwindow.dimensionreduction2">Entering a minimum threshold for exclusive percentage</a></dt><dt>20.3. <a href="#perfexplorer.mainwindow.maxclusters">Entering a maximum number of clusters</a></dt><dt>20.4. <a href="#perfexplorer.mainwindow.clustering">Selecting a
	Metric to Cluster</a></dt><dt>20.5. <a href="#perfexplorer.confirm.clustering">Confirm
	Clustering Options</a></dt><dt>20.6. <a href="#perfexplorer.cluster.results">Cluster
	Results</a></dt><dt>20.7. <a href="#perfexplorer.cluster.histogram">Cluster
	Membership Histogram</a></dt><dt>20.8. <a href="#perfexplorer.cluster.scatterplot">Cluster
	Membership Scatterplot</a></dt><dt>20.9. <a href="#perfexplorer.cluster.topology">Cluster
	Virtual Topology</a></dt><dt>20.10. <a href="#perfexplorer.cluster.averages">Cluster
	Average Behavior</a></dt><dt>21.1. <a href="#perfexplorer.mainwindow.dimensionreduction1b">Selecting a dimension reduction method</a></dt><dt>21.2. <a href="#perfexplorer.mainwindow.dimensionreduction2b">Entering a minimum threshold for exclusive percentage</a></dt><dt>21.3. <a href="#perfexplorer.mainwindow.correlation">Selecting a
	Metric to Cluster</a></dt><dt>21.4. <a href="#perfexplorer.correlation.results">Correlation
	Results</a></dt><dt>21.5. <a href="#perfexplorer.correlation.example">Correlation
	Example</a></dt><dt>22.1. <a href="#perfexplorer.charts.groupofinterest">Setting Group of Interest</a></dt><dt>22.2. <a href="#perfexplorer.charts.metricofinterest">Setting Metric of Interest</a></dt><dt>22.3. <a href="#perfexplorer.charts.eventofinterest">Setting Event of Interest</a></dt><dt>22.4. <a href="#perfexplorer.charts.timesteps">Setting Timesteps</a></dt><dt>22.5. <a href="#perfexplorer.charts.timestepspersecond">Timesteps per Second</a></dt><dt>22.6. <a href="#perfexplorer.charts.relativeefficiency">Relative Efficiency</a></dt><dt>22.7. <a href="#perfexplorer.charts.relativeefficiencybyevent">Relative Efficiency by Event</a></dt><dt>22.8. <a href="#perfexplorer.charts.relativeefficiencyoneevent">Relative Efficiency one Event</a></dt><dt>22.9. <a href="#perfexplorer.charts.relativespeedup">Relative Speedup</a></dt><dt>22.10. <a href="#perfexplorer.charts.relativespeedupbyevent">Relative Speedup by Event</a></dt><dt>22.11. <a href="#perfexplorer.charts.relativespeeduponeevent">Relative Speedup one Event</a></dt><dt>22.12. <a href="#perfexplorer.charts.percentoftotal">Group % of Total Runtime</a></dt><dt>22.13. <a href="#perfexplorer.charts.runtimebreakdown">Runtime Breakdown</a></dt><dt>22.14. <a href="#perfexplorer.charts.relativeefficiencybyphase">Relative Efficiency per Phase</a></dt><dt>22.15. <a href="#perfexplorer.charts.relativespeedupbyphase">Relative Speedup per Phase</a></dt><dt>22.16. <a href="#perfexplorer.charts.phasebreakdown">Phase Fraction of Total Runtime</a></dt><dt>23.1. <a href="#perfexplorer.customcharts.interface">The Custom Charts
	Interface</a></dt><dt>24.1. <a href="#perfexplorer.visualization.threed">3D
		Visualization of multivariate data</a></dt><dt>24.2. <a href="#perfexplorer.visualization.datasummary">Data
		Summary Window</a></dt><dt>24.3. <a href="#perfexplorer.visualization.boxchart">Boxchart</a></dt><dt>24.4. <a href="#perfexplorer.visualization.histogram">Histogram</a></dt><dt>24.5. <a href="#perfexplorer.visualization.normalprobability">Normal
		Probability</a></dt><dt>25.1. <a href="#perfexplorer.views.parametricexample">Potential
	scalability data organized as a parametric study</a></dt><dt>25.2. <a href="#perfexplorer.views.viewslevel">Selecting a table</a></dt><dt>25.3. <a href="#perfexplorer.views.viewscolumn">Selecting a
	column</a></dt><dt>25.4. <a href="#perfexplorer.views.viewsoperator">Selecting an
	operator</a></dt><dt>25.5. <a href="#perfexplorer.views.viewsvalue">Selecting a value</a></dt><dt>25.6. <a href="#perfexplorer.views.viewsname">Entering a name
	for the view</a></dt><dt>25.7. <a href="#perfexplorer.views.completedview">The completed
	view</a></dt><dt>25.8. <a href="#perfexplorer.views.subview">Selecting the base
	view</a></dt><dt>25.9. <a href="#perfexplorer.views.completedsubview">Completed
	sub-views</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#d0e137">Different methods of instrumenting applications</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"></div><p>TAU Performance System&reg;  is a portable profiling and tracing
      toolkit for performance analysis of parallel programs written in Fortran,
      C, C++, Java, and Python.
      
      TAU (Tuning and Analysis Utilities) is capable of gathering performance
      information through instrumentation of functions, methods, basic blocks,
      and statements. The TAU API also provides selection of profiling groups
      for organizing and controlling instrumentation. Calls to the TAU API are
      made by probes inserted into the execution of the application via source
      transformation, compiler directives or by library interposition.</p><p>This guide is organized into different sections. Readers wanting to
      get started right way can skip to
      the <a href="#ApplicationScenario" title="Chapter&nbsp;6.&nbsp;Some Common Application Scenario">Common Profile Requests</a>
      section for step-by-step instructions for obtaining difference kinds of
      performance data. Or browse the <a href="#StartersGuide" title="Chapter&nbsp;5.&nbsp;Quick Reference">starters
      guide</a> for a quick reference to common TAU commands and
      variables.</p><p>TAU can be found on the web at: <a href="http://tau.uoregon.edu" target="_top">http://tau.uoregon.edu</a></p></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUUSERMANUAL"></a>Part&nbsp;I.&nbsp;Tau User Guide</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tauInstrumentation">1. Tau Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e234">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e239">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e267">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Profiling">2. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Analysis">4. Analyzing Parallel Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></dd><dt><span class="chapter"><a href="#StartersGuide">5. Quick Reference</a></span></dt><dt><span class="chapter"><a href="#ApplicationScenario">6. Some Common Application Scenario</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e688">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e707">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e729">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e751">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e773">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e795">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e814">6.7. Q. How does my application scale?
</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tauInstrumentation"></a>Chapter&nbsp;1.&nbsp;Tau Instrumentation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e234">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e239">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e267">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p>
          </p><p>TAU provides three methods to track the performance of your
	application. Library interposition using tau_exec, 
	compiler directives or source transformation using PDT. Here is a
	table that lists the features/requirement for each method:</p><div class="table"><a name="d0e137"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Different methods of instrumenting applications</b></p><table summary="Different methods of instrumenting applications" border="1"><colgroup><col width="12%"><col width="13%"><col width="12%"><col width="13%"><col width="12%"><col width="13%"><col width="12%"><col width="13%"></colgroup><thead><tr><th><span class="emphasis"><em>Method</em></span></th><th>Requires
					recompiling</th><th>Requires
					PDT</th><th>Shows MPI events</th><th>Routine-level event</th><th>Low level
					events (loops, phases, etc...)</th><th>Throttling to reduce
					overhead</th><th>Ability to exclude file from
					instrumentation</th><th>Ability to exclude
			    other regions of code</th></tr></thead><tbody><tr><td>Interposition</td><td>&nbsp;</td><td>&nbsp;</td><td>Yes</td><td>&nbsp;</td><td>&nbsp;</td><td>Yes</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Compiler</td><td>Yes</td><td>&nbsp;</td><td>Yes</td><td>Yes</td><td>&nbsp;</td><td>Yes</td><td>Yes</td><td>&nbsp;</td></tr><tr><td>Source</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></div>


		The requirements for each method increases as we move down the table: tau_exec
		only requires a system with shared library support. Compiler based
		instrumentation requires re-compiling that target application and Source
		instrumentation aditionally requires PDT. For this reason we often recommend that users
		start with Library interposition and move down the table if more features
		are needed.
		
</div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TauLibraryInterposition"></a>1.1.&nbsp;Dynamic instrumentation through library pre-loading</h2></div></div></div><p>Dynamic instrumentation is achieved through library pre-loading. The
		libraries chosen for pre-loading determine the scope of instrumentation.
		Some options include tracking MPI, io, memory, cuda, opencl library
		calls. MPI instrumentation is included by default the others are enabled by command-line options to
		<code class="literal">tau_exec</code>. More info at the <a href="#tau_exec" title="tau_exec"><code class="literal">tau_exec</code> manual page</a>. Dynamic
		instrumentation can be used on both uninstrumented binaries and binaries
		instrumented via one of the methods below, in this way different layers of
		instrumentation can be combined.</p><p>To use <code class="literal">tau_exec</code> place this command before the
		application executable when running the application. In this example IO
		instrumentation is requested.
		</p><pre class="screen">
%&gt; tau_exec -io ./a.out
%&gt; mpirun -np 4 tau_exec -io ./a.out
</pre><p>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e234"></a>1.2.&nbsp;TAU scripted compilation</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"></div>For more detailed profiles, TAU provides two means to compile your
	application with TAU: through your compiler or through source transformation
	using PDT.</div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e239"></a>1.2.1.&nbsp;Compiler Based Instrumentation</h3></div></div></div><p>TAU provides these scripts: tau_f90.sh, tau_cc.sh, and tau_cxx.sh to
    instrument and compile Fortran, C, and C++ programs respectively. You might
    use tau_cc.sh to compile a C program by typing: 
    </p><pre class="screen">
%&gt; module load tau
%&gt; tau_cc.sh -tau_options=-optCompInst samplecprogram.c
    </pre><p>
	    On machines where a TAU module is not available, you will need to set the
			tau makefile and/or options. The makefile and options controls how will
			TAU will compile you application. Use
		</p><pre class="screen">
%&gt;tau_cc.sh -tau_makefile=[path to makefile] \
            -tau_options=[option] samplecprogram.c
    </pre><p>
    The Makefile can be found in the <code class="literal">/[arch]/lib</code>
		directory of your TAU distribution, for example
    <code class="literal">/x86_64/lib/Makefile.tau-mpi-pdt</code>.</p><p>You can also use a Makefile
    specified in an environment variable. To run tau_cc.sh so it uses the
    Makefile specified by environment variable <code class="literal">TAU_MAKEFILE</code>,
    type:
    
    </p><pre class="screen">
%&gt;export TAU_MAKEFILE=[path to tau]/[arch]/lib/[makefile]
%&gt;export TAU_OPTIONS=-optCompInst
%&gt;tau_cc.sh sampleCprogram.c
    </pre><p>

    Similarly, if you want to set compile time options like
    selective instrumentation you can use the <code class="literal">TAU_OPTIONS</code>
    environment variable.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e267"></a>1.2.2.&nbsp;Source Based Instrumentation</h3></div></div></div><p>TAU provides these scripts: tau_f90.sh, tau_cc.sh, and tau_cxx.sh to
    instrument and compile Fortran, C, and C++ programs respectively. You might
    use tau_cc.sh to compile a C program by typing: 
    </p><pre class="screen">
%&gt; module load tau
%&gt; tau_cc.sh samplecprogram.c
    </pre><p>
    When setting the TAU_MAKEFILE make sure the Makefile name contains
		<code class="literal">pdt</code> because you will need a version of TAU built with
		PDT.</p><p>A list of options for the TAU compiler scripts can be found by typing
		<code class="literal">man tau_compiler.sh</code> or in this chapter of the <a href="#tau_compiler.sh" title="tau_compiler.sh">reference guide</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TAUCompilerOptions"></a>1.2.3.&nbsp;Options to TAU compiler scripts</h3></div></div></div><p>These are some commonly used options available to the TAU compiler
		scripts. Either set them via the <code class="literal">TAU_OPTIONS</code> environment
		variable or the <code class="literal">-tau_options=</code> option to
		<code class="literal">tau_f90.sh, tau_cc.sh, or tau_cxx.sh</code></p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-optVerbose</code></span></dt><dd>Enable verbose output (default: on)</dd><dt><span class="term"><code class="literal">-optKeepFiles</code></span></dt><dd>Do not remove intermediate files</dd><dt><span class="term"><code class="literal">-optShared</code></span></dt><dd>Use shared library of TAU (consider when using
				<code class="literal">tau_exec</code></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SelectiveProfiling"></a>1.3.&nbsp;Selectively Profiling an Application</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ManualSelectiveProfiling"></a>1.3.1.&nbsp;Custom Profiling</h3></div></div></div><p>TAU allows you to customize the instrumentation of a program by using a
		selective instrumentation file. This instrumentation file is used to
      manually control which parts of the application are profiled and how they
      are profiled. If you are using one of the TAU compiler wrapper scripts to instrument your
			application you can use the <code class="literal">-tau_options=-optTauSelectFile=&lt;file&gt;</code>
			option to enable selective instrumentation. 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Selective instrumentation is only available when using source-level
		instrumentation (PDT).</td></tr></table></div>
      To specify a selective instrumentation file, create a text file and use
			the following guide to fill it in:
			<div class="itemizedlist"><ul type="disc"><li>Wildcards for routine names are specified with the
				<code class="literal">#</code> mark (because <code class="literal">*</code>
				symbols show up in routine signatures.)  The <code class="literal">#</code> mark is unfortunately the comment character
				as well, so to specify a leading wildcard, place the entry in quotes.
				</li><li>
					Wildcards for file names are specified with <code class="literal">*</code> symbols.  
				</li></ul></div><pre class="screen"> 
		<p>Here is a example file:</p>
#Tell tau to not profile these functions
BEGIN_EXCLUDE_LIST

void quicksort(int *, int, int)
# The next line excludes all functions beginning with "sort_" and having 
# arguments "int *"
void sort_#(int *)
void interchange(int *, int *)

END_EXCLUDE_LIST

#Exclude these files from profiling
BEGIN_FILE_EXCLUDE_LIST

*.so

END_FILE_EXCLUDE_LIST

BEGIN_INSTRUMENT_SECTION

# A dynamic phase will break up the profile into phase where
# each events is recorded according to what phase of the application
# in which it occured.
dynamic phase name="foo1_bar" file="foo.c" line=26 to line=27

# instrument all the outer loops in this routine
loops file="loop_test.cpp" routine="multiply"

# tracks memory allocations/deallocations as well as potential leaks
memory file="foo.f90" routine="INIT"

# tracks the size of read, write and print statements in this routine
io file="foo.f90" routine="RINB"

END_INSTRUMENT_SECTION
</pre><p>Selective instrumentation files can be created automatically from
<code class="literal"><a href="#ParaProfDoc" title="Part&nbsp;II.&nbsp;ParaProf - User's Manual">ParaProf</a></code>
by right clicking on a trial and selecting the <code class="literal">Create Selective Instrumentation File</code> menu
item.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Profiling"></a>Chapter&nbsp;2.&nbsp;Profiling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></div><p>This chapter describes running an instrumented application,
  generating profile data and analyzing that data. Profiling
  shows the summary statistics of performance metrics that characterize
  application performance behavior. Examples of performance metrics are
  the CPU time associated with a routine, the count of the secondary data
  cache misses associated with a group of statements, the number of times
  a routine executes, etc. </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningApplication"></a>2.1.&nbsp;Running the Application</h2></div></div></div><p>After instrumentation and compilation are completed, the profiled
    application is run to generate the profile data files. These files can be
    stored in a directory specified by the environment variable
    <code class="literal">PROFILEDIR</code>. By default, profiles are placed in the
		current directory. You can also set the <code class="literal">TAU_VERBOSE</code>
		enviroment variable to see the steps the TAU measurement systems takes
		when your application is running.

    Example: </p><pre class="screen">
% setenv TAU_VERBOSE 1
% setenv PROFILEDIR /home/sameer/profiledata/experiment55
% mpirun -np 4 matrix 
</pre><p>Other environment variables you can set to enable these
		advanced MPI measurement features are <code class="literal">TAU_TRACK_MESSAGE</code>
		to track MPI message statistics when profiling or messages lines when tracing, and
		<code class="literal">TAU_COMM_MATRIX</code> to generate MPI communication matrix
		data.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TauThrottle"></a>2.2.&nbsp;Reducing Performance Overhead with TAU_THROTTLE</h2></div></div></div><p>TAU automatically throttles short running functions in an effort
			to reduce the amount of overhead associated with profiles of such functions.
			This feature may be turned off by setting the environment variable
			<code class="literal">TAU_THROTTLE</code> to 0.
      The default rules TAU uses to determine which functions to throttle is:
      <code class="literal">numcalls &gt; 100000 &amp;&amp; usecs/call &lt; 10</code>
      which means that if a function executes more than 100000 times and has
      an inclusive time per call of less than 10 microseconds, then profiling of
      that function will be disabled after that threshold is reached. To change the values of
      numcalls
      and usecs/call the user may optionally set environment variables:
      </p><pre class="screen">
% setenv TAU_THROTTLE_NUMCALLS 2000000
% setenv TAU_THROTTLE_PERCALL  5
  </pre><p>
      The changes the values to 2 million and 5 microseconds per call.  Functions that are throttled
      are marked explicitly in there names as THROTTLED. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="callpathProfiling"></a>2.3.&nbsp;Profiling each event callpath</h2></div></div></div><p>You can enable callpath profiling by setting the environment variable
		<code class="literal">TAU_CALLPATH</code>. In this mode TAU will recorded the each
		event callpath to the depth set by the <code class="literal">TAU_CALLPATH_DEPTH</code>
		environment variable (default is two). Because instrumentation overhead will increase with 
		the depth of the callpath, you should use the shortest call path that is sufficient.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MultipleHardwareCounters"></a>2.4.&nbsp;Using Hardware Counters for Measurement</h2></div></div></div><p>Performance counters exist on many modern microprocessors. They can
    count hardware performance events such as cache misses, floating point
    operations, etc. while the program executes on the processor. The
    Performance Data Standard and <code class="literal">API (<a href="http://icl.cs.utk.edu/papi/" target="_top">PAPI</a>)</code>
    package provides a uniform interface to access these performance
    counters.</p><p>To use these counters, you must first find out which PAPI events your system supports.
    To do so type:</p><pre class="screen">
%&gt; papi_avail 
Available events and hardware information.
-------------------------------------------------------------------------
Vendor string and code   : AuthenticAMD (2)
Model string and code    : AMD K8 Revision C (15)
CPU Revision             : 2.000000
CPU Megahertz            : 2592.695068
CPU's in this Node       : 4
Nodes in this System     : 1
Total CPU's              : 4
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------------------------------------
The following correspond to fields in the PAPI_event_info_t structure.

Name            Code            Avail   Deriv   Description (Note)
PAPI_L1_DCM     0x80000000      Yes     Yes     Level 1 data cache misses
PAPI_L1_ICM     0x80000001      Yes     Yes     Level 1 instruction cache misses
...

</pre><p>Next, to test the compatibility between each metric you wish papi to profile,
    use <code class="literal">papi_event_chooser:</code></p><pre class="screen">
papi/utils&gt; papi_event_chooser PAPI_LD_INS PAPI_SR_INS PAPI_L1_DCM
Test case eventChooser: Available events which can be added with given
events.
-------------------------------------------
Vendor string and code   : GenuineIntel (1)
Model string and code    : Itanium 2 (2)
CPU Revision             : 1.000000
CPU Megahertz            : 1500.000000
CPU's in this Node       : 16
Nodes in this System     : 1
Total CPU's              : 16
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------
Event PAPI_L1_DCM can't be counted with others
</pre><p>Here the event chooser tells us that PAPI_LD_INS, PAPI_SR_INS, and PAPI_L1_DCM 
    are incompatible metrics. Let try again this time removing PAPI_L1_DCM:</p><pre class="screen">
% papi/utils&gt; papi_event_chooser PAPI_LD_INS PAPI_SR_INS
Test case eventChooser: Available events which can be added with given
events.
-------------------------------------------
Vendor string and code   : GenuineIntel (1)
Model string and code    : Itanium 2 (2)
CPU Revision             : 1.000000
CPU Megahertz            : 1500.000000
CPU's in this Node       : 16
Nodes in this System     : 1
Total CPU's              : 16
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------
Usage: eventChooser NATIVE|PRESET evt1 evet2 ...
</pre><p>Here the event chooser verifies that PAPI_LD_INS and PAPI_SR_INS are compatible
    metrics.</p><p>Next, make sure that you are using a makefile with
		<code class="literal">papi</code> in its
		name. Then set the environment variable <code class="literal">TAU_METRICS</code> to a
		colon delimited list of PAPI metrics
		you would like to use.
	  </p><pre class="screen">
setenv TAU_METRICS PAPI_FP_OPS\:PAPI_L1_DCM
</pre><p>		
		
		</p><p>In addition to PAPI counters, we support TIME (via unix gettimeofday).
		On Linux and CrayCNL systems, we provide the high resolution LINUXTIMERS metric and 
		on BGL/BGP systems we provide BGLTIMERS and
		BGPTIMERS. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Tracing"></a>Chapter&nbsp;3.&nbsp;Tracing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></div><p>Typically, profiling shows the distribution of execution
  time across routines. It can show the code locations associated with
  specific bottlenecks, but it can not show the temporal aspect of
  performance variations. Tracing the execution of a parallel program
  shows when and where an event occurred, in terms of the process that
  executed it and the location in the source code. This chapter discusses
  how TAU can be used to generate event traces.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GeneratingEventTraces"></a>3.1.&nbsp;Generating Event Traces</h2></div></div></div><p>To enable tracing with TAU, set the environment variable
		<code class="literal">TAU_TRACE</code> to 1. Similarly you can enable/disable profile
		with the <code class="literal">TAU_PROFILE</code> variable. Just like with profiling, you can set
		the output directory with a environment variable:

		</p><pre class="screen">
% setenv TRACEDIR /users/sameer/tracedata/experiment56
</pre><p>

    This will generate a trace file and an event file for each processor. To
		merge these files, use the <code class="literal">tau_treemerge.pl</code> script. If you
		want to convert TAU trace file into another format use the
		<code class="literal">tau2otf</code>, <code class="literal">tau2vtf</code>, or
		<code class="literal">tau2slog2</code> scripts.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Analysis"></a>Chapter&nbsp;4.&nbsp;Analyzing Parallel Applications</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pprof"></a>4.1.&nbsp;Text summary</h2></div></div></div><p>For a quick view summary of TAU performance, use
		<code class="literal">pprof</code> It reads and prints a summary of the TAU data in the
		current directory. For performance data with multiple metrics, move into one
		of the directories to get information about that metric:</p><pre class="screen">
%&gt; cd MULTI__P_WALL_CLOCK_TIME
%&gt; pprof
Reading Profile files in profile.*

NODE 0;CONTEXT 0;THREAD 0: 
--------------------------------------------------------------------------------------- 
%Time    Exclusive    Inclusive       #Call      #Subrs  Inclusive Name 
              msec   total msec                          usec/call  
--------------------------------------------------------------------------------------- 
100.0           24          590           1           1     590963 main 
 95.9           26          566           1           2     566911 multiply 
 47.3          279          279           1           0     279280 multiply-opt 
 44.1          260          260           1           0     260860 multiply-regular 
 </pre><p>

   </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ParaProf.brief"></a>4.2.&nbsp;ParaProf</h2></div></div></div><p>To launch ParaProf, execute paraprof from the command line where
		 the profiles are located. Launching ParaProf will bring up the manager window and 
		 a window displaying the profile data as shown below. </p><div class="figure"><a name="paraprof.maindatawindow1.figure"></a><p class="title"><b>Figure&nbsp;4.1.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/maindatawindow.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div><p>For more information see the <a href="#ParaProfDoc" title="Part&nbsp;II.&nbsp;ParaProf - User's Manual">ParaProf section in the reference
		 guide</a>.
		 </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Jumpshot.brief"></a>4.3.&nbsp;Jumpshot</h2></div></div></div><p>To use Argonne's Jumpshot (bundled with TAU), first merge and convert TAU traces to slog2  
format:  
</p><pre class="screen"> 
% tau_treemerge.pl 
% tau2slog2 tau.trc tau.edf -o tau.slog2 
% jumpshot tau.slog2 
</pre><p> 
Launching Jumpshot will bring up the main display window showing the entire trace, zoom in  
to see more detail.</p><div class="figure"><a name="jumpshot.overview.figure"></a><p class="title"><b>Figure&nbsp;4.2.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/jumpshot-overview.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="StartersGuide"></a>Chapter&nbsp;5.&nbsp;Quick Reference</h2></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal"><a href="#tauex" title="tauex">tau_run</a></code></span></dt><dd>TAU's binary instrumentation tool</dd><dt><span class="term"><code class="literal">tau_cc.sh -tau_options=-optCompInst / tau_cxx.sh -tau_options=-optCompInst / tau_f90.sh -tau_options=-optCompInst</code></span></dt><dd><a href="#tau_compiler.sh" title="tau_compiler.sh">Compiler wrappers</a> (Compiler instrumentation)</dd><dt><span class="term"><code class="literal">tau_cc.sh / tau_cxx.sh / tau_f90.sh</code></span></dt><dd><a href="#tau_compiler.sh" title="tau_compiler.sh">Compiler wrappers</a> (PDT instrumentation)</dd><dt><span class="term"><code class="literal">TAU_MAKEFILE</code></span></dt><dd>Set instrumentation definition file</dd><dt><span class="term"><code class="literal">TAU_OPTIONS</code></span></dt><dd>Set instrumentation options</dd><dt><span class="term"><code class="literal">dynamic phase name=<span class="emphasis"><em>'name'</em></span>
		  file=<span class="emphasis"><em>'filename'</em></span>
			line=<span class="emphasis"><em>start_line_#</em></span> to
			line=<span class="emphasis"><em>end_line_#</em></span>	
			</code></span></dt><dd>Specify dynamic Phase</dd><dt><span class="term"><code class="literal">loops file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Instrument outer loops</dd><dt><span class="term"><code class="literal">memory file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Track memory</dd><dt><span class="term"><code class="literal">io file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Track IO</dd><dt><span class="term"><code class="literal">TAU_PROFILE / TAU_TRACE</code></span></dt><dd>Enable profiling and/or tracing</dd><dt><span class="term"><code class="literal">PROFILEDIR / TRACEDIR</code></span></dt><dd>Set profile/trace output directory</dd><dt><span class="term"><code class="literal">TAU_CALLPATH=1 / TAU_CALLPATH_DEPTH</code></span></dt><dd>Enable Callpath profiling, set callpath depth</dd><dt><span class="term"><code class="literal">TAU_THROTTLE=1 / TAU_THROTTLE_NUMCALLS / TAU_THROTTLE_PERCALL</code></span></dt><dd>Enable event throttling, set number of call, percall (us)
			threshold</dd><dt><span class="term"><code class="literal">TAU_METRICS</code></span></dt><dd>List of PAPI metrics to profile</dd><dt><span class="term"><code class="literal"><a href="#tau_treemerge.pl" title="tau_treemerge.pl">tau_treemerge.pl</a></code></span></dt><dd>Merge traces to one file</dd><dt><span class="term"><code class="literal"><a href="#tau2otf" title="tau2otf">tau2otf</a> / <a href="#tau2vtf" title="tau2vtf">tau2vtf</a> / <a href="#tau2slog2" title="tau2slog2">tau2slog2</a></code></span></dt><dd>Trace conversion tools</dd></dl></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ApplicationScenario"></a>Chapter&nbsp;6.&nbsp;Some Common Application Scenario</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e688">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e707">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e729">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e751">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e773">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e795">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e814">6.7. Q. How does my application scale?
</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e688"></a>6.1.&nbsp;Q. What routines account for the most time? How much?</h2></div></div></div><p>A. Create a flat profile with wallclock time.</p><div class="figure"><a name="d0e693"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;Flat Profile</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/flat_profile.png" align="middle" alt="Flat Profile"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e699"></a>Here is how to generate a flat profile with MPI</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-<span class="emphasis"><em>pdt</em></span>-pgi
 
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 

% paraprof app.ppk
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e707"></a>6.2.&nbsp;Q. What loops account for the most time? How much?</h2></div></div></div><p>A. Create a flat profile with wallclock time with loop instrumentation.</p><div class="figure"><a name="d0e712"></a><p class="title"><b>Figure&nbsp;6.2.&nbsp;Flat Profile with Loops</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/loop_profile.png" align="middle" alt="Flat Profile with Loops"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e718"></a>Here is how to instrument loops in an application</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
<span class="emphasis"><em>% setenv TAU_OPTIONS &#8216;-optTauSelectFile=select.tau &#8211;optVerbose&#8217;</em></span>
% cat select.tau
  BEGIN_INSTRUMENT_SECTION
  <span class="emphasis"><em>loops routine=&#8220;#&#8221;</em></span>
  END_INSTRUMENT_SECTION

% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 

% paraprof app.ppk
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e729"></a>6.3.&nbsp;Q. What MFlops am I getting in all loops?</h2></div></div></div><p>A. Create a flat profile with PAPI_FP_INS/OPS and time with loop instrumentation.</p><div class="figure"><a name="d0e734"></a><p class="title"><b>Figure&nbsp;6.3.&nbsp;MFlops per loop</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/mflops_profile.png" align="middle" alt="MFlops per loop"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e740"></a>Here is how to generate a flat profile with FP operations</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-<span class="emphasis"><em>papi</em></span>-mpi-pdt-pgi
% setenv TAU_OPTIONS &#8216;-optTauSelectFile=select.tau &#8211;optVerbose&#8217;
% cat select.tau
  BEGIN_INSTRUMENT_SECTION
  loops routine=&#8220;#&#8221;
  END_INSTRUMENT_SECTION

% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_METRICS GET_TIME_OF_DAY\:PAPI_FP_INS</em></span>
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 
% paraprof app.ppk
  Choose 'Options' -&gt; 'Show Derived Panel' -&gt; Arg 1 = PAPI_FP_INS, Arg 2 =
	GET_TIME_OF_DAY, Operation = Divide -&gt; Apply, close.
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e751"></a>6.4.&nbsp;Q. Who calls MPI_Barrier() Where?</h2></div></div></div><p>A. Create a callpath profile with given depth.</p><div class="figure"><a name="d0e756"></a><p class="title"><b>Figure&nbsp;6.4.&nbsp;Callpath Profile</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/callpath_profile.png" align="middle" alt="Callpath Profile"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e762"></a>Here is how to generate a callpath profile with MPI</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE
% /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_CALLPATH 1</em></span>
<span class="emphasis"><em>% setenv TAU_CALLPATH_DEPTH 100</em></span>

% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 
% paraprof app.ppk
(Windows -&gt; Thread -&gt; Call Graph)
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e773"></a>6.5.&nbsp;Q. How do I instrument Python Code?</h2></div></div></div><p>A. Create an python wrapper library.</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e778"></a>Here to instrument python code</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-icpc-python-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% setenv TAU_OPTIONS &#8216;<span class="emphasis"><em>-optShared</em></span> -optVerbose'
(Python needs shared object based TAU library)
% make F90=tau_f90.sh CXX=tau_cxx.sh CC=tau_cc.sh  (build pyMPI w/TAU)
% cat <span class="emphasis"><em>wrapper.py</em></span>
  import tau
  def OurMain():
      import App
  tau.run(&#8216;OurMain()&#8217;)
Uninstrumented:
% mpirun.lsf /pyMPI-2.4b4/bin/pyMPI ./App.py
Instrumented:
<span class="emphasis"><em>% setenv PYTHONPATH&lt;taudir&gt;/x86_64/&lt;lib&gt;/bindings-python-mpi-pdt-pgi</em></span>
(same options string as TAU_MAKEFILE)
<span class="emphasis"><em>setenv LD_LIBRARY_PATH &lt;taudir&gt;/x86_64/lib/bindings-icpc-python-mpi-pdt-pgi\:$LD_LIBRARY_PATH
% mpirun &#8211;np 4 &lt;dir&gt;/pyMPI-2.4b4-TAU/bin/pyMPI ./wrapper.py</em></span>
(Instrumented pyMPI with wrapper.py)
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e795"></a>6.6.&nbsp;Q. What happens in my code at a given time?
</h2></div></div></div><p>A. Create an event trace.</p><div class="figure"><a name="d0e800"></a><p class="title"><b>Figure&nbsp;6.5.&nbsp;Tracing with Vampir</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/vampir_trace.png" align="middle" alt="Tracing with Vampir"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e806"></a>How to create a trace</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE
% /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt-pgi
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_TRACE 1</em></span>
% qsub  run.job
% tau_treemerge.pl
(merges binary traces to create tau.trc and tau.edf files)
JUMPSHOT:
% tau2slog2 tau.trc tau.edf &#8211;o app.slog2 
% jumpshot app.slog2
   OR
VAMPIR:
% tau2otf tau.trc tau.edf app.otf &#8211;n 4 &#8211;z
(4 streams, compressed output trace)
% vampir app.otf
(or vng client with vngd server).
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e814"></a>6.7.&nbsp;Q. How does my application scale?
</h2></div></div></div><p>A. Examine profiles in PerfExplorer.</p><div class="figure"><a name="d0e819"></a><p class="title"><b>Figure&nbsp;6.6.&nbsp;Scalability chart</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/scalability.png" align="middle" alt="Scalability chart"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e825"></a>How to examine a series of profiles in PerfExplorer</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run1p.job
% paraprof -&#8211;pack 1p.ppk
% qsub run2p.job 
% paraprof -&#8211;pack 2p.ppk ...and so on.
On your client:
% <span class="emphasis"><em>perfdmf_configure</em></span>
(Choose derby, blank user/password, yes to save password, defaults)
% perfexplorer_configure
(Yes to load schema, defaults)
% paraprof 
(load each trial: Right click on trial -&gt;<span class="emphasis"><em>Upload trial to DB</em></span>
<span class="emphasis"><em>% perfexplorer </em></span>
(Charts -&gt; Speedup)
</pre></div></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="ParaProfDoc"></a>Part&nbsp;II.&nbsp;ParaProf - User's Manual</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#paraprof.intro">7. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.views">8. Views and Sub-Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.trialmanagement">9. Profile Data Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.3d">10. 3-D Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.threaddisplays">11. Thread Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.functiondisplays">12. Function Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.phasedisplays">13. Phase Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.comparison">14. Comparative Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.otherdisplays">15. Miscellaneous Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.preferences">16. Preferences</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.intro"></a>Chapter&nbsp;7.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></div><p>ParaProf is a portable, scalable performance analysis tool
  included with the TAU distribution.
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>ParaProf requires <span class="emphasis"><em>Oracle / Sun's</em></span> Java 1.5
	Runtime Environment for basic functionality.  Java JOGL (included) is
    required for 3d visualization and image export.  Additionally, OpenGL is
    required for 3d visualization.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Most windows in ParaProf can export bitmap (png/jpg) and vector
  (svg/eps) images to disk (png/jpg) or print directly to a printer.  This are
  available through the <span class="emphasis"><em>File</em></span> menu.</p></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usage"></a>7.1.&nbsp;Using ParaProf from the command line</h2></div></div></div><p>ParaProf is a java program that is run from the supplied
      <span><strong class="command">paraprof</strong></span> script (<span><strong class="command">paraprof.bat</strong></span> for
      windows binary release).
    </p><pre class="screen">% paraprof --help
Usage: paraprof [options] &lt;files/directory&gt;

Options:

  -f, --filetype &lt;filetype&gt;       Specify type of performance data, options are:
                                    profiles (default), pprof, dynaprof, mpip,
                                    gprof, psrun, hpm, packed, cube, hpc, ompp
                                    snap, perixml, gptl, ipm, google
  --range a-b:c                   Load only profiles from the given range(s) of processes
                                    Seperate individual ids or dash-defined ranges with colons
  -h, --help                      Display this help message

The following options will run only from the console (no GUI will launch):

  --merge &lt;file.gz&gt;               Merges snapshot profiles
  --pack &lt;file&gt;                   Pack the data into packed (.ppk) format
  --dump                          Dump profile data to TAU profile format
  --dumprank &lt;rank&gt;               Dump profile data for &lt;rank&gt; to TAU profile format
  -v, --dumpsummary               Dump derived statistical data to TAU profile format
  --overwrite                     Allow overwriting of profiles
  -o, --oss                       Print profile data in OSS style text output
  -q, --dumpmpisummary            Print high level time and communication summary
  -d, --metadump                  Print profile metadata (works with --dumpmpisummary)
  -x, --suppressmetrics           Exclude child calls and exclusive time from --dumpmpisummary
  -s, --summary                   Print only summary statistics
                                    (only applies to OSS output)

Notes:
  For the TAU profiles type, you can specify either a specific set of profile
files on the commandline, or you can specify a directory (by default the current
directory).  The specified directory will be searched for profile.*.*.* files,
or, in the case of multiple counters, directories named MULTI_* containing
profile data.

</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.formats"></a>7.2.&nbsp;Supported Formats</h2></div></div></div><p>ParaProf can load profile date from many sources.  The types
      currently supported are:
    </p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>TAU Profiles (profiles)</strong></span>
	  - Output from the TAU measurement library, these files generally take the
		form of <code class="filename">profile.X.X.X</code>, one for each
		node/context/thread combination.  When multiple counters are used, each
		metric is located in a directory prefixed with "MULTI__".  To launch
		ParaProf with all the metrics, simply launch it from the root of the
		MULTI__ directories.</p></li><li><p><span class="bold"><strong>ParaProf Packed Format
	  (ppk)</strong></span> - Export format supported by PerfDMF/ParaProf.
	  Typically .ppk.  </p></li><li><p><span class="bold"><strong>TAU Merged Profiles
	  (snap)</strong></span> - Merged and snapshot profile format supported by
	  TAU.  Typically tauprofile.xml.</p></li><li><p><span class="bold"><strong>TAU pprof (pprof)</strong></span> - Dump
	  Output from TAU's <span><strong class="command">pprof -d</strong></span>.  Provided for backward
	  compatibility only.</p></li><li><p><span class="bold"><strong>DynaProf (dynaprof)</strong></span> -
	  Output From DynaProf's wallclock and papi probes.  </p></li><li><p><span class="bold"><strong>mpiP (mpip)</strong></span> - Output
	  from mpiP.  </p></li><li><p><span class="bold"><strong>gprof (gprof)</strong></span> - Output
	  from gprof, see also the --fixnames option.  </p></li><li><p><span class="bold"><strong>PerfSuite (psrun)</strong></span> -
	  Output from PerfSuite psrun files.</p></li><li><p><span class="bold"><strong>HPM Toolkit (hpm)</strong></span> -
	  Output from IBM's HPM Toolkit.  </p></li><li><p><span class="bold"><strong>Cube (cube)</strong></span> - Output
	  from Kojak Expert tool for use with Cube.  </p></li><li><p><span class="bold"><strong>Cube3 (cube3)</strong></span> - Output
	  from Kojak Expert tool for use with Cube3 and Cube4.  </p></li><li><p><span class="bold"><strong>HPCToolkit (hpc)</strong></span> - XML
	  data from hpcquick.  Typically, the user runs hpcrun, then hpcquick on
	  the resulting binary file.  </p></li><li><p><span class="bold"><strong>OpenMP Profiler (ompp)</strong></span> -
	  CSV format from the ompP OpenMP Profiler (http://www.ompp-tool.com).  The
	  user must use OMPP_OUTFORMAT=CVS.</p></li><li><p><span class="bold"><strong>PERI XML (perixml)</strong></span> -
	  Output from the PERI data exchange format.</p></li><li><p><span class="bold"><strong>General Purpose Timing Library
	  (gptl)</strong></span> - Output from the General Purpose Timing
	  Library.</p></li><li><p><span class="bold"><strong>Paraver (paraver)</strong></span> -
	  2D output from the Paraver trace analysis tool from
	  BSC.</p></li><li><p><span class="bold"><strong>IPM (ipm)</strong></span> -
	  Integrated Performance Monitoring format, from NERSC.</p></li><li><p><span class="bold"><strong>Google (google)</strong></span> -
	  Google Profiles.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.options"></a>7.3.&nbsp;Command line options</h2></div></div></div><p>In addition to specifying the profile format, the user can also
      specify the following options</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>--fixnames</strong></span> - Use the fixnames option
	  for gprof.  When C and Fortran code are mixed, the C routines have to be mapped
	  to either .function or function_.  Strip the leading period or trailing underscore, if it is there.  
	</p></li><li><p><span class="bold"><strong>--pack &lt;file&gt;</strong></span> - Rather
	  than load the data and launch the GUI, pack the data into the specified file.
	</p></li><li><p><span class="bold"><strong>--dump</strong></span> - Rather than
	  load the data and launch the GUI, dump the data to TAU Profiles.
	  This can be used to convert supported formats to TAU Profiles.
	</p></li><li><p><span class="bold"><strong>--oss</strong></span> - Outputs profile
	  data in OSS Style.  Example:

	  </p><pre class="screen">
-------------------------------------------------------------------------------
Thread: n,c,t 0,0,0
-------------------------------------------------------------------------------
 excl.secs  excl.%   cum.%    PAPI_TOT_CYC     PAPI_FP_OPS     calls  function
     0.005   56.0%   56.0%        13475345         4194518         1  foo
     0.003   40.1%   96.1%         9682185         4205367         1  bar
         0    3.6%   99.7%          223173           17445         1  baz
   2.2E-05    0.3%  100.0%           14663             206         1  main
</pre><p>

	</p></li><li><p><span class="bold"><strong>--summary</strong></span> - Output only summary
	  information for OSS style output.
	</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.views"></a>Chapter&nbsp;8.&nbsp;Views and Sub-Views</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></div><p>
 In the past, PerfDMF used a hierarchy of Applications and Experiments to organize Trials.  This approach was too rigid, so in TAUdb, trials are organized by dynamic Views.  Views are lists of Trials that share a given metadata value.  For example, a View could contain all the Trials where the total number of threads is less than 16.    Views can also have Sub-Views.  For example, it might be useful to have a View of all Trials from a certain machine and then Sub-Views for each executable ran on that machine.  Trials can belong to any number of VIews and Sub-Views and new Trials loaded to the database will be sorted into Views automatically.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.createviews"></a>8.1.&nbsp;To Create a (Sub-)Views</h2></div></div></div><p>
Launch ParaProf and Right click on a database or an existing View and select "Add View" or "Add Sub-View."  
</p><div class="figure"><a name="d0e1021"></a><p class="title"><b>Figure&nbsp;8.1.&nbsp;Add View</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/AddView.png" align="middle" alt="Add View"></td></tr></table><div class="caption"><p>
 In ParaProf and PerfExplorer, Views are marked by the Folder Icon and Trials are now marked with a yellow ball.  (The "All Trials" View is created when a database is created.)  
</p></div></div></div><p>
This will launch the View Creator window.  
</p><div class="figure"><a name="d0e1032"></a><p class="title"><b>Figure&nbsp;8.2.&nbsp;View Creator Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/ViewCreator.png" align="middle" alt="View Creator Window"></td></tr></table></div></div><p>
Here you can create the rule(s) for which Trials appear in this new View.  At the top you can choose to match all of the rules ("and") or to match any of the rules.  The "-" or "=" buttons will remove the current rule or add a new one.  The first drop down box  chooses which metadata field to use.  The second box chooses whether the field should be read as a string or a number.  Depending on whether it is read as a string or a number, the fourth box will give options on how to compare the metadata field.  So to create a View for all trials that have less than 16 threads, select total_threads, read as a string, is less than, 16.  Then click Save and give the View a name.  
</p><p>
The 'Edit' context menu option on an existing view will allow you to view and alter the view's criteria in the same interface. 
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.trialmanagement"></a>Chapter&nbsp;9.&nbsp;Profile Data Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></div><p>ParaProf uses <em class="firstterm">PerfDMF</em> to manage profile
  data.  This enables it to read the various profile formats as well as
  store and retrieve them from a database.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.mainwindow"></a>9.1.&nbsp;ParaProf Manager Window</h2></div></div></div><p>Upon launching ParaProf, the user is greeted with the ParaProf Manager Window.</p><div class="figure"><a name="paraprof.mainwindow.figure"></a><p class="title"><b>Figure&nbsp;9.1.&nbsp;ParaProf Manager Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/manager.gif" align="middle" alt="ParaProf Manager Window"></td></tr></table></div></div><p>This window is used to manage profile data.  The user can
      upload/download profile data, edit meta-data, launch visual displays,
      export data, derive new metrics, etc.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.loading"></a>9.2.&nbsp;Loading Profiles</h2></div></div></div><p>To load profile data, select File-&gt;Open, or right click on the
    Application's tree and select "Add Trial".
    </p><div class="figure"><a name="d0e1069"></a><p class="title"><b>Figure&nbsp;9.2.&nbsp;Loading Profile Data</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="216"><tr><td align="center"><img src="images/loadtrial.gif" align="middle" alt="Loading Profile Data"></td></tr></table></div></div><p>Select the type of data from the "Trial Type" drop-down box.  For TAU
    Profiles, select a directory, for other types, files.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.database"></a>9.3.&nbsp;Database Interaction</h2></div></div></div><p>
      Database interaction is done through the tree view of the ParaProf
      Manager Window.  Applications expand to Experiments, Experiments to
      Trials, and Trials are loaded directly into ParaProf just as if they were
      read off disk.  Additionally, the meta-data associated with each element
      is show on the right, as in <a href="#paraprof.mainwindow.figure" title="Figure&nbsp;9.1.&nbsp;ParaProf Manager Window">Figure&nbsp;9.1, &#8220;ParaProf Manager Window&#8221;</a>.  A trial can be exported by right clicking on it and selecting
      "Export as Packed Profile".
    </p><p>
      New trials can be uploaded to the database by either right-clicking on an
      entity in the database and selecting "Add Trial", or by right-clicking
      on an Application/Experiment/Trial hierarchy from the "Standard
      Applications" and selecting "Upload Application/Experiment/Trial to DB".
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.derivedmetrics"></a>9.4.&nbsp;Creating Derived Metrics</h2></div></div></div><p>ParaProf can created derived metrics using the <span class="emphasis"><em>Derived
	Metric Panel</em></span>, available from the <span class="emphasis"><em>Options</em></span>
      menu of the ParaProf Manager Window.
    </p><div class="figure"><a name="paraprof.derivedmetrics.figure"></a><p class="title"><b>Figure&nbsp;9.3.&nbsp;Creating Derived Metrics</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/derivedmetric.gif" align="middle" alt="Creating Derived Metrics"></td></tr></table></div></div><p>In <a href="#paraprof.derivedmetrics.figure" title="Figure&nbsp;9.3.&nbsp;Creating Derived Metrics">Figure&nbsp;9.3, &#8220;Creating Derived Metrics&#8221;</a>, we have just
      divided Floating Point Instructions by Wall-clock time, creating FLOPS
      (Floating Point Operations per Second).  The 2nd argument is a user
      editable text-box and can be filled in with scalar values by using the
      keyword 'val' (e.g. "val 1.5").
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.maindatawindow"></a>9.5.&nbsp;Main Data Window</h2></div></div></div><p>Upon loading a profile, or double-clicking on a metric, the
        <em class="firstterm">Main Data Window</em> will be displayed.</p><div class="figure"><a name="paraprof.maindatawindow.figure"></a><p class="title"><b>Figure&nbsp;9.4.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/maindatawindow.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div><p>This window shows each thread as well as statistics as a combined bar
      graph.  Each function is represented by a different color (though
      possibly cycled).  From anywhere in ParaProf, you can right-click on
      objects representing threads or functions to launch displays associated
      with those objects.  For example, in <a href="#paraprof.maindatawindow.figure" title="Figure&nbsp;9.4.&nbsp;Main Data Window">Figure&nbsp;9.4, &#8220;Main Data Window&#8221;</a>, right click on the text
      <span class="emphasis"><em>n,c,t, 8,0,0</em></span> to launch thread based displays for
      node 8.
    </p><div class="figure"><a name="d0e1128"></a><p class="title"><b>Figure&nbsp;9.5.&nbsp;Unstacked Bars</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/unstacked.gif" align="middle" alt="Unstacked Bars"></td></tr></table></div></div><p>
      You may also turn off the stacking of bars so that individual functions
      can be compared across threads in a global display.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.3d"></a>Chapter&nbsp;10.&nbsp;3-D Visualization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></div><p>ParaProf displays massive parallel profiles through the use of OpenGL
    hardware acceleration through the <em class="firstterm">3D Visualization</em>
    window.  Each window is fully configurable with rotation, translation, and
    zooming capabilities.  Rotation is accomplished by holding the left mouse
    button down and dragging the mouse.  Translation is done likewise with the
    right mouse button.  Zooming is done with the mousewheel and the + and -
    keyboard buttons.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.trianglemesh"></a>10.1.&nbsp;Triangle Mesh Plot</h2></div></div></div><div class="figure"><a name="d0e1148"></a><p class="title"><b>Figure&nbsp;10.1.&nbsp;Triangle Mesh Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/trianglemeshplot.gif" align="middle" alt="Triangle Mesh Plot"></td></tr></table></div></div><p>This visualization method shows two metrics for all functions, all
      threads.  The height represents one chosen metric, and the color,
      another.  These are selected from the drop-down boxes on the right.
    </p><p>To pinpoint a specific value in the plot, move the
      <span class="emphasis"><em>Function</em></span> and <span class="emphasis"><em>Thread</em></span> sliders to
      cycle through the available functions/threads.  The values for the two
      metrics, in this case for <code class="function">MPI_Recv()</code> on
      <code class="literal">Node 351</code>, the value is <code class="literal">14.37</code>
      seconds.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.3dbarplot"></a>10.2.&nbsp;3-D Bar Plot</h2></div></div></div><div class="figure"><a name="paraprof.3dbarplot.figure"></a><p class="title"><b>Figure&nbsp;10.2.&nbsp;3-D Mesh Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3dvew1.png" align="middle" alt="3-D Mesh Plot"></td></tr></table></div></div><p>This visualization method is similar to the triangle mesh plot.  It
      simply displays the data using 3d bars instead of a mesh.  The controls
      works the same.  Note that in <a href="#paraprof.3dbarplot.figure" title="Figure&nbsp;10.2.&nbsp;3-D Mesh Plot">Figure&nbsp;10.2, &#8220;3-D Mesh Plot&#8221;</a>
      the transparency option is selected, which changes the way in which the
      selection model operates. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.scatterplot"></a>10.3.&nbsp;3-D Scatter Plot</h2></div></div></div><div class="figure"><a name="d0e1189"></a><p class="title"><b>Figure&nbsp;10.3.&nbsp;3-D Scatter Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/scatterplot2.gif" align="middle" alt="3-D Scatter Plot"></td></tr></table></div></div><p>This visualization method plots the value of each thread along up to
      4 axes (each a different function/metric).  This view allows you to
      discern clustering of values and relationships between functions across
      threads.</p><p>Select functions using the button for each dimension, then select a
    metric.  A single function across 4 metrics could be used, for
    example.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.top)ology"></a>10.4.&nbsp;3-D Topology Plot</h2></div></div></div><div class="figure"><a name="d0e1202"></a><p class="title"><b>Figure&nbsp;10.4.&nbsp;3-D Topology Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/topology2.gif" align="middle" alt="3-D Topology Plot"></td></tr></table></div></div><p> In this visualization, you can either define the layout with a MESP topology definition 
         file or you can fill a rectangular prism of user-defined volume with rank-points in order of rank.
         For more information, please see the etc/topology directory for additional details on MESP 
         topology definitions.
       </p><p> If the loaded profile is a cube file or a profile from a BGB, then this visualizations 
        groups the threads in two or three dimensional space using topology
        information supplied by the profile.</p><p>
When topology metadata is available a trial-specific topological layout may be visualized by selecting Windows-&gt;gt;3D Visualization and selecting Topology Plot on the visualization pane.
</p><p>
The layout tab allows control of the layout and display of visualized cores/processes.

</p><p>
Minimum/Maximum Visible (restricts display of nodes with measured values above/below the selected levels).  Lock Range causes the sliders to move in unison.

</p><p>
The X/Y/Z Axis sliders allow selection of planes, lines and individual points in the topology for examination of specific values in the display, listed in the Avg. Color Value field.

</p><p>
The topology selection dropdown box allows selection of either trial-specific topologies contained in the metadata, mapped topologies stored in an external file or a custom topology defined by the size of the prism containing the visualized cores.  The ... button allows selection of a custom topology mapping file while the map button allows selection of a map file (see &lt;tau2&gt;/etc/topology/README.cray_map for more information on generating map files).

</p><p>
If a Custom is selected the dimensions of the rectangular prism containing the cores are defined by the X/Y/Z axis control widgets.

</p><p>
The Events tab controls which events are used to define the color values and positions of cores/processes in the display.  For trail-specific and Custom topologies only event3(Color) can be changed.  For topologies loaded in MESP definition files all four events may be used in calculation of the topology layout.  In either case, interval, atomic or metadata values may be used to color or position points in the display.
    
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.commicationmatrix"></a>10.5.&nbsp;3-D Commication Matrix</h2></div></div></div><div class="figure"><a name="d0e1229"></a><p class="title"><b>Figure&nbsp;10.5.&nbsp;3-D Commication Matrix</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3DCommMatrix.png" align="middle" alt="3-D Commication Matrix"></td></tr></table></div></div><p> 
   If a Trial has commication information (set  TAU_COMM_MATRIX=1 at runtime of your application), then you can launch the 3D Commication window as shown.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.threaddisplays"></a>Chapter&nbsp;11.&nbsp;Thread Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></div><p>ParaProf displays several windows that show data for one thread of
      execution.  In addition to per thread values, the users may also select
      <span class="emphasis"><em>mean</em></span> or <span class="emphasis"><em>standard deviation</em></span> as
      the "thread" to display.  In this mode, the mean or standard deviation of
      the values across the threads will be used as the value.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.threaddatawindow"></a>11.1.&nbsp;Thread Bar Graph</h2></div></div></div><div class="figure"><a name="d0e1252"></a><p class="title"><b>Figure&nbsp;11.1.&nbsp;Thread Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="304"><tr><td align="center"><img src="images/threaddatawindow.gif" align="middle" alt="Thread Bar Graph"></td></tr></table></div></div><p>This display graphs each function on a particular thread for
      comparison.  The metric, units, and sort order can be changed from the
      <span class="emphasis"><em>Options</em></span> menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.threadstatwindow"></a>11.2.&nbsp;Thread Statistics Text Window</h2></div></div></div><div class="figure"><a name="d0e1266"></a><p class="title"><b>Figure&nbsp;11.2.&nbsp;Thread Statistics Text Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="477"><tr><td align="center"><img src="images/threadstatwindow.gif" align="middle" alt="Thread Statistics Text Window"></td></tr></table></div></div><p>This display shows a <span><strong class="command">pprof</strong></span> style text view of the
      data.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.treetablewindow"></a>11.3.&nbsp;Thread Statistics Table</h2></div></div></div><div class="figure"><a name="paraprof.thread.treetable1"></a><p class="title"><b>Figure&nbsp;11.3.&nbsp;Thread Statistics Table, inclusive and exclusive</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable1.gif" align="middle" alt="Thread Statistics Table, inclusive and exclusive"></td></tr></table></div></div><p>
      This display shows the callpath data in a table.  Each callpath can be traced
      from root to leaf by opening each node in the tree view.  A colorscale
      immediately draws attention to "hot spots", areas that contain highest values.
    </p><div class="figure"><a name="paraprof.thread.treetable2"></a><p class="title"><b>Figure&nbsp;11.4.&nbsp;Thread Statistics Table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable2.gif" align="middle" alt="Thread Statistics Table"></td></tr></table></div></div><div class="figure"><a name="paraprof.thread.treetable3"></a><p class="title"><b>Figure&nbsp;11.5.&nbsp;Thread Statistics Table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable3.gif" align="middle" alt="Thread Statistics Table"></td></tr></table></div></div><p>
      The display can be used in one of two ways, in "inclusive/exclusive"
      mode, both the inclusive and exclusive values are shown for each path,
      see <a href="#paraprof.thread.treetable1" title="Figure&nbsp;11.3.&nbsp;Thread Statistics Table, inclusive and exclusive">Figure&nbsp;11.3, &#8220;Thread Statistics Table, inclusive and exclusive&#8221;</a> for an example.
    </p><p>
      When this option is off, the inclusive value for a node is show when it
      is closed, and the exclusive value is shown when it is open.  This allows
      the user to more easily see where the time is spent since the total time
      for the application will always be represented in one column.  See <a href="#paraprof.thread.treetable2" title="Figure&nbsp;11.4.&nbsp;Thread Statistics Table">Figure&nbsp;11.4, &#8220;Thread Statistics Table&#8221;</a> and <a href="#paraprof.thread.treetable3" title="Figure&nbsp;11.5.&nbsp;Thread Statistics Table">Figure&nbsp;11.5, &#8220;Thread Statistics Table&#8221;</a> for examples.
      
      This display also functions as a regular statistics table without
      callpath data.  The data can be sorted by columns by clicking on the
      column heading.  When multiple metrics are available, you can add and
      remove columns for the display using the menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.callgraphwindow"></a>11.4.&nbsp;Call Graph Window</h2></div></div></div><div class="figure"><a name="d0e1313"></a><p class="title"><b>Figure&nbsp;11.6.&nbsp;Call Graph Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="274"><tr><td align="center"><img src="images/callgraph.gif" align="middle" alt="Call Graph Window"></td></tr></table></div></div><p>This display shows callpath data in a graph using two metrics, one
      determines the width, the other the color.  The full name of the function
      as well as the two values (color and width) are displayed in a tooltip
      when hovering over a box.  By clicking on a box, the actual ancestors and
      descendants for that function and their paths (arrows) will be
      highlighted with blue.  This allows you to see which functions are called
      by which other functions since the interplay of multiple paths may
      obscure it.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.callpaththreadrelations"></a>11.5.&nbsp;Thread Call Path Relations Window</h2></div></div></div><div class="figure"><a name="paraprof.thread.callpathrelations"></a><p class="title"><b>Figure&nbsp;11.7.&nbsp;Thread Call Path Relations Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/callpaththreadrelations.gif" align="middle" alt="Thread Call Path Relations Window"></td></tr></table></div></div><p>This display shows callpath data in a <span><strong class="command">gprof</strong></span> style
      view.  Each function is shown with its immediate parents.  For example,
      <a href="#paraprof.thread.callpathrelations" title="Figure&nbsp;11.7.&nbsp;Thread Call Path Relations Window">Figure&nbsp;11.7, &#8220;Thread Call Path Relations Window&#8221;</a> shows that
      <code class="function">MPI_Recv()</code> is call from two places for a total of
      <code class="literal">9.052</code> seconds.  Most of that time comes from the 30
      calls when <code class="function">MPI_Recv()</code> is called by
      <code class="function">MPIScheduler::postMPIRecvs()</code>.  The other 60 calls do
      not amount to much time.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usereventstats"></a>11.6.&nbsp;User Event Statistics Window</h2></div></div></div><div class="figure"><a name="d0e1353"></a><p class="title"><b>Figure&nbsp;11.8.&nbsp;User Event Statistics Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="504"><tr><td align="center"><img src="images/usereventstats.gif" align="middle" alt="User Event Statistics Window"></td></tr></table></div></div><p>This display shows a <span><strong class="command">pprof</strong></span> style text view of the
      user event data.  Right clicking on a User Event will give you the option
      to open a Bar Graph for that particular User Event across all threads.  See
      <a href="#paraprof.userevent.bargraph" title="15.1.&nbsp;User Event Bar Graph">Section&nbsp;15.1, &#8220;User Event Bar Graph&#8221;</a></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usereventthreadbar"></a>11.7.&nbsp;User Event Thread Bar Chart</h2></div></div></div><div class="figure"><a name="d0e1368"></a><p class="title"><b>Figure&nbsp;11.9.&nbsp;User Event Thread Bar Chart Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="504"><tr><td align="center"><img src="images/usereventthreadbargraph.gif" align="middle" alt="User Event Thread Bar Chart Window"></td></tr></table></div></div><p>This display shows a particular thread's user defined event
    statistics as a bar chart.  This is the same data from the <a href="#paraprof.usereventstats" title="11.6.&nbsp;User Event Statistics Window">Section&nbsp;11.6, &#8220;User Event Statistics Window&#8221;</a>, in graphical form.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.functiondisplays"></a>Chapter&nbsp;12.&nbsp;Function Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></div><p>ParaProf has two displays for showing a single function across all
  threads of execution.  This chapter describes the Function Bar Graph
  Window and the Function Histogram Window.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.function.bargraph"></a>12.1.&nbsp;Function Bar Graph</h2></div></div></div><div class="figure"><a name="d0e1387"></a><p class="title"><b>Figure&nbsp;12.1.&nbsp;Function Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="277"><tr><td align="center"><img src="images/functionbargraph.gif" align="middle" alt="Function Bar Graph"></td></tr></table></div></div><p>This display graphs the values that the particular function had for
      each thread along with the mean and standard deviation across the
      threads.  You may also change the units and metric displayed from the
      <span class="emphasis"><em>Options</em></span> menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.function.histogram"></a>12.2.&nbsp;Function Histogram</h2></div></div></div><div class="figure"><a name="d0e1401"></a><p class="title"><b>Figure&nbsp;12.2.&nbsp;Function Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="342"><tr><td align="center"><img src="images/functionhistogram.gif" align="middle" alt="Function Histogram"></td></tr></table></div></div><p>This display shows a histogram of each thread's value for the given
      function.  Hover the mouse over a given bar to see the range minimum and
      maximum and how many threads fell into that range.  You may also change
      the units and metric displayed from the <span class="emphasis"><em>Options</em></span>
      menu.
    </p><p>
      You may also dynamically change how many bins are used (1-100) in the
      histogram.  This option is available from the
      <span class="emphasis"><em>Options</em></span> menu.  Changing the number of bins can
      dramatically change the shape of the histogram, play around with it to
      get a feel for the true distribution of the data.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.phasedisplays"></a>Chapter&nbsp;13.&nbsp;Phase Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></div><p>When a profile contains phase data, ParaProf will automatically run in
  phase mode.  Most displays will show data for a particular phase.  This phase
  will be displayed in teh top left corner in the meta data panel.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.phase.mainwindow"></a>13.1.&nbsp;Using Phase Based Displays</h2></div></div></div><p>The initial window will default to top level phase, usually <span class="emphasis"><em>main</em></span></p><div class="figure"><a name="d0e1430"></a><p class="title"><b>Figure&nbsp;13.1.&nbsp;Initial Phase Display</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="401"><tr><td align="center"><img src="images/phase_main.gif" align="middle" alt="Initial Phase Display"></td></tr></table></div></div><p>To access other phases, either right click on the phase and select,
    "Open Profile for this Phase", or go to the <span class="emphasis"><em>Phase
    Ledger</em></span> and select it there.
    </p><div class="figure"><a name="d0e1441"></a><p class="title"><b>Figure&nbsp;13.2.&nbsp;Phase Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="189"><tr><td align="center"><img src="images/phase_ledger.gif" align="middle" alt="Phase Ledger"></td></tr></table></div></div><p>ParaProf can also display a particular function's value across all of
    the phases.  To do so, right click on a function and select, "Show Function Data over Phases".
    </p><div class="figure"><a name="d0e1449"></a><p class="title"><b>Figure&nbsp;13.3.&nbsp;Function Data over Phases</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="325"><tr><td align="center"><img src="images/phase_function.gif" align="middle" alt="Function Data over Phases"></td></tr></table></div></div><p>Because Phase information is implemented as callpaths, many of the
    callpath displays will show phase data as well.  For example, the Call Path
    Text Window is useful for showing how functions behave across phases.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.comparison"></a>Chapter&nbsp;14.&nbsp;Comparative Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></div><p>ParaProf can perform cross-thread and cross-trial anaylsis.  In this
  way, you can compare two or more trials and/or threads in a single display.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.comparison.using"></a>14.1.&nbsp;Using Comparitive Analysis</h2></div></div></div><p>Comparative analysis in ParaProf is based on individual threads of
    execution.  There is a maximum of one Comparison window for a given
    ParaProf session.  To add threads to the window, right click on them and
    select "Add Thread to Comparison Window".  The Comparison Window will pop
    up with the thread selected.  Note that "mean" and "std. dev." are
    considered threads for this any most other purposes.
    </p><div class="figure"><a name="d0e1468"></a><p class="title"><b>Figure&nbsp;14.1.&nbsp;Comparison Window (initial)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison1.gif" align="middle" alt="Comparison Window (initial)"></td></tr></table></div></div><p>Add additional threads, from any trial, by the same means.
    </p><div class="figure"><a name="d0e1476"></a><p class="title"><b>Figure&nbsp;14.2.&nbsp;Comparison Window (2 trials)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison2.gif" align="middle" alt="Comparison Window (2 trials)"></td></tr></table></div></div><div class="figure"><a name="d0e1482"></a><p class="title"><b>Figure&nbsp;14.3.&nbsp;Comparison Window (3 threads)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison3.gif" align="middle" alt="Comparison Window (3 threads)"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.otherdisplays"></a>Chapter&nbsp;15.&nbsp;Miscellaneous Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.userevent.bargraph"></a>15.1.&nbsp;User Event Bar Graph</h2></div></div></div><p>In addition to displaying the text statistics for User Defined
      Events, ParaProf can also graph a particular User Event across all
      threads.</p><div class="figure"><a name="d0e1497"></a><p class="title"><b>Figure&nbsp;15.1.&nbsp;User Event Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="284"><tr><td align="center"><img src="images/usereventbargraph.gif" align="middle" alt="User Event Bar Graph"></td></tr></table></div></div><p>This display graphs the value that the particular user event had for each thread.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.ledgers"></a>15.2.&nbsp;Ledgers</h2></div></div></div><p>ParaProf has three ledgers that show the functions, groups, and user events.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.function"></a>15.2.1.&nbsp;Function Ledger</h3></div></div></div><div class="figure"><a name="d0e1513"></a><p class="title"><b>Figure&nbsp;15.2.&nbsp;Function Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="248"><tr><td align="center"><img src="images/functionledger.gif" align="middle" alt="Function Ledger"></td></tr></table></div></div><p>The function ledger shows each function along with its current
	color.  As with other displays showing functions, you may right-click on
	a function to launch other function-specific displays.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.group"></a>15.2.2.&nbsp;Group Ledger</h3></div></div></div><div class="figure"><a name="d0e1524"></a><p class="title"><b>Figure&nbsp;15.3.&nbsp;Group Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/groupledger.gif" align="middle" alt="Group Ledger"></td></tr></table></div></div><p>The group ledger shows each group along with its current color.
	This ledger is especially important because it gives you the ability to
	mask all of the other displays based on group membership.  For example,
	you can right-click on the <code class="literal">MPI</code> group and select
	"Show This Group Only" and all of the windows will now mask to only
	those functions which are members of the <code class="literal">MPI</code> group.
	You may also mask by the inverse by selecting "Show All Groups Except
	This One" to mask out a particular group.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.userevent"></a>15.2.3.&nbsp;User Event Ledger</h3></div></div></div><div class="figure"><a name="d0e1541"></a><p class="title"><b>Figure&nbsp;15.4.&nbsp;User Event Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="185"><tr><td align="center"><img src="images/usereventledger.gif" align="middle" alt="User Event Ledger"></td></tr></table></div></div><p>
	The user event ledger shows each user event along with its current color.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.createselectivefile"></a>15.3.&nbsp;Selective Instrumentation File Generator</h2></div></div></div><p>ParaProf can also help you refine your program performance by
		excluding some functions from instrumentation. You can select rules to
		determine which function get excluded; both rules must be true for a given
		function to be excluded. Below each function that will be excluded based
		on these rules are listed. 
		</p><div class="figure"><a name="d0e1554"></a><p class="title"><b>Figure&nbsp;15.5.&nbsp;Selective Instrumentation Dialog</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="284"><tr><td align="center"><img src="images/ParaProfSelectiveFile.gif" align="middle" alt="Selective Instrumentation Dialog"></td></tr></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Only the functions profilied in ParaProf can be excluded. If you
		had previously setup selective instrumentation for this application the
		functions that where previously excluded will not longer be excluded.</p></td></tr></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.preferences"></a>Chapter&nbsp;16.&nbsp;Preferences</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></div><p>Preferences are modified from
  the ParaProf Preferences Window, launched from the File menu. Preferences
  are saved between sessions in the
  <code class="filename">.ParaProf/ParaProf.prefs</code> 
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.window"></a>16.1.&nbsp;Preferences Window</h2></div></div></div><p>In addition to displaying the text statistics for User Defined
      Events, ParaProf can also graph a particular User Event across all
      threads. </p><div class="figure"><a name="d0e1577"></a><p class="title"><b>Figure&nbsp;16.1.&nbsp;ParaProf Preferences Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="298"><tr><td align="center"><img src="images/preferences.gif" align="middle" alt="ParaProf Preferences Window"></td></tr></table></div></div><p>The preferences window allows the user to modify the behavior and
      display style of ParaProf's windows.  The font size affects bar height, a
      sample display is shown in the upper-right.
    </p><p>The Window defaults section will determine the initial settings for
      new windows.  You may change the initial units selection and whether you
      want values displayed as percentages or as raw values.
    </p><p>The Settings section controls the following</p><div class="itemizedlist"><ul type="disc"><li><p>Show Path Title in Reverse - Path title will normally be
	  shown in normal order (/home/amorris/data/etc).  They can be reverse
	  using this option (etc/data/amorris/home).  This only affects loaded
	  trials and the titlebars of new windows.</p></li><li><p>Reverse Call Paths - This option will immediately change
	  the display of all callpath functions between <code class="literal">Root =&gt;
	    Leaf</code> and <code class="literal">Leaf &lt;= Root</code>.</p></li><li><p>Statistics Computation - Turning this option on causes
	  the mean computation to take the sum of value for a function across all
	  threads and divide it by the total number of threads.  With this option
	  off the sum will only be divided by the number of threads that actively
	  participated in the sum.  This way the user can control whether or not
	  threads which do not call a particular function are consider as a
	  <code class="literal">0</code> in the computation of statistics.</p></li><li><p>
	  Generate Reverse Calltree Data - This option will enable
	  the generation of reverse callpath data necessary for the reverse callpath option of the statistics tree-table window.
	</p></li><li><p>
	  Show Source Locations - This option will enable the display of source code locations in event names.
	</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.defaultcolors"></a>16.2.&nbsp;Default Colors</h2></div></div></div><div class="figure"><a name="d0e1617"></a><p class="title"><b>Figure&nbsp;16.2.&nbsp;Edit Default Colors</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="443"><tr><td align="center"><img src="images/defaultcolors.gif" align="middle" alt="Edit Default Colors"></td></tr></table></div></div><p>The default color editor changes how colors are distributed to
      functions whose color has not been specifically assigned.  It is
      accessible from the File menu of the Preferences Window. 
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.colormap"></a>16.3.&nbsp;Color Map</h2></div></div></div><div class="figure"><a name="d0e1628"></a><p class="title"><b>Figure&nbsp;16.3.&nbsp;Color Map</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="229"><tr><td align="center"><img src="images/colormap.gif" align="middle" alt="Color Map"></td></tr></table></div></div><p>The color map shows specifically assigned colors.  These values are
      used across all trials loaded so that the user can identify a particular
      function across multiple trials.  In order to map an entire trial's
      function set, Select "Assign Defaults from -&gt;" and select a loaded trial.
    </p><p>Individual functions can be assigned a particular color by
      clicking on them in any of the other ParaProf Windows.
    </p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="PerfExplorerDoc"></a>Part&nbsp;III.&nbsp;PerfExplorer - User's Manual</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#Introduction">17. Introduction</a></span></dt><dt><span class="chapter"><a href="#InstallPerfExplorer">18. Installation and Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RunningPerfExplorer">19. Running PerfExplorer</a></span></dt><dt><span class="chapter"><a href="#ClusterAnalysis">20. Cluster Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#CorrelationAnalysis">21. Correlation Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Charts">22. Charts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CustomCharts">23. Custom Charts</a></span></dt><dt><span class="chapter"><a href="#Visualization">24. Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Views">25. Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Scripting">26. Running PerfExplorer Scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Derived Metrics">27. Derived Metrics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Introduction"></a>Chapter&nbsp;17.&nbsp;Introduction</h2></div></div></div><p>PerfExplorer is a framework for parallel performance data
        mining and knowledge discovery. The framework architecture
        enables the development and integration of data mining
        operations that will be applied to large-scale parallel
        performance profiles.</p><p>The overall goal of the PerfExplorer project is to create
        a software to integrate sophisticated data mining techniques in
        the analysis of large-scale parallel performance data.</p><p>PerfExplorer supports clustering, summarization,
        association, regression, and correlation.  Cluster analysis is
        the process of organizing data points into logically similar
        groupings, called clusters.  Summarization is the process of
        describing the similarities within, and dissimilarities between,
        the  discovered clusters.  Association is the process of finding
        relationships in the data.  One such method of association is
        regression analysis, the process of finding independent and
        dependent correlated variables in the data.  In addition,
        comparative analysis extends these operations to   compare
        results from different experiments, for instance, as part of a
        parametric study.</p><p>In addition to the data mining operations available, the
        user may optionally choose to perform comparative analysis.  The
        types of charts available include time-steps per second,
        relative efficiency and speedup of the entire application,
        relative efficiency and speedup of one event, relative
        efficiency and speedup for all events, relative efficiency and
        speedup for all phases and runtime breakdown of the application
        by event or by phase.  In addition, when the events are grouped
        together, such as in the case of communication routines, yet
        another chart shows the percentage of total runtime spent in
        that group of events.  These analyses can be conducted across
        different combinations of parallel profiles and across phases
        within an execution.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="InstallPerfExplorer"></a>Chapter&nbsp;18.&nbsp;Installation and Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></div><p>PerfExplorer uses TAUdb and PerfDMF databases so if you have not already you
        will need to install TAUdb, see <a href="#taudb.intro" title="Chapter&nbsp;28.&nbsp;Introduction">Chapter&nbsp;28, <i>Introduction</i></a>.

        To configure PerfExplorer move to the
        <code class="literal">tools/src/PerfExplorer/</code> directory in you TAU
        distribution. Type:</p><pre class="screen"> %&gt;./configure</pre><p>

        If you haven't already done so for other TAU tools, add
        <code class="literal">[path to tau]/tau2/apple/bin</code> to your
        path.</p><p>The following command-line options are available to
        configure:</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigurationOptions"></a>18.1.&nbsp;Available configuration options</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-engine=&lt;analysis engine&gt;</code></p><p>Specifies the data-mining engine to use.  The
            supported options include weka and R.</p></li><li><p><code class="literal">-rroot=&lt;directory&gt;</code></p><p>Specifies the directory where R is installed.
            Specifically, it should be the directory where the
            <code class="literal">bin</code>, <code class="literal">include</code>,
            <code class="literal">lib</code>, <code class="literal">library</code> and 
            <code class="literal">share</code> directories are located.</p></li><li><p><code class="literal">-objectport=&lt;available network
            port&gt;</code></p><p>Specifies the port that the PerfExplorer server should
            use, when running PerfExplorer in client-server mode.
            Select an available network port, and make sure that other
            appropriate network configurations are made (firewalls,
            etc.).  The default port is 9999.</p></li><li><p><code class="literal">-registryport=&lt;available network
            port&gt;</code></p><p>Specifies the port that the rmiregistry should
            use, when ruining PerfExplorer in client-server mode.
            Select an available network port, and make sure that other
            appropriate network configurations are made (firewalls,
            etc.).  The default port is 1099.</p></li><li><p><code class="literal">-server=&lt;server name&gt;</code></p><p>Specifies the fully qualified domain name of the
            server where PerfExplorer is run, when running PerfExplorer
            in client-server mode.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="RunningPerfExplorer"></a>Chapter&nbsp;19.&nbsp;Running PerfExplorer</h2></div></div></div><p>To run PerfExplorer type: </p><pre class="screen">
%&gt;perfexplorer
</pre><p>

        When PerfExplorer loads you will see on the left window all the 
        experiments that where loaded into PerfDMF. You can select which 
        performance data you are interested by navigating the tree structure. 
        PerfExplorer will allow you to 
        run analysis operations on these experiments. Also the cluster analysis
        results are visible on the right side of the window.  Various types of
        comparative analysis are available from the drop down menu
        selected.</p><p>To run an analysis operation, first select the metric of interest
        form the experiments on the left. Then perform the operation by selecting it
        from the <code class="literal">Analysis</code> menu. If you would like you can set 
        the <code class="literal"> clustering method, dimension reduction, normalization method
		</code> and the <code class="literal"> number of clusters </code>from the same
		menu.</p><p>The options under the Charts menu provide analysis over one or
		more applications, experiments, views or trials. To view these charts
		first choose a metric of interest by selecting a trial form the tree on
		the left. Then optionally choose the <code class="literal">Set Metric of
        Interest</code> or <code class="literal">Set Event of Interest</code> form the 
        <code class="literal">Charts</code> menu (if you don't, and you need to, you will
		be prompted). Now you can view a chart by selecting it
        from the <code class="literal">Charts</code> menu.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ClusterAnalysis"></a>Chapter&nbsp;20.&nbsp;Cluster Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></div><p>Cluster analysis is a valuable tool for reducing large
	parallel profiles down to representative groups for investigation.
	Currently, there are two types of clustering analysis implemented in
	PerfExplorer.  Both <span class="emphasis"><em>hierarchical</em></span> and
	<span class="emphasis"><em>k-means</em></span> analysis are used to group parallel
	profiles into common clusters, and then the clusters are summarized.
	Initially, we used similarity measures computed on a single parallel
	profile as input to the clustering algorithms, although other forms
	of input are possible.  Here, the performance data is organized into
	multi-dimensional vectors for analysis.  Each vector represents one
	parallel thread (or process) of execution in the profile.  Each
	dimension in the vector represents an event that was profiled in the
	application.  Events can be any sub-region of code, including
	libraries, functions, loops, basic blocks or even individual lines
	of code.  In simple clustering examples, each vector represents only
	one metric of measurement.  For our purposes, some dissimilarity
	value, such as <span class="emphasis"><em>Euclidean</em></span> or
	<span class="emphasis"><em>Manhattan</em></span> distance, is computed on the vectors.
	As discussed later, we have tested hierarchical and $k$-means
	cluster analysis in PerfExplorer on profiles with over 32K threads
	of execution with few difficulties.  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DimensionReduction"></a>20.1.&nbsp;Dimension Reduction</h2></div></div></div><p>Often, many hundreds of events are instrumented when
            profile data is collected.  Clustering works best with
            dimensions less than 10, so dimension reduction is often
            necessary to get meaningful results.  Currently, there is
            only one type of dimension reduction available in
            PerfExplorer.  To reduce dimensions, the user specifies a
            minimum exclusive percentage for an event to be considered
            "significant".
			</p><p>To reduce dimensions, select the "Select Dimension
            Reduction" item under the "Analysis" main menu bar item.
			The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction1"></a><p class="title"><b>Figure&nbsp;20.1.&nbsp;Selecting a dimension reduction method</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction1.gif" align="middle" alt="Selecting a dimension reduction method"></td></tr></table></div></div><p>
			Select "Over X Percent".  The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction2"></a><p class="title"><b>Figure&nbsp;20.2.&nbsp;Entering a minimum threshold for exclusive percentage</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction2.gif" align="middle" alt="Entering a minimum threshold for exclusive percentage"></td></tr></table></div></div><p>
			Enter a value, for example "1".
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MaxClusters"></a>20.2.&nbsp;Max Number of Clusters</h2></div></div></div><p>By default, PerfExplorer will attempt k-means
			clustering with values of k from 2 to 10.  To change the
			maximum number of clusters, select the "Set Maximum Number
			of Clusters" item under the "Analysis" main menu item.
			The following dialog will appear:  
			</p><div class="figure"><a name="perfexplorer.mainwindow.maxclusters"></a><p class="title"><b>Figure&nbsp;20.3.&nbsp;Entering a maximum number of clusters</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/maxclusters.gif" align="middle" alt="Entering a maximum number of clusters"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerformingClusterAnalysis"></a>20.3.&nbsp;Performing Cluster Analysis</h2></div></div></div><p>To perform cluster analysis, you first need to select a
		metric.  To select a metric, navigate through the tree of
		applications, experiments and trials, and expand the trial of
		interest, showing the available metrics, as shown in the figure
		below:
		</p><div class="figure"><a name="perfexplorer.mainwindow.clustering"></a><p class="title"><b>Figure&nbsp;20.4.&nbsp;Selecting a
	Metric to Cluster</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusteringselection.gif" align="middle" alt="Selecting a Metric to Cluster"></td></tr></table></div></div><p>After selecting the metric of interest, select the "Do
		Clustering" item under the "Analysis" main menu bar item.
		The following dialog will appear:  </p><div class="figure"><a name="perfexplorer.confirm.clustering"></a><p class="title"><b>Figure&nbsp;20.5.&nbsp;Confirm
	Clustering Options</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/confirmclustering.gif" align="middle" alt="Confirm Clustering Options"></td></tr></table></div></div><p>After confirming the clustering, the clustering will
		begin.  When the clustering results are available, you can view
		them in the "Cluster Results" tab.
		</p><div class="figure"><a name="perfexplorer.cluster.results"></a><p class="title"><b>Figure&nbsp;20.6.&nbsp;Cluster
	Results</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusterresults.gif" align="middle" alt="Cluster Results"></td></tr></table></div></div><p>There are a number of images in the "Cluster Results"
		window.  From left to right, the windows indicate the cluster
		membership histogram, a PCA scatterplot showing the cluster
		memberships, a virtual topology of the parallel machine, the
		minimum values for each event in each cluster, the average
		values for each event in each cluster, and the maximum values
		for each event in each cluster.  Clicking on a thumbnail image
		in the main window will bring up the images, as shown below:
		</p><div class="figure"><a name="perfexplorer.cluster.histogram"></a><p class="title"><b>Figure&nbsp;20.7.&nbsp;Cluster
	Membership Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/histogram.gif" align="middle" alt="Cluster Membership Histogram"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.scatterplot"></a><p class="title"><b>Figure&nbsp;20.8.&nbsp;Cluster
	Membership Scatterplot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/scatterplot.gif" align="middle" alt="Cluster Membership Scatterplot"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.topology"></a><p class="title"><b>Figure&nbsp;20.9.&nbsp;Cluster
	Virtual Topology</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/topology.gif" align="middle" alt="Cluster Virtual Topology"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.averages"></a><p class="title"><b>Figure&nbsp;20.10.&nbsp;Cluster
	Average Behavior</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/averages.gif" align="middle" alt="Cluster Average Behavior"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="CorrelationAnalysis"></a>Chapter&nbsp;21.&nbsp;Correlation Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></div><p>Correlation analysis in PerfExplorer is used to explore relationships
	between events in a profile.  Each event is pairwise plotted with the other
	events, and a correlation coefficient is calcuated for the relationship.
	When the events are highly positively correlated (coefficient of close to
	1.0) or highly negatively correlated (coefficient close to -1.0), then the
	relationships will show up as linear groupings in the results.  Clusters
	may also be apparent.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DimensionReduction2"></a>21.1.&nbsp;Dimension Reduction</h2></div></div></div><p>Often, many hundreds of events are instrumented when
        profile data is collected.  Clustering works best with
        dimensions less than 10, so dimension reduction is often
        necessary to get meaningful results.  Currently, there is
        only one type of dimension reduction available in
        PerfExplorer.  To reduce dimensions, the user specifies a
        minimum exclusive percentage for an event to be considered
        "significant".
		</p><p>To reduce dimensions, select the "Select Dimension
        Reduction" item under the "Analysis" main menu bar item.
		The following dialog will appear:  
        </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction1b"></a><p class="title"><b>Figure&nbsp;21.1.&nbsp;Selecting a dimension reduction method</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction1.gif" align="middle" alt="Selecting a dimension reduction method"></td></tr></table></div></div><p>
			Select "Over X Percent".  The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction2b"></a><p class="title"><b>Figure&nbsp;21.2.&nbsp;Entering a minimum threshold for exclusive percentage</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction2.gif" align="middle" alt="Entering a minimum threshold for exclusive percentage"></td></tr></table></div></div><p>
			Enter a value, for example "1".
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerformingCorrelationAnalysis"></a>21.2.&nbsp;Performing Correlation Analysis</h2></div></div></div><p>To perform correlation analysis, you first need to select a
		metric.  To select a metric, navigate through the tree of
		applications, experiments and trials, and expand the trial of
		interest, showing the available metrics, as shown in the figure
		below:
		</p><div class="figure"><a name="perfexplorer.mainwindow.correlation"></a><p class="title"><b>Figure&nbsp;21.3.&nbsp;Selecting a
	Metric to Cluster</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusteringselection.gif" align="middle" alt="Selecting a Metric to Cluster"></td></tr></table></div></div><p>After selecting the metric of interest, select the "Do
		Correlation Analysis" item under the "Analysis" main menu bar item.
		A confirmation dialog will appear, and you can either confirm
		the correlation request or cancel it.  After confirming the
		correlation, the analysis will begin.  When the analysis results
		are available, you can view them in the "Correlation Results" tab.
		</p><div class="figure"><a name="perfexplorer.correlation.results"></a><p class="title"><b>Figure&nbsp;21.4.&nbsp;Correlation
	Results</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/correlationresults.gif" align="middle" alt="Correlation Results"></td></tr></table></div></div><p>There are a number of images in the "Correlation Results"
		window.  Each thumbnail represents a pairwise correlation plot
		of two events.  Clicking on a thumbnail image
		in the main window will bring up the images, as shown below:
		</p><div class="figure"><a name="perfexplorer.correlation.example"></a><p class="title"><b>Figure&nbsp;21.5.&nbsp;Correlation
	Example</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/correlationexample.gif" align="middle" alt="Correlation Example"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Charts"></a>Chapter&nbsp;22.&nbsp;Charts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SettingChartParameters"></a>22.1.&nbsp;Setting Parameters</h2></div></div></div><p>There are a few parameters which need to be set when
		doing comparisons between trials in the database.  If any
		necessary setting is not configured before requesting a
		chart, you will be prompted to set the value.  The following
		settings may be necessary for the various charts available:
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="GroupOfInterest"></a>22.1.1.&nbsp;Group of Interest</h3></div></div></div><p>TAU events are often associated with common groups,
		such as "MPI", "TRANSPOSE", etc.  This value is used for
		showing what fraction of runtime that this group of
		events contributed to the total runtime.</p><div class="figure"><a name="perfexplorer.charts.groupofinterest"></a><p class="title"><b>Figure&nbsp;22.1.&nbsp;Setting Group of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/groupofinterest.gif" align="middle" alt="Setting Group of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="MetricOfInterest"></a>22.1.2.&nbsp;Metric of Interest</h3></div></div></div><p>Profiles may contain many metrics gathered for a
		single trial.  This selects which of the available metrics
		the user is interested in.</p><div class="figure"><a name="perfexplorer.charts.metricofinterest"></a><p class="title"><b>Figure&nbsp;22.2.&nbsp;Setting Metric of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/metricofinterest.gif" align="middle" alt="Setting Metric of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="EventOfInterest"></a>22.1.3.&nbsp;Event of Interest</h3></div></div></div><p>Some charts examine events in isolation.  This setting
		configures which event to examine.</p><div class="figure"><a name="perfexplorer.charts.eventofinterest"></a><p class="title"><b>Figure&nbsp;22.3.&nbsp;Setting Event of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/eventofinterest.gif" align="middle" alt="Setting Event of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TotalNumberOfTimesteps"></a>22.1.4.&nbsp;Total Number of
		Timesteps</h3></div></div></div><p>One chart, the "Timesteps per second" chart, will
		calculate the number of timesteps completed per second.
		This setting configures that value.</p><div class="figure"><a name="perfexplorer.charts.timesteps"></a><p class="title"><b>Figure&nbsp;22.4.&nbsp;Setting Timesteps</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/timesteps.gif" align="middle" alt="Setting Timesteps"></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChartTypes"></a>22.2.&nbsp;Standard Chart Types</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TimestepsPerSecond"></a>22.2.1.&nbsp;Timesteps Per
		Second</h3></div></div></div><p>The Timesteps Per Second chart shows how an application
		scales as it relates to time-to-solution.  If the timesteps are
		not already set, you will be prompted to enter the total number
		of timesteps in the trial (see <a href="#TotalNumberOfTimesteps" title="22.1.4.&nbsp;Total Number of&#xA;Timesteps">Section&nbsp;22.1.4, &#8220;Total Number of
		Timesteps&#8221;</a> ).  If there is more than
		one metric to choose from, you may be prompted to select the
		metric of interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.timestepspersecond"></a><p class="title"><b>Figure&nbsp;22.5.&nbsp;Timesteps per Second</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/timestepspersecond.gif" align="middle" alt="Timesteps per Second"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiency"></a>22.2.2.&nbsp;Relative
		Efficiency</h3></div></div></div><p>The Relative Efficiency chart shows how an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiency"></a><p class="title"><b>Figure&nbsp;22.6.&nbsp;Relative Efficiency</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiency.gif" align="middle" alt="Relative Efficiency"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyByEvent"></a>22.2.3.&nbsp;Relative Efficiency by
		Event</h3></div></div></div><p>The Relative Efficiency By Event chart shows how each
		event in an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencybyevent"></a><p class="title"><b>Figure&nbsp;22.7.&nbsp;Relative Efficiency by Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencybyevent.gif" align="middle" alt="Relative Efficiency by Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyOneEvent"></a>22.2.4.&nbsp;Relative Efficiency for
		One Event</h3></div></div></div><p>The Relative Efficiency for One Event chart shows how one
		event from an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  
		If there is more than one event to choose from, and you have not
		yet selected an event of interest, you may be prompted to select
		the event of interest (see <a href="#EventOfInterest" title="22.1.3.&nbsp;Event of Interest">Section&nbsp;22.1.3, &#8220;Event of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencyoneevent"></a><p class="title"><b>Figure&nbsp;22.8.&nbsp;Relative Efficiency one Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencyoneevent.gif" align="middle" alt="Relative Efficiency one Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedup"></a>22.2.5.&nbsp;Relative
		Speedup</h3></div></div></div><p>The Relative Speedup chart shows how an application
		scales with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedup"></a><p class="title"><b>Figure&nbsp;22.9.&nbsp;Relative Speedup</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedup.gif" align="middle" alt="Relative Speedup"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupByEvent"></a>22.2.6.&nbsp;Relative Speedup by
		Event</h3></div></div></div><p>The Relative Speedup By Event chart shows how the events
		in an application
		scale with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedupbyevent"></a><p class="title"><b>Figure&nbsp;22.10.&nbsp;Relative Speedup by Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedupbyevent.gif" align="middle" alt="Relative Speedup by Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupOneEvent"></a>22.2.7.&nbsp;Relative Speedup for One
		Event</h3></div></div></div><p>The Relative Speedup for One Event chart shows how one
		event in an application
		scales with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  
		If there is more than one event to choose from, and you have not
		yet selected an event of interest, you may be prompted to select
		the event of interest (see <a href="#EventOfInterest" title="22.1.3.&nbsp;Event of Interest">Section&nbsp;22.1.3, &#8220;Event of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeeduponeevent"></a><p class="title"><b>Figure&nbsp;22.11.&nbsp;Relative Speedup one Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeeduponeevent.gif" align="middle" alt="Relative Speedup one Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="PercentOfTotal"></a>22.2.8.&nbsp;Group % of Total
		Runtime</h3></div></div></div><p>
		The Group % of Total Runtime chart shows how the fraction of the
		total runtime for one group of events changes as the number of
		processors increases.  
		If there is more than one group
		to choose from, and you have not yet selected a group of
		interest, you may be prompted to select the group of
		interest (see <a href="#GroupOfInterest" title="22.1.1.&nbsp;Group of Interest">Section&nbsp;22.1.1, &#8220;Group of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.percentoftotal"></a><p class="title"><b>Figure&nbsp;22.12.&nbsp;Group % of Total Runtime</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/percentoftotal.gif" align="middle" alt="Group % of Total Runtime"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RuntimeBreakdown"></a>22.2.9.&nbsp;Runtime
		Breakdown</h3></div></div></div><p>
		The Runtime Breakdown chart shows the fraction of the total
		runtime for all events in the application, and how the fraction
		changes as the number of processors increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.runtimebreakdown"></a><p class="title"><b>Figure&nbsp;22.13.&nbsp;Runtime Breakdown</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/runtimebreakdown.gif" align="middle" alt="Runtime Breakdown"></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PhaseChartTypes"></a>22.3.&nbsp;Phase Chart Types</h2></div></div></div><p>TAU now provides the ability to break down profiles with
		respect to phases of execution.  One such application would be
		to collect separate statistics for each timestep, or group of
		timesteps.  In order to visualize the variance between the
		phases of execution, a number of phase-based charts are
		available.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyPhase"></a>22.3.1.&nbsp;Relative Efficiency per Phase</h3></div></div></div><p>
		The Relative Efficiency Per Phase chart shows the relative
		efficiency for each phase, as the number of processors
		increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencybyphase"></a><p class="title"><b>Figure&nbsp;22.14.&nbsp;Relative Efficiency per Phase</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencybyphase.gif" align="middle" alt="Relative Efficiency per Phase"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupPhase"></a>22.3.2.&nbsp;Relative Speedup per Phase</h3></div></div></div><p>
		The Relative Speedup Per Phase chart shows the relative
		speedup for each phase, as the number of processors
		increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedupbyphase"></a><p class="title"><b>Figure&nbsp;22.15.&nbsp;Relative Speedup per Phase</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedupbyphase.gif" align="middle" alt="Relative Speedup per Phase"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="PhaseBreakdown"></a>22.3.3.&nbsp;Phase Fraction of Total
		Runtime</h3></div></div></div><p>
		The Phase Fraction of Total Runtime chart shows the breakdown of
		the execution by phases, and shows how that breakdown changes as
		the number of processors increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.phasebreakdown"></a><p class="title"><b>Figure&nbsp;22.16.&nbsp;Phase Fraction of Total Runtime</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/phasebreakdown.gif" align="middle" alt="Phase Fraction of Total Runtime"></td></tr></table></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="CustomCharts"></a>Chapter&nbsp;23.&nbsp;Custom Charts</h2></div></div></div><p>In addition to the default charts available in the charts menu, there
	are is a custom chart interface.  To access the interface, select the "Custom
	Charts" tab on in the results pane of the main window, as shown:</p><div class="figure"><a name="perfexplorer.customcharts.interface"></a><p class="title"><b>Figure&nbsp;23.1.&nbsp;The Custom Charts
	Interface</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/customcharts.gif" align="middle" alt="The Custom Charts Interface"></td></tr></table></div></div><p>There are a number of controls for the cusotom charts.  They are:</p><div class="itemizedlist"><ul type="disc"><li><p>Main Only - When selected, only the main event (the event with
	the highest inclusive value) will be selected.  When deselected, the
	"Events" control (see below) is activated, and one or all events can be
	selected.</p></li><li><p>Call Paths - When selected, callpath events will be available in
	the "Events" control (see below).</p></li><li><p>Log Y - When selected, the Y axis will be the log of the true
	value.</p></li><li><p>Scalability - When selected, the chart will be interpreted as a
	speedup chart.  The trial with the fewest number of threads of execution
	will be considered the baseline trial.</p></li><li><p>Efficiency - When selected, the chart will be interpreted as a
	relative efficiency chart.  The trial with the fewest number of threads of
	execution will be considered the baseline trial.</p></li><li><p>Strong Scaling - When deselected, the speedup or efficiency chart
	will be interpreted as a strong scaling study (the workload is the same for
	all trials).  When selected, the button will change to "Weak Scaling", and
	the chart will be interpreted as a weak scaling study (the workload is
	proportional to the total number of threads in each trial).</p></li><li><p>Horizontal - when selected, the chart X and Y axes will be
	swapped.</p></li><li><p>Show Y-Axis Zero - when selected, the chart will include the
	value 0.  When deselected, the chart will only show the relevant values for
	all data points.</p></li><li><p>Chart Title - value to use for the chart title</p></li><li><p>Series Name/Value - the field to be used to group the data points
	as a series.</p></li><li><p>X Axis Value - the field to use as the X axis value.</p></li><li><p>X Axis Name - the name to put in the chart for the value along
	the X axis.</p></li><li><p>Y Axis Value - the field to use as the Y axis value</p></li><li><p>Y Axis Name - the name to put in the chart for the value along
	the X axis.</p></li><li><p>Dimension Reduction - whether or not to use dimension reduction.
	This is only applicable when "Main Only" is disabled.</p></li><li><p>Cutoff - when the "Dimension Reduction" is enabled, the cutoff
	value for selecting "All Events".</p></li><li><p>Metric - The metric of interest for the Y axis.</p></li><li><p>Units - The unit to be selected for the Y axis.</p></li><li><p>Event - The event of interest, or "All Events".</p></li><li><p>XML Field - When the X or Y axis is selected to be an XML field,
	this is the field of interest.</p></li><li><p>Apply - build the chart.</p></li><li><p>Reset - restore the options back to the default
	values.</p></li></ul></div><p>When the chart is generated, it can be saved as a vector image by
	selecting "File -&gt; Save As Vector Image".  The chart can also be saved
	as a PNG by right clicking on the chart, and selecting "Save As...".</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Visualization"></a>Chapter&nbsp;24.&nbsp;Visualization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></div><p>Under the "Visualization" main menu item, there are five types
	of raw data visualization. The five items are "3D Visualization",
	"Data Summary", "Create Boxchart", "Create Histogram" and 
	"Create Normal Probability Chart".  For the Boxchart, Histogram
	and Normal Probability Charts, you can either select one metric
	in the trial (which selects all events by default), or expand the metric
	and select events of interest.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ThreeDVisualization"></a>24.1.&nbsp;3D Visualization</h2></div></div></div><p>When the "3D Visualization" is requested, PerfExplorer
		examines the data to try to determine the most interesting
		events in the trial.  That is, for the selected metric in the
		selected trial, the database will calculate the weighted
		relative variance for each event across all threads of
		execution, in order to find the top four "significant" events.
		These events are selected by calculating: stddev(exclusive) /
		(max(exclusive) - min(exclusive)) * exclusive_percentage.  After
		selecting the top four events, they are graphed in an OpenGL
		window.</p><div class="figure"><a name="perfexplorer.visualization.threed"></a><p class="title"><b>Figure&nbsp;24.1.&nbsp;3D
		Visualization of multivariate data</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3dvisualization.gif" align="middle" alt="3D Visualization of multivariate data"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DataSummary"></a>24.2.&nbsp;Data Summary</h2></div></div></div><p>In order to see a summary of the performance data in the
		database, select the "Show Data Summary" item under the
		"Visualization" main menu item.</p><div class="figure"><a name="perfexplorer.visualization.datasummary"></a><p class="title"><b>Figure&nbsp;24.2.&nbsp;Data
		Summary Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/datasummary.gif" align="middle" alt="Data Summary Window"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateBoxchart"></a>24.3.&nbsp;Creating a Boxchart</h2></div></div></div><p>In order to see a boxchart summary of the performance data in the
		database, select the "Create Boxchart" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.boxchart"></a><p class="title"><b>Figure&nbsp;24.3.&nbsp;Boxchart</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/boxchart.gif" align="middle" alt="Boxchart"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateHistogram"></a>24.4.&nbsp;Creating a Histogram</h2></div></div></div><p>In order to see a histogram summary of the performance data in the
		database, select the "Create Histogram" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.histogram"></a><p class="title"><b>Figure&nbsp;24.4.&nbsp;Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/histogram2.gif" align="middle" alt="Histogram"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateNormalProbability"></a>24.5.&nbsp;Creating a Normal Probability Chart</h2></div></div></div><p>In order to see a normal probability summary of the performance data in the
		database, select the "Create NormalProbability" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.normalprobability"></a><p class="title"><b>Figure&nbsp;24.5.&nbsp;Normal
		Probability</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/normalprobability.gif" align="middle" alt="Normal Probability"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Views"></a>Chapter&nbsp;25.&nbsp;Views</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></div><p>Often times, data is loaded into the database with multiple
	parametric cross-sections.  For example, the charts available in
	PerfExplorer are primarily designed for scalability analysis,
	however data might be loaded as a parametric study.  For example, in
	the following example, the data has been loaded with three problem
	sizes, MIN, HALF and FULL.</p><div class="figure"><a name="perfexplorer.views.parametricexample"></a><p class="title"><b>Figure&nbsp;25.1.&nbsp;Potential
	scalability data organized as a parametric study</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/parametricdata.gif" align="middle" alt="Potential scalability data organized as a parametric study"></td></tr></table></div></div><p>In order to examine this data in a scalability study, it is
	necessary to reorganize the data.  However, it is not necessary to
	re-load the data.  Using views in PerfExplorer, you can re-organize
	the data based on values in the database.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingViews"></a>25.1.&nbsp;Creating Views</h2></div></div></div><p>To create a view, select the "Create New View" item under
		the "Views" main menu item.  The first step is to select the
		table which will form the basis of the view.  The three possible
		values are Application, Experiment and Trial:</p><div class="figure"><a name="perfexplorer.views.viewslevel"></a><p class="title"><b>Figure&nbsp;25.2.&nbsp;Selecting a table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewslevel.gif" align="middle" alt="Selecting a table"></td></tr></table></div></div><p>
		After selecting the table, you need to select the column on
		which to filter:
		</p><div class="figure"><a name="perfexplorer.views.viewscolumn"></a><p class="title"><b>Figure&nbsp;25.3.&nbsp;Selecting a
	column</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewscolumn.gif" align="middle" alt="Selecting a column"></td></tr></table></div></div><p>
		After selecting the column, you need to select the operator for
		comparing to that column:
		</p><div class="figure"><a name="perfexplorer.views.viewsoperator"></a><p class="title"><b>Figure&nbsp;25.4.&nbsp;Selecting an
	operator</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsoperator.gif" align="middle" alt="Selecting an operator"></td></tr></table></div></div><p>
		After selecting the operator, you need to select the value for
		comparing to the column:
		</p><div class="figure"><a name="perfexplorer.views.viewsvalue"></a><p class="title"><b>Figure&nbsp;25.5.&nbsp;Selecting a value</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsvalue.gif" align="middle" alt="Selecting a value"></td></tr></table></div></div><p>
		After selecting the value, you need to select a name for the
		view:
		</p><div class="figure"><a name="perfexplorer.views.viewsname"></a><p class="title"><b>Figure&nbsp;25.6.&nbsp;Entering a name
	for the view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsname.gif" align="middle" alt="Entering a name for the view"></td></tr></table></div></div><p>
		After creating the view, you will need to exit PerfExplorer and
		re-start it to see the view.  This is a known problem with the
		application, and will be fixed in a future release.
		</p><div class="figure"><a name="perfexplorer.views.completedview"></a><p class="title"><b>Figure&nbsp;25.7.&nbsp;The completed
	view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/completedview.gif" align="middle" alt="The completed view"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingSubviews"></a>25.2.&nbsp;Creating Subviews</h2></div></div></div><p>In order to create sub-views, you first need to select
		the "Create New Sub-View" item from the "Views" main menu item.
		The first dialog box will prompt you to select the view (or
		sub-view) to base the new sub-view on:</p><div class="figure"><a name="perfexplorer.views.subview"></a><p class="title"><b>Figure&nbsp;25.8.&nbsp;Selecting the base
	view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/subview.gif" align="middle" alt="Selecting the base view"></td></tr></table></div></div><p>After selecting the base view or sub-view, the options for
		creating the new sub-view are the same as creating a new view.  
		After creating the sub-view, you will need to exit PerfExplorer and
		re-start it to see the sub-view.  This is a known problem with the
		application, and will be fixed in a future release.
		</p><div class="figure"><a name="perfexplorer.views.completedsubview"></a><p class="title"><b>Figure&nbsp;25.9.&nbsp;Completed
	sub-views</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/completedsubview.gif" align="middle" alt="Completed sub-views"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Scripting"></a>Chapter&nbsp;26.&nbsp;Running PerfExplorer Scripts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></div><p>As of version 2.0, PerfExplorer has officially supported a
	scripting interface.  The scripting interface is useful for adding
	automation to PerfExplorer.  For example, a user can load a trial,
	perform data reduction, extract out key phases, derive metrics, 
	and plot the result.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="AnalysisComponents"></a>26.1.&nbsp;Analysis Components</h2></div></div></div><p>There are many operations available, including:</p><div class="itemizedlist"><ul type="disc"><li><p>BasicStatisticsOperation</p></li><li><p>CopyOperation</p></li><li><p>CorrelateEventsWithMetadata</p></li><li><p>CorrelationOperation</p></li><li><p>DeriveMetricOperation</p></li><li><p>DifferenceMetadataOperation</p></li><li><p>DifferenceOperation</p></li><li><p>DrawBoxChartGraph</p></li><li><p>DrawGraph</p></li><li><p>DrawMMMGraph</p></li><li><p>ExtractCallpathEventOperation</p></li><li><p>ExtractEventOperation</p></li><li><p>ExtractMetricOperation</p></li><li><p>ExtractNonCallpathEventOperation</p></li><li><p>ExtractPhasesOperation</p></li><li><p>ExtractRankOperation</p></li><li><p>KMeansOperation</p></li><li><p>LinearRegressionOperation</p></li><li><p>LogarithmicOperation</p></li><li><p>MergeTrialsOperation</p></li><li><p>MetadataClusterOperation</p></li><li><p>PCAOperation</p></li><li><p>RatioOperation</p></li><li><p>ScalabilityOperation</p></li><li><p>TopXEvents</p></li><li><p>TopXPercentEvents</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Scripting_Interface"></a>26.2.&nbsp;Scripting Interface</h2></div></div></div><p>
	The scripting interface is in Python, and scripts can be used to build
	analysis workflows.  The Python scripts control the Java classes in the
	application through the Jython interpreter (http://www.jython.org/).  There
	are two types of components which are useful in
	building analysis scripts.  The first type is the PerformanceResult interface,
	and the second is the PerformanceAnalysisComponent interface.  For
	documentation on how to use the Java classes, see the javadoc in the
	perfexplorer source distribution, and the example scripts below.
	To build the perfexplorer javadoc, type </p><pre class="screen"> %&gt;./make javadoc</pre><p>
	in the perfexplorer source directory.
	
      </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExampleScript"></a>26.3.&nbsp;Example Script</h2></div></div></div><pre class="screen">
from glue import PerformanceResult
from glue import PerformanceAnalysisOperation
from glue import ExtractEventOperation
from glue import Utilities
from glue import BasicStatisticsOperation
from glue import DeriveMetricOperation
from glue import MergeTrialsOperation
from glue import TrialResult
from glue import AbstractResult
from glue import DrawMMMGraph
from edu.uoregon.tau.perfdmf import Trial
from java.util import HashSet
from java.util import ArrayList

True = 1
False = 0

def glue():
	print "doing phase test for gtc on jaguar"
	# load the trial
	Utilities.setSession("perfdmf.demo")
	trial1 = Utilities.getTrial("gtc_bench", "Jaguar Compiler Options", "fastsse")
	result1 = TrialResult(trial1)

	print "got the data"

	# get the iteration inclusive totals

	events = ArrayList()
	for event in result1.getEvents():
		#if event.find("Iteration") &gt;= 0 and result1.getEventGroupName(event).find("TAU_PHASE") &lt; 0:
		if event.find("Iteration") &gt;= 0 and event.find("=&gt;") &lt; 0:
			events.add(event)

	extractor = ExtractEventOperation(result1, events)
	extracted = extractor.processData().get(0)

	print "extracted phases"

	# derive metrics

	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCA", "PAPI_L1_TCM", DeriveMetricOperation.SUBTRACT)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCA-PAPI_L1_TCM", "PAPI_L1_TCA", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCM", "PAPI_L2_TCM", DeriveMetricOperation.SUBTRACT)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCM-PAPI_L2_TCM", "PAPI_L1_TCM", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_FP_INS", "P_WALL_CLOCK_TIME", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_FP_INS", "PAPI_TOT_INS", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)

	print "derived metrics..."

	# get the Statistics
	dostats = BasicStatisticsOperation(extracted, False)
	stats = dostats.processData()

	print "got stats..."

	return

	for metric in stats.get(0).getMetrics():
		grapher = DrawMMMGraph(stats)
		metrics = HashSet()
		metrics.add(metric)
		grapher.set_metrics(metrics)
		grapher.setTitle("GTC Phase Breakdown: " + metric)
		grapher.setSeriesType(DrawMMMGraph.TRIALNAME);
		grapher.setCategoryType(DrawMMMGraph.EVENTNAME)
		grapher.setValueType(AbstractResult.INCLUSIVE)
		grapher.setXAxisLabel("Iteration")
		grapher.setYAxisLabel("Inclusive " + metric);
		# grapher.setLogYAxis(True)
		grapher.processData()

	# graph the significant events in the iteration

	subsetevents = ArrayList()
	subsetevents.add("CHARGEI")
	subsetevents.add("PUSHI")
	subsetevents.add("SHIFTI")

	print "got data..."

	for subsetevent in subsetevents:
		events = ArrayList()
		for event in result1.getEvents():
			if event.find("Iteration") &gt;= 0 and event.rfind(subsetevent) &gt;= 0:
				events.add(event)

		extractor = ExtractEventOperation(result1, events)
		extracted = extractor.processData().get(0)

		print "extracted phases..."

		# get the Statistics
		dostats = BasicStatisticsOperation(extracted, False)
		stats = dostats.processData()

		print "got stats..."

		for metric in stats.get(0).getMetrics():
			grapher = DrawMMMGraph(stats)
			metrics = HashSet()
			metrics.add(metric)
			grapher.set_metrics(metrics)
			grapher.setTitle(subsetevent + ", " + metric)
			grapher.setSeriesType(DrawMMMGraph.TRIALNAME);
			grapher.setCategoryType(DrawMMMGraph.EVENTNAME)
			grapher.setValueType(AbstractResult.INCLUSIVE)
			# grapher.setLogYAxis(True)
			grapher.processData()
	return

print "--------------- JPython test script start ------------"
glue()
print "---------------- JPython test script end -------------"
	</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Derived Metrics"></a>Chapter&nbsp;27.&nbsp;Derived Metrics</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></div><p>Sometimes metrics in a profile need to be combined to create a derived
	metric.  PerfExplorer allows the user to create these using the derived metric expression tab.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingExpression"></a>27.1.&nbsp;CreatingExpressions</h2></div></div></div><p>The text box at the top of the tab allows the user to enter an expression.  
        Double clicking on a metric in the "Performance Data" tree will copy that metrics name into the
        box.  If a metric contains any operands, the whole metric must be surrounded by quotes. If 
        the you would like of the metric to be renamed, then you should start the expression with 
        the new name and and equals sign.
		</p><p> If this is the only metric you wish to derive, then select the trial, expression or 
		application where the metric should be derived and then click apply.  If you wish to derive 
		many metrics, then click Add to List and create more expressions.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Applying"></a>27.2.&nbsp;Selecting Expressions</h2></div></div></div><p>If you have added multiple expressions, you can select one or many of them to apply.
		They will be derived from top to bottom.  After you have select some, you can select the trial, 
		experiment or application to apply the expression to and then click apply.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Files"></a>27.3.&nbsp;Expression Files</h2></div></div></div><p>You can also derive metrics using an expression file.  An expression file has a single 
		expression per line.  To parse the file, select the trial, experiment or application to apply
		the expressions to; then select File &gt; Parse Expression File and chose the file.
		</p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUdbDoc"></a>Part&nbsp;IV.&nbsp;TAUdb</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#taudb.intro">28. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">29. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">30. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">31. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.intro"></a>Chapter&nbsp;28.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></div><p>
	TAUdb (TAU Database), formerly known as PerfDMF (Performance Data
	Management Framework) is a an API/Toolkit that sits atop a DBMS to manage
	and analyze performance data.  The API is available in its native Java form
	as well as C.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.prereq"></a>28.1.&nbsp;Prerequisites</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p>A supported Database Management System (DBMS).  TAUdb
	  currently supports PostgreSQL, MySQL, Oracle, H2, and Derby. For
	  use with the C API, only PostgreSQL is supported (SQLite support is
	  currently being evaluated). Because they are Java only, H2 and Derby
	  can NO  be accessed with the C API.</p></li><li><p>Java 1.5.</p></li><li><p>If the C API is desired, a working C compiler is
	  required, along with the following libraries: libpq (PostgreSQL
	  libraries), libxml2, libz, libuuid. These libraries are all commonly
	  installed by default on *NIX systems.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.installation"></a>28.2.&nbsp;Installation</h2></div></div></div><p>The TAUdb utilities and applications are installed as part of the
    standard TAU release.  Shell scripts are installed in the TAU bin directory
    to configure and run the utilities.  It is assumed that the user has
    installed TAU and run TAU's configure and 'make install'.
    </p><div class="orderedlist"><ol type="1"><li><p>(Optionally) Create a database.  This step will depend on the user's
		chosen DBMS.
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>H2:</strong></span>
	  Because it is an embedded, file-based DBMS, H2 does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. TAUdb takes advantage of the "auto-server"
	  capabilities in H2, so multiple clients can connect to the same database
	  at the same time. Users should use the H2 DBMS if they expect to
	  maintain a small to moderate local repository of performance data, and
	  want the convenience of connecting to the database from multiple clients.
	  </p></li><li><p><span class="bold"><strong>Derby:</strong></span>
	  Because it is an embedded, file-based DBMS, Derby does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. Be advised that the Derby DBMS does <span class="bold"><strong>not</strong></span> allow multiple clients to connect to the same
	  database. For that reason, we suggest users use the H2 DBMS if a
	  file-based database is desired. Derby support is maintained for backwards
	  compatability.
	  </p></li><li><p><span class="bold"><strong>PostgreSQL:</strong></span>
	  </p><pre class="screen">$ createdb -O taudb taudb</pre><p>
	  Or, from <span><strong class="command">psql</strong></span>
	  </p><pre class="screen">psql=# create database taudb with owner = taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>MySQL:</strong></span>  From the MySQL prompt
	  </p><pre class="screen">mysql&gt; create database taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>Oracle:</strong></span> It is recommended that
	  you create a tablespace for taudb: 
	  </p><pre class="screen">create tablespace taudb 
datafile '/path/to/somewhere' size 500m reuse;</pre><p>

	  Then, create a user that has this tablespace as default:
	  </p><pre class="screen">create user amorris identified by db;
grant create session to amorris;
grant create table to amorris;
grant create sequence to amorris;
grant create trigger to amorris;
alter user amorris quota unlimited on taudb;
alter user amorris default tablespace taudb;</pre><p>
	  
TAUdb is set up to use the Oracle Thin Java driver.  You will have
to obtain this jar file for your DBMS.  In our case, it was
ojdbc14.jar.
	  </p></li></ul></div></li><li><p>Configure a TAUdb connection.  To configure TAUdb, run the
	<span><strong class="command">taudb_configure</strong></span> program from the TAU bin directory.</p><p>The configuration program will prompt the user for several values.  The
	default values will work for most users.  When configuration is complete,
	it will connect to the database and test the configuration.  If the
	configuration is valid and the schema is not already found in the database
	(as will be the case on initial configuration), the schema will be
	uploaded.  Be sure to specify the correct version of the schema for your
	DBMS.
	</p><p>An example session for configuring a database is below. The user
	is creating an H2 database, with default settings including no username
	and no password (recommended for file-based databases when security is not
	an issue).
	</p><pre class="screen">
$ taudb_configure
Configuration file NOT found...
a new configuration file will be created.

Welcome to the configuration program for PerfDMF.
This program will prompt you for some information necessary to 
ensure the desired behavior for the PerfDMF tools.


You will now be prompted for new values, if desired.  The current 
or default values for each prompt are shown in parenthesis.
To accept the current/default value, just press Enter/Return.

Please enter the name of this configuration.
():documentation_example
Please enter the database vendor (oracle, postgresql, mysql, db2, 
derby or h2).
(h2):
Please enter the JDBC jar file.
(/Users/khuck/src/tau2/apple/lib/h2.jar):
Please enter the JDBC Driver name.
(org.h2.Driver):
Please enter the path to the database directory.
(/Users/khuck/.ParaProf/documentation_example):
Please enter the database username.
():
Store the database password in CLEAR TEXT in your configuration 
file? (y/n):y
Please enter the database password: 
Please enter the PerfDMF schema file.
(/Users/khuck/src/tau2/etc/taudb.sql):

Writing configuration file: 
/Users/khuck/.ParaProf/perfdmf.cfg.documentation_example

Now testing your database connection.

Database created, command: 
jdbc:h2:/Users/khuck/.ParaProf/documentation_example/perfdmf;AUTO_SERVER=TRUE;create=true

Uploading Schema: /Users/khuck/src/tau2/etc/taudb.sql
Found /Users/khuck/src/tau2/etc/taudb.sql  ... Loading
Successfully uploaded schema

Database connection successful.
Configuration complete.
	</pre><p>
	</p></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.using"></a>Chapter&nbsp;29.&nbsp;Using TAUdb</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></div><p>The easiest way to interact with TAUdb is to use ParaProf which
    provides a GUI interface to all of the database information.  In addition,
    the following commandline utilities are provided.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createapp"></a>29.1.&nbsp;perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates applications with a given name</p><pre class="screen">$ perfdmf_createapp -n "New Application"
Created Application, ID: 24</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createexp"></a>29.2.&nbsp;perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates experiments with a given name, under a specified application</p><pre class="screen">$ perfdmf_createexp -a 24 -n "New Experiment"
Created Experiment, ID: 38</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.loadtrial"></a>29.3.&nbsp;taudb_loadtrial</h2></div></div></div><p>This utility uploads a trial to the database with a given name, under
    a specified experiment</p><pre class="screen">
$ taudb_loadtrial -h
Usage: perfdmf_loadtrial -a &lt;appName&gt; -x &lt;expName&gt; -n &lt;name&gt; 
[options] &lt;files&gt;

Required Arguments:

  -n, --name &lt;text&gt;              Specify the name of the trial
  -a, --applicationname &lt;string&gt; Specify associated application name
                                 for this trial
  -x, --experimentname &lt;string&gt;  Specify associated experiment name
                                 for this trial
               ...or...

  -n, --name &lt;text&gt;              Specify the name of the trial
  -e, --experimentid &lt;number&gt;    Specify associated experiment ID
                                 for this trial

Optional Arguments:

  -c, --config &lt;name&gt;       Specify the name of the configuration to use
  -g, --configFile &lt;file&gt;   Specify the configuration file to use
                            (overrides -c)
  -f, --filetype &lt;filetype&gt; Specify type of performance data, options 
                            are: profiles (default), pprof, dynaprof, 
                            mpip, gprof, psrun, hpm, packed, cube, 
                            hpc, ompp, snap, perixml, gptl, paraver, 
                            ipm, google
  -t, --trialid &lt;number&gt;    Specify trial ID
  -i, --fixnames            Use the fixnames option for gprof
  -z, --usenull             Include NULL values as 0 for mean 
                            calculation
  -r, --reduce &lt;percentage&gt; Aggregate all timers less than percentage 
                            as "other"
  -m, --metadata &lt;filename&gt; XML metadata for the trial

Notes:
  For the TAU profiles type, you can specify either a specific set 
of profile files on the commandline, or you can specify a directory 
(by default the current directory).  The specified directory will be 
searched for profile.*.*.* files, or, in the case of multiple counters, 
directories named MULTI_* containing profile data.

Examples:

  perfdmf_loadtrial -e 12 -n "Batch 001"
    This will load profile.* (or multiple counters directories 
    MULTI_*) into experiment 12 and give the trial the name 
    "Batch 001"

  perfdmf_loadtrial -e 12 -n "HPM data 01" -f hpm perfhpm*
    This will load perfhpm* files of type HPMToolkit into experiment 
    12 and give the trial the name "HPM data 01"

  perfdmf_loadtrial -a "NPB2.3" -x "parametric" -n "64" par64.ppk
    This will load packed profile par64.ppk into the experiment named
    "parametric" under the application named "NPB2.3" and give the 
    trial the name "64".  The application and experiment will be 
    created if not found.
  </pre><p>TAUdb supports a large number of parallel profile formats:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>TAU Profiles (profiles)</strong></span>
	  - Output from the TAU measurement library, these files generally take the
		form of <code class="filename">profile.X.X.X</code>, one for each
		node/context/thread combination.  When multiple counters are used, each
		metric is located in a directory prefixed with "MULTI__".  To launch
		ParaProf with all the metrics, simply launch it from the root of the
		MULTI__ directories.</p></li><li><p><span class="bold"><strong>ParaProf Packed Format
	  (ppk)</strong></span> - Export format supported by PerfDMF/ParaProf.
	  Typically .ppk.  </p></li><li><p><span class="bold"><strong>TAU Merged Profiles
	  (snap)</strong></span> - Merged and snapshot profile format supported by
	  TAU.  Typically tauprofile.xml.</p></li><li><p><span class="bold"><strong>TAU pprof (pprof)</strong></span> - Dump
	  Output from TAU's <span><strong class="command">pprof -d</strong></span>.  Provided for backward
	  compatibility only.</p></li><li><p><span class="bold"><strong>DynaProf (dynaprof)</strong></span> -
	  Output From DynaProf's wallclock and papi probes.  </p></li><li><p><span class="bold"><strong>mpiP (mpip)</strong></span> - Output
	  from mpiP.  </p></li><li><p><span class="bold"><strong>gprof (gprof)</strong></span> - Output
	  from gprof, see also the --fixnames option.  </p></li><li><p><span class="bold"><strong>PerfSuite (psrun)</strong></span> -
	  Output from PerfSuite psrun files.</p></li><li><p><span class="bold"><strong>HPM Toolkit (hpm)</strong></span> -
	  Output from IBM's HPM Toolkit.  </p></li><li><p><span class="bold"><strong>Cube (cube)</strong></span> - Output
	  from Kojak Expert tool for use with Cube.  </p></li><li><p><span class="bold"><strong>Cube3 (cube3)</strong></span> - Output
	  from Kojak Expert tool for use with Cube3 and Cube4.  </p></li><li><p><span class="bold"><strong>HPCToolkit (hpc)</strong></span> - XML
	  data from hpcquick.  Typically, the user runs hpcrun, then hpcquick on
	  the resulting binary file.  </p></li><li><p><span class="bold"><strong>OpenMP Profiler (ompp)</strong></span> -
	  CSV format from the ompP OpenMP Profiler (http://www.ompp-tool.com).  The
	  user must use OMPP_OUTFORMAT=CVS.</p></li><li><p><span class="bold"><strong>PERI XML (perixml)</strong></span> -
	  Output from the PERI data exchange format.</p></li><li><p><span class="bold"><strong>General Purpose Timing Library
	  (gptl)</strong></span> - Output from the General Purpose Timing
	  Library.</p></li><li><p><span class="bold"><strong>Paraver (paraver)</strong></span> -
	  2D output from the Paraver trace analysis tool from
	  BSC.</p></li><li><p><span class="bold"><strong>IPM (ipm)</strong></span> -
	  Integrated Performance Monitoring format, from NERSC.</p></li><li><p><span class="bold"><strong>Google (google)</strong></span> -
	  Google Profiles.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.views"></a>29.4.&nbsp;TAUdb Views</h2></div></div></div><p>In order to provide flexible data management, the application /
	experiment / trial hierarchy was removed in the conversion from PerfDMF to
	TAUdb. In addition, trial metadata was promoted from an XML blob in PerfDMF
	to queryable tables. Users can now organize their data in arbitrary
	hierarchies using Views and SubViews.  Creating and using Views is outlined
	in the ParaProf User Manual, in Chapter 2.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.schema"></a>Chapter&nbsp;30.&nbsp;Database Schema</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></div><p>
    The database schema in TAUdb is designed to flexibly and efficiently store
    multidimensional parallel performance data. There are 5 dimensions to the
    actual timer measurements, and 4 dimensions to the counter measurements
    </p><p>Timer dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Metric of interest (i.e. FP_OPS, TIME)</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><p>Counter dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.schema.sql"></a>30.1.&nbsp;SQL for TAUdb</h2></div></div></div><p>Below is the SQL schema definition for TAUdb.</p><pre class="screen">
/****************************/
/* CREATE THE STATIC TABLES */
/****************************/

CREATE TABLE schema_version (
 version     INT NOT NULL,
 description VARCHAR NOT NULL
);
/* IF THE SCHEMA IS MODIFIED, INCREMENT THIS VALUE */
/* 0 = PERFDMF (ORIGINAL) */
/* 1 = TAUDB (APRIL, 2012) */
/*VALUES (1, 'TAUdb redesign from Spring, 2012');*/
INSERT INTO schema_version (version, description) 
  VALUES (2, 'Changes after Nov. 9, 2012 release');

/* These are our supported parsers. */
CREATE TABLE data_source (
 id          INT UNIQUE NOT NULL,
 name        VARCHAR NOT NULL,
 description VARCHAR
);

INSERT INTO data_source (name,id,description) 
  VALUES ('ppk',0,'TAU Packed profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('TAU profiles',1,'TAU profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('DynaProf',2,'PAPI DynaProf profiles (UTK)');
INSERT INTO data_source (name,id,description) 
  VALUES ('mpiP',3,'mpiP: Lightweight, Scalable MPI Profiling (Vetter, Chambreau)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPM',4,'HPM Toolkit profiles (IBM)');
INSERT INTO data_source (name,id,description) 
  VALUES ('gprof',5,'gprof profiles (GNU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('psrun',6,'PerfSuite psrun profiles (NCSA)');
INSERT INTO data_source (name,id,description) 
  VALUES ('pprof',7,'TAU pprof.dat output (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube',8,'Cube data (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPCToolkit',9,'HPC Toolkit profiles (Rice Univ.)');
INSERT INTO data_source (name,id,description) 
  VALUES ('SNAP',10,'TAU Snapshot profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('OMPP',11,'OpenMP Profiler profiles (Fuerlinger)');
INSERT INTO data_source (name,id,description) 
  VALUES ('PERIXML',12,'Data Exchange Format (PERI)');
INSERT INTO data_source (name,id,description) 
  VALUES ('GPTL',13,'General Purpose Timing Library (ORNL)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Paraver',14,'Paraver profiles (BSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('IPM',15,'Integrated Performance Monitoring (NERSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Google',16,'Google profiles (Google)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube3',17,'Cube 3D profiles (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Gyro',100,'Self-timing profiles from Gyro application');
INSERT INTO data_source (name,id,description) 
  VALUES ('GAMESS',101,'Self-timing profiles from GAMESS application');
INSERT INTO data_source (name,id,description) 
  VALUES ('Other',999,'Other profiles');

/* threads make it convenient to identify timer values.
   Special values for thread_index:
   -1 mean (nulls ignored)
   -2 total
   -3 stddev (nulls ignored)
   -4 min
   -5 max
   -6 mean (nulls are 0 value)
   -7 stddev (nulls are 0 value)
*/

CREATE TABLE derived_thread_type (
 id INT NOT NULL,
 name VARCHAR NOT NULL,
 description VARCHAR NOT NULL
);

INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-1, 'MEAN', 'MEAN (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-2, 'TOTAL', 'TOTAL');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-3, 'STDDEV', 'STDDEV (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-4, 'MIN', 'MIN');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-5, 'MAX', 'MAX');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-6, 'MEAN', 'MEAN (nulls are 0 value)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-7, 'STDDEV', 'STDDEV (nulls are 0 value)');

/**************************/
/* CREATE THE TRIAL TABLE */
/**************************/

/* trials are the top level table */

CREATE TABLE trial (
 id                  SERIAL NOT NULL PRIMARY KEY,
 name                VARCHAR,
 /* where did this data come from? */
 data_source         INT,
 /* number of processes */
 node_count          INT,
 /* legacy values - these are actually "max" values - i.e. not all nodes have
  * this many threads */
 contexts_per_node   INT,
 /* how many threads per node? */
 threads_per_context INT,
 /* total number of threads */
 total_threads       INT,
 /* reference to the data source table. */
 FOREIGN KEY(data_source) REFERENCES data_source(id) 
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/******************************/
/* CREATE THE DATA DIMENSIONS */
/******************************/

/* threads are the "location" dimension */

CREATE TABLE thread (
 id           SERIAL NOT NULL PRIMARY KEY,
 /* trial this thread belongs to */
 trial        INT NOT NULL,
 /* process rank, really */
 node_rank    INT NOT NULL,
 /* legacy value */
 context_rank INT NOT NULL,
 /* thread rank relative to the process */
 thread_rank  INT NOT NULL,
 /* thread index from 0 to N-1 */
 thread_index INT NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id) ON DELETE 
   NO ACTION ON UPDATE NO ACTION
);

/* metrics are things like num_calls, num_subroutines, TIME, PAPI
   counters, and derived metrics. */

CREATE TABLE metric (
 id      SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial   INT NOT NULL,
 /* name of the metric */
 name    VARCHAR NOT NULL,
 /* if this metric is derived by one of the tools */
 derived BOOLEAN NOT NULL DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timers are timers, capturing some interval value.  For callpath or
   phase profiles, the parent refers to the calling function or phase. */

CREATE TABLE timer (
 id                SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial             INT NOT NULL,
 /* name of the timer */
 name              VARCHAR NOT NULL,
 /* short name of the timer - without source or parameter info */
 short_name        VARCHAR NOT NULL,
 /* filename */
 source_file       VARCHAR,
 /* line number of the start of the block of code */
 line_number       INT,
 /* line number of the end of the block of code */
 line_number_end   INT,
 /* column number of the start of the block of code */
 column_number     INT,
 /* column number of the end of the block of code */
 column_number_end INT,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer index on the trial and name columns */
CREATE INDEX timer_trial_index on timer (trial, name);

/***********************************/
/* CREATE THE TIMER RELATED TABLES */
/***********************************/

/* timer groups are the groups such as TAU_DEFAULT,
   MPI, OPENMP, TAU_PHASE, TAU_CALLPATH, TAU_PARAM, etc. 
   This mapping table allows for NxN mappings between timers
   and groups */

CREATE TABLE timer_group (
 timer INT,
 group_name  VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* index for faster queries into groups */
CREATE INDEX timer_group_index on timer_group (timer, group_name);

/* timer parameters are parameter based profile values. 
 * an example is foo (x,y) where x=4 and y=10. In that example,
 * timer would be the index of the timer with the
 * name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. This table would have two
 * entries, one for the x value and one for the y value. */

CREATE TABLE timer_parameter (
 timer     INT,
 parameter_name  VARCHAR NOT NULL,
 parameter_value VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer callpath have the information about the call graph in a trial.
 * If the profile is "flat", these will all have no parents. Otherwise,
 * the parent points to a node in the callgraph, the calling timer 
 * (function). */

CREATE TABLE timer_callpath (
 id        SERIAL NOT NULL PRIMARY KEY,
 /* what timer is this? */
 timer     INT NOT NULL,
 /* what is the parent timer? */
 parent    INT,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* By definition, profiles have no time data. However, there are a few
 * examples where time ranges make sense, such as tracking call stacks
 * or associating metadata to a particular phase. The time_range table
 * is used to give other measurements a time context. The iteration
 * start and end can be used to indicate which loop iterations or 
 * calls to a function are relevant for this time range. */

CREATE TABLE time_range (
 id SERIAL NOT NULL PRIMARY KEY,
 /* starting iteration */
 iteration_start INT NOT NULL,
 /* ending iteration. */
 iteration_end INT,
 /* starting timestamp */
 time_start BIGINT NOT NULL,
 /* ending timestamp. */
 time_end BIGINT
);

/* timer_call_data records have the dynamic information for when a node
 * in the callgraph is visited by a thread. If you are tracking dynamic
 * callstacks, you would use the time_range field. If you are storing
 * snapshot data, you would use the time_range field. */

CREATE TABLE timer_call_data (
 id          SERIAL NOT NULL PRIMARY KEY,
 /* what callgraph node is this? */
 timer_callpath       INT NOT NULL,
 /* what thread is this? */
 thread      INT NOT NULL,
 /* how many times this timer was called */
 calls       INT,
 /* how many subroutines this timer called */
 subroutines INT,
 /* what is the time_range? this is for supporting snapshots */
 time_range  INT,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer values have the timer of one timer
   on one thread for one metric, at one location on the callgraph. */

CREATE TABLE timer_value (
 /* what node in the callgraph and thread is this? */
 timer_call_data       INT NOT NULL,
 /* what metric is this? */
 metric                INT NOT NULL,
 /* The inclusive value for this timer */
 inclusive_value       DOUBLE PRECISION,
 /* The exclusive value for this timer */
 exclusive_value       DOUBLE PRECISION,
 /* The inclusive percent for this timer */
 inclusive_percent     DOUBLE PRECISION,
 /* The exclusive percent for this timer */
 exclusive_percent     DOUBLE PRECISION,
 /* The variance for this timer */
 sum_exclusive_squared DOUBLE PRECISION,
 FOREIGN KEY(timer_call_data) REFERENCES timer_call_data(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(metric) REFERENCES metric(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one metric, one thread, one timer */
CREATE INDEX timer_value_index on timer_value (timer_call_data, metric);

/*************************************/
/* CREATE THE COUNTER RELATED TABLES */
/*************************************/

/* counters measure some counted value. */

CREATE TABLE counter (
 id          SERIAL      NOT NULL PRIMARY KEY,
 trial       INT         NOT NULL,
 name        VARCHAR        NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* counter index on the trial and name columns */
CREATE INDEX counter_trial_index on counter (trial, name);

CREATE TABLE counter_value (
 /* what counter is this? */
 counter            INT NOT NULL,
 /* where in the callgraph? */
 timer_callpath     INT,
 /* what thread is this? */
 thread             INT NOT NULL,
 /* The total number of samples */
 sample_count       INT,         
 /* The maximum value seen */
 maximum_value      DOUBLE PRECISION,
 /* The minimum value seen */
 minimum_value      DOUBLE PRECISION,
 /* The mean value seen */
 mean_value         DOUBLE PRECISION,
 /* The variance for this counter */
 standard_deviation DOUBLE PRECISION,
 FOREIGN KEY(counter) REFERENCES counter(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one thread, one counter */
CREATE INDEX counter_value_index on counter_value (counter, thread);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

CREATE TABLE primary_metadata (
 trial    INT NOT NULL,
 name     VARCHAR NOT NULL,
 value    VARCHAR,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the primary_metadata table */
CREATE INDEX primary_metadata_index on primary_metadata (trial, name);

/* secondary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

CREATE TABLE secondary_metadata (
 id       VARCHAR NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial    INT NOT NULL,
 /* this metadata value could be associated with a thread */
 thread   INT,
 /* this metadata value could be associated with a timer that happened */
 timer_callpath    INT,
 /* which call to the context timer was this? */
 time_range    INT,
 /* this metadata value could be a nested structure */
 parent   VARCHAR,
 /* the name of the metadata field */
 name     VARCHAR NOT NULL,
 /* the value of the metadata field */
 value    VARCHAR,
 /* this metadata value could be an array - so tokenize it */
 is_array BOOLEAN DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES secondary_metadata(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the secondary_metadata table */
CREATE INDEX secondary_metadata_index on secondary_metadata 
   (trial, name, thread, parent);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* this is the view table, which organizes and filters trials */
create table taudb_view (
    id                    SERIAL            NOT NULL    PRIMARY KEY,
    /* views can be nested */
    parent                INTEGER            NULL,
    /* name of the view */
    name                VARCHAR    NOT NULL,
    /* view conjoin type for parameters */
    conjoin                VARCHAR    NOT NULL,
    FOREIGN KEY (parent) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

create table taudb_view_parameter (
    /* the view ID */
    taudb_view            INTEGER    NOT NULL,
    /* the table name for the where clause */
    table_name            VARCHAR    NOT NULL,
    /* the column name for the where clause.
       If the table_name is one of the metadata tables, this is the 
       value of the "name" column */
    column_name            VARCHAR    NOT NULL,
    /* the operator for the where clause */
    operator            VARCHAR    NOT NULL,
    /* the value for the where clause */
    value                VARCHAR    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

/* simple view of all trials */
INSERT INTO taudb_view (parent, name, conjoin) 
    VALUES (NULL, 'All Trials', 'and');
/* must have a parameter or else the sub views for this view 
   do not work correctly*/
INSERT INTO taudb_view_parameter 
    (taudb_view, table_name, column_name, operator, value) 
	VALUES (1, 'trial', 'total_threads', '&gt;', '-1');

/* the application and experiment columns are not used in the 
   latest schema, but keeping them makes the code in 
   PerfExplorer simpler. */
create table analysis_settings (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    taudb_view          INTEGER         NULL,
    application         INTEGER         NULL,
    experiment          INTEGER         NULL,
    trial               INTEGER         NULL,
    metric              INTEGER         NULL,
    method              VARCHAR(255)    NOT NULL,
    dimension_reduction VARCHAR(255)    NOT NULL,
    normalization       VARCHAR(255)    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (trial) REFERENCES trial(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (metric) REFERENCES metric(id)
        ON DELETE CASCADE ON UPDATE CASCADE
);

create table analysis_result (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    analysis_settings   INTEGER         NOT NULL,
    description         VARCHAR(255)    NOT NULL,
    thumbnail_size      INTEGER         NULL,
    image_size          INTEGER         NULL,
    thumbnail           BYTEA           NULL,
    image               BYTEA           NULL,
    result_type         INTEGER         NOT NULL
);

 /* Performance indexes! */
create index trial_name_index on trial(name);
create index timer_name_index on timer(name);
CREATE INDEX timer_callpath_parent on timer_callpath(parent);
CREATE INDEX thread_trial on thread(trial);
CREATE INDEX timer_call_data_timer_callpath on 
    timer_call_data(timer_callpath);
CREATE INDEX counter_name_index on counter(name);
CREATE INDEX timer_call_data_thread on timer_call_data(thread);

/* SHORT TERM FIX! These views make sure that charts 
   (mostly) work... for now. */

DROP VIEW IF EXISTS interval_location_profile;
DROP VIEW IF EXISTS interval_mean_summary;
DROP VIEW IF EXISTS interval_total_summary;
DROP VIEW IF EXISTS interval_event_value;
DROP VIEW IF EXISTS interval_event;
DROP VIEW IF EXISTS atomic_location_profile;
DROP VIEW IF EXISTS atomic_mean_summary;
DROP VIEW IF EXISTS atomic_total_summary;
DROP VIEW IF EXISTS atomic_event_value;
DROP VIEW IF EXISTS atomic_event;

CREATE OR REPLACE VIEW interval_event 
(id, trial, name, group_name, source_file, line_number, line_number_end) 
AS  
SELECT tcp.id, t.trial, t.name, tg.group_name,  
t.source_file, t.line_number, t.line_number_end  
FROM timer_callpath tcp  
INNER JOIN timer t ON tcp.timer = t.id  
INNER JOIN timer_group tg ON tg.timer = t.id; 

CREATE OR REPLACE VIEW interval_event_value 
(interval_event, node, context, thread, metric, inclusive_percentage,  
inclusive, exclusive_percentage, exclusive, call, subroutines,  
inclusive_per_call, sum_exclusive_squared) 
AS SELECT tcd.timer_callpath, t.node_rank, t.context_rank,  
t.thread_rank, tv.metric, tv.inclusive_percent,  
tv.inclusive_value, tv.exclusive_percent, tv.exclusive_value, tcd.calls, 
tcd.subroutines, tv.inclusive_value / tcd.calls, tv.sum_exclusive_squared 
FROM timer_value tv 
INNER JOIN timer_call_data tcd on tv.timer_call_data = tcd.id 
INNER JOIN thread t on tcd.thread = t.id; 

CREATE OR REPLACE VIEW interval_location_profile 
AS SELECT * from interval_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW interval_total_summary 
AS SELECT * from interval_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW interval_mean_summary 
AS SELECT * from interval_event_value WHERE thread = -1; 
 
 
CREATE OR REPLACE VIEW atomic_event  
(id, trial, name, group_name, source_file, line_number) 
AS SELECT c.id, c.trial, c.name, NULL, NULL, NULL 
FROM counter c; 

CREATE OR REPLACE VIEW atomic_event_value 
(atomic_event, node, context, thread, sample_count, 
maximum_value, minimum_value, mean_value, standard_deviation) 
AS SELECT cv.counter, t.node_rank, t.context_rank, t.thread_rank, 
cv.sample_count, cv.maximum_value, cv.minimum_value, cv.mean_value, 
cv.standard_deviation FROM counter_value cv 
INNER JOIN thread t ON cv.thread = t.id;
 
CREATE OR REPLACE VIEW atomic_location_profile 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW atomic_total_summary 
AS SELECT * FROM atomic_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW atomic_mean_summary 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= -1; 
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.capi"></a>Chapter&nbsp;31.&nbsp;TAUdb C API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.overview"></a>31.1.&nbsp;TAUdb C API Overview</h2></div></div></div><p>The C API for TAUdb is currently under development, but there is a
	beta version of the API available.  The API provides the following
    capabilities: </p><div class="itemizedlist"><ul type="disc"><li><p>Loading trials from the database</p></li><li><p>Inserting trials into the database</p></li><li><p>Parsing TAU profile files</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.structs"></a>31.2.&nbsp;TAUdb C Structures</h2></div></div></div><p>The C structures are roughly organized as a tree, with a trial
        object at the root.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>taudb_trial: </strong></span>
A top-level structure which contains the collections of all the performance data
dimensions.</p></li><li><p><span class="bold"><strong>taudb_primary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial.</p></li><li><p><span class="bold"><strong>taudb_secondary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial. Unlike primary_metadata
values, secondary_metadata objects can have complex value types. They are also associated
with a measurement context - a thread of execution, a timer, a timestamp, an iteration,
etc.</p></li><li><p><span class="bold"><strong>taudb_thread: </strong></span>
A structure which represents a thread of execution in the parallel
measurement.</p></li><li><p><span class="bold"><strong>taudb_time_range: </strong></span>
A structure which holds a time-range value of beginning and ending iteration
numbers or timestamps.</p></li><li><p><span class="bold"><strong>taudb_metric: </strong></span>
A structure which represents a unit of measurement, such as TIME, FP_OPS,
L1_DCM, etc.</p></li><li><p><span class="bold"><strong>taudb_timer: </strong></span>
A structure which represents a region of code. For example, a phase, a 
function, a loop, a basic block, or even a line of code.</p></li><li><p><span class="bold"><strong>taudb_timer_parameter: </strong></span>
A structure which represents parameter values, when parameter based profiling
is used.</p></li><li><p><span class="bold"><strong>taudb_timer_group: </strong></span>
A structure which represents a semantic grouping of timers, such as "I/O",
"MPI", "OpenMP", etc.</p></li><li><p><span class="bold"><strong>taudb_timer_callpath: </strong></span>
A structure which represents a node in the dynamic callpath tree. Timer_callpaths
with a null parent are either top level timers, or a timers in a flat
profile.</p></li><li><p><span class="bold"><strong>taudb_timer_call_data: </strong></span>
A structure which represents a tuple between a thread of execution and a node
on the timer callpath tree.</p></li><li><p><span class="bold"><strong>taudb_timer_value: </strong></span>
A structure which represents a tuple between a timer_call_data object and a
metric. The timer_value contains the measurement of one metric for one timer on
one thread of execution.</p></li><li><p><span class="bold"><strong>taudb_counter: </strong></span>
A structure which represents a counter in the profile. For example, 
the number of bytes transferred on an MPI_Send() timer.</p></li><li><p><span class="bold"><strong>taudb_counter_value: </strong></span>
A structure which represents a counter measurement on one thread of
execution.</p></li></ul></div><p>Below are the object definitions, from the TAUdb C header file.</p><pre class="screen">
#ifndef TAUDB_STRUCTS_H
#define TAUDB_STRUCTS_H 1

#include "time.h"
#include "uthash.h"
#include "taudb_structs.h"

#if defined __TAUDB_POSTGRESQL__
#include "libpq-fe.h"
#elif defined __TAUDB_SQLITE__
#include "sqlite3.h"
#endif

#ifndef boolean
#define TRUE  1
#define FALSE 0
typedef int boolean;
#endif

typedef struct taudb_prepared_statement {
 char* name;
 UT_hash_handle hh; /* hash index for hashing by name */
} TAUDB_PREPARED_STATEMENT;

/* forward declarations to ease objects that need to know about 
 * each other and have doubly-linked relationships */

struct taudb_timer_call_data;
struct taudb_timer_value;
struct taudb_timer_callpath;
struct taudb_timer_group;
struct taudb_timer_parameter;
struct taudb_timer;
struct taudb_counter_value;
struct taudb_counter;
struct taudb_primary_metadata;
struct taudb_secondary_metadata;
struct taudb_time_range;
struct taudb_thread;
struct taudb_metric;
struct taudb_trial;
struct perfdmf_experiment;
struct perfdmf_application;

typedef struct taudb_configuration {
  char* jdbc_db_type;    /* to identify DBMS vendor. 
                          * postgresql, mysql, h2, derby, etc. */
  char* db_hostname;     /* server host name */
  char* db_portnum;      /* server port number */
  char* db_dbname;       /* the database name at the server */
  char* db_schemaprefix; /* the schema prefix. This is appended to 
                          * all table names for some DBMSs */
  char* db_username;     /* the database username */
  char* db_password;     /* the database password for username */
  char* db_schemafile;   /* full or relative path to the schema file, 
                          * used for configuration, not used in C API */
} TAUDB_CONFIGURATION;

typedef enum taudb_database_schema_version {
  TAUDB_2005_SCHEMA,
  TAUDB_2012_SCHEMA
} TAUDB_SCHEMA_VERSION;

typedef struct taudb_data_source {
 int id;
 char* name;
 char*description;
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_DATA_SOURCE;

typedef struct taudb_connection {
  TAUDB_CONFIGURATION *configuration;
#if defined __TAUDB_POSTGRESQL__
  PGconn *connection;
  PGresult *res;
  TAUDB_PREPARED_STATEMENT *statements;
#elif defined __TAUDB_SQLITE__
  sqlite3 *connection;
  sqlite3_stmt *ppStmt;
  int rc; 
#endif
  TAUDB_SCHEMA_VERSION schema_version;
  boolean inTransaction;
  boolean inPortal;
  TAUDB_DATA_SOURCE* data_sources_by_id;
  TAUDB_DATA_SOURCE* data_sources_by_name;
} TAUDB_CONNECTION;

/* these are the derived thread indexes. */

#define TAUDB_MEAN_WITHOUT_NULLS -1
#define TAUDB_TOTAL -2
#define TAUDB_STDDEV_WITHOUT_NULLS -3
#define TAUDB_MIN -4
#define TAUDB_MAX -5
#define TAUDB_MEAN_WITH_NULLS -6
#define TAUDB_STDDEV_WITH_NULLS -7

/* trials are the top level structure */

typedef struct taudb_trial {
 /* actual data from the database */
 int id;
 char* name;
 struct taudb_data_source* data_source;
 int node_count;             /* i.e. number of processes. */
 int contexts_per_node;      /* rarely used, usually 1. */
 int threads_per_context;    /* max number of threads per process 
                              * (can be less on individual processes) */
 int total_threads;          /* total number of threads */
 /* arrays of data for this trial */
 struct taudb_metric* metrics_by_id;
 struct taudb_metric* metrics_by_name;
 struct taudb_thread* threads;
 struct taudb_time_range* time_ranges;
 struct taudb_timer* timers_by_id;
 struct taudb_timer* timers_by_name;
 struct taudb_timer_group* timer_groups;
 struct taudb_timer_callpath* timer_callpaths_by_id;
 struct taudb_timer_callpath* timer_callpaths_by_name;
 struct taudb_timer_call_data* timer_call_data_by_id;
 struct taudb_timer_call_data* timer_call_data_by_key;
 struct taudb_counter* counters_by_id;
 struct taudb_counter* counters_by_name;
 struct taudb_counter_value* counter_values;
 struct taudb_primary_metadata* primary_metadata;
 struct taudb_secondary_metadata* secondary_metadata;
 struct taudb_secondary_metadata* secondary_metadata_by_key;
} TAUDB_TRIAL;

/*********************************************/
/* data dimensions */
/*********************************************/

/* thread represents one physical &amp; logical 
 * location for a measurement. */

typedef struct taudb_thread {
 int id; /* database id, also key to hash */
 struct taudb_trial* trial;
 int node_rank;    /* which process does this thread belong to? */
 int context_rank; /* which context? USUALLY 0 */
 int thread_rank;  /* what is this thread's rank in the process */
 int index;        /* what is this threads OVERALL index? 
                    * ranges from 0 to trial.thread_count-1 */
 struct taudb_secondary_metadata* secondary_metadata;
 UT_hash_handle hh;
} TAUDB_THREAD;

/* metrics are things like TIME, PAPI counters, and derived metrics. */

typedef struct taudb_metric {
 int id; /* database value, also key to hash */
 char* name; /* key to hash hh2 */
 boolean derived;  /* was this metric measured, or created by a 
                    * post-processing tool? */
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_METRIC;

/* Time ranges are ways to delimit the profile data within time ranges.
   They are also useful for secondary metadata which is associated with
   a specific call to a function. */

typedef struct taudb_time_range {
 int id; /* database value, also key to hash */
 int iteration_start;
 int iteration_end;
 uint64_t time_start;
 uint64_t time_end;  /* was this metric measured, 
                      * or created by a post-processing tool? */
 UT_hash_handle hh;
} TAUDB_TIME_RANGE;

/* timers are interval timers, capturing some interval value.  
 * For callpath or phase profiles, the parent refers to the calling 
 * function or phase.  Timers can also be sample locations, or 
 * phases (dynamic or static), or sample aggregations (intermediate) */

typedef struct taudb_timer {
 int id; /* database value, also key to hash */
 struct taudb_trial* trial;  /* pointer back to trial - NOTE: Necessary? */
 char* name;  /* the full timer name, can have file, line, etc. */
 char* short_name;  /* just the function name, for example */
 char* source_file;  /* what source file does this function live in? */
 int line_number;  /* what line does the timer start on? */
 int line_number_end;  /* what line does the timer end on? */
 int column_number;  /* what column number does the timer start on? */
 int column_number_end;  /* what column number does the timer end on? */
 struct taudb_timer_group* groups; /* hash of groups, 
                                    * using group hash handle hh2 */
 struct taudb_timer_parameter* parameters; /* array of parameters */
 UT_hash_handle trial_hash_by_id;  /* hash key for id lookup */
 UT_hash_handle trial_hash_by_name;  /* hash key for name lookup 
                                      * in temporary hash */
 UT_hash_handle group_hash_by_name;  /* hash key for name lookup 
                                      * in timer group */
} TAUDB_TIMER;

/*********************************************/
/* timer related structures  */
/*********************************************/

/* timer groups are the groups such as tau_default,
   mpi, openmp, tau_phase, tau_callpath, tau_param, etc. 
   this mapping table allows for nxn mappings between timers
   and groups */

typedef struct taudb_timer_group {
 char* name;
 struct taudb_timer* timers;   /* hash of timers, 
                                * using timer hash handle hh3 */
 UT_hash_handle trial_hash_by_name;  // hash handle for trial
 UT_hash_handle timer_hash_by_name;  // hash handle for timers
} TAUDB_TIMER_GROUP;

/* timer parameters are parameter based profile values. 
   an example is foo (x,y) where x=4 and y=10. in that example,
   timer would be the index of the timer with the
   name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. this table would have two
   entries, one for the x value and one for the y value.
   The parameter can also be a phase / iteration index.
*/

typedef struct taudb_timer_parameter {
 char* name;
 char* value;
 UT_hash_handle hh;
} TAUDB_TIMER_PARAMETER;

/* callpath objects contain the merged dynamic callgraph tree seen
 * during execution */

typedef struct taudb_timer_callpath {
 int id; /* link back to database, and hash key */
 struct taudb_timer* timer; /* which timer is this? */
 struct taudb_timer_callpath *parent; /* callgraph parent */
 char* name; /* a string which has the aggregated callpath. */
 UT_hash_handle hh1; /* hash key for hash by id */
 UT_hash_handle hh2; /* hash key for name (a =&gt; b =&gt; c...) lookup */
} TAUDB_TIMER_CALLPATH;

/* timer_call_data objects are observations of a node of the callgraph
   for one of the threads. */

typedef struct taudb_call_data_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_TIMER_CALL_DATA_KEY;

typedef struct taudb_timer_call_data {
 int id; /* link back to database */
 TAUDB_TIMER_CALL_DATA_KEY key; /* hash table key */
 int calls;  /* number of times this timer was seen */
 int subroutines;  /* number of timers this timer calls */
 struct taudb_timer_value* timer_values;
 UT_hash_handle hh1;
 UT_hash_handle hh2;
} TAUDB_TIMER_CALL_DATA;

/* finally, timer_values are specific measurements during one of the
   observations of the node of the callgraph on a thread. */

typedef struct taudb_timer_value {
 struct taudb_metric* metric;   /* which metric is this? */
 double inclusive;              /* the inclusive value of this metric */
 double exclusive;              /* the exclusive value of this metric */
 double inclusive_percentage;   /* the inclusive percentage of 
                                 * total time of the application */
 double exclusive_percentage;   /* the exclusive percentage of 
                                 * total time of the application */
 double sum_exclusive_squared;  /* how much variance did we see 
                                 * every time we measured this timer? */
 char *key; /* hash table key - metric name */
 UT_hash_handle hh;
} TAUDB_TIMER_VALUE;

/*********************************************/
/* counter related structures  */
/*********************************************/

/* counters measure some counted value. An example would be MPI message size
 * for an MPI_Send.  */

typedef struct taudb_counter {
 int id; /* database reference */
 struct taudb_trial* trial;
 char* name;
 UT_hash_handle hh1; /* hash key for hashing by id */
 UT_hash_handle hh2; /* hash key for hashing by name */
} TAUDB_COUNTER;

/* counters are atomic counters, not just interval timers */

typedef struct taudb_counter_value_key {
 struct taudb_counter* counter; /* the counter we are measuring */
 struct taudb_thread* thread;   /* where this measurement is */
 struct taudb_timer_callpath* context; /* the calling context (can be null) */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_COUNTER_VALUE_KEY;

typedef struct taudb_counter_value {
 TAUDB_COUNTER_VALUE_KEY key;
 int sample_count;          /* how many times did we see take this count? */
 double maximum_value;      /* what was the max value we saw? */
 double minimum_value;      /* what was the min value we saw? */
 double mean_value;         /* what was the average value we saw? */
 double standard_deviation; /* how much variance was there? */
 UT_hash_handle hh1; /* hash key for hashing by key */
} TAUDB_COUNTER_VALUE;

/*********************************************/
/* metadata related structures  */
/*********************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

typedef struct taudb_primary_metadata {
 char* name;
 char* value;
 UT_hash_handle hh; /* uses the name as the key */
} TAUDB_PRIMARY_METADATA;

/* primary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

typedef struct taudb_secondary_metadata_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 struct taudb_secondary_metadata* parent; /* self-referencing */
 struct taudb_time_range* time_range;
 char* name;
} TAUDB_SECONDARY_METADATA_KEY;

typedef struct taudb_secondary_metadata {
 char* id; /* link back to database */
 TAUDB_SECONDARY_METADATA_KEY key;
 int num_values; /* can have arrays of data */
 char** value;
 int child_count;
 struct taudb_secondary_metadata* children; /* self-referencing  */
 UT_hash_handle hh; /* uses the id as a compound key */
 UT_hash_handle hh2; /* uses the key as a compound key */
} TAUDB_SECONDARY_METADATA;

/* these are for supporting the older schema */

typedef struct perfdmf_experiment {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_EXPERIMENT;

typedef struct perfdmf_application {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_APPLICATION;

#endif /* TAUDB_STRUCTS_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.api"></a>31.3.&nbsp;TAUdb C API</h2></div></div></div><pre class="screen">
#ifndef TAUDB_API_H
#define TAUDB_API_H 1

#include "taudb_structs.h"

/* when a "get" function is called, this global has the number of 
   top-level objects that are returned. */
extern int taudb_numItems;

/* the database version */
extern enum taudb_database_schema_version taudb_version;

/* to connect to the database */
extern TAUDB_CONNECTION* taudb_connect_config(char* config_name);
extern TAUDB_CONNECTION* taudb_connect_config_file(char* config_file_name);

/* test the connection status */
extern int taudb_check_connection(TAUDB_CONNECTION* connection);

/* disconnect from the database */
extern int taudb_disconnect(TAUDB_CONNECTION* connection);

/************************************************/
/* query functions */
/************************************************/

/* functions to support the old database schema - avoid these if you can */
extern PERFDMF_APPLICATION* 
    perfdmf_query_applications(TAUDB_CONNECTION* connection);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiments(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application);
extern PERFDMF_APPLICATION* 
    perfdmf_query_application(TAUDB_CONNECTION* connection, char* name);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiment(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application, char* name);
extern TAUDB_TRIAL* perfdmf_query_trials(TAUDB_CONNECTION* connection, 
    PERFDMF_EXPERIMENT* experiment);

/* get the data sources */
extern TAUDB_DATA_SOURCE* 
    taudb_query_data_sources(TAUDB_CONNECTION* connection);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_id(TAUDB_DATA_SOURCE* data_sources, 
	const int id);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_name(TAUDB_DATA_SOURCE* data_sources, 
	const char* name);

/* using the properties set in the filter, find a set of trials */
extern TAUDB_TRIAL* 
    taudb_query_trials(TAUDB_CONNECTION* connection, boolean complete, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_query_primary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_get_primary_metadata_by_name(TAUDB_PRIMARY_METADATA* primary_metadata, 
	const char* name);
extern TAUDB_SECONDARY_METADATA* 
    taudb_query_secondary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);

/* get the threads for a trial */
extern TAUDB_THREAD* 
    taudb_query_threads(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_query_derived_threads(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_get_thread(TAUDB_THREAD* threads, int thread_index);
extern int taudb_get_total_threads(TAUDB_THREAD* threads);

/* get the metrics for a trial */
extern TAUDB_METRIC* 
    taudb_query_metrics(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_METRIC* 
    taudb_get_metric_by_name(TAUDB_METRIC* metrics, const char* name);
extern TAUDB_METRIC* 
    taudb_get_metric_by_id(TAUDB_METRIC* metrics, const int id);

/* get the time_ranges for a trial */
extern TAUDB_TIME_RANGE* 
    taudb_query_time_range(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIME_RANGE* 
    taudb_get_time_range(TAUDB_TIME_RANGE* time_ranges, const int id);

/* get the timers for a trial */
extern TAUDB_TIMER* 
    taudb_query_timers(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_TIMER* 
    taudb_get_timer_by_id(TAUDB_TIMER* timers, int id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER_GROUP* 
    taudb_query_timer_groups(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern void 
    taudb_parse_timer_group_names(TAUDB_TRIAL* trial, TAUDB_TIMER* timer, 
	char* group_names);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_trial_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_timer_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER* timer);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_id(TAUDB_TIMER_CALLPATH* timers, int id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_name(TAUDB_TIMER_CALLPATH* timers, 
	const char* id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_all_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern char* taudb_get_callpath_string(TAUDB_TIMER_CALLPATH* timer_callpath);

/* get the counters for a trial */
extern TAUDB_COUNTER* 
    taudb_query_counters(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_id(TAUDB_COUNTER* counters, int id);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_name(TAUDB_COUNTER* counters, const char* id);
extern TAUDB_COUNTER_VALUE* 
    taudb_query_counter_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
TAUDB_COUNTER_VALUE* 
    taudb_get_counter_value(TAUDB_COUNTER_VALUE* counter_values, 
	TAUDB_COUNTER* counter, TAUDB_THREAD* thread, 
	TAUDB_TIMER_CALLPATH* context, char* timestamp);

/* get the timer call data for a trial */
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_id(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	int id);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_key(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_TIMER_CALLPATH* callpath, TAUDB_THREAD* thread, char* timestamp);

/* get the timer values for a trial */
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_get_timer_value(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_METRIC* metric);

/* find main */
extern TAUDB_TIMER* 
    taudb_query_main_timer(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);

/* save everything */
extern void taudb_save_trial(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update, boolean cascade);
extern void taudb_save_threads(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_metrics(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timers(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_time_ranges(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_groups(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_parameters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_callpaths(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_call_data(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counter_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_primary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_secondary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);

/************************************************/
/* memory functions */
/************************************************/

extern char* taudb_strdup(const char* in_string);
extern TAUDB_TRIAL* taudb_create_trials(int count);
extern TAUDB_METRIC*             taudb_create_metrics(int count);
extern TAUDB_TIME_RANGE*         taudb_create_time_ranges(int count);
extern TAUDB_THREAD*             taudb_create_threads(int count);
extern TAUDB_SECONDARY_METADATA* taudb_create_secondary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_create_primary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_resize_primary_metadata(int count, 
    TAUDB_PRIMARY_METADATA* old_primary_metadata);
extern TAUDB_COUNTER*            taudb_create_counters(int count);
extern TAUDB_COUNTER_VALUE*      taudb_create_counter_values(int count);
extern TAUDB_TIMER*              taudb_create_timers(int count);
extern TAUDB_TIMER_PARAMETER*    taudb_create_timer_parameters(int count);
extern TAUDB_TIMER_GROUP*        taudb_create_timer_groups(int count);
extern TAUDB_TIMER_GROUP*        taudb_resize_timer_groups(int count, 
    TAUDB_TIMER_GROUP* old_groups);
extern TAUDB_TIMER_CALLPATH*     taudb_create_timer_callpaths(int count);
extern TAUDB_TIMER_CALL_DATA*    taudb_create_timer_call_data(int count);
extern TAUDB_TIMER_VALUE*        taudb_create_timer_values(int count);

extern void taudb_delete_trials(TAUDB_TRIAL* trials, int count);

/************************************************/
/* Adding objects to the hierarchy */
/************************************************/

extern void taudb_add_metric_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_METRIC* metric);
extern void taudb_add_time_range_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIME_RANGE* time_range);
extern void taudb_add_thread_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_THREAD* thread);
extern void taudb_add_secondary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_SECONDARY_METADATA* secondary_metadata);
extern void taudb_add_secondary_metadata_to_secondary_metadata
    (TAUDB_SECONDARY_METADATA* parent, TAUDB_SECONDARY_METADATA* child);
extern void taudb_add_primary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_PRIMARY_METADATA* primary_metadata);
extern void taudb_add_counter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER* counter);
extern void taudb_add_counter_value_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER_VALUE* counter_value);
extern void taudb_add_timer_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_parameter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_PARAMETER* timer_parameter);
extern void taudb_add_timer_group_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_GROUP* timer_group);
extern void taudb_add_timer_to_timer_group(TAUDB_TIMER_GROUP* timer_group, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_callpath_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALLPATH* timer_callpath);
extern void taudb_add_timer_call_data_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALL_DATA* timer_call_data);
extern void taudb_add_timer_value_to_timer_call_data
    (TAUDB_TIMER_CALL_DATA* timer_call_data, TAUDB_TIMER_VALUE* timer_value);

/* Profile parsers */
extern TAUDB_TRIAL* taudb_parse_tau_profiles(const char* directory_name);

/* Analysis routines */
extern void taudb_compute_statistics(TAUDB_TRIAL* trial);

/* iterators */
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_name_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_id_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_THREAD* 
    taudb_next_thread_by_index_from_trial(TAUDB_THREAD* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_name_from_trial(TAUDB_METRIC* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_id_from_trial(TAUDB_METRIC* current);
extern TAUDB_TIME_RANGE* 
    taudb_next_time_range_by_id_from_trial(TAUDB_TIME_RANGE* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_id_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_group(TAUDB_TIMER* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_trial
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_timer
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_PARAMETER* 
    taudb_next_timer_parameter_by_name_from_timer
	(TAUDB_TIMER_PARAMETER* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_name_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_id_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_key_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_id_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_VALUE* 
    taudb_next_timer_value_by_metric_from_timer_call_data
	(TAUDB_TIMER_VALUE* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_name_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_id_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER_VALUE* 
    taudb_next_counter_value_by_key_from_trial(TAUDB_COUNTER_VALUE* current);
extern TAUDB_PRIMARY_METADATA* 
    taudb_next_primary_metadata_by_name_from_trial
	(TAUDB_PRIMARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_key_from_trial
	(TAUDB_SECONDARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_id_from_trial
	(TAUDB_SECONDARY_METADATA* current);

#endif /* TAUDB_API_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.examples"></a>31.4.&nbsp;TAUdb C API Examples</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.insert"></a>31.4.1.&nbsp;Creating a trial and inserting into the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include "dump_functions.h"

int main (int argc, char** argv) {
  TAUDB_CONNECTION* connection = NULL;
  if (argc &gt;= 2) {
    connection = taudb_connect_config(argv[1]);
  } else {
    fprintf(stderr, "Please specify a TAUdb config file.\n");
    exit(1);
  }
  printf("Checking connection...\n");
  taudb_check_connection(connection);

  // create a trial
  TAUDB_TRIAL* trial = taudb_create_trials(1);
  trial-&gt;name = taudb_strdup("TEST TRIAL");
  // set the data source to "other"
  trial-&gt;data_source = taudb_get_data_source_by_id(
      taudb_query_data_sources(connection), 999);
  
  // create some metadata
  TAUDB_PRIMARY_METADATA* pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Application");
  pm-&gt;value = taudb_strdup("Test Application");
  taudb_add_primary_metadata_to_trial(trial, pm);

  pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Start Time");
  pm-&gt;value = taudb_strdup("2012-11-07 12:30:00");
  taudb_add_primary_metadata_to_trial(trial, pm);

  // alternatively, you can allocate the primary metadata in blocks
  pm = taudb_create_primary_metadata(10);
  pm[0].name = taudb_strdup("ClientID");
  pm[0].value = taudb_strdup("joe_user");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[0]));
  pm[1].name = taudb_strdup("hostname");
  pm[1].value = taudb_strdup("hopper04");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[1]));
  pm[2].name = taudb_strdup("Operating System");
  pm[2].value = taudb_strdup("Linux");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[2]));
  pm[3].name = taudb_strdup("Release");
  pm[3].value = taudb_strdup("2.6.32.36-0.5-default");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[3]));
  pm[4].name = taudb_strdup("Machine");
  pm[4].value = taudb_strdup("Hopper.nersc.gov");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[4]));
  pm[5].name = taudb_strdup("CPU Cache Size");
  pm[5].value = taudb_strdup("512 KB");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[5]));
  pm[6].name = taudb_strdup("CPU Clock Frequency");
  pm[6].value = taudb_strdup("800.000 MHz");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[6]));
  pm[7].name = taudb_strdup("CPU Model");
  pm[7].value = taudb_strdup("Quad-Core AMD Opteron(tm) Processor 8378");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[7]));

  // create a metric
  TAUDB_METRIC* metric = taudb_create_metrics(1);
  metric-&gt;name = taudb_strdup("TIME");
  taudb_add_metric_to_trial(trial, metric);

  // create a thread
  TAUDB_THREAD* thread = taudb_create_threads(1);
  thread-&gt;node_rank = 1;
  thread-&gt;context_rank = 1;
  thread-&gt;thread_rank = 1;
  thread-&gt;index = 1;
  taudb_add_thread_to_trial(trial, thread);

  // create a timer, timer_callpath, timer_call_data, timer_value
  TAUDB_TIMER_GROUP* timer_group = taudb_create_timer_groups(1);
  TAUDB_TIMER* timer = taudb_create_timers(1);
  TAUDB_TIMER_CALLPATH* timer_callpath = taudb_create_timer_callpaths(1);
  TAUDB_TIMER_CALL_DATA* timer_call_data = taudb_create_timer_call_data(1);
  TAUDB_TIMER_VALUE* timer_value = taudb_create_timer_values(1);

  timer-&gt;name = taudb_strdup(
      "int main(int, char **) [{kernel.c} {134,1}-{207,1}]");
  timer-&gt;short_name = taudb_strdup("main");
  timer-&gt;source_file = taudb_strdup("kernel.c");
  timer-&gt;line_number = 134;
  timer-&gt;column_number = 1;
  timer-&gt;line_number_end = 207;
  timer-&gt;column_number_end = 1;
  taudb_add_timer_to_trial(trial, timer);

  timer_group-&gt;name = taudb_strdup("TAU_DEFAULT");
  taudb_add_timer_group_to_trial(trial, timer_group);
  taudb_add_timer_to_timer_group(timer_group, timer);

  timer_callpath-&gt;timer = timer;
  timer_callpath-&gt;parent = NULL;
  taudb_add_timer_callpath_to_trial(trial, timer_callpath);

  timer_call_data-&gt;key.timer_callpath = timer_callpath;
  timer_call_data-&gt;key.thread = thread;
  timer_call_data-&gt;calls = 1;
  timer_call_data-&gt;subroutines = 0;
  taudb_add_timer_call_data_to_trial(trial, timer_call_data);

  timer_value-&gt;metric = metric;
  // 5 seconds, or 5 million microseconds
  timer_value-&gt;inclusive = 5000000; 
  timer_value-&gt;exclusive = 5000000;
  timer_value-&gt;inclusive_percentage = 100.0;
  timer_value-&gt;exclusive_percentage = 100.0;
  timer_value-&gt;sum_exclusive_squared = 0.0;
  taudb_add_timer_value_to_timer_call_data(timer_call_data, timer_value);

  // compute stats
  printf("Computing Stats...\n");
  taudb_compute_statistics(trial);

  // save the trial!
  printf("Testing inserts...\n");
  boolean update = FALSE;
  boolean cascade = TRUE;
  taudb_save_trial(connection, trial, update, cascade);
  
  printf("Disconnecting...\n");
  taudb_disconnect(connection);
  printf("Done.\n");
  return 0;
}
	    </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.query"></a>31.4.2.&nbsp;Querying a trial from the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void dump_metadata(TAUDB_PRIMARY_METADATA *metadata) {
   printf("%d metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_PRIMARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_primary_metadata_by_name_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;name, current-&gt;value);
   }
}

void dump_secondary_metadata(TAUDB_SECONDARY_METADATA *metadata) {
   printf("%d secondary metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_SECONDARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_secondary_metadata_by_key_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;key.name, current-&gt;value[0]);
   }
}

void dump_trial(TAUDB_CONNECTION* connection, TAUDB_TRIAL* filter, 
                boolean haveTrial) {
   TAUDB_TRIAL* trial;
   if (haveTrial) {
     trial = filter;
   } else {
     trial = taudb_query_trials(connection, FALSE, filter);
   }
   TAUDB_TIMER* timer = taudb_query_main_timer(connection, trial);
   printf("Trial name: '%s', id: %d, main: '%s'\n\n", 
          trial-&gt;name, trial-&gt;id, timer-&gt;name);
}

int main (int argc, char** argv) {
   printf("Connecting...\n");
   TAUDB_CONNECTION* connection = NULL;
   if (argc &gt;= 2) {
     connection = taudb_connect_config(argv[1]);
   } else {
     fprintf(stderr, "Please specify a TAUdb config file.\n");
     exit(1);
   }
   printf("Checking connection...\n");
   taudb_check_connection(connection);
   printf("Testing queries...\n");

   int t;

   // test the "find trials" method to populate the trial
   TAUDB_TRIAL* filter = taudb_create_trials(1);
   filter-&gt;id = atoi(argv[2]);
   TAUDB_TRIAL* trials = taudb_query_trials(connection, TRUE, filter);
   int numTrials = taudb_numItems;
   for (t = 0 ; t &lt; numTrials ; t = t+1) {
      printf("  Trial name: '%s', id: %d\n", 
	         trials[t].name, trials[t].id);
      dump_metadata(trials[t].primary_metadata);
      dump_secondary_metadata(trials[t].secondary_metadata);
      dump_trial(connection, &amp;(trials[t]), TRUE);
   }

   printf("Disconnecting...\n");
   taudb_disconnect(connection);
   printf("Done.\n");
   return 0;
}
	    </pre></div></div></div></div></div><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauInstallGuide"></a>TAU Install Guide</h1></div><div><div class="legalnotice"><a name="d0e2906"></a><p>Updated May 4th, 2015, for use with version 2.24.1 or greater.</p><p>Copyright &copy; 1997-2012
      Department of Computer and Information Science, University of Oregon 
      Advanced Computing Laboratory, LANL, NM 
      Research Centre Julich, ZAM, Germany</p><p>Permission to use, copy, modify, and distribute this software and
	its documentation for any purpose and without fee is hereby granted,
	provided that the above copyright notice appear in all copies and that
	both that copyright notice and this permission notice appear in
	supporting documentation, and that the name of University of Oregon (UO)
	Research Centre Julich, (ZAM) and Los Alamos National Laboratory (LANL)
	not be used in advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.  The University of
	Oregon, ZAM and LANL make no representations about the suitability of
	this software for any purpose.  It is provided "as is" without express or
	implied warranty.</p><p>UO, ZAM AND LANL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
	SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF OREGON, ZAM OR LANL BE
	LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      </p><p>TAU can be found on the web at: <a href="http://www.cs.uoregon.edu/research/tau" target="_top">http://www.cs.uoregon.edu/research/tau</a></p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tau.installation">1. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2951">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3016">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3107">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3164">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3446">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e3451">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e3461">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e3466">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#d0e3310"></a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tau.installation"></a>Chapter&nbsp;1.&nbsp;Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2951">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3016">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3107">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3164">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3446">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e3451">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e3461">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e3466">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></div><p> TAU (Tuning and Analysis Utilities) is a portable profiling and 
      tracing toolkit for performance analysis of parallel programs written 
      in Fortran, C++, C, Java and Python.  The model that TAU uses to profile 
      parallel, multi-threaded programs maintains performance data for each 
      thread, context, and node in use by an application. The profiling 
      instrumentation needed to implement the model captures data for 
      functions, methods, basic blocks, and statement execution at these 
      levels. All C++ language features are supported in the TAU profiling 
      instrumentation including templates and namespaces, which is available 
      through an API at the library or application level. The API also 
      provides selection of profiling groups for organizing and controlling 
      instrumentation. The instrumentation can be inserted in the source code 
      using an automatic instrumentor tool based on the Program Database 
      Toolkit (PDT), dynamically using DyninstAPI, at runtime in the Java 
      virtual machine, or manually using the instrumentation API.  TAU's 
      profile visualization tool, paraprof, provides graphical displays of 
      all the performance analysis results, in aggregate and single 
      node/context/thread forms.  The user can quickly identify sources of 
      performance bottlenecks in the application using the graphical 
      interface. In addition, TAU can generate event traces that can be 
      displayed with the Vampir or Paraver trace visualization tools.  
      This chapter discusses installation of the TAU portable profiling 
      package.</p><p>
      Some tau options allow external resources to be automatically downloaded 
      and built when TAU is configured. To obtain these resources in a single
      package download  http://tau.uoregon.edu/ext.tgz and unpack it in TAU's
      root directory. When you configure TAU with:
      
      </p><div class="itemizedlist"><ul type="disc"><li><p>
				<code class="literal">
				-bfd=download
				</code>
			</p></li><li><p>
				<code class="literal">
				-unwind=download
				</code>
			</p></li><li><p>
				<code class="literal">
				-ompt=download
				</code>
			</p></li></ul></div><p>
      these packages will be provided by the ext.tgz package and no additional
      network activity will be required.
      </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installing.tau"></a>1.1.&nbsp;Installing TAU</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2951"></a>1.1.1.&nbsp;Know what options you will need</h3></div></div></div><p>Each TAU configuration results in a single
			<code class="literal">Makefile</code>. These <code class="literal">Makefiles</code> denote
			the configuration that produced it and is used by the user to select
			the TAU libraries/scripts associated with its configuration. (These
			makefiles are named after the configuration options, ie. TAU configured with
			MPI, PDT, PGI compilers and the '-nocomm' option is named:
			<code class="literal">Makefile.tau-nocomm-mpi-pdt-pgi</code>). On most machines
			several configuration of TAU will need to be built in order to take full
			advantage of the many features of TAU. This section should help you
			decide on the smallest set of configuration you will need to build.</p><p>
			The options used to configure TAU can be grouped into two
			categories:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
					External packages: TAU will use these when instrumenting or measuring an
					application. <span class="emphasis"><em>Configuring with these options does
					not force the user to
					use these packages</em></span>, ie: configuring with PDT does not force the user
					to use source code based instrumentation (they can use
					compiler based instrumentation instead). Similarly configuring with
					PAPI does not forces the user to select any PAPI counters when
					profiling.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
						The only exception is configuring with the epilog (scalasca) tracing
						package. This will replace the TAU tracer with the epliog one, a single
						configuration cannot use both tracers.
						</p></td></tr></table></div><p>
					</p><p>
					For this reason it is recommend that you <span class="emphasis"><em>configure with every external
					packages that the user might be interested in using</em></span>, letting them choose
					which packages to enable when they go to instrument or measure their
					application.</p></li><li><p>
					Compiler and MPI options: these control the behavior of TAU when it compiles the
					instrumented application. TAU provides compiler wrapper scripts,
					these options control which compiler TAU will wrap, <span class="emphasis"><em>These
					options are determinative: select only options that are
				  compatible.</em></span> For example, when configuring with MPI use a
					version of MPI compatible with the compiler you select.</p><p>Since multiple compiler/MPI libraries cannot be specified for a
					single configuration, <span class="emphasis"><em>each set of compiler/MPI libraries that you want
					to use with TAU need to be configured separately.</em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
						Configurations with different compilers are given separate
						<code class="literal">Makefiles</code> automatically, however configurations with different
						MPI implementations are not. Use the <code class="literal">-tag=</code> option
						to distinguish between different MPIs, ie:
						<code class="literal">-tag=mvapich</code> or
						<code class="literal">-tag=openmpi</code>.
						</p></td></tr></table></div></li></ul></div><p>
		</p><p>The <code class="literal">configure</code> shell script attempts to guess 
    correct values for various system-dependent variables used during 
    compilation (compilers and system architecture), other options need to be
		specified on the command line.</p><p>The following are the most important command-line options are available to configure:</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3016"></a>1.1.2.&nbsp;Common configuration options</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3019"></a>1.1.2.1.&nbsp;Select compiler</h4></div></div></div><p>TAU defaults to using any compilers found in the environment. To
			use a specific compiler use these options:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-c++=&lt;C++ compiler&gt;</code></p><p>Specifies the name of the C++ compiler. Supported C++ 
        compilers include KCC (from KAI/Intel), CC (SGI, Sun), g++ 
        (from GNU), FCC (from Fujitsu), xlC (from IBM), guidec++ 
        (from KAI/Intel), cxx (Tru64) and aCC (from HP), c++ (from Apple), 
        icpc and ecpc (from Intel) and pgCC (from PGI).</p></li><li><p><code class="literal">-cc=&lt;C Compiler&gt;</code></p><p> Specifies the name of the C compiler. Supported C 
        compilers include cc, gcc (from GNU), pgcc (from PGI), 
        fcc (from Fujitsu), xlc (from IBM), and KCC (from KAI/ Intel), 
        icc and ecc (from Intel).</p></li><li><p><code class="literal">-fortran=&lt;Fortran Compiler&gt;</code></p><p>Specifies the name of the Fortran90 compiler. Valid options are: 
        gnu, sgi, ibm, ibm64, intel, cray, pgi, absoft, fujitsu, sun, kai, nec, 
        hitachi, compaq, nagware, g95 and hp.</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3043"></a>1.1.2.2.&nbsp;Using MPI</h4></div></div></div><p>To profile a program that use MPI configure TAU with these
				options:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-mpi</code></p><p>With this option, TAU will try to guess the location of the MPI
	libraries if the mpirun command is in your path. This does not always work in
	which case use these more detailed options:</p></li><li><p><code class="literal">-mpiinc=&lt;dir&gt;</code></p><p>Specifies the directory where MPI header files reside (such as 
        mpi.h and mpif.h).  This option also generates the TAU MPI wrapper 
        library that instruments MPI routines using the MPI Profiling 
        Interface. See the examples/NPB2.3/config/make.def file for its 
        usage with Fortran and MPI programs. <a href="http://www-unix.mcs.anl.gov/mpi/" target="_top">MPI</a></p></li><li><p><code class="literal">-mpilib=&lt;dir&gt;</code></p><p>Specifies the directory where MPI library files reside. This option
      should be used in conjunction with the -mpiinc=&lt;dir&gt; option to
      generate the TAU MPI wrapper library. </p></li><li><p><code class="literal">-mpilibrary=&lt;lib&gt;</code></p><p>Specifies the use of a different MPI library. By default, TAU uses
      -lmpi or -lmpich as the MPI library. This option allows the user to 
      specify another library. e.g., -mpilibrary=-lmpi_r for specifying a 
      thread-safe MPI library.</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3075"></a>1.1.2.3.&nbsp;OpenMP</h4></div></div></div><p>To profile programs using openmp use -openm and either 
			OPARI option:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-openmp</code></p><p>Specifies OpenMP as the threads package to be used.
        <a href="http://www.open-mpi.org/" target="_top">Open MPI</a></p></li><li><p><code class="literal">-opari</code></p><p>The use of Opari2 source-to-source instrumentor in conjunction 
        with TAU exposes OpenMP events for instrumentation. See 
        examples/opari directory. <a href="ihttp://www.vi-hps.org/projects/score-p/" target="_top">OPARI</a> </p></li><li><p><code class="literal">-opari1</code></p><p>Use this option for the use of the original Opari.
        Only use this option if -opari fails. <a href="http://www.fz-juelich.de/zam/kojak/opari/" target="_top">OPARI</a> </p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3107"></a>1.1.3.&nbsp;Configuring with external packages</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-pdt=&lt;directory&gt;</code></p><p>Specifies the location of the installed PDT (Program Database 
        Toolkit) root directory. PDT is used to build tau_instrumentor, 
        a C++, C and F90 instrumentation program that automatically inserts 
        TAU annotations in the source code <a href="http://www.cs.uoregon.edu/research/pdt" target="_top">PDT</a>.  If PDT is configured 
        with a subdirectory option (-compdir=&lt;opt&gt;) then TAU can be 
        configured with the same option.</p></li><li><p><code class="literal">-pdt_c++=&lt;C++ Compiler&gt;</code></p><p>Specifies a different C++ compiler for PDT (tau_instrumentor). 
        This is typically used when the library is compiled with a C++ 
        compiler (specified with -c++) and the tau_instrumentor is compiled 
        with a different &lt;pdt_c++&gt; compiler. For e.g., </p><pre class="screen">-arch=craycnl -pdt=/usr/pdtoolkit-3.17 -pdt_c++=g++ ...</pre><p>uses g++ to compile the tau_instrumentor, for example on CRAY XT5
				systems use this option to build TAU any of the backend compilers.</p><pre class="screen">-arch=bgp -pdt=/usr/pdtoolkit-3.17 -pdt_c++=xlC -mpi</pre><p>uses PDT, MPI for IBM BG/P and specifies the use of the front-end
        xlC compiler for building tau_instrumentor.</p></li><li><p><code class="literal">-papi=&lt;directory&gt;</code></p><p>Specifies the location of the installed PAPI (Performance 
        Data Standard and API) root directory. PCL provides a common 
        interface to access hardware performance counters and timers on 
        modern microprocessors. Most modern CPUs provide on-chip hardware 
        performance counters that can record several events such as the 
        number of instructions issued, floating point operations performed, 
        the number of primary and secondary data and instruction cache misses.
        To measure floating point instructions, set the environment 
        variable TAU_METRICS to PAPI_FP_INS (for example). This option (by 
        default) specifies the use of hardware performance counters for 
        profiling (instead of time).
		  
		  <a href="http://icl.cs.utk.edu/papi/" target="_top">PAPI</a>
				</p></li><li><p><code class="literal">-epilog=&lt;dir&gt;</code></p><p>Specifies the directory where the EPILOG tracing package 
      <a href="http://www.fz-juelich.de/zam/kojak/epilog/" target="_top">EPILOG</a> is installed.This option should be used in conjunction with 
      the -TRACE option to generate binary EPILOG traces (instead of 
      binary TAU traces). EPILOG traces can then be used with other tools 
      such as EXPERT. EPILOG comes with its own implementation of the 
      MPI wrapper library and the POMP library used with Opari. Using option 
      overrides TAU's libraries for MPI, and OpenMP.</p></li><li><p><code class="literal">-otf=&lt;directory&gt;</code></p><p>
	    Specifies the location of the OTF trace libraries generation package. TAU's
	    binary traces can be converted to the OTF format using tau2otf, a
	    tool that links with the OTF library. 
        </p></li><li><p><code class="literal">-vtf=&lt;directory&gt;</code></p><p>
	    Specifies the location of the VTF3 trace generation package. TAU's
	    binary traces can be converted to the VTF3 format using tau2vtf, a
	    tool that links with the VTF3 library. The VTF3 format is read by
	    Intel trace analyzer, formerly known as vampir, a commercial trace
	    visualization tool developed by TU. Dresden, Germany.
        </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3164"></a>1.1.4.&nbsp;More configuration options</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-PROFILEPHASE</code></p><p>This option generates phase based profiles. It requires special
      instrumentation to mark phases in an application (I/O, computation,
      etc.). Phases can be static or dynamic (different phases for each loop
      iteration, for instance).  See examples/phase/README for further
      information.
      </p></li><li><p><code class="literal">-prefix=&lt;directory&gt;</code></p><p>Specifies the destination directory where the header, library and 
        binary files are copied. By default, these are copied to subdirectories 
        &lt;arch&gt;/bin and &lt;arch&gt;/lib in the TAU root directory.</p></li><li><p><code class="literal">-arch=&lt;architecture&gt;</code></p><p>Specifies the architecture. If the user does not 
        specify this option, configure determines the architecture. 
        For IBM BGL, the user should specify bgl as the architecture. 
        For SGI, the user can specify either of sgi32, sgin32 or 
        sgi64 for 32, n32 or 64 bit compilation modes respectively. 
        The files are installed in the &lt;architecture&gt;/bin and 
        &lt;architecture&gt;/lib directories. Cray options are xt3, craycnl or
				crayxmt.</p></li><li><p><code class="literal">-tag=&lt;Unique Name&gt;</code></p><p>Specifies a tag in the name of the stub Makefile and TAU makefiles to uniquely identify the installation. This is useful when more than one MPI library may be used with different versions of compilers. e.g.,</p><pre class="screen"> 
% configure -c++=icpc -cc=icc -tag=intel71-vmi   \ 
            -mpiinc=/vmi2/mpich/include
	</pre></li><li><p><code class="literal">-scalasca=&lt;dir&gt;</code></p><p>Specifies the directory where the <a href="http://www.sclasca.org" target="_top">SCALASCA</a> package 
       is installed.</p></li><li><p><code class="literal">-pthread</code></p><p>Specifies pthread as the thread package to be used. In the 
        default mode, no thread package is used.</p></li><li><p><code class="literal">-opari_region</code></p><p>Report performance data for only OpenMP regions and not 
        constructs.  By default, both regions and constructs are profiled 
        with Opari.</p></li><li><p><code class="literal">-opari_construct</code></p><p>Report performance data for only OpenMP constructs and not 
        Regions.  By default, both regions and constructs are profiled with 
        Opari.</p></li><li><p><code class="literal">-pdtarch=&lt;architecture&gt;</code></p><p>Specifies the architecture used to build pdt, default the tau architecture.</p></li><li><p><code class="literal">-papithreads</code> </p><p>Same as papi, except uses threads to
      highlight how hardware performance counters may be used in a
      multi-threaded application. When it is used with PAPI, TAU should be
      configured with -papi=&lt;dir&gt; -pthread autoinstrument Shows the use
      of Program Database Toolkit (PDT) for automating the insertion of TAU
      macros in the source code. It requires configuring TAU with the
      -pdt=&lt;dir&gt; option. The Makefile is modified to illustrate the use
      of a source to source translator (tau_instrumentor). </p></li><li><p><code class="literal">-jdk=&lt;directory&gt;</code></p><p>Specifies the location of the installed Java root directory. 
        TAU can profile or trace Java 
        applications without any modifications to the source code, byte-code 
        or the Java virtual machine. See README.JAVA on instructions on 
        using TAU with Java 2 applications. Also the refence guide has more information 
        on the new tau_java tool.  This option should only be used 
        for configuring TAU to use JVMTI for profiling and tracing of Java 
        applications. It should not be used for configuring paraprof, 
        which uses Java from the user's path.</p></li><li><p><code class="literal">-dyninst=&lt;dir&gt;</code></p><p>Specifies the directory where the DynInst dynamic 
        instrumentation package is installed. Using DynInst, a user can 
        invoke tau_run to instrument an executable program at runtime or 
        prior to execution by rewriting it. 
        <a href="http://www.dyninst.org/" target="_top">DyninstAPI</a><a href="http://www.paradyn.org/" target="_top">PARA-DYN</a>.</p></li><li><p><code class="literal">-vampirtrace=&lt;directory&gt;</code></p><p>
	    Specifies the location of the Vampir Trace package. 
      With this option TAU will generate traces in Open Trace Format (OTF). 
      For more information, see <a href="       http://www.tu-dresden.de/zih/vampirtrace" target="_top">Technische Universitat
      Dresden</a>
        </p></li><li><p><code class="literal">-scorep=&lt;directory&gt;</code></p><p>
	    Specify location of Score-P package.  Set the enviroment varible SCOREP_PROFILING_FORMAT 
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles. 
        </p></li><li><p><code class="literal">-shmeminc=&lt;dir&gt;</code></p><p>Specifies the directory where shmem.h resides and specifies the use of
      the TAU SHMEM interface.</p></li><li><p><code class="literal">-shmemlib=&lt;dir&gt;</code></p><p>Specifies the directory where libsma.a resides and specifies the use
      of the TAU SHMEM interface.</p></li><li><p><code class="literal">-shmemlibrary=&lt;lib&gt;</code></p><p>By default, TAU uses -lsma as the shmem/pshmem library. This option
      allows the user to specify a different shmem library.</p></li><li><p><code class="literal">-nocomm</code></p><p>Allows the user to turn off tracking of messages 
      (synchronous/asynchronous) in TAU's MPI wrapper interposition 
      library. Entry and exit events for MPI routines are still tracked. 
      Affects both profiling and tracing.</p></li><li><p><code class="literal">-cuda=&lt;dir&gt;</code></p><p>Specifies the location of the top level CUDA SDK</p></li><li><p><code class="literal">-gpi=&lt;dir&gt;</code></p><p>Specify use of TAU's GPI wrapper library. </p><p> It works well with PDT and compiler based instrumentation of the source code and there is  a wrapper interposition library that is linked in to track the communication of GPI.  It is important to specify all TAU runtime options in the tau.conf file that must reside in the current working directory where the executable is stored and launched from. This is important because the worker tasks are spawned by the GPI daemon on remote nodes and do not inherit the user's working directory or the environment. 
So, options such as TAU_TRACE=1, and sampling must be specified in the tau.conf file. </p><div class="figure"><a name="d0e3310"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/onesidecomm.png" align="middle"></td></tr></table></div><div class="caption">
Context events using GPI as shown in ParaProf.
</div></div></li><li><p><code class="literal">-opencl=&lt;dir&gt;</code></p><p>Specifies the location of the OpenCL package</p></li><li><p><code class="literal">-armci=&lt;dir&gt;</code></p><p>Specifies the location of the ARMCI directory</p></li><li><p><code class="literal">-epiloglib=&lt;dir&gt;</code></p><p>Specifies the directory of where the Epilog library is to be
        found. Ex: if directory structure is:
        <code class="literal">/usr/local/epilog/fe/lib/</code> let the install options be:
        <code class="literal">-epilog=/usr/local/epilog -epiloglib=/usr/local/epilog/fe/lib.</code>
      </p></li><li><p><code class="literal">-epilogbin=&lt;dir&gt;</code></p><p>Specifies the directory of where the Epilog binaries are to be
      found.
      </p></li><li><p><code class="literal">-epiloginc=&lt;dir&gt;</code></p><p>Specifies the directory of where the epilog's included sources headers are to be
      found.
      </p></li><li><p><code class="literal">-MPITRACE</code></p><p>Specifies the tracing option and generates event traces for MPI
      calls and routines that are ancestors of MPI calls in the callstack. This
      option is useful for generating traces that are converted to the EPILOG
      trace format.  KOJAK's Expert automatic diagnosis tool needs traces with
      events that call MPI routines. Do not use this option with the -TRACE
      option. </p></li><li><p><code class="literal">-pythoninc=&lt;dir&gt;</code></p><p>Specifies the location of the Python include directory. This is 
      the directory   where Python.h header file is located. This option 
      enables python bindings to be generated. The user should set the 
      environment variable PYTHONPATH to 
      &lt;TAUROOT&gt;/&lt;ARCH&gt;/lib/bindings-&lt;options&gt; to use a 
      specific version of the TAU Python bindings. By importing package pytau, 
      a user can manually instrument the source code and use the TAU API. On 
      the other hand, by importing tau and using tau.run(`&lt;func&gt;'), 
      TAU can automatically generate instrumentation. See examples/python 
      directory for further information.</p></li><li><p><code class="literal">-pythonlib=&lt;dir&gt;</code></p><p>Specifies the location of the Python lib directory. This is the 
      directory where *.py and *.pyc files (and config directory) are located. 
      This option is mandatory for IBM when Python bindings are used. For other
      systems, this option may not be specified (but -pythoninc=&lt;dir&gt; 
      needs to be specified).</p></li><li><p><code class="literal">-PROFILEMEMORY</code></p><p>
	Specifies tracking heap memory utilization for each instrumented
	function.  When any function entry takes place, a sample of the heap
	memory used is taken. This data is stored as user-defined event data in
	profiles/traces.
      </p></li><li><p><code class="literal">-PROFILECOMMUNICATORS</code></p><p>
	This option generates MPI information partitioned by communicators. TAU
   lists upto 8 ranks in each communicator in the listing. 
      </p></li><li><p><code class="literal">-PROFILEHEADROOM</code></p><p>
	Specifies tracking memory available in the heap (as opposed to memory
	utilization tracking in -PROFILEMEMORY). When any function entry takes
	place, a sample of the memory available (headroom to grow) is
	taken. This data is stored as user-defined event data in
	profiles/traces. Please refer to the examples/headroom/README file for
	a full explanation of these headroom options and the C++/C/F90 API for
	evaluating the headroom.
      </p></li><li><p><code class="literal">-COMPENSATE</code></p><p>
	Specifies online compensation of performance perturbation. When this
	option is used, TAU computes its overhead and subtracts it from the
	profiles. It can be only used when profiling is chosen. This option
	works with MULTIPLECOUNTERS as well, but while it is relevant for
	removing perturbation with wallclock time, it cannot accurately account
	for perturbation with hardware performance counts (e.g., L1 Data cache
	misses).  See TAU Publication [Europar04] for further information on
	this option.
      </p></li><li><p><code class="literal">-PROFILECOUNTERS</code></p><p>Specifies use of hardware performance counters for profiling 
      under IRIX using the SGI R10000 perfex counter access interface. The 
      use of this option is deprecated in favor of the -pcl=&lt;dir&gt; 
      and -papi=&lt;dir&gt; options described above. </p></li><li><p><code class="literal">-noex</code></p><p>Specifies that no exceptions be used while compiling the library. 
      This is relevant for C++. </p></li><li><p><code class="literal">-useropt=&lt;options-list&gt;</code></p><p>Specifies additional user options such as -g or -I. For multiple 
      options, the options list should be enclosed in a single quote. For 
      example </p><pre class="screen">
%./configure -useropt='-g -I/usr/local/stl'
      </pre></li><li><p><code class="literal">-mrnet=&lt;mrnet source root&gt;</code></p><p>Base location of the MRnet package.</p></li><li><p><code class="literal">-mrnetlib=&lt;mrnet libraries&gt;</code></p><p>Path to the MRnet libraries. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">On some cluster systems the MRnet libraries need to
			available to the runtime system (ie. on the lustre filesystem.)</td></tr></table></div></li><li><p><code class="literal">-scorep=&lt;scorep subsystem&gt;</code></p><p>Path to the Score-P measurement system. Set the enviroment varible SCOREP_PROFILING_FORMAT
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles.
      </p></li><li><p><code class="literal">-help</code></p><p>Lists all the available configure options and quits.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3446"></a>1.1.5.&nbsp;tau_setup</h3></div></div></div><p>tau_setup is a GUI interface to the configure and installtau tools.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3451"></a>1.1.6.&nbsp;installtau script</h3></div></div></div><p>To install multiple (typical) configurations of TAU at a site, you 
    may use the script `installtau'. It takes options similar to those 
    described above. It invokes ./configure &lt;opts&gt;; make clean install;  
    to create multiple libraries that may be requested by the users at a 
    site. The installtau script accepts the following options: </p><pre class="screen">
% installtau -help

TAU Configuration Utility 
***************************************************
Usage: installtau [OPTIONS]
  where [OPTIONS] are:
-arch=&lt;arch&gt;  
-fortran=&lt;compiler&gt;  
-cc=&lt;compiler&gt;   
-c++=&lt;compiler&gt;   
-useropt=&lt;options&gt;  
-pdt=&lt;pdtdir&gt;  
-pdtcompdir=&lt;compdir&gt;  
-pdt_c++=&lt;C++ Compiler&gt;  
-papi=&lt;papidir&gt;  
-vtf=&lt;vtfdir&gt;  
-otf=&lt;otfdir&gt;  
-dyninst=&lt;dyninstdir&gt; 
-mpi
-mpiinc=&lt;mpiincdir&gt;  
-mpilib=&lt;mpilibdir&gt;  
-mpilibrary=&lt;mpilibrary&gt;  
-perfinc=&lt;dir&gt; 
-perflib=&lt;dir&gt; 
-perflibrary=&lt;library&gt; 
-mpi
-tag=&lt;unique name&gt; 
-opari=&lt;oparidir&gt;  
-epilog=&lt;epilogdir&gt;  
-epiloginc=&lt;absolute path to epilog include dir&gt; (&lt;epilog&gt;/include default) 
-epilogbin=&lt;absolute path to epilog bin dir&gt; (&lt;epilog&gt;/bin default)  
-epiloglib=&lt;absolute path to epilog lib dir&gt; (&lt;epilog&gt;/lib default)  
-prefix=&lt;dir&gt;  
-exec-prefix=&lt;dir&gt; 
-j=&lt;num processes for parallel make&gt;  (just -j for full parallel) 

******************************************************************
</pre><p>These options are similar to the options used by the configure script.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3461"></a>1.1.7.&nbsp;upgradetau</h3></div></div></div><p>This script is provided to rebuild all TAU configurations
                previously built in a different TAU source directory. Give this
                command the location of a previous version of tau followed by
                any additional configurations and it will rebuild tau
                with these same options.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3466"></a>1.1.8.&nbsp;tau_validate</h3></div></div></div><p>This script will attempt to validate a tau installation. Its only
      argument is TAU's architecture directory. These are some options: 
      </p><div class="itemizedlist"><ul type="disc"><li><p>-v Verbose output</p></li><li><p>--html       Output results in HTML</p></li><li><p>--build      Only build</p></li><li><p>--run        Only run</p></li></ul></div><p>  
    </p><p> Here is a simple example: 
    </p><pre class="screen">

bash : ./tau_validate --html x86_64 &amp;&gt; results.html
tcsh : ./tau_validate --html x86_64 &gt;&amp; results.html
</pre><p>
    </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="platforms.supported"></a>1.2.&nbsp;Platforms Supported</h2></div></div></div><p>TAU has been tested on the following platforms:</p><div class="itemizedlist"><ul type="disc"><li><p>LINUX Clusters</p><p>On Linux based Intel x86 (32 and 64 bit) PC clusters, KAI/Intel's KCC, g++, egcs
        (GNU), <a href="http://www.pgroup.com" target="_top">pgCC (PGI)</a>, <a href="http://www.fujitsu.com" target="_top">FCC (Fujitsu)</a> and icpc/ecpc <a href="http://www.intel.com" target="_top">Intel</a> compilers have been
        tested. TAU also runs under IA-64, Opteron, ARM, PowerPC, Alpha, Apple
        PowerMac, Sparc and other processors running Linux. </p></li><li><p>Cray Compute Node Linux (XT5, XT6, XE6), X1, T3E, SV-1, XT3, and RedStorm</p><p>When using Cray CNL you need to configure tau with the option 
				<code class="literal">-arch=craycnl</code>On Cray T3E systems, KAI KCC and Cray CC compilers have been 
        tested with TAU. On Cray SV-1 and X1 systems, Cray CC compilers 
        have been tested with TAU. On Cray XT3, and RedStorm systems, PGI and
        GNU compilers have been tested with TAU. </p></li><li><p>IBM</p><p>On IBM BlueGene (L/P/Q) SP2 and AIX systems.  On IBM BG: IBM xlC, blrts_xlC,
        blrts_xlf90, blrts_xlc, and gnu compilers work with TAU. SP2 and AIX: vKAI KCC, KAP/Pro, IBM xlC, xlc, 
        xlf90 and g++ compilers work with TAU. On IBM pSeries
        Linux, xlC, xlc, xlf90 and gnu compilers work with TAU. </p></li><li><p>Sun Solaris</p><p>Sun compilers (CC, F90), KAI KCC, KAP/Pro and GNU g++ work with 
        TAU.</p></li><li><p>Apple OS X</p><p>On Apple OS X machines, c++ or g++ may be used to compile TAU. 
        Also, IBM's xlf90, xlf and Absoft Fortran 90 compilers for G4/G5 may 
        be used with TAU.</p></li><li><p>SGI</p><p>On IRIX 6.x based systems, including Indy, Power Challenge, Onyx,
        Onyx2 and Origin 200, 2000, 3000 Series, CC 7.2+, <a href="http://www.kai.com" target="_top">KAI</a> KCC and <a href="http://www.gnu.org" target="_top">g++</a> compilers are supported. On SGI
        Altix systems, Intel, and GNU compilers are supported.</p></li><li><p>Accelerators</p><p>TAU performance data can be retrived from ATI, Nvidia or Intel GPUs
				(through OpenCL, or CUDA). Intel Many Intergrated Cores (MIC) is
				supported in native execution.</p></li><li><p>Intel</p></li><li><p>HP HP-UX</p><p>On HP PA-RISC systems, aCC and g++ can be used.</p></li><li><p>HP Alpha Tru64</p><p>On HP Alpha Tru64 machines, cxx and g++, and Guide compilers 
        may be used with TAU.</p></li><li><p>NEC SX series vector machines</p><p>On NEC SX-5 systems, NEC c++ may be used with TAU.</p></li><li><p>On Hitachi machines, Hitachi KCC, g++ and Hitachi cc compilers 
        may be used with TAU</p></li><li><p>Fujitsu PRIMEPOWER</p><p>On Fujitsu Power machines, Sun and Fujitsu compilers may be used
        with TAU. </p></li><li><p>Microsoft Window</p><p>On Windows, Microsoft Visual C++ 6.0 or higher and JDK 1.2+ 
        compilers have been tested with TAU</p></li></ul></div><p>NOTE: TAU has been tested with JDK 1.2, 1.3, 1.4.x under Solaris, SGI, IBM, 
    Linux, and MacOS X.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="software.requirements"></a>1.3.&nbsp;Software Requirements</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>1. Java v 1.5</p><p>TAU's GUI ParaProf and PerfExplorer require Java v1.4 or better 
        in your path. If Java 1.4 is the only version avaible, older version of 
        ParaProf and PerfExplorer can be installed.  To do so, simple run either program 
        with Java 1.4 in your path.  You will guided through the installation process.
        ParaProf does not 
        require -jdk=&lt;dir&gt; option to be specified during configuration. (This option 
        is used for configuring TAU for analyzing Java applications.)</p></li></ul></div></div></div></div><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauReferenceGuide"></a>TAU Reference Guide</h1></div><div><div class="legalnotice"><a name="d0e3616"></a><p>Updated May 4th, 2015, for use with version 2.24.1 or greater.</p><p>Copyright &copy; 1997-2012
      Department of Computer and Information Science, University of Oregon 
      Advanced Computing Laboratory, LANL, NM 
      Research Centre Julich, ZAM, Germany</p><p>Permission to use, copy, modify, and distribute this software and
	its documentation for any purpose and without fee is hereby granted,
	provided that the above copyright notice appear in all copies and that
	both that copyright notice and this permission notice appear in
	supporting documentation, and that the name of University of Oregon (UO)
	Research Centre Julich, (ZAM) and Los Alamos National Laboratory (LANL)
	not be used in advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.  The University of
	Oregon, ZAM and LANL make no representations about the suitability of
	this software for any purpose.  It is provided "as is" without express or
	implied warranty.</p><p>UO, ZAM AND LANL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
	SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF OREGON, ZAM OR LANL BE
	LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      </p><p>TAU can be found on the web at: <a href="http://www.cs.uoregon.edu/research/tau" target="_top">http://www.cs.uoregon.edu/research/tau</a></p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tau.installation">1. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3661">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3726">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3817">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3874">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e4156">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e4161">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e4171">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e4176">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#instrumentationOptions">2. TAU Instrumentation Options</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e4304">2.1. Selective Instrumentation Options</a></span></dt><dt><span class="sect1"><a href="#RunningDynInstAIP">2.2. Running an application using DynInstAPI</a></span></dt><dt><span class="sect1"><a href="#RewritingMaqao">2.3. Rewriting Binaries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Maqao">2.3.1. Using MAQAO</a></span></dt><dt><span class="sect2"><a href="#d0e4463">2.3.2. Using PEBIL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingParam">2.4. Profiling each call to a function</a></span></dt><dt><span class="sect1"><a href="#d0e4485">2.5. Profiling with Hardware counters</a></span></dt><dt><span class="sect1"><a href="#HardwarePerformanceCounters">2.6. Using Hardware Performance Counters</a></span></dt><dt><span class="sect1"><a href="#PerfLib">2.7. Profiling with PerfLib</a></span></dt><dt><span class="sect1"><a href="#RunningPython">2.8. Running a Python application with TAU</a></span></dt><dt><span class="sect1"><a href="#pprof">2.9. pprof</a></span></dt><dt><span class="sect1"><a href="#RunningJAVA">2.10. Running a JAVA application with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingTauConf">2.11. Using a tau.conf File</a></span></dt><dt><span class="sect1"><a href="#UsingScoreP">2.12. Using Score-P with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingUPC">2.13. Using UPC  with TAU</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tracingReference">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e5662">3.1. How to configure tracing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e5790">4. TAU Memory Profiling Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#memoryOptions">4.1. TAU's memory API options</a></span></dt><dt><span class="sect1"><a href="#tauExecMemory">4.2. Using tau_exec</a></span></dt><dt><span class="sect1"><a href="#profilingMemory">4.3. Evaluating Memory Utilization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5818">4.3.1. TAU_TRACK_MEMORY</a></span></dt><dt><span class="sect2"><a href="#d0e5842">4.3.2. TAU_TRACK_MEMORY_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5853">4.3.3. TAU_TRACK_MEMORY_FOOTPRINT</a></span></dt><dt><span class="sect2"><a href="#d0e5858">4.3.4. TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5863">4.3.5. -PROFILEMEMORY</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingHeadroom">4.4. Evaluating Memory Headroom</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5871">4.4.1. TAU_TRACK_MEMORY_HEADROOM()</a></span></dt><dt><span class="sect2"><a href="#d0e5892">4.4.2. TAU_TRACK_MEMORY_HEADROOM_HERE()</a></span></dt><dt><span class="sect2"><a href="#d0e5906">4.4.3. -PROFILEHEADROOM</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5925">4.5. DetectingMemoryLeaks</a></span></dt><dt><span class="sect1"><a href="#MemoryTrackingInFortran">4.6. Memory Tracking In Fortran</a></span></dt></dl></dd><dt><span class="chapter"><a href="#EclipseTauJava">5. Eclipse Tau Java System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Installation">5.1. Installation</a></span></dt><dt><span class="sect1"><a href="#Instrumentation">5.2. Instrumentation</a></span></dt><dt><span class="sect1"><a href="#Uninstrumentation">5.3. Uninstrumentation</a></span></dt><dt><span class="sect1"><a href="#RunningTauJava">5.4. Running Java with TAU</a></span></dt><dt><span class="sect1"><a href="#Options">5.5. Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#EclipsePlugin">6. Eclipse PTP / CDT plug-in System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#InstallEclipse">6.1. Installation</a></span></dt><dt><span class="sect1"><a href="#TauLaucher">6.2. Creating a Tau Launch Configuration</a></span></dt><dt><span class="sect1"><a href="#SelectiveLaunch">6.3. Selective Instrumentation</a></span></dt><dt><span class="sect1"><a href="#CollectingData">6.4. Launching a Program and Collecting Data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e6181">7. Tools</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#tau_compiler.sh">tau_compiler.sh</a></span><span class="refpurpose"> - Instrumenting source files.</span></dt><dt><span class="refentrytitle"><a href="#vtf2profile">vtf2profile</a></span><span class="refpurpose"> - Generate a TAU profile set from a vampir trace file</span></dt><dt><span class="refentrytitle"><a href="#tau2vtf">tau2vtf</a></span><span class="refpurpose"> - convert TAU tracefiles to vampir tracefiles</span></dt><dt><span class="refentrytitle"><a href="#trace2profile">trace2profile</a></span><span class="refpurpose"> - convert TAU tracefiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau2elg">tau2elg</a></span><span class="refpurpose"> - convert TAU tracefiles to Epilog tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2slog2">tau2slog2</a></span><span class="refpurpose"> - convert TAU tracefiles to SLOG2 tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2otf">tau2otf</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#tau2otf2">tau2otf2</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF2
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#perf2tau">perf2tau</a></span><span class="refpurpose"> - converts PerfLib profiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau_merge">tau_merge</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_treemerge.pl">tau_treemerge.pl</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_convert">tau_convert</a></span><span class="refpurpose"> - convert TAU tracefiles into various alternative trace formats</span></dt><dt><span class="refentrytitle"><a href="#tau_reduce">tau_reduce</a></span><span class="refpurpose"> - generates selective
    instrumentation rules based on profile data</span></dt><dt><span class="refentrytitle"><a href="#tau_ompcheck">tau_ompcheck</a></span><span class="refpurpose"> - Completes uncompleted do/for/parallel omp directives</span></dt><dt><span class="refentrytitle"><a href="#tau_poe">tau_poe</a></span><span class="refpurpose"> - Instruments a MPI application while it is being executed with poe.</span></dt><dt><span class="refentrytitle"><a href="#tau_validate">tau_validate</a></span><span class="refpurpose"> - Validates a TAU installation by performing
    various tests on each TAU stub Makefile</span></dt><dt><span class="refentrytitle"><a href="#tauex">tauex</a></span><span class="refpurpose"> - Allows you to choose a tau configuration at runtime</span></dt><dt><span class="refentrytitle"><a href="#tau_exec">tau_exec</a></span><span class="refpurpose"> - TAU execution wrapping script</span></dt><dt><span class="refentrytitle"><a href="#tau_timecorrect">tau_timecorrect</a></span><span class="refpurpose"> - Corrects and reorders the records of tau trace files.</span></dt><dt><span class="refentrytitle"><a href="#tau_throttle.sh">tau_throttle.sh</a></span><span class="refpurpose"> - This tool generates a selective instrumentation file (called
    throttle.tau) from a program output that has "Disabling"
    messages.</span></dt><dt><span class="refentrytitle"><a href="#tau_portal.py">tau_portal.py</a></span><span class="refpurpose"> - 
      This tool is design to interact with the TAU web portal (http://tau.nic.uoregon.edu). There are commands
      for uploading or downloading packed profile files form the TAU portal.
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_configure">taudb_configure</a></span><span class="refpurpose"> - 
     Configuration program for a PerfDMF database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createapp">perfdmf_createapp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a application in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createexp">perfdmf_createexp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a experiment in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_loadtrial">taudb_loadtrial</a></span><span class="refpurpose"> - 
      Command line tool to load a trial into the TAUdb database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer">perfexplorer</a></span><span class="refpurpose"> - 
      Launches TAU's Performance Data Mining Analyzer.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer_configure">perfexplorer_configure</a></span><span class="refpurpose"> - 
	Configures a TAUdb database for use with perfexplorer, and installs necessary JAR files.
    </span></dt><dt><span class="refentrytitle"><a href="#taucc.man">taucc</a></span><span class="refpurpose"> - 
      C compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauupc.man">tauupc</a></span><span class="refpurpose"> - 
      UPC wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#taucxx.man">taucxx</a></span><span class="refpurpose"> - 
      C++ compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauf90.man">tauf90</a></span><span class="refpurpose"> - 
      Fortran compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#paraprof.man">paraprof</a></span><span class="refpurpose"> - 
      Launches TAU's Java-based performance data viewer.
    </span></dt><dt><span class="refentrytitle"><a href="#pprof.man">pprof</a></span><span class="refpurpose"> - 
      Quickly diplays profile data.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_instrumentor">tau_instrumentor</a></span><span class="refpurpose"> - 
      automaticly instruments a source basied on information provided by pdt.
    </span></dt><dt><span class="refentrytitle"><a href="#vtfconverter">vtfconverter</a></span><span class="refpurpose"> - 
      
    </span></dt><dt><span class="refentrytitle"><a href="#tau_setup">tau_setup</a></span><span class="refpurpose"> - 
      Launches GUI interface to configure TAU.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_wrap">tau_wrap</a></span><span class="refpurpose"> - 
      Instruments an external library with TAU without needing to recompile
    </span></dt><dt><span class="refentrytitle"><a href="#tau_gen_wrapper">tau_gen_wrapper</a></span><span class="refpurpose"> - 
     Generates a wrapper library that can intercept 
 at link time or at runtime routines specified in a header file
    </span></dt><dt><span class="refentrytitle"><a href="#tau_pin">tau_pin</a></span><span class="refpurpose"> - 
      Instruments application at run time using Intel's PIN library
    </span></dt><dt><span class="refentrytitle"><a href="#tau_java">tau_java</a></span><span class="refpurpose"> - 
      Instruments java applications at runtime using JVMTI
    </span></dt><dt><span class="refentrytitle"><a href="#tau_cupti_avail">tau_cupti_avail</a></span><span class="refpurpose"> - 
			Detects the available CUPTI counters on the a each GPU device.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_run">tau_run</a></span><span class="refpurpose"> - 
 Instruments and executes binaries to generate performance data. (DyninstAPI based instrumentor)
    </span></dt><dt><span class="refentrytitle"><a href="#tau_rewrite">tau_rewrite</a></span><span class="refpurpose"> - 
           Rewrites binaries using Maqao if Tau is configured using PDT 3.17+ at the routine level. 
          If it doesn't find the Maqao package from PDT 3.17, it reverts to tau_run (DyninstAPI based instrumentor). 
    </span></dt></dl></dd><dt><span class="part"><a href="#TAUdbDoc">I. TAUdb</a></span></dt><dd><dl><dt><span class="chapter"><a href="#taudb.intro">8. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">8.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">8.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">9. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">9.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">9.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">9.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">9.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">10. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">10.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">11. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">11.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">11.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">11.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">11.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">11.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">11.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e10848">12. Windows</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TAUonWin">12.1. TAU on Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e10854">12.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#d0e10865">12.1.2. Instrumenting an application with Visual Studio C/C++</a></span></dt><dt><span class="sect2"><a href="#UsingMINGW">12.1.3. Using MINGW  with TAU</a></span></dt></dl></dd></dl></dd><dt><span class="reference"><a href="#d0e10925">I. TAU Instrumentation API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_START">TAU_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STOP">TAU_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE">TAU_PROFILE</a></span><span class="refpurpose"> - Profile a C++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PROFILE">TAU_DYNAMIC_PROFILE</a></span><span class="refpurpose"> - dynamic_profile a c++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_DYNAMIC">TAU_PROFILE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Creates a dynamic timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_DYNAMIC_AUTO">TAU_CREATE_DYNAMIC_AUTO</a></span><span class="refpurpose"> - Creates a dynamic timer for C/C++</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DYNAMIC_ITER">TAU_PROFILE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic timer in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_DYNAMIC_ITER">TAU_PHASE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic phase in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER">TAU_PROFILE_TIMER</a></span><span class="refpurpose"> - Defines a static timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_START">TAU_PROFILE_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STOP">TAU_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_START">TAU_STATIC_TIMER_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_STOP">TAU_STATIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_START">TAU_DYNAMIC_TIMER_START</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_STOP">TAU_DYNAMIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_DYNAMIC">TAU_PROFILE_TIMER_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DECLARE_TIMER">TAU_PROFILE_DECLARE_TIMER</a></span><span class="refpurpose"> - Declares a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_TIMER">TAU_PROFILE_CREATE_TIMER</a></span><span class="refpurpose"> - Creates a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER">TAU_GLOBAL_TIMER</a></span><span class="refpurpose"> - Declares a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_EXTERNAL">TAU_GLOBAL_TIMER_EXTERNAL</a></span><span class="refpurpose"> - Declares a global timer from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_START">TAU_GLOBAL_TIMER_START</a></span><span class="refpurpose"> - Starts a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_STOP">TAU_GLOBAL_TIMER_STOP</a></span><span class="refpurpose"> - Stops a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE">TAU_PHASE</a></span><span class="refpurpose"> - Profile a C++ function as a phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE">TAU_DYNAMIC_PHASE</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_DYNAMIC">TAU_PHASE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_STATIC">TAU_PHASE_CREATE_STATIC</a></span><span class="refpurpose"> - Defines a static phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_START">TAU_PHASE_START</a></span><span class="refpurpose"> - Enters a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_STOP">TAU_PHASE_STOP</a></span><span class="refpurpose"> - Exits a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_START">TAU_DYNAMIC_PHASE_START</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_STOP">TAU_DYNAMIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_START">TAU_STATIC_PHASE_START</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_STOP">TAU_STATIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE">TAU_GLOBAL_PHASE</a></span><span class="refpurpose"> - Declares a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_EXTERNAL">TAU_GLOBAL_PHASE_EXTERNAL</a></span><span class="refpurpose"> - Declares a global phase from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_START">TAU_GLOBAL_PHASE_START</a></span><span class="refpurpose"> - Starts a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_STOP">TAU_GLOBAL_PHASE_STOP</a></span><span class="refpurpose"> - Stops a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_EXIT">TAU_PROFILE_EXIT</a></span><span class="refpurpose"> - Alerts the profiling system to an exit call</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_THREAD">TAU_REGISTER_THREAD</a></span><span class="refpurpose"> - Register a thread with the profiling system</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_NODE">TAU_PROFILE_GET_NODE</a></span><span class="refpurpose"> - Returns the measurement system's node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_CONTEXT">TAU_PROFILE_GET_CONTEXT</a></span><span class="refpurpose"> - Gives the measurement system's context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_THREAD">TAU_PROFILE_SET_THREAD</a></span><span class="refpurpose"> - Informs the measurement system of the THREAD id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_THREAD">TAU_PROFILE_GET_THREAD</a></span><span class="refpurpose"> - Gives the measurement system's thread id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_NODE">TAU_PROFILE_SET_NODE</a></span><span class="refpurpose"> - Informs the measurement system of the node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_CONTEXT">TAU_PROFILE_SET_CONTEXT</a></span><span class="refpurpose"> - Informs the measurement system of the context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_FORK">TAU_REGISTER_FORK</a></span><span class="refpurpose"> - Informs the measurement system that a fork has taken place</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_EVENT">TAU_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_REGISTER_EVENT">TAU_PROFILER_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_THREAD">TAU_EVENT_THREAD</a></span><span class="refpurpose"> - Triggers a user event on a given thread</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_CONTEXT_EVENT">TAU_REGISTER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Registers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_CONTEXT_EVENT">TAU_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT">TAU_TRIGGER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a context user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_CONTEXT_EVENT">TAU_ENABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Enable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_CONTEXT_EVENT">TAU_DISABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Disable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_SET_NAME">TAU_EVENT_SET_NAME</a></span><span class="refpurpose"> - Sets the name of an event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MAX">TAU_EVENT_DISABLE_MAX</a></span><span class="refpurpose"> - Disables tracking of maximum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MEAN">TAU_EVENT_DISABLE_MEAN</a></span><span class="refpurpose"> - Disables tracking of mean statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MIN">TAU_EVENT_DISABLE_MIN</a></span><span class="refpurpose"> - Disables tracking of minimum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_STDDEV">TAU_EVENT_DISABLE_STDDEV</a></span><span class="refpurpose"> - Disables tracking of standard deviation statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_STATISTICS">TAU_REPORT_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_THREAD_STATISTICS">TAU_REPORT_THREAD_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics, plus thread statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_INSTRUMENTATION">TAU_ENABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Enables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_INSTRUMENTATION">TAU_DISABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Disables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP">TAU_ENABLE_GROUP</a></span><span class="refpurpose"> - Enables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP">TAU_DISABLE_GROUP</a></span><span class="refpurpose"> - Disables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP">TAU_PROFILE_TIMER_SET_GROUP</a></span><span class="refpurpose"> - Change the group of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME">TAU_PROFILE_TIMER_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name for a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_NAME">TAU_PROFILE_TIMER_SET_NAME</a></span><span class="refpurpose"> - Changes the name of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_TYPE">TAU_PROFILE_TIMER_SET_TYPE</a></span><span class="refpurpose"> - Changes the type of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_GROUP_NAME">TAU_PROFILE_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name of a profiled section</span></dt><dt><span class="refentrytitle"><a href="#TAU_INIT">TAU_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_INIT">TAU_PROFILE_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_PROFILE_GROUP">TAU_GET_PROFILE_GROUP</a></span><span class="refpurpose"> - Creates groups based on names</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP_NAME">TAU_ENABLE_GROUP_NAME</a></span><span class="refpurpose"> - Enables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP_NAME">TAU_DISABLE_GROUP_NAME</a></span><span class="refpurpose"> - Disables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_ALL_GROUPS">TAU_ENABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Enables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_ALL_GROUPS">TAU_DISABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Disables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_NAMES">TAU_GET_EVENT_NAMES</a></span><span class="refpurpose"> - Gets the registered user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_VALS">TAU_GET_EVENT_VALS</a></span><span class="refpurpose"> - Gets user event data for given user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_COUNTER_NAMES">TAU_GET_COUNTER_NAMES</a></span><span class="refpurpose"> - Gets the counter names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_NAMES">TAU_GET_FUNC_NAMES</a></span><span class="refpurpose"> - Gets the function names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_VALS">TAU_GET_FUNC_VALS</a></span><span class="refpurpose"> - Gets detailed performance data for given functions</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY">TAU_ENABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Enables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY">TAU_DISABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Disables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER">TAU_TRACK_POWER</a></span><span class="refpurpose"> - Initializes POWER tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER_HERE">TAU_TRACK_POWER_HERE</a></span><span class="refpurpose"> - Triggers power tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_POWER">TAU_ENABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Enables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_POWER">TAU_DISABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Disables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY">TAU_TRACK_MEMORY</a></span><span class="refpurpose"> - Initializes memory tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HERE">TAU_TRACK_MEMORY_HERE</a></span><span class="refpurpose"> - Triggers memory tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT">TAU_TRACK_MEMORY_FOOTPRINT</a></span><span class="refpurpose"> - Initializes memory footprint tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE">TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span><span class="refpurpose"> - Triggers memory footprint tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Enables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Disables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM">TAU_TRACK_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM_HERE">TAU_TRACK_MEMORY_HEADROOM_HERE</a></span><span class="refpurpose"> - Takes a sample of the amount of memory available at a given point.</span></dt><dt><span class="refentrytitle"><a href="#TAU_SET_INTERRUPT_INTERVAL">TAU_SET_INTERRUPT_INTERVAL</a></span><span class="refpurpose"> - Change the inter-interrupt interval for tracking memory and headroom</span></dt><dt><span class="refentrytitle"><a href="#CT">CT</a></span><span class="refpurpose"> - Returns the type information for a variable</span></dt><dt><span class="refentrytitle"><a href="#TAU_TYPE_STRING">TAU_TYPE_STRING</a></span><span class="refpurpose"> - Creates a type string</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP">TAU_DB_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_MERGED_DUMP">TAU_DB_MERGED_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_INCR">TAU_DB_DUMP_INCR</a></span><span class="refpurpose"> - Dumps profile database into timestamped profiles on disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX">TAU_DB_DUMP_PREFIX</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given prefix</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX_TASK">TAU_DB_DUMP_PREFIX_TASK</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given task</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_PURGE">TAU_DB_PURGE</a></span><span class="refpurpose"> - Purges the performance data.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_NAMES">TAU_DUMP_FUNC_NAMES</a></span><span class="refpurpose"> - Dumps function names to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS">TAU_DUMP_FUNC_VALS</a></span><span class="refpurpose"> - Dumps performance data for given functions to disk.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS_INCR">TAU_DUMP_FUNC_VALS_INCR</a></span><span class="refpurpose"> - Dumps function values with a timestamp</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STMT">TAU_PROFILE_STMT</a></span><span class="refpurpose"> - Executes a statement only when TAU is used.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CALLSTACK">TAU_PROFILE_CALLSTACK</a></span><span class="refpurpose"> - Generates a callstack trace at a given location.</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_RECVMSG">TAU_TRACE_RECVMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_SENDMSG">TAU_TRACE_SENDMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_PARAM1L">TAU_PROFILE_PARAM1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT">TAU_PROFILE_SNAPSHOT</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT_1L">TAU_PROFILE_SNAPSHOT_1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_CREATE">TAU_PROFILER_CREATE</a></span><span class="refpurpose"> - Creates a profiler object referenced as a standard pointer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_TASK">TAU_CREATE_TASK</a></span><span class="refpurpose"> - Creates a task id.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START">TAU_PROFILER_START</a></span><span class="refpurpose"> - starts a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START_TASK">TAU_PROFILER_START_TASK</a></span><span class="refpurpose"> - Starts a profiler object created by  on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP">TAU_PROFILER_STOP</a></span><span class="refpurpose"> - stops a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP_TASK">TAU_PROFILER_STOP_TASK</a></span><span class="refpurpose"> - Stops a profiler object on a task</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS">TAU_PROFILER_GET_CALLS</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS_TASK">TAU_PROFILER_GET_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS">TAU_PROFILER_GET_CHILD_CALLS</a></span><span class="refpurpose"> - Gets the number of calls made while this timer was running</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK">TAU_PROFILER_GET_CHILD_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of child call for this timer, created by , is started on a task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES">TAU_PROFILER_GET_INCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES">TAU_PROFILER_GET_EXCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO">TAU_PROFILER_GET_COUNTER_INFO</a></span><span class="refpurpose"> - Returns information about all the timers created.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK">TAU_PROFILER_GET_COUNTER_INFO_TASK</a></span><span class="refpurpose"> - Returns information about all the timers created on a task. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_DECLARE_EVENT">TAU_QUERY_DECLARE_EVENT</a></span><span class="refpurpose"> - Returns a event handle.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_CURRENT_EVENT">TAU_QUERY_GET_CURRENT_EVENT</a></span><span class="refpurpose"> - set event to be the current TAU event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_EVENT_NAME">TAU_QUERY_GET_EVENT_NAME</a></span><span class="refpurpose"> - Gets the name of a given event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_PARENT_EVENT">TAU_QUERY_GET_PARENT_EVENT</a></span><span class="refpurpose"> - gets the parent of the current event. 
	</span></dt></dl></dd><dt><span class="reference"><a href="#d0e19666">II. TAU Mapping API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_MAPPING">TAU_MAPPING</a></span><span class="refpurpose"> - Encapsulates a C++ statement for profiling</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_CREATE">TAU_MAPPING_CREATE</a></span><span class="refpurpose"> - Creates a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_LINK">TAU_MAPPING_LINK</a></span><span class="refpurpose"> - Creates a mapping link</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_OBJECT">TAU_MAPPING_OBJECT</a></span><span class="refpurpose"> - Declares a mapping object</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE">TAU_MAPPING_PROFILE</a></span><span class="refpurpose"> - Profiles a block based on a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_START">TAU_MAPPING_PROFILE_START</a></span><span class="refpurpose"> - Starts a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_STOP">TAU_MAPPING_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_TIMER">TAU_MAPPING_PROFILE_TIMER</a></span><span class="refpurpose"> - Declares a mapping timer</span></dt></dl></dd><dt><span class="appendix"><a href="#d0e20170">A. Environment Variables</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#d0e4020"></a></dt><dt>5.1. <a href="#d0e6011">TAUJava Options Screen</a></dt><dt>5.2. <a href="#d0e6024">TAUJava Project Instrumentation</a></dt><dt>5.3. <a href="#d0e6048">TAUJava Running</a></dt><dt>6.1. <a href="#d0e6100">TAU Setup</a></dt><dt>6.2. <a href="#d0e6113">TAU Launch Configuration</a></dt><dt>6.3. <a href="#d0e6150">Optional User Defined Events</a></dt><dt>6.4. <a href="#d0e6163">Adding User Defined Events</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#PAPI_TABLE">Events measured by setting the environment variable TAU_METRICS in TAU</a></dt><dt>2.2. <a href="#PCL_TABLE">Events measured by setting the environment variable PCL_EVENT in TAU</a></dt><dt>7.1. <a href="#d0e7956">Selection Attributes</a></dt><dt>A.1. <a href="#d0e20173">TAU Environment Variables</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tau.installation"></a>Chapter&nbsp;1.&nbsp;Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3661">1.1.1. Know what options you will need</a></span></dt><dt><span class="sect2"><a href="#d0e3726">1.1.2. Common configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e3817">1.1.3. Configuring with external packages</a></span></dt><dt><span class="sect2"><a href="#d0e3874">1.1.4. More configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e4156">1.1.5. tau_setup</a></span></dt><dt><span class="sect2"><a href="#d0e4161">1.1.6. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e4171">1.1.7. upgradetau</a></span></dt><dt><span class="sect2"><a href="#d0e4176">1.1.8. tau_validate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></div><p> TAU (Tuning and Analysis Utilities) is a portable profiling and 
      tracing toolkit for performance analysis of parallel programs written 
      in Fortran, C++, C, Java and Python.  The model that TAU uses to profile 
      parallel, multi-threaded programs maintains performance data for each 
      thread, context, and node in use by an application. The profiling 
      instrumentation needed to implement the model captures data for 
      functions, methods, basic blocks, and statement execution at these 
      levels. All C++ language features are supported in the TAU profiling 
      instrumentation including templates and namespaces, which is available 
      through an API at the library or application level. The API also 
      provides selection of profiling groups for organizing and controlling 
      instrumentation. The instrumentation can be inserted in the source code 
      using an automatic instrumentor tool based on the Program Database 
      Toolkit (PDT), dynamically using DyninstAPI, at runtime in the Java 
      virtual machine, or manually using the instrumentation API.  TAU's 
      profile visualization tool, paraprof, provides graphical displays of 
      all the performance analysis results, in aggregate and single 
      node/context/thread forms.  The user can quickly identify sources of 
      performance bottlenecks in the application using the graphical 
      interface. In addition, TAU can generate event traces that can be 
      displayed with the Vampir or Paraver trace visualization tools.  
      This chapter discusses installation of the TAU portable profiling 
      package.</p><p>
      Some tau options allow external resources to be automatically downloaded 
      and built when TAU is configured. To obtain these resources in a single
      package download  http://tau.uoregon.edu/ext.tgz and unpack it in TAU's
      root directory. When you configure TAU with:
      
      </p><div class="itemizedlist"><ul type="disc"><li><p>
				<code class="literal">
				-bfd=download
				</code>
			</p></li><li><p>
				<code class="literal">
				-unwind=download
				</code>
			</p></li><li><p>
				<code class="literal">
				-ompt=download
				</code>
			</p></li></ul></div><p>
      these packages will be provided by the ext.tgz package and no additional
      network activity will be required.
      </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installing.tau"></a>1.1.&nbsp;Installing TAU</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3661"></a>1.1.1.&nbsp;Know what options you will need</h3></div></div></div><p>Each TAU configuration results in a single
			<code class="literal">Makefile</code>. These <code class="literal">Makefiles</code> denote
			the configuration that produced it and is used by the user to select
			the TAU libraries/scripts associated with its configuration. (These
			makefiles are named after the configuration options, ie. TAU configured with
			MPI, PDT, PGI compilers and the '-nocomm' option is named:
			<code class="literal">Makefile.tau-nocomm-mpi-pdt-pgi</code>). On most machines
			several configuration of TAU will need to be built in order to take full
			advantage of the many features of TAU. This section should help you
			decide on the smallest set of configuration you will need to build.</p><p>
			The options used to configure TAU can be grouped into two
			categories:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
					External packages: TAU will use these when instrumenting or measuring an
					application. <span class="emphasis"><em>Configuring with these options does
					not force the user to
					use these packages</em></span>, ie: configuring with PDT does not force the user
					to use source code based instrumentation (they can use
					compiler based instrumentation instead). Similarly configuring with
					PAPI does not forces the user to select any PAPI counters when
					profiling.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
						The only exception is configuring with the epilog (scalasca) tracing
						package. This will replace the TAU tracer with the epliog one, a single
						configuration cannot use both tracers.
						</p></td></tr></table></div><p>
					</p><p>
					For this reason it is recommend that you <span class="emphasis"><em>configure with every external
					packages that the user might be interested in using</em></span>, letting them choose
					which packages to enable when they go to instrument or measure their
					application.</p></li><li><p>
					Compiler and MPI options: these control the behavior of TAU when it compiles the
					instrumented application. TAU provides compiler wrapper scripts,
					these options control which compiler TAU will wrap, <span class="emphasis"><em>These
					options are determinative: select only options that are
				  compatible.</em></span> For example, when configuring with MPI use a
					version of MPI compatible with the compiler you select.</p><p>Since multiple compiler/MPI libraries cannot be specified for a
					single configuration, <span class="emphasis"><em>each set of compiler/MPI libraries that you want
					to use with TAU need to be configured separately.</em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
						Configurations with different compilers are given separate
						<code class="literal">Makefiles</code> automatically, however configurations with different
						MPI implementations are not. Use the <code class="literal">-tag=</code> option
						to distinguish between different MPIs, ie:
						<code class="literal">-tag=mvapich</code> or
						<code class="literal">-tag=openmpi</code>.
						</p></td></tr></table></div></li></ul></div><p>
		</p><p>The <code class="literal">configure</code> shell script attempts to guess 
    correct values for various system-dependent variables used during 
    compilation (compilers and system architecture), other options need to be
		specified on the command line.</p><p>The following are the most important command-line options are available to configure:</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3726"></a>1.1.2.&nbsp;Common configuration options</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3729"></a>1.1.2.1.&nbsp;Select compiler</h4></div></div></div><p>TAU defaults to using any compilers found in the environment. To
			use a specific compiler use these options:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-c++=&lt;C++ compiler&gt;</code></p><p>Specifies the name of the C++ compiler. Supported C++ 
        compilers include KCC (from KAI/Intel), CC (SGI, Sun), g++ 
        (from GNU), FCC (from Fujitsu), xlC (from IBM), guidec++ 
        (from KAI/Intel), cxx (Tru64) and aCC (from HP), c++ (from Apple), 
        icpc and ecpc (from Intel) and pgCC (from PGI).</p></li><li><p><code class="literal">-cc=&lt;C Compiler&gt;</code></p><p> Specifies the name of the C compiler. Supported C 
        compilers include cc, gcc (from GNU), pgcc (from PGI), 
        fcc (from Fujitsu), xlc (from IBM), and KCC (from KAI/ Intel), 
        icc and ecc (from Intel).</p></li><li><p><code class="literal">-fortran=&lt;Fortran Compiler&gt;</code></p><p>Specifies the name of the Fortran90 compiler. Valid options are: 
        gnu, sgi, ibm, ibm64, intel, cray, pgi, absoft, fujitsu, sun, kai, nec, 
        hitachi, compaq, nagware, g95 and hp.</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3753"></a>1.1.2.2.&nbsp;Using MPI</h4></div></div></div><p>To profile a program that use MPI configure TAU with these
				options:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-mpi</code></p><p>With this option, TAU will try to guess the location of the MPI
	libraries if the mpirun command is in your path. This does not always work in
	which case use these more detailed options:</p></li><li><p><code class="literal">-mpiinc=&lt;dir&gt;</code></p><p>Specifies the directory where MPI header files reside (such as 
        mpi.h and mpif.h).  This option also generates the TAU MPI wrapper 
        library that instruments MPI routines using the MPI Profiling 
        Interface. See the examples/NPB2.3/config/make.def file for its 
        usage with Fortran and MPI programs. <a href="http://www-unix.mcs.anl.gov/mpi/" target="_top">MPI</a></p></li><li><p><code class="literal">-mpilib=&lt;dir&gt;</code></p><p>Specifies the directory where MPI library files reside. This option
      should be used in conjunction with the -mpiinc=&lt;dir&gt; option to
      generate the TAU MPI wrapper library. </p></li><li><p><code class="literal">-mpilibrary=&lt;lib&gt;</code></p><p>Specifies the use of a different MPI library. By default, TAU uses
      -lmpi or -lmpich as the MPI library. This option allows the user to 
      specify another library. e.g., -mpilibrary=-lmpi_r for specifying a 
      thread-safe MPI library.</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3785"></a>1.1.2.3.&nbsp;OpenMP</h4></div></div></div><p>To profile programs using openmp use -openm and either 
			OPARI option:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-openmp</code></p><p>Specifies OpenMP as the threads package to be used.
        <a href="http://www.open-mpi.org/" target="_top">Open MPI</a></p></li><li><p><code class="literal">-opari</code></p><p>The use of Opari2 source-to-source instrumentor in conjunction 
        with TAU exposes OpenMP events for instrumentation. See 
        examples/opari directory. <a href="ihttp://www.vi-hps.org/projects/score-p/" target="_top">OPARI</a> </p></li><li><p><code class="literal">-opari1</code></p><p>Use this option for the use of the original Opari.
        Only use this option if -opari fails. <a href="http://www.fz-juelich.de/zam/kojak/opari/" target="_top">OPARI</a> </p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3817"></a>1.1.3.&nbsp;Configuring with external packages</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-pdt=&lt;directory&gt;</code></p><p>Specifies the location of the installed PDT (Program Database 
        Toolkit) root directory. PDT is used to build tau_instrumentor, 
        a C++, C and F90 instrumentation program that automatically inserts 
        TAU annotations in the source code <a href="http://www.cs.uoregon.edu/research/pdt" target="_top">PDT</a>.  If PDT is configured 
        with a subdirectory option (-compdir=&lt;opt&gt;) then TAU can be 
        configured with the same option.</p></li><li><p><code class="literal">-pdt_c++=&lt;C++ Compiler&gt;</code></p><p>Specifies a different C++ compiler for PDT (tau_instrumentor). 
        This is typically used when the library is compiled with a C++ 
        compiler (specified with -c++) and the tau_instrumentor is compiled 
        with a different &lt;pdt_c++&gt; compiler. For e.g., </p><pre class="screen">-arch=craycnl -pdt=/usr/pdtoolkit-3.17 -pdt_c++=g++ ...</pre><p>uses g++ to compile the tau_instrumentor, for example on CRAY XT5
				systems use this option to build TAU any of the backend compilers.</p><pre class="screen">-arch=bgp -pdt=/usr/pdtoolkit-3.17 -pdt_c++=xlC -mpi</pre><p>uses PDT, MPI for IBM BG/P and specifies the use of the front-end
        xlC compiler for building tau_instrumentor.</p></li><li><p><code class="literal">-papi=&lt;directory&gt;</code></p><p>Specifies the location of the installed PAPI (Performance 
        Data Standard and API) root directory. PCL provides a common 
        interface to access hardware performance counters and timers on 
        modern microprocessors. Most modern CPUs provide on-chip hardware 
        performance counters that can record several events such as the 
        number of instructions issued, floating point operations performed, 
        the number of primary and secondary data and instruction cache misses.
        To measure floating point instructions, set the environment 
        variable TAU_METRICS to PAPI_FP_INS (for example). This option (by 
        default) specifies the use of hardware performance counters for 
        profiling (instead of time).
		  
		  <a href="http://icl.cs.utk.edu/papi/" target="_top">PAPI</a>
				</p></li><li><p><code class="literal">-epilog=&lt;dir&gt;</code></p><p>Specifies the directory where the EPILOG tracing package 
      <a href="http://www.fz-juelich.de/zam/kojak/epilog/" target="_top">EPILOG</a> is installed.This option should be used in conjunction with 
      the -TRACE option to generate binary EPILOG traces (instead of 
      binary TAU traces). EPILOG traces can then be used with other tools 
      such as EXPERT. EPILOG comes with its own implementation of the 
      MPI wrapper library and the POMP library used with Opari. Using option 
      overrides TAU's libraries for MPI, and OpenMP.</p></li><li><p><code class="literal">-otf=&lt;directory&gt;</code></p><p>
	    Specifies the location of the OTF trace libraries generation package. TAU's
	    binary traces can be converted to the OTF format using tau2otf, a
	    tool that links with the OTF library. 
        </p></li><li><p><code class="literal">-vtf=&lt;directory&gt;</code></p><p>
	    Specifies the location of the VTF3 trace generation package. TAU's
	    binary traces can be converted to the VTF3 format using tau2vtf, a
	    tool that links with the VTF3 library. The VTF3 format is read by
	    Intel trace analyzer, formerly known as vampir, a commercial trace
	    visualization tool developed by TU. Dresden, Germany.
        </p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3874"></a>1.1.4.&nbsp;More configuration options</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-PROFILEPHASE</code></p><p>This option generates phase based profiles. It requires special
      instrumentation to mark phases in an application (I/O, computation,
      etc.). Phases can be static or dynamic (different phases for each loop
      iteration, for instance).  See examples/phase/README for further
      information.
      </p></li><li><p><code class="literal">-prefix=&lt;directory&gt;</code></p><p>Specifies the destination directory where the header, library and 
        binary files are copied. By default, these are copied to subdirectories 
        &lt;arch&gt;/bin and &lt;arch&gt;/lib in the TAU root directory.</p></li><li><p><code class="literal">-arch=&lt;architecture&gt;</code></p><p>Specifies the architecture. If the user does not 
        specify this option, configure determines the architecture. 
        For IBM BGL, the user should specify bgl as the architecture. 
        For SGI, the user can specify either of sgi32, sgin32 or 
        sgi64 for 32, n32 or 64 bit compilation modes respectively. 
        The files are installed in the &lt;architecture&gt;/bin and 
        &lt;architecture&gt;/lib directories. Cray options are xt3, craycnl or
				crayxmt.</p></li><li><p><code class="literal">-tag=&lt;Unique Name&gt;</code></p><p>Specifies a tag in the name of the stub Makefile and TAU makefiles to uniquely identify the installation. This is useful when more than one MPI library may be used with different versions of compilers. e.g.,</p><pre class="screen"> 
% configure -c++=icpc -cc=icc -tag=intel71-vmi   \ 
            -mpiinc=/vmi2/mpich/include
	</pre></li><li><p><code class="literal">-scalasca=&lt;dir&gt;</code></p><p>Specifies the directory where the <a href="http://www.sclasca.org" target="_top">SCALASCA</a> package 
       is installed.</p></li><li><p><code class="literal">-pthread</code></p><p>Specifies pthread as the thread package to be used. In the 
        default mode, no thread package is used.</p></li><li><p><code class="literal">-opari_region</code></p><p>Report performance data for only OpenMP regions and not 
        constructs.  By default, both regions and constructs are profiled 
        with Opari.</p></li><li><p><code class="literal">-opari_construct</code></p><p>Report performance data for only OpenMP constructs and not 
        Regions.  By default, both regions and constructs are profiled with 
        Opari.</p></li><li><p><code class="literal">-pdtarch=&lt;architecture&gt;</code></p><p>Specifies the architecture used to build pdt, default the tau architecture.</p></li><li><p><code class="literal">-papithreads</code> </p><p>Same as papi, except uses threads to
      highlight how hardware performance counters may be used in a
      multi-threaded application. When it is used with PAPI, TAU should be
      configured with -papi=&lt;dir&gt; -pthread autoinstrument Shows the use
      of Program Database Toolkit (PDT) for automating the insertion of TAU
      macros in the source code. It requires configuring TAU with the
      -pdt=&lt;dir&gt; option. The Makefile is modified to illustrate the use
      of a source to source translator (tau_instrumentor). </p></li><li><p><code class="literal">-jdk=&lt;directory&gt;</code></p><p>Specifies the location of the installed Java root directory. 
        TAU can profile or trace Java 
        applications without any modifications to the source code, byte-code 
        or the Java virtual machine. See README.JAVA on instructions on 
        using TAU with Java 2 applications. Also the refence guide has more information 
        on the new tau_java tool.  This option should only be used 
        for configuring TAU to use JVMTI for profiling and tracing of Java 
        applications. It should not be used for configuring paraprof, 
        which uses Java from the user's path.</p></li><li><p><code class="literal">-dyninst=&lt;dir&gt;</code></p><p>Specifies the directory where the DynInst dynamic 
        instrumentation package is installed. Using DynInst, a user can 
        invoke tau_run to instrument an executable program at runtime or 
        prior to execution by rewriting it. 
        <a href="http://www.dyninst.org/" target="_top">DyninstAPI</a><a href="http://www.paradyn.org/" target="_top">PARA-DYN</a>.</p></li><li><p><code class="literal">-vampirtrace=&lt;directory&gt;</code></p><p>
	    Specifies the location of the Vampir Trace package. 
      With this option TAU will generate traces in Open Trace Format (OTF). 
      For more information, see <a href="       http://www.tu-dresden.de/zih/vampirtrace" target="_top">Technische Universitat
      Dresden</a>
        </p></li><li><p><code class="literal">-scorep=&lt;directory&gt;</code></p><p>
	    Specify location of Score-P package.  Set the enviroment varible SCOREP_PROFILING_FORMAT 
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles. 
        </p></li><li><p><code class="literal">-shmeminc=&lt;dir&gt;</code></p><p>Specifies the directory where shmem.h resides and specifies the use of
      the TAU SHMEM interface.</p></li><li><p><code class="literal">-shmemlib=&lt;dir&gt;</code></p><p>Specifies the directory where libsma.a resides and specifies the use
      of the TAU SHMEM interface.</p></li><li><p><code class="literal">-shmemlibrary=&lt;lib&gt;</code></p><p>By default, TAU uses -lsma as the shmem/pshmem library. This option
      allows the user to specify a different shmem library.</p></li><li><p><code class="literal">-nocomm</code></p><p>Allows the user to turn off tracking of messages 
      (synchronous/asynchronous) in TAU's MPI wrapper interposition 
      library. Entry and exit events for MPI routines are still tracked. 
      Affects both profiling and tracing.</p></li><li><p><code class="literal">-cuda=&lt;dir&gt;</code></p><p>Specifies the location of the top level CUDA SDK</p></li><li><p><code class="literal">-gpi=&lt;dir&gt;</code></p><p>Specify use of TAU's GPI wrapper library. </p><p> It works well with PDT and compiler based instrumentation of the source code and there is  a wrapper interposition library that is linked in to track the communication of GPI.  It is important to specify all TAU runtime options in the tau.conf file that must reside in the current working directory where the executable is stored and launched from. This is important because the worker tasks are spawned by the GPI daemon on remote nodes and do not inherit the user's working directory or the environment. 
So, options such as TAU_TRACE=1, and sampling must be specified in the tau.conf file. </p><div class="figure"><a name="d0e4020"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/onesidecomm.png" align="middle"></td></tr></table></div><div class="caption">
Context events using GPI as shown in ParaProf.
</div></div></li><li><p><code class="literal">-opencl=&lt;dir&gt;</code></p><p>Specifies the location of the OpenCL package</p></li><li><p><code class="literal">-armci=&lt;dir&gt;</code></p><p>Specifies the location of the ARMCI directory</p></li><li><p><code class="literal">-epiloglib=&lt;dir&gt;</code></p><p>Specifies the directory of where the Epilog library is to be
        found. Ex: if directory structure is:
        <code class="literal">/usr/local/epilog/fe/lib/</code> let the install options be:
        <code class="literal">-epilog=/usr/local/epilog -epiloglib=/usr/local/epilog/fe/lib.</code>
      </p></li><li><p><code class="literal">-epilogbin=&lt;dir&gt;</code></p><p>Specifies the directory of where the Epilog binaries are to be
      found.
      </p></li><li><p><code class="literal">-epiloginc=&lt;dir&gt;</code></p><p>Specifies the directory of where the epilog's included sources headers are to be
      found.
      </p></li><li><p><code class="literal">-MPITRACE</code></p><p>Specifies the tracing option and generates event traces for MPI
      calls and routines that are ancestors of MPI calls in the callstack. This
      option is useful for generating traces that are converted to the EPILOG
      trace format.  KOJAK's Expert automatic diagnosis tool needs traces with
      events that call MPI routines. Do not use this option with the -TRACE
      option. </p></li><li><p><code class="literal">-pythoninc=&lt;dir&gt;</code></p><p>Specifies the location of the Python include directory. This is 
      the directory   where Python.h header file is located. This option 
      enables python bindings to be generated. The user should set the 
      environment variable PYTHONPATH to 
      &lt;TAUROOT&gt;/&lt;ARCH&gt;/lib/bindings-&lt;options&gt; to use a 
      specific version of the TAU Python bindings. By importing package pytau, 
      a user can manually instrument the source code and use the TAU API. On 
      the other hand, by importing tau and using tau.run(`&lt;func&gt;'), 
      TAU can automatically generate instrumentation. See examples/python 
      directory for further information.</p></li><li><p><code class="literal">-pythonlib=&lt;dir&gt;</code></p><p>Specifies the location of the Python lib directory. This is the 
      directory where *.py and *.pyc files (and config directory) are located. 
      This option is mandatory for IBM when Python bindings are used. For other
      systems, this option may not be specified (but -pythoninc=&lt;dir&gt; 
      needs to be specified).</p></li><li><p><code class="literal">-PROFILEMEMORY</code></p><p>
	Specifies tracking heap memory utilization for each instrumented
	function.  When any function entry takes place, a sample of the heap
	memory used is taken. This data is stored as user-defined event data in
	profiles/traces.
      </p></li><li><p><code class="literal">-PROFILECOMMUNICATORS</code></p><p>
	This option generates MPI information partitioned by communicators. TAU
   lists upto 8 ranks in each communicator in the listing. 
      </p></li><li><p><code class="literal">-PROFILEHEADROOM</code></p><p>
	Specifies tracking memory available in the heap (as opposed to memory
	utilization tracking in -PROFILEMEMORY). When any function entry takes
	place, a sample of the memory available (headroom to grow) is
	taken. This data is stored as user-defined event data in
	profiles/traces. Please refer to the examples/headroom/README file for
	a full explanation of these headroom options and the C++/C/F90 API for
	evaluating the headroom.
      </p></li><li><p><code class="literal">-COMPENSATE</code></p><p>
	Specifies online compensation of performance perturbation. When this
	option is used, TAU computes its overhead and subtracts it from the
	profiles. It can be only used when profiling is chosen. This option
	works with MULTIPLECOUNTERS as well, but while it is relevant for
	removing perturbation with wallclock time, it cannot accurately account
	for perturbation with hardware performance counts (e.g., L1 Data cache
	misses).  See TAU Publication [Europar04] for further information on
	this option.
      </p></li><li><p><code class="literal">-PROFILECOUNTERS</code></p><p>Specifies use of hardware performance counters for profiling 
      under IRIX using the SGI R10000 perfex counter access interface. The 
      use of this option is deprecated in favor of the -pcl=&lt;dir&gt; 
      and -papi=&lt;dir&gt; options described above. </p></li><li><p><code class="literal">-noex</code></p><p>Specifies that no exceptions be used while compiling the library. 
      This is relevant for C++. </p></li><li><p><code class="literal">-useropt=&lt;options-list&gt;</code></p><p>Specifies additional user options such as -g or -I. For multiple 
      options, the options list should be enclosed in a single quote. For 
      example </p><pre class="screen">
%./configure -useropt='-g -I/usr/local/stl'
      </pre></li><li><p><code class="literal">-mrnet=&lt;mrnet source root&gt;</code></p><p>Base location of the MRnet package.</p></li><li><p><code class="literal">-mrnetlib=&lt;mrnet libraries&gt;</code></p><p>Path to the MRnet libraries. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">On some cluster systems the MRnet libraries need to
			available to the runtime system (ie. on the lustre filesystem.)</td></tr></table></div></li><li><p><code class="literal">-scorep=&lt;scorep subsystem&gt;</code></p><p>Path to the Score-P measurement system. Set the enviroment varible SCOREP_PROFILING_FORMAT
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles.
      </p></li><li><p><code class="literal">-help</code></p><p>Lists all the available configure options and quits.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4156"></a>1.1.5.&nbsp;tau_setup</h3></div></div></div><p>tau_setup is a GUI interface to the configure and installtau tools.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4161"></a>1.1.6.&nbsp;installtau script</h3></div></div></div><p>To install multiple (typical) configurations of TAU at a site, you 
    may use the script `installtau'. It takes options similar to those 
    described above. It invokes ./configure &lt;opts&gt;; make clean install;  
    to create multiple libraries that may be requested by the users at a 
    site. The installtau script accepts the following options: </p><pre class="screen">
% installtau -help

TAU Configuration Utility 
***************************************************
Usage: installtau [OPTIONS]
  where [OPTIONS] are:
-arch=&lt;arch&gt;  
-fortran=&lt;compiler&gt;  
-cc=&lt;compiler&gt;   
-c++=&lt;compiler&gt;   
-useropt=&lt;options&gt;  
-pdt=&lt;pdtdir&gt;  
-pdtcompdir=&lt;compdir&gt;  
-pdt_c++=&lt;C++ Compiler&gt;  
-papi=&lt;papidir&gt;  
-vtf=&lt;vtfdir&gt;  
-otf=&lt;otfdir&gt;  
-dyninst=&lt;dyninstdir&gt; 
-mpi
-mpiinc=&lt;mpiincdir&gt;  
-mpilib=&lt;mpilibdir&gt;  
-mpilibrary=&lt;mpilibrary&gt;  
-perfinc=&lt;dir&gt; 
-perflib=&lt;dir&gt; 
-perflibrary=&lt;library&gt; 
-mpi
-tag=&lt;unique name&gt; 
-opari=&lt;oparidir&gt;  
-epilog=&lt;epilogdir&gt;  
-epiloginc=&lt;absolute path to epilog include dir&gt; (&lt;epilog&gt;/include default) 
-epilogbin=&lt;absolute path to epilog bin dir&gt; (&lt;epilog&gt;/bin default)  
-epiloglib=&lt;absolute path to epilog lib dir&gt; (&lt;epilog&gt;/lib default)  
-prefix=&lt;dir&gt;  
-exec-prefix=&lt;dir&gt; 
-j=&lt;num processes for parallel make&gt;  (just -j for full parallel) 

******************************************************************
</pre><p>These options are similar to the options used by the configure script.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4171"></a>1.1.7.&nbsp;upgradetau</h3></div></div></div><p>This script is provided to rebuild all TAU configurations
                previously built in a different TAU source directory. Give this
                command the location of a previous version of tau followed by
                any additional configurations and it will rebuild tau
                with these same options.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4176"></a>1.1.8.&nbsp;tau_validate</h3></div></div></div><p>This script will attempt to validate a tau installation. Its only
      argument is TAU's architecture directory. These are some options: 
      </p><div class="itemizedlist"><ul type="disc"><li><p>-v Verbose output</p></li><li><p>--html       Output results in HTML</p></li><li><p>--build      Only build</p></li><li><p>--run        Only run</p></li></ul></div><p>  
    </p><p> Here is a simple example: 
    </p><pre class="screen">

bash : ./tau_validate --html x86_64 &amp;&gt; results.html
tcsh : ./tau_validate --html x86_64 &gt;&amp; results.html
</pre><p>
    </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="platforms.supported"></a>1.2.&nbsp;Platforms Supported</h2></div></div></div><p>TAU has been tested on the following platforms:</p><div class="itemizedlist"><ul type="disc"><li><p>LINUX Clusters</p><p>On Linux based Intel x86 (32 and 64 bit) PC clusters, KAI/Intel's KCC, g++, egcs
        (GNU), <a href="http://www.pgroup.com" target="_top">pgCC (PGI)</a>, <a href="http://www.fujitsu.com" target="_top">FCC (Fujitsu)</a> and icpc/ecpc <a href="http://www.intel.com" target="_top">Intel</a> compilers have been
        tested. TAU also runs under IA-64, Opteron, ARM, PowerPC, Alpha, Apple
        PowerMac, Sparc and other processors running Linux. </p></li><li><p>Cray Compute Node Linux (XT5, XT6, XE6), X1, T3E, SV-1, XT3, and RedStorm</p><p>When using Cray CNL you need to configure tau with the option 
				<code class="literal">-arch=craycnl</code>On Cray T3E systems, KAI KCC and Cray CC compilers have been 
        tested with TAU. On Cray SV-1 and X1 systems, Cray CC compilers 
        have been tested with TAU. On Cray XT3, and RedStorm systems, PGI and
        GNU compilers have been tested with TAU. </p></li><li><p>IBM</p><p>On IBM BlueGene (L/P/Q) SP2 and AIX systems.  On IBM BG: IBM xlC, blrts_xlC,
        blrts_xlf90, blrts_xlc, and gnu compilers work with TAU. SP2 and AIX: vKAI KCC, KAP/Pro, IBM xlC, xlc, 
        xlf90 and g++ compilers work with TAU. On IBM pSeries
        Linux, xlC, xlc, xlf90 and gnu compilers work with TAU. </p></li><li><p>Sun Solaris</p><p>Sun compilers (CC, F90), KAI KCC, KAP/Pro and GNU g++ work with 
        TAU.</p></li><li><p>Apple OS X</p><p>On Apple OS X machines, c++ or g++ may be used to compile TAU. 
        Also, IBM's xlf90, xlf and Absoft Fortran 90 compilers for G4/G5 may 
        be used with TAU.</p></li><li><p>SGI</p><p>On IRIX 6.x based systems, including Indy, Power Challenge, Onyx,
        Onyx2 and Origin 200, 2000, 3000 Series, CC 7.2+, <a href="http://www.kai.com" target="_top">KAI</a> KCC and <a href="http://www.gnu.org" target="_top">g++</a> compilers are supported. On SGI
        Altix systems, Intel, and GNU compilers are supported.</p></li><li><p>Accelerators</p><p>TAU performance data can be retrived from ATI, Nvidia or Intel GPUs
				(through OpenCL, or CUDA). Intel Many Intergrated Cores (MIC) is
				supported in native execution.</p></li><li><p>Intel</p></li><li><p>HP HP-UX</p><p>On HP PA-RISC systems, aCC and g++ can be used.</p></li><li><p>HP Alpha Tru64</p><p>On HP Alpha Tru64 machines, cxx and g++, and Guide compilers 
        may be used with TAU.</p></li><li><p>NEC SX series vector machines</p><p>On NEC SX-5 systems, NEC c++ may be used with TAU.</p></li><li><p>On Hitachi machines, Hitachi KCC, g++ and Hitachi cc compilers 
        may be used with TAU</p></li><li><p>Fujitsu PRIMEPOWER</p><p>On Fujitsu Power machines, Sun and Fujitsu compilers may be used
        with TAU. </p></li><li><p>Microsoft Window</p><p>On Windows, Microsoft Visual C++ 6.0 or higher and JDK 1.2+ 
        compilers have been tested with TAU</p></li></ul></div><p>NOTE: TAU has been tested with JDK 1.2, 1.3, 1.4.x under Solaris, SGI, IBM, 
    Linux, and MacOS X.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="software.requirements"></a>1.3.&nbsp;Software Requirements</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>1. Java v 1.5</p><p>TAU's GUI ParaProf and PerfExplorer require Java v1.4 or better 
        in your path. If Java 1.4 is the only version avaible, older version of 
        ParaProf and PerfExplorer can be installed.  To do so, simple run either program 
        with Java 1.4 in your path.  You will guided through the installation process.
        ParaProf does not 
        require -jdk=&lt;dir&gt; option to be specified during configuration. (This option 
        is used for configuring TAU for analyzing Java applications.)</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="instrumentationOptions"></a>Chapter&nbsp;2.&nbsp;TAU Instrumentation Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e4304">2.1. Selective Instrumentation Options</a></span></dt><dt><span class="sect1"><a href="#RunningDynInstAIP">2.2. Running an application using DynInstAPI</a></span></dt><dt><span class="sect1"><a href="#RewritingMaqao">2.3. Rewriting Binaries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Maqao">2.3.1. Using MAQAO</a></span></dt><dt><span class="sect2"><a href="#d0e4463">2.3.2. Using PEBIL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingParam">2.4. Profiling each call to a function</a></span></dt><dt><span class="sect1"><a href="#d0e4485">2.5. Profiling with Hardware counters</a></span></dt><dt><span class="sect1"><a href="#HardwarePerformanceCounters">2.6. Using Hardware Performance Counters</a></span></dt><dt><span class="sect1"><a href="#PerfLib">2.7. Profiling with PerfLib</a></span></dt><dt><span class="sect1"><a href="#RunningPython">2.8. Running a Python application with TAU</a></span></dt><dt><span class="sect1"><a href="#pprof">2.9. pprof</a></span></dt><dt><span class="sect1"><a href="#RunningJAVA">2.10. Running a JAVA application with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingTauConf">2.11. Using a tau.conf File</a></span></dt><dt><span class="sect1"><a href="#UsingScoreP">2.12. Using Score-P with TAU</a></span></dt><dt><span class="sect1"><a href="#UsingUPC">2.13. Using UPC  with TAU</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4304"></a>2.1.&nbsp;Selective Instrumentation Options</h2></div></div></div><div class="variablelist"><a name="SelectiveProfilingOverview"></a><p><b>Selective Instrumentation File Specification.&nbsp;</b>The selective instrumentation file has the following sections,
			  each preceded and followed by:</p><dl><dt><span class="term"><code class="literal">BEGIN_EXCLUDE_LIST</code> / 
        <code class="literal">END_EXCLUDE_LIST</code> or <code class="literal">BEGIN_INCLUDE_LIST</code> / 
        <code class="literal">END_INCLUDE_LIST</code> </span></dt><dd><p>
            exclude/include list of routines and/or files for instrumentation. The
            list of routines to be excluded from instrumentation is specified, one
            per line, enclosed by <code class="literal">BEGIN_EXCLUDE_LIST</code> and
            <code class="literal">END_EXCLUDE_LIST</code>. Instead of specifying which
            routines should be excluded, the user can specify the list of routines
            that are to be instrumented using the include list, one routine name per
            line, enclosed by <code class="literal">BEGIN_INCLUDE_LIST</code> and
            <code class="literal">END_INCLUDE_LIST</code>.
          </p></dd><dt><span class="term"><code class="literal">BEGIN_FILE_EXCLUDE_LIST</code> / 
        <code class="literal">END_FILE_EXCLUDE_LIST</code> or <code class="literal">BEGIN_FILE_INCLUDE_LIST</code> / 
        <code class="literal">END_FILE_INCLUDE_LIST</code> </span></dt><dd><p>
            Similarly, files can be included or
            excluded with the <code class="literal">BEGIN_FILE_EXCLUDE_LIST, END_FILE_EXCLUDE_LIST,
            BEGIN_FILE_INCLUDE_LIST, and END_FILE_INCLUDE_LIST </code> lines. 
		      </p></dd><dt><span class="term"><code class="literal">BEGIN_INSTRUMENT_SECTION</code> /
			  <code class="literal">END_INSTRUMENT_SECTION</code></span></dt><dd><p>Manually editing the selective instrumentation file gives you more
            options. These tags allow you to control the type of instrumentation
            performed in certain portions of your application.
          </p></dd></dl></div><div class="itemizedlist"><ul type="disc"><li><p>Static and Dynamic timers can be set by specifying either
              a range of line numbers or a routine.</p><pre class="screen">
static timer name="foo_bar" file="foo.c" line=17 to line=18
dynamic timer routine="int foo1(int)
              </pre></li><li><p>
                Static and Dynamic phases can be set by specifying either a
                range of line numbers or a routine. If you do not configure TAU
                with <code class="literal">-PROFILEPHASE</code> these phases will be
                converted to regular timers.
              </p><pre class="screen">
static phase routine="int foo(int)
dynamic phase name="foo1_bar" file="foo.c" line=26 to line=27
              </pre></li><li><p>
                Loops in the source code can be profiled by
                specifying a routine in which all loop should be profiled, like:
              </p><pre class="screen">
loops file="loop_test.cpp" routine="multiply"
              </pre></li><li><p>
                With <a href="#memoryOptions" title="4.1.&nbsp;TAU's memory API options">Memory Profiling</a> the following events are tracked: memory
                allocation, memory deallocation, and memory leaks.
              </p><pre class="screen">
memory file="foo.f90" routine="INIT"
              </pre></li><li><p>
                IO Events track the
                size, in bytes of read, write, and print statements.
              </p><pre class="screen">
io file="foo.f90" routine="RINB"
              </pre></li></ul></div><p>
            Both Memory and IO
            events are represented along with their call-stack; the length of which can
            be set with environment variable
            <code class="literal">TAU_CALLPATH_DEPTH</code>.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              Due to the limitations of the some compilers (IBM xlf, PGI pgf90, GNU
              gfortran),  the size of the memory reported for a Fortran Array is 
              not the number of bytes but rather the number of elements. 
            </p></td></tr></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningDynInstAIP"></a>2.2.&nbsp;Running an application using DynInstAPI</h2></div></div></div><p>TAU also allows you to dynamically instrument your application using
		the DynInst package. There are a few limitation to DyInst: 1) only function
		level events will be captured and 2) your application must be compiled with
		debugging symbols (<code class="literal">-g</code>).</p><p>To install the DynInstAPI package, configure TAU with -dyinst= option
		which will point TAU to where dyninst is installed. Use the
		<code class="literal">tau_run</code> tool to instrument your application at runtime.</p><p>The command-line options accepted by tau_run are:</p><pre class="screen">
Usage: tau_run [-Xrun&lt;Taulibrary&gt; ][-v][-o outfile] \
       [-f &lt;instrumentation file&gt; ] &lt;application&gt; [args]
</pre><p>By default, <code class="literal">libTAU</code>. so is loaded by
    tau_run. However, the user can override this and specify another file
    using the -Xrun&lt;Taulibrary&gt;. In this case lib&lt;Taulibrary&gt;.so
    will be loaded using <code class="literal">LD_LIBRARY_PATH</code>. </p><p>To use <code class="literal">tau_run</code>, TAU is configured with
    DyninstAPI as shown below:</p><pre class="screen">
% configure -dyninst=/usr/local/packages/dyninstAPI
% make install
% cd tau/examples/dyninst
% make install
% tau_run klargest 2500 23
% pprof; paraprof
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RewritingMaqao"></a>2.3.&nbsp;Rewriting Binaries</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="Maqao"></a>2.3.1.&nbsp;Using MAQAO</h3></div></div></div><p>TAU also allows you to rewrite  your application using
		the MAQAO package included in PDToolkit 3.17 or above(http://tau.uoregon.edu/pdt.tgz). 
</p><p>Install PDToolkit 3.17+ and configure TAU with -pdt= option
		which will point TAU to where PDToolkit is installed. Use the
		<code class="literal">tau_rewrite</code> tool to instrument your application.
		(If TAU is not configured with PDT 3.17+, then <code class="literal">tau_rewrite</code> 
		defaults to tau_run.) 
</p><pre class="screen">
% configure -pdt=/usr/local/packages/pdtoolkit-3.17
% make install
% tau_rewrite -T scorep,pdt &nbsp;-loadlib=/tmp/libfoo.so ./a.out -o a.inst 
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4463"></a>2.3.2.&nbsp;Using PEBIL</h3></div></div></div><p>TAU also allows you to rewrite  your application using
		the PEBIL package included in PDToolkit 3.18.1 or above(http://tau.uoregon.edu/pdt.tgz). 
</p><p>Install PDToolkit 3.18.1 and configure TAU with -pdt= option
		which will point TAU to where PDToolkit is installed. Use the
		<code class="literal">tau_pebil_rewrite</code> tool to instrument your application.
     </p><pre class="screen">
% tau_pebil_rewrite -T &lt;commands&gt; -f select.tau &lt;exe&gt; [-o] &lt;output_exe&gt; 
</pre><p>
The select.tau file  supports outer-loop level instrumentation and exclude/include lists of functions just like tau_instrumentor's select.tau (same format). 
Also,	-T &lt;options&gt; are identical to tau_exec -T options.  
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ProfilingParam"></a>2.4.&nbsp;Profiling each call to a function</h2></div></div></div><p>
      By default TAU profiles the total time (inclusive/exclusive) spent on a
      given function. Profiling each function call  
      for an application that calls some function hundred of thousands of
      times, is impractical since the profile data would grow enormously. But
      configuring TAU with the <code class="literal">-PROFILEPARAM</code> option will have
      TAU profile select functions
      each time they are called. But TAU will also 
      group some of these function calls together according to the value of
      the parameter they are given. For example if a function mpisend(int i) is called 2000
      times 1000 times with 512 and 1000 times with 1024 then we will receive two
      profile for mpisend() one we it is called with 512 and one when it is called with
      1024. This reduces the overhead since we are profiling mpisend() two times not 2000
      times.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4485"></a>2.5.&nbsp;Profiling with Hardware counters</h2></div></div></div><p>LIST OF COUNTERS:</p><p>Set the TAU_METRICS environment variable with a comma separated list of metrics or to use the old method set the following values for the COUNTER&lt;1-25&gt; environment variables.</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">GET_TIME_OF_DAY</code>    - For the default profiling option using gettimeofday()</p></li><li><p><code class="literal">SGI_TIMERS</code>         - For <code class="literal">-SGITIMERS</code> configuration option under IRIX</p></li><li><p><code class="literal">CRAY_TIMERS</code>   - For <code class="literal">-CRAYTIMERS</code> configuration option under Cray X1.</p></li><li><p><code class="literal">LINUX_TIMERS</code>       - For -LINUXTIMERS configuration option under Linux</p></li><li><p><code class="literal">CPU_TIME</code>           - For user+system time from getrusage() call with <code class="literal">-CPUTIME</code></p></li><li><p><code class="literal">P_WALL_CLOCK_TIME</code> - For PAPI's WALLCLOCK time using <code class="literal">-PAPIWALLCLOCK</code></p></li><li><p><code class="literal">P_VIRTUAL_TIME</code>     - For PAPI's process virtual time using <code class="literal">-PAPIVIRTUAL</code></p></li><li><p><a name="MUSE"></a><code class="literal">TAU_MUSE</code> - For reading counts of
      Linux OS kernel level events when MAGNET/MUSE is installed and -muse
      configuration option is enabled.
      <a href="http://public.lanl.gov/radiant/" target="_top">MUSE</a>.<code class="literal">TAU_MUSE_PACKAGE</code> environment variable has
      to be set to package name (busy_time, count, etc.)</p></li><li><p><code class="literal">TAU_MPI_MESSAGE_SIZE</code> - For tracking
      the cumulative message size for all MPI operations by a node for each
      routine. </p></li><li><p><code class="literal">ENERGY</code> - For tracking
      the power use of the application in joules. Requires an -arch=craycnl configuration. </p></li><li><p><code class="literal">ACCEL_ENERGY</code> - For tracking
      the power use of the application on accelerators in joules. Requires an -arch=craycnl configuration. </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When TAU is configured with -TRACE -MULTIPLECOUNTERS and 
      -papi=&lt;dir&gt; options, the COUNTER1 environment variable must be 
      set to GET_TIME_OF_DAY to allow TAU's tracing module to use a globally
      synchronized real-time clock for time-stamping event records. When we use
      tracing with hardware performance counters, the counters specified in 
      environment variables COUNTER[2-25] are accessed at routine transitions
      and logged in the trace file. Use tau2vtf tool to convert TAU traces to 
      VTF3 traces that may be loaded in the Vampir trace visualization tool. 
      </p></td></tr></table></div><p>and PAPI/PCL options that can be found in <a href="#PAPI_TABLE" title="Table&nbsp;2.1.&nbsp;Events measured by setting the environment variable TAU_METRICS in TAU">Table&nbsp;2.1, &#8220;Events measured by setting the environment variable TAU_METRICS in TAU&#8221;</a> and <a href="#PCL_TABLE" title="Table&nbsp;2.2.&nbsp;Events measured by setting the environment variable PCL_EVENT in TAU">Table&nbsp;2.2, &#8220;Events measured by setting the environment variable PCL_EVENT in TAU&#8221;</a>. Example:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">PCL_FP_INSTR</code>       - For floating point operations using PCL (-pcl=&lt;dir&gt;)</p></li><li><p><code class="literal">PAPI_FP_INS</code>        - For floating point operations using PAPI (-papi=&lt;dir&gt;)</p></li><li><p><code class="literal">PAPI_NATIVE_&lt;event&gt;</code>        - For native papi events using PAPI (-papi=&lt;dir&gt;)</p></li></ul></div><p><span class="emphasis"><em>NOTE:</em></span> When
    <code class="literal">-MULTIPLECOUNTERS</code> is used with
    <code class="literal">-TRACE</code> option, the tracing library uses the wall-clock
    time from the function specified in the <code class="literal">COUNTER1</code>
    variable. This should typically point to wall-clock time routines (such
    as <code class="literal">GET_TIME_OF_DAY or SGI_TIMERS</code> or
    <code class="literal">LINUX_TIMERS</code>).</p><p>Example:</p><pre class="screen">
% setenv COUNTER1   P_WALL_CLOCK_TIME
% setenv COUNTER2 PAPI_L1_DCM
% setenv COUNTER3 PAPI_FP_INS
</pre><p>will produce profile files in directories called <code class="literal">MULT_P_WALL_CLOCK_TIME, MULTI__PAPI_L1_DCM, and MULTI_PAPI_FP_INS.</code></p><div class="table"><a name="PAPI_TABLE"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Events measured by setting the environment variable TAU_METRICS in TAU</b></p><table summary="Events measured by setting the environment variable TAU_METRICS in TAU" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">TAU_METRICS</th><th align="left">EVENT Measured</th></tr></thead><tbody><tr><td align="left">PAPI_L1_DCM</td><td align="left">Level 1 data cache misses</td></tr><tr><td align="left">PAPI_L1_ICM</td><td align="left">Level 1 instruction cache misses</td></tr><tr><td align="left">PAPI_L2_DCM</td><td align="left">Level 2 data cache misses</td></tr><tr><td align="left">PAPI_L2_ICM</td><td align="left">Level 2 instruction cache misses</td></tr><tr><td align="left">PAPI_L3_DCM</td><td align="left">Level 3 data cache misses</td></tr><tr><td align="left">PAPI_L3_ICM</td><td align="left">Level 3 instruction cache misses</td></tr><tr><td align="left">PAPI_L1_TCM</td><td align="left">Level 1 total cache misses</td></tr><tr><td align="left">PAPI_L2_TCM</td><td align="left">Level 2 total cache misses</td></tr><tr><td align="left">PAPI_L3_TCM</td><td align="left">Level 3 total cache misses</td></tr><tr><td align="left">PAPI_CA_SNP</td><td align="left">Snoops</td></tr><tr><td align="left">PAPI_CA_SHR</td><td align="left">Request for access to shared cache line (SMP)</td></tr><tr><td align="left">PAPI_CA_CLN</td><td align="left">Request for access to clean cache line (SMP)</td></tr><tr><td align="left">PAPI_CA_INV</td><td align="left">Cache Line Invalidation (SMP)</td></tr><tr><td align="left">PAPI_CA_ITV</td><td align="left">Cache Line Intervention (SMP)</td></tr><tr><td align="left">PAPI_L3_LDM</td><td align="left">Level 3 load misses</td></tr><tr><td align="left">PAPI_L3_STM</td><td align="left">Level 3 store misses</td></tr><tr><td align="left">PAPI_BRU_IDL</td><td align="left">Cycles branch units are idle</td></tr><tr><td align="left">PAPI_FXU_IDL</td><td align="left">Cycles integer units are idle</td></tr><tr><td align="left">PAPI_FPU_IDL</td><td align="left">Cycles floating point units are idle</td></tr><tr><td align="left">PAPI_LSU_IDL</td><td align="left">Cycles load/store units are idle</td></tr><tr><td align="left">PAPI_TLB_DM</td><td align="left">Data translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_TLB_IM</td><td align="left">Instruction translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_TLB_TL</td><td align="left"> Total translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_L1_LDM</td><td align="left">Level 1 load misses</td></tr><tr><td align="left">PAPI_L1_STM</td><td align="left">Level 1 store misses</td></tr><tr><td align="left">PAPI_L2_LDM</td><td align="left">Level 2 load misses</td></tr><tr><td align="left">PAPI_L2_STM</td><td align="left">Level 2 store misses</td></tr><tr><td align="left">PAPI_BTAC_M</td><td align="left">BTAC miss</td></tr><tr><td align="left">PAPI_PRF_DM</td><td align="left">Prefetch data instruction caused a miss</td></tr><tr><td align="left">PAPI_L3_DCH</td><td align="left">Level 3 Data Cache Hit</td></tr><tr><td align="left">PAPI_TLB_SD</td><td align="left">Translation lookaside buffer shootdowns (SMP)</td></tr><tr><td align="left">PAPI_CSR_FAL</td><td align="left">Failed store conditional instructions</td></tr><tr><td align="left">PAPI_CSR_SUC</td><td align="left">Successful store conditional instructions</td></tr><tr><td align="left">PAPI_CSR_TOT</td><td align="left">Total store conditional instructions</td></tr><tr><td align="left">PAPI_MEM_SCY</td><td align="left">Cycles Stalled Waiting for Memory Access</td></tr><tr><td align="left">PAPI_MEM_RCY</td><td align="left">Cycles Stalled Waiting for Memory Read</td></tr><tr><td align="left">PAPI_MEM_WCY</td><td align="left">Cycles Stalled Waiting for Memory Write</td></tr><tr><td align="left">PAPI_STL_ICY</td><td align="left">Cycles with No Instruction Issue</td></tr><tr><td align="left">PAPI_FUL_ICY</td><td align="left">Cycles with Maximum Instruction Issue</td></tr><tr><td align="left">PAPI_STL_CCY</td><td align="left">Cycles with No Instruction Completion</td></tr><tr><td align="left">PAPI_FUL_CCY</td><td align="left">Cycles with Maximum Instruction Completion</td></tr><tr><td align="left">PAPI_HW_INT</td><td align="left">Hardware interrupts</td></tr><tr><td align="left">PAPI_BR_UCN</td><td align="left">Unconditional branch instructions executed</td></tr><tr><td align="left">PAPI_BR_CN</td><td align="left">Conditional branch instructions executed</td></tr><tr><td align="left">PAPI_BR_TKN</td><td align="left">Conditional branch instructions taken</td></tr><tr><td align="left">PAPI_BR_NTK</td><td align="left">Conditional branch instructions not taken</td></tr><tr><td align="left">PAPI_BR_MSP</td><td align="left">Conditional branch instructions mispredicted</td></tr><tr><td align="left">PAPI_BR_PRC</td><td align="left">Conditional branch instructions correctly predicted</td></tr><tr><td align="left">PAPI_FMA_INS</td><td align="left">FMA instructions completed</td></tr><tr><td align="left">PAPI_TOT_IIS</td><td align="left">Total instructions issued</td></tr><tr><td align="left">PAPI_TOT_INS</td><td align="left">Total instructions executed</td></tr><tr><td align="left">PAPI_INT_INS</td><td align="left">Integer instructions executed</td></tr><tr><td align="left">PAPI_FP_INS</td><td align="left">Floating point instructions executed</td></tr><tr><td align="left">PAPI_LD_INS</td><td align="left">Load instructions executed</td></tr><tr><td align="left">PAPI_SR_INS</td><td align="left">Store instructions executed</td></tr><tr><td align="left">PAPI_BR_INS</td><td align="left">Total branch instructions executed</td></tr><tr><td align="left">PAPI_VEC_INS</td><td align="left">Vector/SIMD instructions executed</td></tr><tr><td align="left">PAPI_FLOPS</td><td align="left">Floating Point Instructions executed per second</td></tr><tr><td align="left">PAPI_RES_STL</td><td align="left">Cycles processor is stalled on resource</td></tr><tr><td align="left">PAPI_FP_STAL</td><td align="left">FP units are stalled</td></tr><tr><td align="left">PAPI_TOT_CYC</td><td align="left">Total cycles</td></tr><tr><td align="left">PAPI_IPS</td><td align="left">Instructions executed per second</td></tr><tr><td align="left">PAPI_LST_INS</td><td align="left">Total load/store instructions executed</td></tr><tr><td align="left">PAPI_SYC_INS</td><td align="left">Synchronization instructions executed</td></tr><tr><td align="left">PAPI_L1_DCH</td><td align="left">L1 D Cache Hit</td></tr><tr><td align="left">PAPI_L2_DCH</td><td align="left">L2 D Cache Hit</td></tr><tr><td align="left">PAPI_L1_DCA</td><td align="left">L1 D Cache Access</td></tr><tr><td align="left">PAPI_L2_DCA</td><td align="left">L2 D Cache Access</td></tr><tr><td align="left">PAPI_L3_DCA</td><td align="left">L3 D Cache Access</td></tr><tr><td align="left">PAPI_L1_DCR</td><td align="left">L1 D Cache Read</td></tr><tr><td align="left">PAPI_L2_DCR</td><td align="left">L2 D Cache Read</td></tr><tr><td align="left">PAPI_L3_DCR</td><td align="left">L3 D Cache Read</td></tr><tr><td align="left">PAPI_L1_DCW</td><td align="left">L1 D Cache Write</td></tr><tr><td align="left">PAPI_L2_DCW</td><td align="left">L2 D Cache Write</td></tr><tr><td align="left">PAPI_L3_DCW</td><td align="left">L3 D Cache Write</td></tr><tr><td align="left">PAPI_L1_ICH</td><td align="left">L1 instruction cache hits</td></tr><tr><td align="left">PAPI_L2_ICH</td><td align="left">L2 instruction cache hits</td></tr><tr><td align="left">PAPI_L3_ICH</td><td align="left">L3 instruction cache hits</td></tr><tr><td align="left">PAPI_L1_ICA</td><td align="left">L1 instruction cache accesses</td></tr><tr><td align="left">PAPI_L2_ICA</td><td align="left">L2 instruction cache accesses</td></tr><tr><td align="left">PAPI_L3_ICA</td><td align="left">L3 instruction cache accesses</td></tr><tr><td align="left">PAPI_L1_ICR</td><td align="left">L1 instruction cache reads</td></tr><tr><td align="left">PAPI_L2_ICR</td><td align="left">L2 instruction cache reads</td></tr><tr><td align="left">PAPI_L3_ICR</td><td align="left">L3 instruction cache reads</td></tr><tr><td align="left">PAPI_L1_ICW</td><td align="left">L1 instruction cache writes</td></tr><tr><td align="left">PAPI_L2_ICW</td><td align="left">L2 instruction cache writes</td></tr><tr><td align="left">PAPI_L3_ICW</td><td align="left">L3 instruction cache writes</td></tr><tr><td align="left">PAPI_L1_TCH</td><td align="left">L1 total cache hits</td></tr><tr><td align="left">PAPI_L2_TCH</td><td align="left">L2 total cache hits</td></tr><tr><td align="left">PAPI_L3_TCH</td><td align="left">L3 total cache hits</td></tr><tr><td align="left">PAPI_L1_TCA</td><td align="left">L1 total cache accesses</td></tr><tr><td align="left">PAPI_L2_TCA</td><td align="left">L2 total cache accesses</td></tr><tr><td align="left">PAPI_L3_TCA</td><td align="left">L3 total cache accesses</td></tr><tr><td align="left">PAPI_L1_TCR</td><td align="left">L1 total cache reads</td></tr><tr><td align="left">PAPI_L2_TCR</td><td align="left">L2 total cache reads</td></tr><tr><td align="left">PAPI_L3_TCR</td><td align="left">L3 total cache reads</td></tr><tr><td align="left">PAPI_L1_TCW</td><td align="left">L1 total cache writes</td></tr><tr><td align="left">PAPI_L2_TCW</td><td align="left">L2 total cache writes</td></tr><tr><td align="left">PAPI_L3_TCW</td><td align="left">L3 total cache writes</td></tr><tr><td align="left">PAPI_FML_INS</td><td align="left">FM ins</td></tr><tr><td align="left">PAPI_FAD_INS</td><td align="left">FA ins</td></tr><tr><td align="left">PAPI_FDV_INS</td><td align="left">FD ins</td></tr><tr><td align="left">PAPI_FSQ_INS</td><td align="left">FSq ins</td></tr><tr><td align="left">PAPI_FNV_INS</td><td align="left">Finv ins</td></tr></tbody></table></div><p>
 For example to measure the floating point operations in routines using
 <code class="literal">PCL</code>,</p><pre class="screen">
% ./configure -pcl=/usr/local/packages/pcl-1.2
% setenv PCL_EVENT PCL_FP_INSTR 
% mpirun -np 8 application
</pre><div class="table"><a name="PCL_TABLE"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Events measured by setting the environment variable PCL_EVENT in TAU</b></p><table summary="Events measured by setting the environment variable PCL_EVENT in TAU" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">PCL_EVENT</th><th align="left">EVENT Measured</th></tr></thead><tbody><tr><td align="left">PCL_L1CACHE_READ</td><td align="left">L1 (Level one) cache reads</td></tr><tr><td align="left">PCL_L1CACHE_WRITE</td><td align="left">L1 cache writes</td></tr><tr><td align="left">PCL_L1CACHE_READWRITE</td><td align="left">L1 cache reads and writes</td></tr><tr><td align="left">PCL_L1CACHE_HIT</td><td align="left">L1 cache hits</td></tr><tr><td align="left">PCL_L1CACHE_MISS</td><td align="left">L1 cache misses</td></tr><tr><td align="left">PCL_L1DCACHE_READ</td><td align="left">L1 data cache reads</td></tr><tr><td align="left">PCL_L1DCACHE_WRITE</td><td align="left">L1 data cache writes</td></tr><tr><td align="left">PCL_L1DCACHE_READWRITE</td><td align="left">L1 data cache reads and writes</td></tr><tr><td align="left">PCL_L1DCACHE_HIT</td><td align="left">L1 data cache hits</td></tr><tr><td align="left">PCL_L1DCACHE_MISS</td><td align="left">L1 data cache misses</td></tr><tr><td align="left">PCL_L1ICACHE_READ</td><td align="left">L1 instruction cache reads</td></tr><tr><td align="left">PCL_L1ICACHE_WRITE</td><td align="left">L1 instruction cache writes</td></tr><tr><td align="left">PCL_L1ICACHE_READWRITE</td><td align="left">L1 instruction cache reads and writes</td></tr><tr><td align="left">PCL_L1ICACHE_HIT</td><td align="left">L1 instruction cache hits</td></tr><tr><td align="left">PCL_L1ICACHE_MISS</td><td align="left">L1 instruction cache misses</td></tr><tr><td align="left">PCL_L2CACHE_READ</td><td align="left">L2 (Level two) cache reads</td></tr><tr><td align="left">PCL_L2CACHE_WRITE</td><td align="left">L2 cache writes</td></tr><tr><td align="left">PCL_L2CACHE_READWRITE</td><td align="left">L2 cache reads and writes</td></tr><tr><td align="left">PCL_L2CACHE_HIT</td><td align="left">L2 cache hits</td></tr><tr><td align="left">PCL_L2CACHE_MISS</td><td align="left">L2 cache misses</td></tr><tr><td align="left">PCL_L2DCACHE_READ</td><td align="left">L2 data cache reads</td></tr><tr><td align="left">PCL_L2DCACHE_WRITE</td><td align="left">L2 data cache writes</td></tr><tr><td align="left">PCL_L2DCACHE_READWRITE</td><td align="left">L2 data cache reads and writes</td></tr><tr><td align="left">PCL_L2DCACHE_HIT</td><td align="left">L2 data cache hits</td></tr><tr><td align="left">PCL_L2DCACHE_MISS</td><td align="left">L2 data cache misses</td></tr><tr><td align="left">PCL_L2ICACHE_READ</td><td align="left">L2 instruction cache reads</td></tr><tr><td align="left">PCL_L2ICACHE_WRITE</td><td align="left">L2 instruction cache writes</td></tr><tr><td align="left">PCL_L2ICACHE_READWRITE</td><td align="left">L2 instruction cache reads and writes</td></tr><tr><td align="left">PCL_L2ICACHE_HIT</td><td align="left">L2 instruction cache hits</td></tr><tr><td align="left">PCL_L2ICACHE_MISS</td><td align="left">L2 instruction cache misses</td></tr><tr><td align="left">PCL_TLB_HIT</td><td align="left">TLB (Translation Lookaside Buffer) hits</td></tr><tr><td align="left">PCL_TLB_MISS</td><td align="left">TLB misses</td></tr><tr><td align="left">PCL_ITLB_HIT</td><td align="left">Instruction TLB hits</td></tr><tr><td align="left">PCL_ITLB_MISS</td><td align="left">Instruction TLB misses</td></tr><tr><td align="left">PCL_DTLB_HIT</td><td align="left">Data TLB hits</td></tr><tr><td align="left">PCL_DTLB_MISS</td><td align="left">Data TLB misses</td></tr><tr><td align="left">PCL_CYCLES</td><td align="left">Cycles</td></tr><tr><td align="left">PCL_ELAPSED_CYCLES</td><td align="left">Cycles elapsed</td></tr><tr><td align="left">PCL_INTEGER_INSTR</td><td align="left">Integer instructions executed</td></tr><tr><td align="left">PCL_FP_INSTR</td><td align="left">Floating point (FP) instructions executed</td></tr><tr><td align="left">PCL_LOAD_INSTR</td><td align="left">Load instructions executed</td></tr><tr><td align="left">PCL_STORE_INSTR</td><td align="left">Store instructions executed</td></tr><tr><td align="left">PCL_LOADSTORE_INSTR</td><td align="left">Loads and stores executed</td></tr><tr><td align="left">PCL_INSTR</td><td align="left">Instructions executed</td></tr><tr><td align="left">PCL_JUMP_SUCCESS</td><td align="left">Successful jumps executed</td></tr><tr><td align="left">PCL_JUMP_UNSUCCESS</td><td align="left">Unsuccessful jumps executed</td></tr><tr><td align="left">PCL_JUMP</td><td align="left">Jumps executed</td></tr><tr><td align="left">PCL_ATOMIC_SUCCESS</td><td align="left">Successful atomic instructions executed</td></tr><tr><td align="left">PCL_ATOMIC_UNSUCCESS</td><td align="left">Unsuccessful atomic instructions executed</td></tr><tr><td align="left">PCL_ATOMIC</td><td align="left">Atomic instructions executed</td></tr><tr><td align="left">PCL_STALL_INTEGER</td><td align="left">Integer stalls</td></tr><tr><td align="left">PCL_STALL_FP</td><td align="left">Floating point stalls</td></tr><tr><td align="left">PCL_STALL_JUMP</td><td align="left">Jump stalls</td></tr><tr><td align="left">PCL_STALL_LOAD</td><td align="left">Load stalls</td></tr><tr><td align="left">PCL_STALL_STORE</td><td align="left">Store Stalls</td></tr><tr><td align="left">PCL_STALL</td><td align="left">Stalls</td></tr><tr><td align="left">PCL_MFLOPS</td><td align="left">Millions of floating point operations/second</td></tr><tr><td align="left">PCL_IPC</td><td align="left">Instructions executed per cycle</td></tr><tr><td align="left">PCL_L1DCACHE_MISSRATE</td><td align="left">Level 1 data cache miss rate</td></tr><tr><td align="left">PCL_L2DCACHE_MISSRATE</td><td align="left">Level 2 data cache miss rate</td></tr><tr><td align="left">PCL_MEM_FP_RATIO</td><td align="left">Ratio of memory accesses to FP operations</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="HardwarePerformanceCounters"></a>2.6.&nbsp;Using Hardware Performance Counters</h2></div></div></div><p> While running the application, set the environment variable
    <code class="literal">PCL_EVENT</code> or <code class="literal">TAU_METRICS</code>
    , to specify which hardware performance counter TAU should
    use while profiling the application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p> By default, only one counter is tracked at a time.  To track
    more than one counter use <code class="literal">-MULTIPLECOUNTERS</code>.  See <a href="#MultipleHardwareCounters" title="2.4.&nbsp;Using Hardware Counters for Measurement">Section&nbsp;2.4, &#8220;Using Hardware Counters for Measurement&#8221;</a> for more details.  </p></td></tr></table></div><p>To select floating point instructions for profiling using
    <code class="literal">PAPI</code>, you would:</p><pre class="screen">
% configure -papi=/usr/local/packages/papi-3.5.0
% make clean install
% cd examples/papi
% setenv TAU_METRICS PAPI_FP_INS
% a.out
    </pre><p>
      In addition to the following events, you can use native events (see
      <span><strong class="command">papi_native</strong></span>) on a given CPU by setting
      <code class="literal">TAU_</code> to
      <code class="literal">PAPI_NATIVE_&lt;event&gt;</code>.  For example:
      </p><pre class="screen">
% setenv PAPI_NATIVE PAPI_NATIVE_PM_BIQ_IDU_FULL_CYC
% a.out
      </pre><p>

    </p><p>By default <code class="literal">PAPI</code> will profile events in all domains
    (users space, kernel, hypervisor, etc). You can restrict the set of domains
    for papi event profiling by using the
    <code class="literal">TAU_PAPI_DOMAIN</code> environment variable with these values (in
    a colon separated list, if desired): <code class="literal">PAPI_DOM_USER,
    PAPI_DOM_KERNEL, PAPI_DOM_SUPERVISOR,</code> and
    <code class="literal">PAPI_DOM_OTHER</code> like thus:
    </p><pre class="screen">
% setenv TAU_PAPI_DOMAIN PAPI_DOM_SUPERVISOR:PAPI_DOM_OTHER
</pre><p>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerfLib"></a>2.7.&nbsp;Profiling with PerfLib</h2></div></div></div><p>This profiling option is currently under development at LANL.</p><p>To configure TAU with PerfLib use the following arguments:
    </p><pre class="screen">
%&gt; configure -perflib=[path_to_perflib lib directory]
             -perfinc=[path_to_perflib inc directory]
             -perflibrary=[argument send to the linker if different than default]
</pre><p>
    After tau is build a new Makefile will be generated with *-perflib-* in its
    name, use this Makefile when profiling applications with perflib.
    </p><p>After configuration and installation, toggle these three environment
    variables before running the application:
    </p><pre class="screen">
%&gt; export PERF_PROFILE=1
%&gt; export PERF_PROFILE_MPI=1
%&gt; export PERF_PROFILE_MEMORY=1
%&gt; export PERF_PROFILE_COUNTERS=1
%&gt; export PERF_DATA_DIRECTORY=&lt;directory&gt;
</pre><p>
    </p><p>We also provide a perf2tau conversion utilities to convert the
    remaining perflib profiles to regular tau profiles. To use perf2tau set the
    environment variable <code class="literal">perf_data_directory</code> to the
    type of the profiling to be converted (the directory where the data is store
    will be called something like perf_data.[type]/). Or you may execute
    perf2tau with the type as an argument:
    </p><pre class="screen">
%&gt; perf2tau [type]
</pre><p>
    </p><p>See also the man page for perf2tau, <a href="#perf2tau" title="perf2tau"><span class="refentrytitle">perf2tau</span></a>.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningPython"></a>2.8.&nbsp;Running a Python application with TAU</h2></div></div></div><p>TAU can automatically instrument all Python routines when the
    tau python package is imported.  Add &lt;TAUROOT&gt;/&lt;ARCH&gt;/lib/bindings-&lt;options&gt; to the PYTHONPATH environment variable in order to use the TAU module.</p><p>To execute the program, tau.run routine is invoked with the name of
    the top level Python code. For e.g.,</p><pre class="screen">
#!/usr/bin/env python

import tau
from time import sleep

def f2():
    print "Inside f2: sleeping for 2 secs..."
    sleep(2)
def f1():
    print "Inside f1, calling f2..."
    f2()

def OurMain():
    f1()

tau.run('OurMain()')
</pre><p>instruments routines <code class="literal">OurMain(), f1() and
    f2()</code> although there are no instrumentation calls in the
    routines. To use this feature, TAU must be configured with the
    -pythoninc=&lt;dir&gt; option (and -pythonlib=&lt;dir&gt; if running
    under IBM). Before running the application, the environment variable
    <code class="literal">PYTHONPATH</code> and <code class="literal">LD_LIBRARY_PATH</code> should be set to include the TAU library
    directory (where tau.py is stored). Manual instrumentation of Python
    sources is also possible using the Python API and the
    <code class="literal">pytau</code> package. For e.g.,</p><pre class="screen">

#!/usr/bin/env python

import pytau
from time import sleep

x = pytau.profileTimer("A Sleep for excl 5 secs")
y = pytau.profileTimer("B Sleep for excl 2 secs")
pytau.start(x)
print "Sleeping for 5 secs ..."
sleep(5)
pytau.start(y)
print "Sleeping for 2 secs ..."
sleep(2)
pytau.stop(y)
pytau.dbDump()
pytau.stop(x)
</pre><p>shows how two timers x and y are created and used. Note,
     multiple timers can be nested, but not overlapping. Overlapping timers
     are detected by TAU at runtime and flagged with a warning (as exclusive
     time is not defined when timers overlap).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pprof"></a>2.9.&nbsp;pprof</h2></div></div></div><p>pprof sorts and displays profile data generated by TAU. To
    view the profile, merely execute pprof in the directory where profile
    files are located (or set the <code class="literal">PROFILEDIR</code> environment
    variable).</p><pre class="screen">
% pprof
</pre><p>Its usage is explained below:</p><pre class="screen">
usage: pprof [-c|-b|-m|-t|-e|-i] [-r] [-s] [-n num] [-f filename] \
       [-l] [node numbers]
  -c : Sort by number of Calls
  -b : Sort by number of suBroutines called by a function
  -m : Sort by Milliseconds (exclusive time total)
  -t : Sort by Total milliseconds (inclusive time total) (DEFAULT)
  -e : Sort by Exclusive time per call (msec/call)
  -i : Sort by Inclusive time per call (total msec/call)
  -v : Sort by standard deViation (excl usec)
  -r : Reverse sorting order
  -s : print only Summary profile information
  -n num : print only first num functions
  -f filename : specify full path and Filename without node ids 
  -p : suPpress conversion to hh:mm:ss:mmm format
  -l : List all functions and exit 
  -d : Dump output format (for Racy) [node numbers] : prints only info about
	all contexts/threads of given node numbers
 node numbers : prints information about all contexts/threads 
 for specified nodes
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningJAVA"></a>2.10.&nbsp;Running a JAVA application with TAU</h2></div></div></div><p>Java applications are profiled/traced using <code class="literal">tau_java</code> as shown below:</p><pre class="screen">
% cd tau/examples/java/pi
% setenv LD_LIBRARY_PATH $LD_LIBRARY_PATH:&lt;tauroot&gt;/&lt;arch&gt;/lib
% tau_java  Pi
</pre><p> More information about <code class="literal">tau_java</code> can be found
  in the Tools section of the Reference Guide. </p><p>Running the application generates profile files with names
    having the form profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.
    These files can be analyzed using pprof or paraprof.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UsingTauConf"></a>2.11.&nbsp;Using a tau.conf File</h2></div></div></div><p>If a tau.conf file is created, then code that uses that TAU lib will effected by the
     settings in tau.conf.  For example, if a directory tau-2.21/tau_system_defaults is created and  
     a tau.conf file is placed in  it, TAU will read that file before doing the measurements. A user 
     of that TAU libs  can choose to override the contents of that file by placing a tau.conf in their 
     own directory. But by default, if the sysadmin chooses to create this dir, all the users of the 
     TAU libs will be globally affected by this tau.conf. 

    </p><p>For example, tau.conf could be:
    </p><pre class="screen">
% cat tau.conf
TAU_LOG_PATH=/soft/apps/tau/logs
PROFILEDIR=$TAU_LOG_DIR
TAU_PROFILE_FORMAT=merged
TAU_SUMMARY=1
TAU_IBM_BG_HWP_COUNTERS=1
TAU_TRACK_MESSAGE=1
    </pre><p>
Then anyone using TAU from that directory will get TAU_IBM_BG_HWP_COUNTERS=1, TAU_TRACK_MESSAGE=1, etc.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UsingScoreP"></a>2.12.&nbsp;Using Score-P with TAU</h2></div></div></div><p>TAU can be configured to use the  Score-P measurement infrastructure (www.score-p.org).
          To use Score-P, configure TAU with <code class="literal">-scorep=</code> option to point TAU to the Score-P
          installation.  (Please use Score-P version 1.0 beta or above.) You may then instrument and run your
          application with TAU in a manor of your choosing.  
    </p><p>  Set the environment variable SCOREP_PROFILING_FORMAT to TAU_SNAPSHOT to produce TAU Snapshot files, 
             which will be found in scorep*/tau/.  Also, the Score-P library must be found in LD_LIBRARY_PATH.
 
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UsingUPC"></a>2.13.&nbsp;Using UPC  with TAU</h2></div></div></div><p> Please see examples/upc for more details. 
 </p><p>To instrument Berkeley UPC with GASP, configure TAU with <code class="literal">-upcnetwork=&lt;option&gt;</code> 
where option is "mpi" or "udp". Then use a selective instrumentation file like the one shown below. 
    </p><pre class="screen">
BEGIN_INSTRUMENT_SECTION
forall routine="#"
loops routine="#"
barrier routine="#"
fence routine="#"
notify routine="#"
END_INSTRUMENT_SECTION
</pre><p> Then tau_upc.sh can be used to build the application. If "udp" is used
with -upcnetwork, then upcrun can be used to run the application. For
"mpi", mpirun or a similar mechanism can be used.
</p><p>To instrument UPC with Cray CCE compilers, the following will produce a configuration that supports Cray UPC and may be used with tau_upc.sh
    </p><pre class="screen">
module load PrgEnv-cray
./configure -arch=craycnl -pdt=&lt;dir&gt; -pdt_c++=g++
</pre><p>
TAU can also build the DMAPP wrapper using Cray CCE compilers. When
the -optDMAPP option is used when building the application with TAU
using TAU_OPTIONS, DMAPP events are automatically instrumented with
tau_upc.sh.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tracingReference"></a>Chapter&nbsp;3.&nbsp;Tracing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e5662">3.1. How to configure tracing</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5662"></a>3.1.&nbsp;How to configure tracing</h2></div></div></div><p>TAU must be configured with the <code class="literal">-TRACE</code>
    option to generate event traces. This can be used in conjunction with
    <code class="literal">-PROFILE</code> to generate both profiles and traces. The
    traces are stored in a directory specified by the environment variable
    <code class="literal">TRACEDIR</code>, or the current directory, by default.
    The environment variables <code class="literal">TAU_TRACEFILE</code> may be used to
    specify the name of Vampir trace file. When this variable is set, 
    trace files are automatically merged and the tau2vtf is invoked to convert
    the merged trace file to VTF3 trace format. This conversion takes place on 
    node 0, thread 0. The intermediate trace files are deleted. To retain the
    trace files, the user can set the environment variable 
    <code class="literal">TAU_KEEP_TRACEFILES</code> to true. When 
    <code class="literal">TAU_TRACEFILE</code> is not specified, the user needs to merge
    and convert the traces as below. 
    
Example:</p><pre class="screen">
% ./configure -arch=sgi64 -TRACE  -mpi -vtf=/usr/local/vtf3-1.34 -slog2
% make clean; make install
% setenv TRACEDIR /users/sameer/tracedata/experiment56
% mpirun -np 4 matrix
    </pre><p>This generates files named</p><pre class="screen">
tautrace.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.trc and events.&lt;node&gt;.edf 
    </pre><p>When generating a Vampir Trace Format (otf or vtf) these
    environment variables maybe helpful:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">VT_FILE_PREFIX</code>Prefix used for trace
        filenames. Default is "a".</p></li><li><p><code class="literal">VT_COMPRESSION</code>Write compressed trace
      files? Default is "yes"</p></li></ul></div><p>Using the utility tau_treemerge.pl, these traces are then merged as shown below:</p><pre class="screen">
% tau_treemerge.pl
</pre><p>This generates tau.trc as the merged trace file and tau.edf as the
    merged event description file.</p><p> tau_treemerge.pl can take an optional argument (with -n
    &lt;value&gt;) to specify the maximum number of trace files to merge in
    each invocation of tau_merge. If we need to merge 2000 trace files and if
    the maximum number of open files specified by unix is 250, tau_treemerge.pl
    will incrementally merge the trace files so as not to exceed the number of
    open file descriptors. This is important for the IBM BlueGene/L machine
    where such restrictions are present on the front-end node. </p><p>To convert merged or per-thread traces to another trace format, the
    utilities, tau2otf, tau_convert, tau2vtf, or tau2slog2 are used as shown
    below:</p><pre class="screen">
Usage: tau2otf [ -n  streams  ] [ -nomessage  ] [ -v  ] [ -z ]
 -n streams : Specifies the number of output streams (default is 1)
 -nomessage : Suppresses printing of message information in the trace
 -v         : Verbose mode sends trace event descriptions to the standard output
 as they are converted
 -z         : Compressed output
</pre><p>Here is an example:</p><pre class="screen">
%&gt; tau2otf tau.trc tau.edf out.otf
</pre><p>Converting to Vampir's VTF format:</p><pre class="screen">
% tau2vtf
Usage: tau2vtf &lt;TAU trace&gt; &lt;edf file&gt; &lt;out file&gt; [-a|-fa] 
               [-nomessage] [-v]
 -a         : ASCII VTF3 file format
 -fa        : FAST ASCII VTF3 file format
 -nomessage : Suppress printing of message information in the trace
 -v         : Verbose
 Default trace format of &lt;out file&gt; is VTF3 binary
 e.g.,
 tau2vtf merged.trc tau.edf app.vpt.gz
% tau2vtf matrix.trc tau.edf matrix.vpt.gz
% vampir matrix.vpt.gz
  </pre><p>To generate slog2 trace files that may be visualized using Jumpshot,
          we recommend using the slog2 SDK and Jumpshot bundled with TAU. </p><pre class="screen">
% configure -slog2 -TRACE ...
% tau2slog2 
tau2slog2 converts a TAU formatted trace file to the SLOG2 format 
          for Jumpshot trace visualizer
Usage: tau2slog2 &lt;tau_tracefile&gt; &lt;edf_file&gt; -o &lt;slog_tracefile&gt;
For e.g., 
% tau2slog2 app.trc tau.edf -o app.slog2
    </pre><p>To generate traces that may be visualized using Vampir, we recommend 
          using tau2vtf over the older tau_convert tool. tau2vtf can produce
          binary traces with user-defined events  (hardware performance counters
          from PAPI etc.) while tau_convert cannot do this. Binary traces load
          faster in Vampir. </p><pre class="screen">
% tau_convert
usage: tau_convert [-alog | -SDDF | -dump | -paraver [-t] | -pv | 
       -vampir [-longsymbolbugfix] [-compact] [-user|-class|-all] 
       [-nocomm]] inputtrc edffile [outputtrc]
 Note: -vampir option assumes multiple threads/node
 Note: -t option used in conjunction with -paraver option assumes 
       multiple threads/node
</pre><p>To view the dump of the trace in text form, use</p><pre class="screen">
% tau_convert -dump matrix.trc tau.edf 
</pre><p>tau_convert can also be used to convert traces to the <a href="http://www.vampir-ng.de/" target="_top">Vampir</a> trace format. For
    single-threaded applications (such as the MPI application above), the
    <code class="literal">-pv</code> option is used to generate Vampir traces as
    follows:</p><pre class="screen">
% tau_convert -pv matrix.trc tau.edf matrix.pv
% vampir matrix.vpt.gz &amp;
</pre><p>To convert TAU traces to <code class="literal">SDDF</code> or
    <code class="literal">ALOG</code> trace formats, <code class="literal">-SDDF</code> and
    <code class="literal">-alog</code> options may be used. When multiple threads are
    used on a node (as with <code class="literal">-jdk, -pthread or
    -tulipthread</code> options during configure), the
    <code class="literal">-vampir</code> option is used to convert the traces to the
    vampir trace format, as shown below:</p><pre class="screen">

% tau_convert -vampir smartsapp.trc tau.edf smartsapp.pv
% vampir smartsapp.pv &amp;
</pre><p>To convert to the Paraver trace format, use the
    <code class="literal">-paraver</code> option for single threaded programs and
    <code class="literal">-paraver -t</code> option for multi-threaded programs.
    </p><p><span class="emphasis"><em>NOTE:</em></span> To ensure that inter-process
    communication events are recorded in the traces, in addition to the
    routine transitions, it is necessary to insert
    <code class="literal">TAU_TRACE_SENDMSG</code> and
    <code class="literal">TAU_TRACE_RECVMSG</code> macro calls in the source code
    during instrumentation. This is not needed when the TAU MPI wrapper
    library is used. </p><p> Vampir format traces may be converted to TAU profiles using the
    vtf2profile tool.</p><pre class="screen">
% vtf2profile -f matrix.vpt.gz -p profiledatadir
% vtf2profile
Usage: vtf2profile [options] 
***************************HELP***************************
* '-h' display this help text.                         *
* '-c' open command line interface.                    *
* '-f' used as -f &lt;VTF File&gt; where                     *
*        VTF File is the name of the trace file          *
*        to be converted to TAU profiles.                *
* '-p' used as -p &lt;path&gt; where 'path' is the relative  *
*        path to the directory where profiles are to     *
*        stored.                                         *
* '-i' used as -i &lt;from&gt; &lt;to&gt; where 'from' and 'to' are*
*        integers to mark the desired profiling interval.*
**********************************************************
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5790"></a>Chapter&nbsp;4.&nbsp;TAU Memory Profiling Tutorial</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#memoryOptions">4.1. TAU's memory API options</a></span></dt><dt><span class="sect1"><a href="#tauExecMemory">4.2. Using tau_exec</a></span></dt><dt><span class="sect1"><a href="#profilingMemory">4.3. Evaluating Memory Utilization</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5818">4.3.1. TAU_TRACK_MEMORY</a></span></dt><dt><span class="sect2"><a href="#d0e5842">4.3.2. TAU_TRACK_MEMORY_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5853">4.3.3. TAU_TRACK_MEMORY_FOOTPRINT</a></span></dt><dt><span class="sect2"><a href="#d0e5858">4.3.4. TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span></dt><dt><span class="sect2"><a href="#d0e5863">4.3.5. -PROFILEMEMORY</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ProfilingHeadroom">4.4. Evaluating Memory Headroom</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5871">4.4.1. TAU_TRACK_MEMORY_HEADROOM()</a></span></dt><dt><span class="sect2"><a href="#d0e5892">4.4.2. TAU_TRACK_MEMORY_HEADROOM_HERE()</a></span></dt><dt><span class="sect2"><a href="#d0e5906">4.4.3. -PROFILEHEADROOM</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5925">4.5. DetectingMemoryLeaks</a></span></dt><dt><span class="sect1"><a href="#MemoryTrackingInFortran">4.6. Memory Tracking In Fortran</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="memoryOptions"></a>4.1.&nbsp;TAU's memory API options</h2></div></div></div><p>TAU can evaluate the following memory events:</p><div class="orderedlist"><ol type="1"><li><p> Memory utilization options that examine how much heap memory
		is currently used, and</p></li><li><p>Memory headroom evaluation options that examine how much a
		program can grow (or how much headroom it has) before it runs out of free
		memory on the heap. During memory headroom evaluation TAU tries to call malloc with chunks that
		progressively increase in size, until all memory is exhausted. Then it
		frees those chunks, keeping track of how much memory it successfully
		allocated.</p></li><li><p>Memory leaks in C/C++ programs TAU will track malloc through the
		execuation issuing user event when the program fails to the allocated
		memory.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tauExecMemory"></a>4.2.&nbsp;Using tau_exec</h2></div></div></div><p>
		The <a href="#tau_exec" title="tau_exec"><span class="refentrytitle">tau_exec</span></a> command allow you to track
		these memory events with either an instrumented or uninstrumented binary. If
		you want to instead track memory usage in select locations in the source
		code consider the TAU API calls below.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="profilingMemory"></a>4.3.&nbsp;Evaluating Memory Utilization</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5818"></a>4.3.1.&nbsp;TAU_TRACK_MEMORY</h3></div></div></div><p>When <code class="literal">TAU_TRACK_MEMORY</code> is called an interrupt is generated every 10 seconds and the memory event
			is triggered with the current value. This interrupt interval can
			be changed by calling
			<code class="literal">TAU_SET_INTERRUPT_INTERVAL(value)</code>. The tracking of
	    	memory events in both cases can be explictly enabled or disabled by
		    calling the macros <code class="literal">TAU_ENABLE_TRACKING_MEMORY()</code> or
		   <code class="literal">TAU_DISABLE_TRACKING_MEMORY()</code> respectively.
			</p><p>TAU_TRACK_MEMORY() can be inserted into the source code:
      </p><pre class="screen">
int main(int argc, char **argv)
{
	TAU_PROFILE("main()", " ", TAU_DEFAULT);
	TAU_PROFILE_SET_NODE(0);

	TAU_TRACK_MEMORY();

	sleep(12);

	int *x = new int[5*1024*1024];

	sleep(12);

	return 0;
}
</pre><p>			
			
			Resulting profile data:
			</p><pre class="screen">
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         2  2.049E+04      2.891  1.024E+04  1.024E+04  Memory Utilization
			(heap, in KB)
---------------------------------------------------------------------------------------
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5842"></a>4.3.2.&nbsp;TAU_TRACK_MEMORY_HERE</h3></div></div></div><p>Triggers memory tracking at a given execution point. For
			example:</p><pre class="screen">
int main(int argc, char **argv) {
	TAU_PROFILE("main()", " ", TAU_DEFAULT);
	TAU_PROFILE_SET_NODE(0);

	TAU_TRACK_MEMORY_HERE();

	int *x = new int[5*1024*1024];
	TAU_TRACK_MEMORY_HERE();
	return 0;
}

</pre><p>Here is the resulting profile:</p><pre class="screen">
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         2  2.049E+04      2.891  1.024E+04  1.024E+04  Memory Utilization
			(heap, in KB)
---------------------------------------------------------------------------------------
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5853"></a>4.3.3.&nbsp;TAU_TRACK_MEMORY_FOOTPRINT</h3></div></div></div><p>Similar to TAU_TRACK_MEMORY but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5858"></a>4.3.4.&nbsp;TAU_TRACK_MEMORY_FOOTPRINT_HERE</h3></div></div></div><p>Similar to TAU_TRACK_MEMORY_HERE but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5863"></a>4.3.5.&nbsp;-PROFILEMEMORY</h3></div></div></div><p>Specifies tracking heap memory utilization for each instrumented
		function. When any function entry takes place, a sample of the heap memory
		used is taken. This data is stored as user-defined event data in
		profiles/traces.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ProfilingHeadroom"></a>4.4.&nbsp;Evaluating Memory Headroom</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5871"></a>4.4.1.&nbsp;TAU_TRACK_MEMORY_HEADROOM()</h3></div></div></div><p>This call sets up a signal handler that is invoked every 10
			seconds by an
			interrupt. Inside, it evaluates how much memory it can allocate and
			associates
			it with the callstack. The user can vary the size of the callstack by
			setting
			the environment variable <code class="literal">TAU_CALLSTACK_DEPTH</code> (default is 2).
			The examples/headroom/track subdirectory has an example that
			illustrates the
			use of this call.  To disable tracking this headroom at runtime, the
			user
			may call:
			<code class="literal">TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</code> and call
			<code class="literal">TAU_ENABLE_TRACKING_MEMORY_HEADROOM()</code> to re-enable 
			tracking of the headroom.
			To set a different interrupt interval, call
			<code class="literal">TAU_SET_INTERRUPT_INTERVAL(value)</code>
			where value (in seconds) represents the inter-interrupt interval.
			</p><p>A sample profile generated has:</p><pre class="screen">
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         3       4067       4061       4065      2.828  Memory Headroom Left (in
			MB)
         3       4067       4061       4065      2.828  Memory Headroom
         Left (in MB) : void quicksort(int *, int, int)   =&gt; void
         quicksort(int *, int, int)
--------------------------------------------------------------------------------
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5892"></a>4.4.2.&nbsp;TAU_TRACK_MEMORY_HEADROOM_HERE()</h3></div></div></div><p>Sometimes it is useful to track the memory available at a certain
			point in the
			program, rather than rely on an interrupt.
			<code class="literal">TAU_TRACK_MEMORY_HEADROOM_HERE()</code>
			allows us to examine the memory available at a particular location in
			the source
			code and associate it with the currently executing callstack.
			The examples/headroom/here subdirectory has an example that illustrates
			this usage.</p><pre class="screen">
  ary = new double [1024*1024*50];
    TAU_TRACK_MEMORY_HEADROOM_HERE(); /* takes a sample here!  */
	   sleep(1);
</pre><p>A sample profile looks like this:</p><pre class="screen">
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         3       3672       3672       3672          0  Memory Headroom Left (in
			MB)
         1       3672       3672       3672          0  Memory Headroom
						Left (in MB) : main() (calls f1, f5) =&gt; f1() (sleeps 1 sec,
						calls f2, f4)
         1       3672       3672       3672          0  Memory
						Headroom Left (in MB) : main() (calls f1, f5) =&gt; f1()
						(sleeps 1 sec, calls f2, f4) =&gt; f4() (sleeps 4 sec,
						calls f2)
         1       3672       3672       3672			  0  Memory Headroom Left 
						(in MB) : main() (calls f1, f5) =&gt; f5() (sleeps 5 sec)
---------------------------------------------------------------------------------------
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5906"></a>4.4.3.&nbsp;-PROFILEHEADROOM</h3></div></div></div><p>Similar to the -PROFILEMEMORY configuration option that takes a
			sample of the
			memory utilization at each function entry, we now have
			<code class="literal">-PROFILEHEADROOM</code>. In this
			<code class="literal">-PROFILEHEADROOM</code> option, a sample is taken at instrumented function's
			entry and
			associated with the function name. This option is meant to be used as a
			debugging aid due the high cost associated with executing a series of
			malloc
			calls. The cost was 106 microseconds on an IBM BG/L (700 MHz CPU). To
			use this
			option, simply configure TAU with the
			<code class="literal">-PROFILEHEADROOM</code> option and
			choose any
			method for instrumentation (PDT, MPI, hand instrumentation). You do not
			need
			to annotate the source code in any special way (as is required for 2a
			and 2b).
			The examples/headroom/available subdirectory has a simple example that
			produces the following profile when TAU is configured with the
			<code class="literal">-PROFILEHEADROOM</code> option.
			</p><pre class="screen">
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         1       4071       4071       4071          0  f1() (sleeps 1 sec,
			calls f2, f4) - Memory Headroom Available (MB)
         2       3671       3671       3671          0  f2() (sleeps 2
			sec, calls f3) - Memory Headroom Available (MB)         
         2       3671       3671       3671          0  f3() (sleeps 3 sec) -
			Memory Headroom Available (MB)         
         1       3671       3671       3671          0  f4() (sleeps 4 sec, 
			calls f2) - Memory Headroom Available (MB)         
         1       3671       3671       3671          0  f5() (sleeps 5 sec) - 
			Memory Headroom Available (MB)         
         1       4071       4071       4071          0  main() (calls f1, f5) 
			- Memory Headroom Available (MB)
---------------------------------------------------------------------------------------
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5925"></a>4.5.&nbsp;DetectingMemoryLeaks</h2></div></div></div><p>TAU's memory leak detection feature can be initiated by giving
		tau_compiler.sh the option <code class="literal">-optDetectMemoryLeaks</code>. For
		a demonstration consider this C++ program:</p><pre class="screen">

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;


/* there is a memory leak in bar when it is invoked with 5 &lt; value &lt;= 15 */
int bar(int value)
{
  printf("Inside bar: %d\n", value);
  int *x;

  if (value &gt; 5)
  {
    printf("looks like it came here from g!\n");
    x = (int *) malloc(sizeof(int) * value);
    x[2]= 2;
    /* do not free it! create a memory leak, unless the value is &gt; 15 */
    if (value &gt; 15) free(x);
  }
  else
  { /* value  &lt;=5 no leak */
    printf("looks like it came here from foo!\n");
    x = (int *) malloc(sizeof(int) * 45);
    x[23]= 2;
    free(x);
  }
  return 0;
}
    
int g(int value)
{
  printf("Inside g: %d\n", value);
  return bar(value);
}

int foo(int value)
{
  printf("Inside f: %d\n", value);
  
  if (value &gt; 5) g(value);
  else bar(value);
	
  return 0;
}
int main(int argc, char **argv)
{
  int *x;
  int *y;
  printf ("Inside main\n");

  foo(12); /* leak */
  foo(20); /* no leak */
  foo(2);  /* no leak */
  foo(13); /* leak */
}
</pre><p>Notice that bar fails to free allocated memory on input between 5 and 15 and
		that foo will call g that calls bar when the input to foo is greater than 5.
		</p><p>Now configuring TAU with <code class="literal">-PROFILECALLPATH</code> run the file
		by:</p><pre class="screen">
%&gt; cd examples/memoryleakdetect/
%&gt; make
%&gt; ./simple
...
USER EVENTS Profile :NODE 0, CONTEXT 0, THREAD 0
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         2         52         48         50          2  MEMORY LEAK! malloc size &lt;file=simple.inst.cpp, line=18&gt; : int g(int)   =&gt; int bar(int)  
         1         80         80         80          0  free size &lt;file=simple.inst.cpp, line=21&gt;
         1         80         80         80          0  free size &lt;file=simple.inst.cpp, line=21&gt; : int g(int)   =&gt; int bar(int)  
         1        180        180        180          0  free size &lt;file=simple.inst.cpp, line=28&gt;
         1        180        180        180          0  free size &lt;file=simple.inst.cpp, line=28&gt; : int foo(int)   =&gt; int bar(int)  
         3         80         48         60      14.24  malloc size &lt;file=simple.inst.cpp, line=18&gt;
         3         80         48         60      14.24  malloc size &lt;file=simple.inst.cpp, line=18&gt; : int g(int)   =&gt; int bar(int)  
         1        180        180        180          0  malloc size &lt;file=simple.inst.cpp, line=26&gt;
         1        180        180        180          0  malloc size &lt;file=simple.inst.cpp, line=26&gt; : int foo(int)   =&gt; int bar(int)  
---------------------------------------------------------------------------------------
</pre><p>Notice that the first row show the two Memory leaks along with the callpath
		tracing where the unallocated memory was requested.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MemoryTrackingInFortran"></a>4.6.&nbsp;Memory Tracking In Fortran</h2></div></div></div><p>To profile memory usage in Fortran 90 use TAU's ability to selectively
    instrument a program. The option
    <code class="literal">-optTauSelectFile=&lt;file&gt;</code> for tau_compilier.sh let
    you specify a selective instrumentation file which defines regions of the
    source code to instrument.</p><p>To begin memory profiling, state which file/routines to profile by
    typing:</p><pre class="screen">

BEGIN_INSTRUMENT_SECTION
memory file="memory.f90" routine="INIT"
END_INSTRUMENT_SECTION
</pre><p>Wildcard can be used to instrument multiple routines. For file names *
    character can be used to specify any number of character, thus foo* matches
    foobar, foo2, etc. also for file names ? can match a single charater, ie.
    foo? matches foo2, fooZ, but not foobar. You can use # as a wildcard for
    routines, ie. b# matches bar, b2z etc.</p><p>Memory Profile in Fortran gives you these three metrics:
    
    </p><div class="itemizedlist"><ul type="disc"><li><p>Total size of memory for each <code class="literal">malloc</code> and
        <code class="literal">free</code> in the source code.</p></li><li><p>The callpath for each occurrence of <code class="literal">malloc</code> or
        <code class="literal">free</code>.</p></li><li><p>A list of all variable that were not deallocated in the source
      code.</p></li></ul></div><p>
    
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Due to the limitations of the <code class="literal">xlf</code> compiler, The
    size of the memory reported for Fortran Array (compilied with
    <code class="literal">xlf</code>) is not the number of bytes but the number of
    elements.</p></td></tr></table></div><p>Here is the profile for the
    <code class="literal">example/memoryleakdetect/f90/foo.f90</code> file. </p><pre class="screen">
%&gt; pprof
..
---------------------------------------------------------------------------------------
NumSamples   MaxValue   MinValue  MeanValue  Std. Dev.  Event Name
---------------------------------------------------------------------------------------
         1         16         16         16          0  MEMORY LEAK! malloc size &lt;file=foo.f90, var=X, line=7&gt; : MAIN =&gt; FOO =&gt; BAR 
         2         52         48         50          2  MEMORY LEAK! malloc size &lt;file=foo.f90, var=X, line=7&gt; : MAIN =&gt; FOO =&gt; G =&gt; BAR 
         1         80         80         80          0  free size &lt;file=foo.f90, var=X, line=10&gt;
         1         80         80         80          0  free size &lt;file=foo.f90, var=X, line=10&gt; : MAIN =&gt; FOO =&gt; G =&gt; BAR 
         1        180        180        180          0  free size &lt;file=foo.f90, var=X, line=15&gt;
         1        180        180        180          0  free size &lt;file=foo.f90, var=X, line=15&gt; : MAIN =&gt; FOO =&gt; BAR 
         1        180        180        180          0  malloc size &lt;file=foo.f90, var=X, line=13&gt;
         1        180        180        180          0  malloc size &lt;file=foo.f90, var=X, line=13&gt; : MAIN =&gt; FOO =&gt; BAR 
         4         80         16         49      22.69  malloc size &lt;file=foo.f90, var=X, line=7&gt;
         1         16         16         16          0  malloc size &lt;file=foo.f90, var=X, line=7&gt; : MAIN =&gt; FOO =&gt; BAR 
         3         80         48         60      14.24  malloc size &lt;file=foo.f90, var=X, line=7&gt; : MAIN =&gt; FOO =&gt; G =&gt; BAR 
---------------------------------------------------------------------------------------
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="EclipseTauJava"></a>Chapter&nbsp;5.&nbsp;Eclipse Tau Java System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Installation">5.1. Installation</a></span></dt><dt><span class="sect1"><a href="#Instrumentation">5.2. Instrumentation</a></span></dt><dt><span class="sect1"><a href="#Uninstrumentation">5.3. Uninstrumentation</a></span></dt><dt><span class="sect1"><a href="#RunningTauJava">5.4. Running Java with TAU</a></span></dt><dt><span class="sect1"><a href="#Options">5.5. Options</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Installation"></a>5.1.&nbsp;Installation</h2></div></div></div><p>Copy the plugins directory in the tau2/tools/src/taujava directory to the location of your eclipse installation.  You may have to restart eclipse if it is running when this is done.</p><p>In eclipse go to the Window menu, select Preferences and go to the TauJava Preferences section.  Enter the location of the lib directory in the tau installation for your architecture in the Tau Library Directory field.  Other options may also be selected at this time.</p><div class="figure"><a name="d0e6011"></a><p class="title"><b>Figure&nbsp;5.1.&nbsp;TAUJava Options Screen</b></p><div class="mediaobject"><img src="images/taujavopt.png" alt="TAUJava Options Screen"></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Instrumentation"></a>5.2.&nbsp;Instrumentation</h2></div></div></div><p>
Java programs can be instrumented at the level of full Java projects, packages or individual Java files.  From within the Java view simply right click on the element in the package explorer that you wish to instrument select the Tau pop up menu and click on Instrument Project, Package or Java respectively.</p><div class="figure"><a name="d0e6024"></a><p class="title"><b>Figure&nbsp;5.2.&nbsp;TAUJava Project Instrumentation</b></p><div class="mediaobject"><img src="images/taujavpopproj.png" alt="TAUJava Project Instrumentation"></div></div><p>
Note that the instrumenter will add the TAU.jar file to the project's class-path the first time any element is instrumented. </p><p>
Do not perform multiple instrumentations of the same Java file.  Do not edit the comments added by the instrumenter or adjust the white space around them.  Doing so may prevent the uninstrumenter from working properly.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Uninstrumentation"></a>5.3.&nbsp;Uninstrumentation</h2></div></div></div><p>
Uninstrumenting a Java project, package or file works just like instrumenting.  Just select the uninstrument option instead.  Note that the uninstrumenter only removes TAU instrumentation as formatted and commented by the instrumenter.  Running the uninstrumenter on code with no TAU instrumentation present has no effect.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningTauJava"></a>5.4.&nbsp;Running Java with TAU</h2></div></div></div><p>
To automatically analyze your instrumented project on a Unix-based system TAU must first be configured with the -JDK option, and any other options you want applied to your trace output.  On windows the type of analysis to be conducted, Profile, Call path or Trace, should be selected from the Window, Preferences TauJava Preferences menu.</p><p>
Once that has been accomplished, right click on the Java file containing the main method you want to run, go to the TAU menu and click on Run Tau-Instrumented Java.  The program will run and, by default, the profile and/or trace files will be placed in a timestamped directory, inside a directory indicating the name of the file that was run, in the TAU_Output directory in the home directory of the Java project.</p><div class="figure"><a name="d0e6048"></a><p class="title"><b>Figure&nbsp;5.3.&nbsp;TAUJava Running</b></p><div class="mediaobject"><img src="images/taujavpoprun.png" alt="TAUJava Running"></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Options"></a>5.5.&nbsp;Options</h2></div></div></div><p>
The following options are accessible from the Window, Preferences TAUJava Preferences menu.</p><p>
Use Alternative TAU Output Directory:  Causes the TAU_Output directory to be placed in the location specified in the associated field.  The internal directory structure of the TAU_Output directory remains unchanged.</p><p>
Automatically run ParaProf on profile output?:  Causes the TAU profile viewer, paraprof, to run on the output of profile and call-path analysis output as soon as the trace files have been produced.</p><p>
Enable selective instrumentation:  Causes Java elements specified in the given selection file to be included or excluded from instrumentation.  By default all packages files and methods are included.  The file should conform to the TAU file selection format described here.</p><pre class="screen">
# Any line beginning with a # is a comment and will be disregarded.
#
# If an entry is both included and excluded inclusion will take precedence. 
#
# Entries in INCLUDE or EXCLUDE lists may use * as a wildcard character.
#
# If an EXCLUDE_LIST is specified, the methods in the list will not be
# instrumented.
#
BEGIN_EXCLUDE_LIST
*main*
END_EXCLUDE_LIST
#
# If an INCLUDE_LIST is specified, only the methods in the list will be
# instrumented.
#
BEGIN_INCLUDE_LIST
*get*
*set*
END_INCLUDE_LIST
#
# TAU also accepts FILE_INCLUDE/EXCLUDE lists.  These may be specified with
# the wildcard character # to exclude/include multiple files.
# These options may be used in conjunction with the routine INCLUDE/EXCLUDE
# lists as shown above. 
#
BEGIN_FILE_INCLUDE_LIST
foo.java
hello#.java
END_FILE_INCLUDE_LIST
#
BEGIN_FILE_EXCLUDE_LIST
bar.java
END_FILE_EXCLUDE_LIST
# Note that the order of the individual sections does not matter
# and not all of the sections need to be included.  Each section
# must be closed.
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="EclipsePlugin"></a>Chapter&nbsp;6.&nbsp;Eclipse PTP / CDT plug-in System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#InstallEclipse">6.1. Installation</a></span></dt><dt><span class="sect1"><a href="#TauLaucher">6.2. Creating a Tau Launch Configuration</a></span></dt><dt><span class="sect1"><a href="#SelectiveLaunch">6.3. Selective Instrumentation</a></span></dt><dt><span class="sect1"><a href="#CollectingData">6.4. Launching a Program and Collecting Data</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="InstallEclipse"></a>6.1.&nbsp;Installation</h2></div></div></div><p>Be certain that the <a href="http://www.eclipse.org/ptp/downloads.php" target="_top">PTP</a>/<a href="http://www.eclipse.org/cdt/downloads.php" target="_top">CDT</a>/<a href="http://www.eclipse.org/photran/download.php" target="_top">Photran</a> plug-ins are installed and running
properly in your eclipse installation.  Use Tau's perfdmf_configure utility to
set up a performance database for Eclipse to store profile output.</p><p>Run the install_plug-ins.sh script located in <code class="literal">[tau
installation]/tools/src/eclipse</code> with the location of your eclipse
installation. e.g:  <code class="literal">~/tau2/tools/src/eclipse/install_plug-ins.sh
/opt/eclipse</code></p><p>Restart eclipse with the -clean flag after installing the plugins.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>By default Eclipse will detect the presence of TAU on your system and
configure itself appropriately so long as the TAU bin directory is in your path. Only if this fails will you need to setup the TAU
preferences manually.
  </p></td></tr></table></div><p>In eclipse go to the Window menu, select Preferences and go to the Performance Tools
preferences section and the Tool Configuration subsection. If the PTP is available the Performance Tools section will be under the
PTP menu.  Enter the location of the desired TAU bin directory in your in the tau Bin Directory field.</p><div class="figure"><a name="d0e6100"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;TAU Setup</b></p><div class="mediaobject"><img src="images/TauSetup.png" alt="TAU Setup"></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TauLaucher"></a>6.2.&nbsp;Creating a Tau Launch Configuration</h2></div></div></div><p>To create a TAU launch configuration, click the profile button added near
the run and debug buttons.  This will provide an interface for launching either a standard or parallel C,
C++ or Fortran application, similar to the interface provided by the standard run configuration dialog.  You may select a pre-existing run configuration or create
a new one in the usual way.</p><div class="figure"><a name="d0e6113"></a><p class="title"><b>Figure&nbsp;6.2.&nbsp;TAU Launch Configuration</b></p><div class="mediaobject"><img src="images/AnalysisTab.png" alt="TAU Launch Configuration"></div></div><p>The run configuration options are equivalent to those of a standard run
configuration, with the addition of a performance analysis tab a parametric study tab and a TAU tab.  To run an application with TAU first make sure that the TAU option is selected in the drop down box on the performance analysis tab.
You may also specify that a Tau instrumented executable should not be run after it is built.
This option will leave a new TAU specific build configuration available for
your use.  It will have the name of the original build configuration, with the
tau configuration options used appended.  The executables available in such
build configurations can be run through the standard run and debug launch
configurations.  This option can be useful if you need to launch Tau
instrumented binaries outside of eclipse.  There is also an option to select existing performance data.  This will upload data specified on the filesystem to a selected database, rather than generating the data from a project in Eclipse.
</p><p>
On the TAU tab you must select
a Tau makefile from the available makefiles in the Tau architecture directory
you specified.  You may select specific configuration options to narrow the list
of makefiles in the dropdown box.  Only makefiles configured with the
<code class="literal">-pdt</code>
option will be listed.  Additional Tau compiler options are provided on the Tau Compiler sub-tab.</p><p>If you select a makefile with the PAPI counter library and
<code class="literal">-MULTIPLECOUNTERS</code>
enabled you may specify the PAPI environment variables using the Select PAPI
Counters button. The counters you select will be placed in the environment
variables list for your run configuration.</p><p>You may specify the use of TAU selective instrumentation either by
selecting a pre-defined selective instrumentation file, by selecting the
internal option to have Tau to use a file generated by the selective
instrumentation commands available in the Eclipse workspace or by selecting the automatic option to have eclipse generate a selective instrumentation file using TAU's tau_reduce utility.  Note that the automatic option will cause your project to be rebuilt and run twice.</p><p>By default TAU profile data will only be stored in a perfdmf
database, if available.  The database may be selected on the Data Collection sub-tab.  You may specify that performance data should be kept on
the file-system with the Keep Profiles option.</p><p>If you wish to collect the resulting profile data on <a href="http://tau.nic.uoregon.edu" target="_top">TAU's online Portal</a>,
check the "Upload profile data to TAU Portal" box. After the profiling has
finished you will be prompted to provide your user name, password and specify
the destination workspace. To view the profile data log on to the portal and
select the specified workspace.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SelectiveLaunch"></a>6.3.&nbsp;Selective Instrumentation</h2></div></div></div><p>C, C++ and Fortran programs have several selective instrumentation options
in Eclipse.  The selective instrumentation sub-menu of the right click menu
provided by C/C++ and Fortran projects, source files and routines in the C/C++
and program outline views allows inclusion, exclusion and loop level
instrumentation to be specified for each of these objects.  You may also clear
instrumentation specified for each of these levels from the selective
instrumentation menu.</p><p>The source editor's context menu allows the insertion of interval and
atomic user defined events.  To specify an atomic user defined event, place the
cursor on the line where you want the event to trigger, right click, go to the
Selective Instrumentation sub-menu and select Insert TAU Atomic User Defined
Event.  Put the name you wish to associate with the event in the first context
window that appears.  Put either a numeric constant or the name of a valid
numeric variable in the second window.</p><div class="figure"><a name="d0e6150"></a><p class="title"><b>Figure&nbsp;6.3.&nbsp;Optional User Defined Events</b></p><div class="mediaobject"><img src="images/UDEs.png" alt="Optional User Defined Events"></div></div><p>To specify an interval based user defined event, select the source code
you wish to be included in the interval, right click, go to the Selective
Instrumentation sub-menu and select Insert TAU Interval (start/stop) User
Defined Event.  You may select use of a Static Timer, Dynamic Timer, Static
Phase or Dynamic Phase event.  Note that to get phase data you must select a Tau
makefile configured with the <code class="literal">-PROFILEPHASE</code> option.  Once you have selected the
event type you will be prompted to enter a name for the event.</p><div class="figure"><a name="d0e6163"></a><p class="title"><b>Figure&nbsp;6.4.&nbsp;Adding User Defined Events</b></p><div class="mediaobject"><img src="images/Context.png" alt="Adding User Defined Events"></div></div><p>All selective instrumentation options are placed in the tau.selective file
in your project's main directory.  This file is automatically employed when the
Tau launch configuration has "internal" selective instrumentation selected.  You
may safely edit this file manually so long as it remains a valid Tau selective
instrumentation file.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CollectingData"></a>6.4.&nbsp;Launching a Program and Collecting Data</h2></div></div></div><p>To launch your project with Tau either select the Profile button from the
profile launch configuration window, select your launch configuration from the
dropdown menu of the profile button or, if your desired configuration is already
selected, simply click on the profile button. </p><p>If a perfdmf database is configured and available, Tau profile data will
be saved there. Trace data and other performance data output will be stored in
your project's top level directory.  If a perfdmf database is not available or
you have selected to save profile data on the file system profile output will
appear in a Profiles directory in your project's top level directory.  Profiles
are organized in sub-directories by the Tau configuration options used to
generate them and the time-stamp of their creation.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e6181"></a>Chapter&nbsp;7.&nbsp;Tools</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#tau_compiler.sh">tau_compiler.sh</a></span><span class="refpurpose"> - Instrumenting source files.</span></dt><dt><span class="refentrytitle"><a href="#vtf2profile">vtf2profile</a></span><span class="refpurpose"> - Generate a TAU profile set from a vampir trace file</span></dt><dt><span class="refentrytitle"><a href="#tau2vtf">tau2vtf</a></span><span class="refpurpose"> - convert TAU tracefiles to vampir tracefiles</span></dt><dt><span class="refentrytitle"><a href="#trace2profile">trace2profile</a></span><span class="refpurpose"> - convert TAU tracefiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau2elg">tau2elg</a></span><span class="refpurpose"> - convert TAU tracefiles to Epilog tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2slog2">tau2slog2</a></span><span class="refpurpose"> - convert TAU tracefiles to SLOG2 tracefiles</span></dt><dt><span class="refentrytitle"><a href="#tau2otf">tau2otf</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#tau2otf2">tau2otf2</a></span><span class="refpurpose"> - convert TAU tracefiles to OTF2
	 tracefiles for Vampir/VNG
	 </span></dt><dt><span class="refentrytitle"><a href="#perf2tau">perf2tau</a></span><span class="refpurpose"> - converts PerfLib profiles to TAU profile files</span></dt><dt><span class="refentrytitle"><a href="#tau_merge">tau_merge</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_treemerge.pl">tau_treemerge.pl</a></span><span class="refpurpose"> - combine multiple node and or thread TAU tracefiles into a
    merged tracefile</span></dt><dt><span class="refentrytitle"><a href="#tau_convert">tau_convert</a></span><span class="refpurpose"> - convert TAU tracefiles into various alternative trace formats</span></dt><dt><span class="refentrytitle"><a href="#tau_reduce">tau_reduce</a></span><span class="refpurpose"> - generates selective
    instrumentation rules based on profile data</span></dt><dt><span class="refentrytitle"><a href="#tau_ompcheck">tau_ompcheck</a></span><span class="refpurpose"> - Completes uncompleted do/for/parallel omp directives</span></dt><dt><span class="refentrytitle"><a href="#tau_poe">tau_poe</a></span><span class="refpurpose"> - Instruments a MPI application while it is being executed with poe.</span></dt><dt><span class="refentrytitle"><a href="#tau_validate">tau_validate</a></span><span class="refpurpose"> - Validates a TAU installation by performing
    various tests on each TAU stub Makefile</span></dt><dt><span class="refentrytitle"><a href="#tauex">tauex</a></span><span class="refpurpose"> - Allows you to choose a tau configuration at runtime</span></dt><dt><span class="refentrytitle"><a href="#tau_exec">tau_exec</a></span><span class="refpurpose"> - TAU execution wrapping script</span></dt><dt><span class="refentrytitle"><a href="#tau_timecorrect">tau_timecorrect</a></span><span class="refpurpose"> - Corrects and reorders the records of tau trace files.</span></dt><dt><span class="refentrytitle"><a href="#tau_throttle.sh">tau_throttle.sh</a></span><span class="refpurpose"> - This tool generates a selective instrumentation file (called
    throttle.tau) from a program output that has "Disabling"
    messages.</span></dt><dt><span class="refentrytitle"><a href="#tau_portal.py">tau_portal.py</a></span><span class="refpurpose"> - 
      This tool is design to interact with the TAU web portal (http://tau.nic.uoregon.edu). There are commands
      for uploading or downloading packed profile files form the TAU portal.
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_configure">taudb_configure</a></span><span class="refpurpose"> - 
     Configuration program for a PerfDMF database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createapp">perfdmf_createapp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a application in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#perfdmf_createexp">perfdmf_createexp</a></span><span class="refpurpose"> - Deprecated
      Command line tool to create a experiment in the perfdmf database. (Deprecated)
    </span></dt><dt><span class="refentrytitle"><a href="#taudb_loadtrial">taudb_loadtrial</a></span><span class="refpurpose"> - 
      Command line tool to load a trial into the TAUdb database.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer">perfexplorer</a></span><span class="refpurpose"> - 
      Launches TAU's Performance Data Mining Analyzer.
    </span></dt><dt><span class="refentrytitle"><a href="#perfexplorer_configure">perfexplorer_configure</a></span><span class="refpurpose"> - 
	Configures a TAUdb database for use with perfexplorer, and installs necessary JAR files.
    </span></dt><dt><span class="refentrytitle"><a href="#taucc.man">taucc</a></span><span class="refpurpose"> - 
      C compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauupc.man">tauupc</a></span><span class="refpurpose"> - 
      UPC wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#taucxx.man">taucxx</a></span><span class="refpurpose"> - 
      C++ compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#tauf90.man">tauf90</a></span><span class="refpurpose"> - 
      Fortran compiler wrapper for TAU
    </span></dt><dt><span class="refentrytitle"><a href="#paraprof.man">paraprof</a></span><span class="refpurpose"> - 
      Launches TAU's Java-based performance data viewer.
    </span></dt><dt><span class="refentrytitle"><a href="#pprof.man">pprof</a></span><span class="refpurpose"> - 
      Quickly diplays profile data.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_instrumentor">tau_instrumentor</a></span><span class="refpurpose"> - 
      automaticly instruments a source basied on information provided by pdt.
    </span></dt><dt><span class="refentrytitle"><a href="#vtfconverter">vtfconverter</a></span><span class="refpurpose"> - 
      
    </span></dt><dt><span class="refentrytitle"><a href="#tau_setup">tau_setup</a></span><span class="refpurpose"> - 
      Launches GUI interface to configure TAU.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_wrap">tau_wrap</a></span><span class="refpurpose"> - 
      Instruments an external library with TAU without needing to recompile
    </span></dt><dt><span class="refentrytitle"><a href="#tau_gen_wrapper">tau_gen_wrapper</a></span><span class="refpurpose"> - 
     Generates a wrapper library that can intercept 
 at link time or at runtime routines specified in a header file
    </span></dt><dt><span class="refentrytitle"><a href="#tau_pin">tau_pin</a></span><span class="refpurpose"> - 
      Instruments application at run time using Intel's PIN library
    </span></dt><dt><span class="refentrytitle"><a href="#tau_java">tau_java</a></span><span class="refpurpose"> - 
      Instruments java applications at runtime using JVMTI
    </span></dt><dt><span class="refentrytitle"><a href="#tau_cupti_avail">tau_cupti_avail</a></span><span class="refpurpose"> - 
			Detects the available CUPTI counters on the a each GPU device.
    </span></dt><dt><span class="refentrytitle"><a href="#tau_run">tau_run</a></span><span class="refpurpose"> - 
 Instruments and executes binaries to generate performance data. (DyninstAPI based instrumentor)
    </span></dt><dt><span class="refentrytitle"><a href="#tau_rewrite">tau_rewrite</a></span><span class="refpurpose"> - 
           Rewrites binaries using Maqao if Tau is configured using PDT 3.17+ at the routine level. 
          If it doesn't find the Maqao package from PDT 3.17, it reverts to tau_run (DyninstAPI based instrumentor). 
    </span></dt></dl></div><div class="refentry" lang="en"><a name="tau_compiler.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_compiler.sh &#8212; Instrumenting source files.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_compiler.sh</code>  [
	<code class="option">-p</code>
	<em class="replaceable"><code>profile</code></em>
      ] [<code class="option">-optVerbose</code>
        ] [<code class="option">-optQuiet</code>
        ] [<code class="option">-optPdtDir=</code><em class="replaceable"><code>dir</code></em>
        ] [<code class="option">-optPdtF95Opts=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtF95Reset=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtCOpts=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtCReset=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtCxxOpts=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtCReset=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optPdtF90Parser=</code><em class="replaceable"><code>parser</code></em>
        ] [<code class="option">-optGnuFortranParser</code>
        ] [<code class="option">-optGnuCleanscapeParser</code>
        ] [<code class="option">-optPdtUser=</code><em class="replaceable"><code>opts</code></em>
        ] [<code class="option">-optTauInstr=</code><em class="replaceable"><code>path</code></em>
        ] [<code class="option">-optDetectMemoryLeaks</code>
] [<code class="option">-optIncludeMemory</code>
] [<code class="option">-optTrackUPCR</code>
] [<code class="option">-optPreProcess</code>
] [<code class="option">-optCPP=</code><em class="replaceable"><code>path</code></em>
] [<code class="option">-optCPPOpts=</code><em class="replaceable"><code>options</code></em>
] [<code class="option">-optCPPReset=</code><em class="replaceable"><code>options</code></em>
] [<code class="option">-optTauSelectFile=</code><em class="replaceable"><code>file</code></em>
        ] [
                <code class="option">-optPDBFile=</code><em class="replaceable"><code>file</code></em>
        ] [
                <code class="option">-optTau=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optCompile=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optTauDefs=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optTauIncludes=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optReset=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optLinking=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optLinkReset=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optTauCC=</code><em class="replaceable"><code>cc</code></em>
        ] [
                <code class="option">-optOpariTool=</code><em class="replaceable"><code>path/opari</code></em>
        ] [
                <code class="option">-optOpariDir=</code><em class="replaceable"><code>path</code></em>
        ] [
                <code class="option">-optOpariOpts=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optOpariReset=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optOpari2Tool=</code><em class="replaceable"><code>path/opari2</code></em>
        ] [
                <code class="option">-optOpari2ConfigTool=</code><em class="replaceable"><code>path/opari2_config</code></em>
        ] [
                <code class="option">-optOpari2Dir=</code><em class="replaceable"><code>path</code></em>
        ] [
                <code class="option">-optOpari2Opts=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optOpari2Reset=</code><em class="replaceable"><code>opts</code></em>
        ] [
                <code class="option">-optNoMpi</code>
        ] [
                <code class="option">-optMpi</code>
        ] [
                <code class="option">-optNoRevert</code>
        ] [
                <code class="option">-optRevert</code>
        ] [
                <code class="option">-optKeepFiles</code>
        ] [<code class="option">-optAppC</code>
        ] [<code class="option">-optAppCXX</code>
        ] [<code class="option">-optAppF90</code>
        ] [<code class="option">-optShared</code>
        ] [<code class="option">-optCompInst</code>
        ] [<code class="option">-optPDTInst</code>
        ] [<code class="option">-optDisableHeaderInst</code>
        ] {
	<em class="replaceable"><code>compiler</code></em>
      } [
	<em class="replaceable"><code>compiler_options</code></em>
      ] [
                <code class="option">-optTauWrapFile=</code><em class="replaceable"><code>filename</code></em>
        ]</p></div></div><div class="refsect1" lang="en"><a name="d0e6521"></a><h2>Description</h2><p>
  The TAU Compiler provides a simple way to automatically instrument an entire project. The TAU Compiler can be used on C, C++, fixed form Fortran, and free form Fortran.
  </p></div><div class="refsect1" lang="en"><a name="d0e6526"></a><h2>Options</h2><p><code class="option">-optVerbose</code>
       Turn on verbose debugging messages.
   </p><p><code class="option">-optQuiet</code>
       Suppresses excessive output.
   </p><p><code class="option">-optDetectMemoryLeaks</code>
 Instructs TAU to detect any memory leaks in C/C++
programs.TAU then tracks the source location of the memory leak as
wellas the place in the callstack where the memory allocation
wasmade.
</p><p><code class="option">-optPdtDir=&lt;dir&gt;</code>
       The PDT architecture directory. Typically 
           <code class="option">$(PDTDIR)/$(PDTARCHDIR)</code>.
   </p><p><code class="option">-optPdtF95Opts=&lt;opts&gt;</code>
       Options for Fortran parser in PDT (f95parse).
   </p><p><code class="option">-optPdtF95Reset=&lt;opts&gt;</code>
       Reset options to the Fortran parser to the given list.
   </p><p><code class="option">-optPdtCOpts=&lt;opts&gt;</code>
       Options for C parser in PDT (cparse). Typically 
           <code class="option">$(TAU_MPI_INCLUDE) $(TAU_INCLUDE) $(TAU_DEFS)</code>.
       
   </p><p><code class="option">-optPdtCReset=&lt;opts&gt;</code>
       Reset options to the C parser to the given list
   </p><p><code class="option">-optPdtCxxOpts=&lt;opts&gt;</code>
Options for C++ parser in PDT (cxxparse).  Typically 
           <code class="option">$(TAU_MPI_INCLUDE) $(TAU_INCLUDE) $(TAU_DEFS)</code>.
       
   </p><p><code class="option">-optPdtCxxReset=&lt;opts&gt;</code>
       Reset options to the C++ parser to the given list
   </p><p><code class="option">-optPdtF90Parser=&lt;parser&gt;</code>
       Specify a different Fortran parser. For e.g., 
           <code class="option">f90parse</code> instead of 
           <code class="option">f95parse</code>.
   </p><p><code class="option">-optGnuFortranParser=&lt;parser&gt;</code>
       Specify the GNU <code class="option">gfortran</code> Fortran parser
<code class="option">gfparse</code>instead of
<code class="option">f95parse</code>

   </p><p><code class="option">-optGnuCleanscapeParser</code>
       Uses the Cleanscape Fortran parser
<code class="option">f95parse</code>instead of GNU's
<code class="option">gfparse</code>

   </p><p><code class="option">-optPdtUser=&lt;opts&gt;</code>
       Optional arguments for parsing source code.
   </p><p><code class="option">-optTauInstr=&lt;path&gt;</code>
       Specify location of tau_instrumentor. Typically 
           <code class="option">$(TAUROOT)/$(CONFIG_ARCH)/bin/tau_instrumentor</code>.
   </p><p><code class="option">-optIncludeMemory</code>
Forinteral use only
</p><p><code class="option">-optTrackUPCR</code>
Adds tracking of the UPC runtime library.
</p><p><code class="option">-optPreProcess</code>
       Preprocess the source code before parsing. Uses
/usr/bin/cpp-P by default.
   		
</p><p><code class="option">-optCPP=&lt;path&gt;</code>
       Specify an alternative preprocessor and pre-process the
sources.
   		
</p><p><code class="option">-optCPPOpts=&lt;options&gt;</code>
       
   		Specify additional options to the C pre-processor.
</p><p><code class="option">-optCPPReset=&lt;options&gt;</code>
       
ResetC preprocessor options to the specified list.

</p><p><code class="option">-optTauSelectFile=&lt;file&gt;</code>
       Specify selective instrumentation file for tau_instrumentor
   </p><p>
       
           <code class="option">-optPDBFile=&lt;file&gt;</code>
       
       
           Specify PDB file for tau_instrumentor. Skips parsing stage.
       
   </p><p>
       
           <code class="option">-optTau=&lt;opts&gt;</code>
       
       
           Specify options for tau_instrumentor.
       
   </p><p>
       
           <code class="option">-optCompile=&lt;opts&gt;</code>
       
       
           Options passed to the compiler. Typically 
           <code class="option">
               $(TAU_MPI_INCLUDE) $(TAU_INCLUDE) $(TAU_DEFS)
           </code>.
       
   </p><p>
       
           <code class="option">-optTauDefs=&lt;opts&gt;</code>
       
       
           Options passed to the compiler by TAU. Typically
	<code class="option">
           	$(TAU_DEFS)
	</code>.
       
   </p><p>
       
           <code class="option">-optTauIncludes=&lt;opts&gt;</code>
       
       
           Options passed to the compiler by TAU. Typically
	<code class="option">
	$(TAU_MPI_INCLUDE) $(TAU_INCLUDE)
	</code>.
       
   </p><p>
       
           <code class="option">-optReset=&lt;opts&gt;</code>
       
       
           Reset options to the compiler to the given list
       
   </p><p>
       
           <code class="option">-optLinking=&lt;opts&gt;</code>
       
       
           Options passed to the linker. Typically 
           <code class="option">$(TAU_MPI_FLIBS) $(TAU_LIBS) $(TAU_CXXLIBS)
           </code>.
       
   </p><p>
       
           <code class="option">-optLinkReset=&lt;opts&gt;</code>
       
       
           Reset options to the linker to the given list.
       
   </p><p>
       
           <code class="option">-optTauCC=&lt;cc&gt;</code>
       
       
           Specifies the C compiler used by TAU.
       
   </p><p>
       
           <code class="option">-optOpariTool=&lt;path/opari&gt;</code>
       
       
           Specifies the location of the Opari tool.
       
   </p><p>
       
           <code class="option">-optOpariDir=&lt;path&gt;</code>
       
       
           Specifies the location of the Opari directory.
       
   </p><p>
       
           <code class="option">-optOpariOpts=&lt;opts&gt;</code>
       
       
           Specifies optional arguments to the Opari tool.
       
   </p><p>
       
           <code class="option">-optOpariReset=&lt;opts&gt;</code>
       
       
           Resets options passed to the Opari tool.
       
   </p><p>
       
           <code class="option">-optNoMpi</code>
       
       
           Removes <code class="option">-l*mpi*</code> 
           libraries during linking (default).
       
   </p><p>
       
           <code class="option">-optMpi</code>
       
       
           Does not remove 
           <code class="option">-l*mpi*</code> 
           libraries during linking.
       
   </p><p>
       
           <code class="option">-optNoRevert</code>
       
       
           Exit on error. Does not revert to the original compilation
	rule on error.
       
   </p><p>
       
           <code class="option">-optRevert</code>
       
       
       Revert to the original compilation rule on error (default).

   </p><p>
       
           <code class="option">-optKeepFiles</code>
       
       
           Does not remove intermediate 
           <code class="option">.pdb</code> and 
           <code class="option">.inst.*</code> files.
       
   </p><p><code class="option">-optAppCC</code>
     
       Sets the failsafe C compiler.
     
   </p><p><code class="option">-optAppCXX</code>
     
       Sets the failsafe C++ compiler.
     
   </p><p><code class="option">-optAppF90</code>
     
       Sets the failsafe F90 compiler
     
   </p><p><code class="option">-optShared</code>
     
       Use shared library version of TAU
     
   </p><p><code class="option">-optCompInst</code>
     
       Use compiler-based instrumentation
     
   </p><p><code class="option">-optNoCompInst</code>
     
        Do not revert to compiler instrumentation if source instrumentation fails.     
   </p><p><code class="option">-optPDTInst</code>
     
       Use PDT-based instrumentation
     
   </p><p><code class="option">-optHeaderInst</code>
     
      Enable instrumentation of headers
     
   </p><p><code class="option">-optDisableHeaderInst</code>
     
       Disable instrumentation of headers
     
   </p><p><code class="option">-optTrackIO</code>
        Specify wrapping of POSIX I/O calls at link time.
     
   </p><p><code class="option">-optWrappersDir=""</code>
     
      Specify the location of the link wrappers directory.     
   </p><p><code class="option">-optTauUseCXXForC</code>
     
       Specifies the use of a C++ compiler for compiling C code
     
   </p><p><code class="option">-optTauWrapFile=&lt;filename&gt;</code>
     
       Specify path to the link_options.tau file generated by tau_wrap
     
   </p><p><code class="option">-optFixHashIf</code>
    
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="vtf2profile"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>vtf2profile &#8212; Generate a TAU profile set from a vampir trace file</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">vtf2profile</code>  [
	<code class="option">-p</code>
	<em class="replaceable"><code>profile</code></em>
      ] [
	<code class="option">-i</code>
	<em class="replaceable"><code>interval_start</code></em>
	<em class="replaceable"><code>interval_end</code></em>
      ] [
	<code class="option">-c</code>
      ] [
	<code class="option">-h</code>
      ] {
	<code class="option">-f</code>
	<em class="replaceable"><code>tracefile</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e6873"></a><h2>Description</h2><p>
    vtf2profile is created when TAU is configured with the -vtf=&lt;vtf_dir&gt;
    option.  This tool converts a VTF trace file (*.vpt) to a tau profile set
    (profile.A.B.C where A, B and C are the node, context and thread numbers
    respectively).
  </p><p>
    The vtf file to be read is specified in the command line by the -f flag
    followed by the file's location.  The VTF tracefile specified may be in gzipped
    form, eg app.vpt.gz.  -p is similarly used to specify the relative path to the
    directory where the profile files should be stored.  If no output directory is
    specified the current directory will be used.  A contiguous interval within the
    vtf file may be selected for conversion by using the -i flag followed by two
    integers, representing the timestamp of the start and end of the desired
    interval respectively.  The entire vtf file is converted if no interval is
    given.
  </p></div><div class="refsect1" lang="en"><a name="d0e6880"></a><h2>Options</h2><p>
    <code class="option">-f tracefile</code>
    -Specify the Vampir tracefile to be converted.
  </p><p>
    <code class="option">-p profile</code>
    -Specify the location where the profile file(s) should be written.
  </p><p>
    <code class="option">-i interval_start interval_end</code>
    -Limit the profile produced to the specified interval within the vampir trace file.
  </p><p>	
    <code class="option">-c</code>	-Opens a command line interface for the program.
  </p><p>	
    <code class="option">-h</code>	-Displays a help message.
  </p></div><div class="refsect1" lang="en"><a name="d0e6908"></a><h2>Examples</h2><p>
    To convert a vampir tracefile, trace.vpt, to an equivalent TAU profile, use the following:
    </p><pre class="screen">
vtf2profile -f trace.vpt
    </pre><p>
    To produce a TAU profile in the ./profiles directory representing only the
    events from the start of the tracefile to timestamp 6000, use:
    </p><pre class="screen">
vtf2profile -f trace.vpt -p ./profiles -i 0 6000
    </pre><p>
  </p></div><div class="refsect1" lang="en"><a name="d0e6919"></a><h2>See Also</h2><p>
    <a href="#tau2vtf" title="tau2vtf"><span class="refentrytitle">tau2vtf</span></a>,
    <a href="#trace2profile" title="trace2profile"><span class="refentrytitle">trace2profile</span></a>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau2vtf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau2vtf &#8212; convert TAU tracefiles to vampir tracefiles</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2vtf</code>  [
	<code class="option">-nomessage</code>
      ] [
	<code class="option">-v</code>
      ] [[
	  <code class="option">-a</code>
	] |  [
	  <code class="option">-fa</code>
	]] {
	<em class="replaceable"><code>tau_tracefile</code></em>
      } {
	<em class="replaceable"><code>tau_eventfile</code></em>
      } {
	<em class="replaceable"><code>vtf_tracefile</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e6980"></a><h2>Description</h2><p>
      This program is generated when TAU is configured with the -vtf=&lt;vtf_dir&gt;
      option.
    </p><p>
      The tau2vtf trace converter takes a single tau_tracefile (*.trc) and
      tau_eventfile (*.edf) and produces a corresponding vtf_tracefile
      (*.vtf).  The input files and output file must be specified in that
      order.  Multi-file TAU traces must be merged before conversion.
    </p><p>
      The default output file format is VTF3 binary.  If the output filename
      is given as the .vpt.gz type, rather than .vpt, the output file will be
      gzipped.  There are two additional output format options.  The command
      line argument '-a' produces the vtf file output in ASCII VTF3 format.
      The command line argument '-fa' produces the vtf file output in the FAST
      ASCII VTF3 format.  Note that these arguments are mutually exclusive.
    </p></div><div class="refsect1" lang="en"><a name="d0e6989"></a><h2>Options</h2><p>
      <code class="option">-nomessage</code> Suppresses printing of message information in the trace.
    </p><p>
      <code class="option">-v</code>    Verbose mode sends trace event
      descriptions to the standard output as they are converted.
    </p><p> 
      <code class="option">-a</code>     Print the vtf file output in the
      human-readable VTF3 ASCII format 
    </p><p> 
      <code class="option">-fa</code> Print the vtf file in the simplified human-readable
      FAST ASCII VTF3 format
    </p></div><div class="refsect1" lang="en"><a name="d0e7012"></a><h2>Examples</h2><p>
      The program must be run with the tau trace, tau event and vtf output
      files specified in the command line in that order.  Any additional
      arguments follow.  The following will produce a VTF, app.vpt, from the
      TAU trace and event files merged.trc and tau.edf trace file:
      </p><pre class="screen">
tau2vtf merged.trc tau.edf app.vpt
      </pre><p>
      The following will convert merged.trc and tau.edf to a gzipped FAST
      ASCII vampir tracefile app.vpt.gz, with message events omitted:
      </p><pre class="screen">
tau2vtf merged.trc tau.edf app.vpt.gz -nomessage -fa
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7023"></a><h2>See Also</h2><p>
      <a href="#vtf2profile" title="vtf2profile"><span class="refentrytitle">vtf2profile</span></a>,
      <a href="#trace2profile" title="trace2profile"><span class="refentrytitle">trace2profile</span></a>,
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>,
      <a href="#tau_convert" title="tau_convert"><span class="refentrytitle">tau_convert</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="trace2profile"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>trace2profile &#8212; convert TAU tracefiles to TAU profile files</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2vprofile</code>  [
	<code class="option">-d</code>
	<em class="replaceable"><code>directory</code></em>
      ] [
	<code class="option">-s</code>
	<em class="replaceable"><code>snapshot_interval</code></em>
      ] {
	<em class="replaceable"><code>tau_tracefile</code></em>
      } {
	<em class="replaceable"><code>tau_eventfile</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e7078"></a><h2>Description</h2><p>
      This program is generated when TAU is configured with the -TRACE
      option.
    </p><p>
      The trace2profile converter takes a single tau_tracefile (*.trc) and
      tau_eventfile (*.edf) and produces a corresponding series of profile files.  The input files must be specified in that order, with optinal parameters coming afterward.  Multi-file TAU traces must be merged before conversion.
    </p></div><div class="refsect1" lang="en"><a name="d0e7085"></a><h2>Options</h2><p>
      <code class="option">-d</code> Output profile files to the specified 'directory' rather than the current directory.
    </p><p>
      <code class="option">-s</code> Output a profile snapshot showing the state of the profile data accumulated from the trace every 'snapshot_interval' time units.  The snapshot profiles are placed sequentially in directories labled 'snapshot_n' where 'n' is an integer ranging from 0 to to the total number of snapshots -1.
    </p></div><div class="refsect1" lang="en"><a name="d0e7098"></a><h2>Examples</h2><p>
      The program must be run with the tau trace and tau event files specified in the command line in that order.  Any additional arguments follow.  The following will produce a profile file array, from the
      TAU trace and event files merged.trc and tau.edf trace file:
      </p><pre class="screen">
trace2profile merged.trc tau.edf
      </pre><p>
      The following will convert merged.trc and tau.edf to a series of profiles one directory higher.  It will also produce a profile snapshot every 250,000 time units:
      </p><pre class="screen">
trace2profile merged.trc tau.edf -d ./.. -s 250000
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7109"></a><h2>See Also</h2><p>
      <a href="#vtf2profile" title="vtf2profile"><span class="refentrytitle">vtf2profile</span></a>,
      <a href="#tau2vtf" title="tau2vtf"><span class="refentrytitle">tau2vtf</span></a>,
      <a href="#tau2otf" title="tau2otf"><span class="refentrytitle">tau2otf</span></a>,
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>,
      <a href="#tau_convert" title="tau_convert"><span class="refentrytitle">tau_convert</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau2elg"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau2elg &#8212; convert TAU tracefiles to Epilog tracefiles</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2elg</code>  [
	<code class="option">-nomessage</code>
      ] [
	<code class="option">-v</code>
      ] {
	<em class="replaceable"><code>tau_tracefile</code></em>
      } {
	<em class="replaceable"><code>tau_eventfile</code></em>
      } {
	<em class="replaceable"><code>elg_tracefile</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e7165"></a><h2>Description</h2><p>
      This program is generated when TAU is configured with the -epilog=&lt;epilog_dir&gt; option.
    </p><p>
      The tau2elg trace converter takes a tau trace file (*.trc) and event definition file (*.edf) and produces a corresponding epilog binary trace file (*.elg). Multi-file TAU traces must be merged before conversion.
    </p></div><div class="refsect1" lang="en"><a name="d0e7172"></a><h2>Options</h2><p>
      <code class="option">-nomessage</code>
      Suppresses printing of message information in the trace.
    </p><p><code class="option">-v</code>	
    Verbose mode sends trace event descriptions to the standard output as they are converted.
    </p></div><div class="refsect1" lang="en"><a name="d0e7184"></a><h2>Examples</h2><p>
      The program must be run with the tau trace, tau event and elg output
      files specified in the command line in that order.  Any additional
      arguments follow.  The following would convert merged.trc and tau.edf to
      the Epilog tracefile app.elg, with message events omitted:
      </p><pre class="screen">
./tau2vtf merged.trc tau.edf app.elg -nomessage
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7192"></a><h2>See Also</h2><p>
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau2slog2"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau2slog2 &#8212; convert TAU tracefiles to SLOG2 tracefiles</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2slog2</code>  [
	<code class="option">options</code>
      ] {
	<em class="replaceable"><code>tau_tracefile</code></em>
      } {
	<em class="replaceable"><code>tau_eventfile</code></em>
      } {
	<code class="option">-o</code>
	<em class="replaceable"><code>output.slog2</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e7238"></a><h2>Description</h2><p>
      This program is generated when TAU is configured with the -slog2 or -slog2=&lt;slog2_dir&gt; option.
    </p><p>
      The tau2slog2 trace converter takes a single tau trace file (*.trc) and
      event definition file (*.edf) and produces a corresponding slog2 binary
      trace file (*.slog2).
    </p><p>
      The tau2slog2 converter is called from the command line with the
      locations of the tau trace and event files.  These arguments must be
      followed by the -o flag and the name of the slog2 file to be written.
      tau2slog 2 accepts no other arguments.
    </p></div><div class="refsect1" lang="en"><a name="d0e7247"></a><h2>Options</h2><p>
      <code class="option">[-h|--h|-help|--help]</code>
      Display HELP message.
    </p><p><code class="option"> [-tc]</code>	
    Check increasing endtime order, exit when 1st violation occurs.
    </p><p><code class="option"> [-tcc]</code>	
    Check increasing endtime order,continue when violations occur.
    </p><p><code class="option"> [-nc number]</code>	
    Number of childern per node (default is 2)
    </p><p><code class="option"> [-ls number]</code>	
    Max byte size of leaf nodes (default is 65536)
    </p><p><code class="option"> [-o output.slog2]</code>	
    Output filename with slog2 suffix
    </p></div><div class="refsect1" lang="en"><a name="d0e7275"></a><h2>Examples</h2><p>
      A typical invocation of the converter, to create app.slog2, is as follows:
      </p><pre class="screen">
tau2slog2 app.trc tau.edf -o app.slog2
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7283"></a><h2>See Also</h2><p>
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>,
      <a href="#tau_convert" title="tau_convert"><span class="refentrytitle">tau_convert</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau2otf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau2otf &#8212; convert TAU tracefiles to OTF
	 tracefiles for Vampir/VNG
	 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2otf</code>  [
	<code class="option">-n</code>
	<em class="replaceable"><code>streams</code></em>
      ] [
	<code class="option">-nomessage</code>
      ] [
	<code class="option">-v</code>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e7326"></a><h2>Description</h2><p>
	 This program is generated when TAU is configured with the
	        -otf=&lt;otf_dir&gt; option.
The tau2otf trace converter takes a TAU formatted tracefile (*.trc) and a TAU event description file (*.edf) and produces an output trace file in the Open Trace Format (OTF). The user may specify the number of output streams for OTF. The input files and output file must be specified in that order. TAU traces should be merged using tau_merge prior to conversion.
																	  
    </p></div><div class="refsect1" lang="en"><a name="d0e7331"></a><h2>Options</h2><p>
    <code class="option">-n</code> streams Specifies the number of output streams (default is 1).

	 <code class="option">-nomessage</code> Suppresses printing of message information in the trace.

	 <code class="option">-v</code> Verbose mode sends trace event descriptions to the standard output as they are converted.
	 </p></div><div class="refsect1" lang="en"><a name="d0e7345"></a><h2>Examples</h2><p>The program must be run with the tau trace, tau event and otf output files specified in the command line in that order. Any additional arguments follow. The following will produced an OTF file, a pp.otf and other related event and definition files, from the TAU trace and event files merged.trc and tau.edf trace file:
  	</p><pre class="screen">
tau2otf merged.trc tau.edf app.otf
</pre><p>

    </p></div><div class="refsect1" lang="en"><a name="d0e7353"></a><h2>See Also</h2><p>
 				tau2vtf(1), trace2profile(1), vtf2profile(1), tau_merge(1), tau_convert(1)
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau2otf2"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau2otf2 &#8212; convert TAU tracefiles to OTF2
	 tracefiles for Vampir/VNG
	 </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau2otf2</code>  [
	<code class="option">-n</code>
	<em class="replaceable"><code>streams</code></em>
      ] [
	<code class="option">-nomessage</code>
      ] [
	<code class="option">-v</code>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e7391"></a><h2>Description</h2><p>
	 This program is generated when TAU is configured with the
	        -otf=&lt;otf_dir&gt; option.
The tau2otf2 trace converter takes a TAU formatted tracefile (*.trc) and a TAU
event description file (*.edf) and produces an output trace file in the Open
Trace Format (OTF2). The user may specify the number of output streams for OTF2. The input files and output file must be specified in that order. TAU traces should be merged using tau_merge prior to conversion.
																	  
    </p></div><div class="refsect1" lang="en"><a name="d0e7396"></a><h2>Options</h2><p>
    <code class="option">-n</code> streams Specifies the number of output streams (default is 1).

	 <code class="option">-nomessage</code> Suppresses printing of message information in the trace.

	 <code class="option">-v</code> Verbose mode sends trace event descriptions to the standard output as they are converted.
	 </p></div><div class="refsect1" lang="en"><a name="d0e7410"></a><h2>Examples</h2><p>The program must be run with the tau trace, tau event and otf2 output
		files specified in the command line in that order. Any additional arguments
		follow. The following will produced an OTF2 file, a pp.otf2 and other related event and definition files, from the TAU trace and event files merged.trc and tau.edf trace file:
  	</p><pre class="screen">
tau2otf2 merged.trc tau.edf app.otf2
</pre><p>

    </p></div><div class="refsect1" lang="en"><a name="d0e7418"></a><h2>See Also</h2><p>
 				tau2vtf(1), trace2profile(1), vtf2profile(1), tau_merge(1), tau_convert(1)
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="perf2tau"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>perf2tau &#8212; converts PerfLib profiles to TAU profile files</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">perf2tau</code>  {
	<em class="replaceable"><code>data_directory</code></em>
      } [
	<code class="option">-h</code>
      ] [
	<code class="option">-flat</code>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e7454"></a><h2>Description</h2><p>
    Converts perflib data to TAU format. 
    </p><p>
   If an argument is not specified, it checks the perf_data_directory
   environment variable. Then opens perf_data.timing directory to read perflib
   data If no args are specified, it tries to read
   perf_data.&lt;current_date&gt; file.
    </p></div><div class="refsect1" lang="en"><a name="d0e7461"></a><h2>Options</h2><p>
      <code class="option">-h</code>
      Display the help information.
    </p><p>
      <code class="option">-flat</code>
      Suppresses callpath profiles, each callpath profile will be flattened to
      show only the function profile.
    </p></div><div class="refsect1" lang="en"><a name="d0e7474"></a><h2>Examples</h2><p>
      </p><pre class="screen">
%&gt; perf2tau timing
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7482"></a><h2>See Also</h2><p>
      <a href="#vtf2profile" title="vtf2profile"><span class="refentrytitle">vtf2profile</span></a>,
      <a href="#tau2vtf" title="tau2vtf"><span class="refentrytitle">tau2vtf</span></a>,
      <a href="#tau2otf" title="tau2otf"><span class="refentrytitle">tau2otf</span></a>,
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>,
      <a href="#tau_convert" title="tau_convert"><span class="refentrytitle">tau_convert</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_merge"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_merge &#8212; combine multiple node and or thread TAU tracefiles into a
    merged tracefile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_merge</code>  [
	<code class="option">-a</code>
      ] [
	<code class="option">-r</code>
      ] [
	<code class="option">-n</code>
      ] [
	<code class="option">-e</code>
	<em class="replaceable"><code>eventfile_list</code></em>
      ] [
	<code class="option">-m</code>
	<em class="replaceable"><code>output_eventfile</code></em>
      ] {
	<em class="replaceable"><code>tracefile_list</code></em>
      } [{
	  <em class="replaceable"><code>output_tracefile</code></em>
	} |  {
	  <em class="replaceable"><code> - </code></em>
	}]</p></div></div><div class="refsect1" lang="en"><a name="d0e7560"></a><h2>Description</h2><p>
      tau_merge is generated when TAU is configured with the -TRACE option.  
    </p><p>
      This tool assembles a set of tau trace and event files from multiple
      multiple nodes or threads across a program's execution into a single
      unified trace file.  Many TAU trace file tools operate on merged trace
      files.
    </p><p>
      Minimally, tau_merge must be invoked with a list of unmerged trace files
      followed by the desired name of the merged trace file or the - flag to
      send the output to the standard out.  Typically the list can be
      designated by giving the shared name of the trace files to be merged
      followed by desired range of thread or node designators in brackets or
      the wild card character '*' to encompass variable thread and node
      designations in the filename (trace.A.B.C.trc where A, B and C are the
      node, context and thread numbers respectively).  For example
      tautrace.*.trc would represent all tracefiles in a given directory while
      tautrace.[0-5].0.0.trc would represent the tracefiles of nodes 0 through
      5 with context 0 and thread 0.
    </p><p>
      tau_merge will generate the specified merged trace file and an event
      definition file, tau.edf by default.
    </p><p>
      The event definition file can be given an alternative name by using the
      '-m' flag followed by the desired filename.  A list of event definition
      files to be merged can be designated explicitly by using the '-e' flag
      followed by a list of unmerged .edf files, specified in the same manner
      as the trace file list.
    </p><p>
      If computational resources are insufficient to merge all trace and event
      files simultaneously the process may be undertaken
      hierarchically. Corresponding subsets of the tracefiles and eventfiles
      may be merged in sequence to produce a smaller set of files that can then
      be to merged into a singular fully merged tracefile and eventfile.
      E.g. for a 100 node trace, trace sets 1-10, 11-20, ..., 91-100 could be
      merged into traces 1a, 2a, ..., 10a.  Then 1a-10a could be merged to
      create a fully merged tracefile.
    </p></div><div class="refsect1" lang="en"><a name="d0e7575"></a><h2>Options</h2><p><code class="option">-e</code> eventfile_list explicitly define the eventfiles to be
    merged</p><p><code class="option">-m</code> output_eventfile explicitly name the merged
    eventfile to be created</p><p><code class="option">-</code>	send the merged tracefile to the standard out</p><p><code class="option">-a</code>	adjust earliest timestamp time to zero</p><p><code class="option">-r</code>	do not reassemble long events</p><p><code class="option">-n</code> do not block waiting for new events.  By default
    tau_merge will block and wait for new events to be appended if a tracefile
    is incomplete.  This command allows offline merging of (potentially)
    incomplete tracefiles.
    </p></div><div class="refsect1" lang="en"><a name="d0e7602"></a><h2>Examples</h2><p>
      To merge all TAU tracefiles into app.trc and produce a merged tau.edf eventfile:
      </p><pre class="screen">
tau_merge *.trc app.trc
      </pre><p>
      To merge all eventfiles 0-255 into ev0_255merged.edf and TAU tracefiles
      for nodes 0-255 into the standard out:
      </p><pre class="screen">
tau_merge -e events.[0-255].edf -m ev0_255merged.edf \
  tautrace.[0-255].*.trc -
      </pre><p>
      To merge eventfiles 0, 5 and seven info ev057.edf and tau tracefiles for
      nodes 0, 5 and 7 with context and thread 0 into app.trc:
      </p><pre class="screen">
tau_merge -e events.0.edf events.5.edf events.7.edf -m ev057.edf \
  tautrace.0.0.0.trc tautrace.5.0.0.trc tautrace.7.0.0.trc app.trc
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7616"></a><h2>See Also</h2><p><a href="#tau_convert" title="tau_convert">tau_convert</a></p><p><a href="#trace2profile" title="trace2profile">trace2profile</a></p><p><a href="#tau2vtf" title="tau2vtf">tau2vtf</a></p><p><a href="#tau2elg" title="tau2elg">tau2elg</a></p><p><a href="#tau2slog2" title="tau2slog2">tau2slog2</a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_treemerge.pl"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_treemerge.pl &#8212; combine multiple node and or thread TAU tracefiles into a
    merged tracefile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_treemerge.pl</code>  [
	<code class="option">-n</code>
	<em class="replaceable"><code>break_amount</code></em>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e7659"></a><h2>Description</h2><p>
      tau_treemerge.pl is generated when TAU is configured with the -TRACE option.  
    </p><p>
      This tool assembles a set of tau trace and event files from multiple
      multiple nodes or threads across a program's execution into a single
      unified trace file.  Many TAU trace file tools operate on merged trace
      files.
    </p><p>
      tau_treemerge.pl will generate the specified merged trace file and an event
      definition file, tau.edf by default.
    </p></div><div class="refsect1" lang="en"><a name="d0e7668"></a><h2>Options</h2><p><code class="option">-n</code> break_amount set the maximum number of trace files
    to merge in each invocation of tau_merge. If we need to merge 2000 trace
    files and if the maximum number of open files specified by unix is 250,
    tau_treemerge.pl will incrementally merge the trace files so as not to
    exceed the number of open file descriptors. 
    </p></div><div class="refsect1" lang="en"><a name="d0e7675"></a><h2>See Also</h2><p><a href="#tau_merge" title="tau_merge">tau_merge</a></p><p><a href="#tau_convert" title="tau_convert">tau_convert</a></p><p><a href="#trace2profile" title="trace2profile">trace2profile</a></p><p><a href="#tau2vtf" title="tau2vtf">tau2vtf</a></p><p><a href="#tau2elg" title="tau2elg">tau2elg</a></p><p><a href="#tau2slog2" title="tau2slog2">tau2slog2</a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_convert"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_convert &#8212; convert TAU tracefiles into various alternative trace formats</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_convert</code>  [[
	  <code class="option">-alog</code>
	] |  [
	  <code class="option">-SSDF</code>
	] |  [
	  <code class="option">-dump</code>
	] |  [
	  <code class="option">-paraver</code>
	   [-t]
	] |  [
	  <code class="option">-pv</code>
	] |  [
	  <code class="option">-vampir</code>
	  
	   [
	    <code class="option">-longsymbolbugfix</code>
	  ]
	   [
	    <code class="option">-compact</code>
	  ]
	   [[
	      <code class="option">-user</code>
	    ] |  [
	      <code class="option">-class</code>
	    ] |  [
	      <code class="option">-all</code>
	    ]]
	  
	   [
	    <code class="option">-nocomm</code>
	  ]
	  
	]] [
	<em class="replaceable"><code>outputtrc</code></em>
      ] {
	<em class="replaceable"><code>inputtrc</code></em>
      } {
	<em class="replaceable"><code>edffile</code></em>
      }</p></div></div><div class="refsect1" lang="en"><a name="d0e7796"></a><h2>Description</h2><p>
      tau_convert is generated when TAU is configured with the -TRACE option.
    </p><p>
      This program requires specification of a TAU tracefile and eventfile.  It
      will convert the given TAU traces to the ASCII-based trace format
      specified in the first argument.  The conversion type specification may
      be followed by additional options specific to the conversion type.  It
      defaults to the single threaded vampir format if no other format is
      specified.  tau_convert also accepts specification of an output file as
      the last argument.  If none is given it prints the converted data to the
      standard out.
    </p></div><div class="refsect1" lang="en"><a name="d0e7803"></a><h2>Options</h2><p><code class="option">-alog</code> convert TAU tracefile into the alog format
    (This format is deprecated.  The SLOG2 format is recommended.)</p><p><code class="option">-SDDF</code> convert TAU tracefile into the SDDF format</p><p><code class="option">-dump</code> convert TAU tracefile into multi-column human
    readable text</p><p><code class="option">-paraver</code> convert TAU tracefile into paraver
    format</p><p><code class="option">-t</code> indicate conversion of multi threaded TAU trace
    into paraver format</p><p><code class="option">-pv</code> convert single threaded TAU tracefile into
    vampir format (all -vampir options apply) (default)</p><p><code class="option">-vampir</code> convert multi threaded TAU tracefile into
    vampir format</p><p><code class="option">-longsymbolbugfix</code> make the first characters of
    long, similar identifier strings unique to avoid a bug in vampir</p><p><code class="option">-compact</code> abbreviate individual event entries</p><p><code class="option">-all</code>	compact all entries (default)</p><p><code class="option">-user</code> compact user entries only</p><p><code class="option">-class</code> compact class entries only</p><p><code class="option">-nocomm</code> disregard communication events</p><p><code class="option">[outputtrc]</code> specify the name of the output tracefile
    to be produced
    </p></div><div class="refsect1" lang="en"><a name="d0e7862"></a><h2>Examples</h2><p>
      To print the contents of a TAU tracefile to the screen:
      </p><pre class="screen">
tau_convert -dump app.trc tau.edf
      </pre><p>
      To convert a merged, threaded TAU tracefile to paraver format:
      </p><pre class="screen">	
tau_convert -paraver -t app.trc tau.edf app.pv 
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e7873"></a><h2>See Also</h2><p>
      <a href="#tau_merge" title="tau_merge"><span class="refentrytitle">tau_merge</span></a>,
      <a href="#tau2vtf" title="tau2vtf"><span class="refentrytitle">tau2vtf</span></a>,
      <a href="#trace2profile" title="trace2profile"><span class="refentrytitle">trace2profile</span></a>,
      <a href="#tau2slog2" title="tau2slog2"><span class="refentrytitle">tau2slog2</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_reduce"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_reduce &#8212; generates selective
    instrumentation rules based on profile data</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_reduce</code>  {
	<code class="option">-f</code>
	<em class="replaceable"><code>filename</code></em>
      } [
	<code class="option">-n</code>
      ] [
	<code class="option">-r</code>
	<em class="replaceable"><code>filename</code></em>
      ] [
	<code class="option">-o</code>
	<em class="replaceable"><code>filename</code></em>
      ] [
	<code class="option">-v</code>
      ] [
	<code class="option">-p</code>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e7941"></a><h2>Description</h2><p>
      tau_reduce is an application that will apply a set of user-defined rules
      to a pprof dump file (<span><strong class="command">pprof -d</strong></span>) in order to create a
      select file that will include an exclude list for selective
      implementation for TAU. The user must specify the name of the pprof dump
      file that this application will use.  This is done with the -f filename
      flag.  If no rule file is specified, then a single default rule will be
      applied to the file.  This rule is: numcalls &gt; 1000000 &amp;
      usecs/call &lt; 2, which will exclude all routines that are called at
      least 1,000,000 times and average less then two microseconds per call. If
      a rule file is specified, then this rule is not applied. If no output
      file is specified, then the results will be printed out to the screen.
    </p></div><div class="refsect1" lang="en"><a name="d0e7949"></a><h2>Rules</h2><p>
      Users can specify a set of rules for tau_reduce to apply.  The rules
      should be specified in a separate file, one rule per line, and the file
      name should be specifed with the appropriate option on the command line.
      The grammar for a rule is: [GROUPNAME:]FIELD OPERATOR NUMBER.  The
      GROUPNAME followed by the colon (:) is optional.  If included, the rule
      will only be applied to routines that are a member of the group
      specified.  Only one group name can be applied to each rule, and a rule
      must follow a groupname.  If only a groupname is given, then an
      unrecognized field error will be returned.  If the desired effect is to
      exclude all routines that belong to a certain group, then a trivial rule,
      such as GROUP:numcalls &gt; -1 may be applied.  If a groupnameis given,
      but the data does not contain any groupname data, then then an error
      message will be given, but the rule will still be applied to the date
      ignoring the groupname specification. A FIELD is any of the routine
      attributes listed in the following table:
    </p><pre class="screen">
ATTRIBUTE NAME     MEANING	
numcalls           Number of times the routine is called	
numsubrs           Number of subroutines that the routine contains	
percent            Percent of total implementation time	
usec               Exclusive routine running time, in microseconds	
cumusec            Inclusive routine running time, in microseconds	
count              Exclusive hardware count	
totalcount         Inclusive hardware count	
stddev             Standard deviation	
usecs/call         Microseconds per call	
counts/call        Hardware counts per call
    </pre><div class="table"><a name="d0e7956"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Selection Attributes</b></p><table summary="Selection Attributes" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">ATTRIBUTE NAME</th><th align="left">MEANING</th></tr></thead><tbody><tr><td align="left">numcalls</td><td align="left">Number of times the routine is called</td></tr><tr><td align="left">numsubrs</td><td align="left">Number of subroutines that the routine contains</td></tr><tr><td align="left">percent</td><td align="left">Percent of total implementation time</td></tr><tr><td align="left">usec</td><td align="left">Exclusive routine running time, in microseconds</td></tr><tr><td align="left">cumusec</td><td align="left">Inclusive routine running time, in microseconds</td></tr><tr><td align="left">count</td><td align="left">Exclusive hardware count</td></tr><tr><td align="left">totalcount</td><td align="left">Inclusive hardware count</td></tr><tr><td align="left">stddev</td><td align="left">Standard deviation</td></tr><tr><td align="left">usecs/call</td><td align="left">Microseconds per call</td></tr><tr><td align="left">counts/call</td><td align="left">Hardware counts per call</td></tr></tbody></table></div><p>
      Some FIELDS are only available for certain files.  If hardware counters
      are used, then usec, cumusec, usecs/per call are not applicable and a
      error is reported.  The opposite is true if timing data is used rather
      than hardware counters.  Also, stddev is only available for certain files
      that contain that data.
    </p><p>
      An OPERATOR is any of the following: &lt; (less than), &gt; (greater
      than), or = (equals).
    </p><p>
      A NUMBER is any number.
    </p><p>
      A compound rule may be formed by using the &amp; (and) symbol in between
      two simple rules.  There is no "OR" because there is an implied or
      between two separate simple rules, each on a separate line.  (ie the
      compound rule usec &lt; 1000 OR numcalls = 1 is the same as the two
      simple rules "usec &lt; 1000" and "numcalls = 1").
    </p></div><div class="refsect1" lang="en"><a name="d0e8027"></a><h2>Rule Examples</h2><pre class="screen">
#exclude all routines that are members of TAU_USER and have less than
#1000 microseconds
TAU_USER:usec &lt; 1000

#exclude all routines that have less than 1000 microseconds and are
#called only once.
usec &lt; 1000 &amp; numcalls = 1

#exclude all routines that have less than 1000 usecs per call OR have a percent
#less than 5
usecs/call &lt; 1000
percent &lt; 5
    </pre><p>
      NOTE: Any line in the rule file that begins with a # is a comment
      line. For clarity, blank lines may be inserted in between rules and will
      also be ignored.
    </p></div><div class="refsect1" lang="en"><a name="d0e8034"></a><h2>Options</h2><p><code class="option">-f</code> filename specify filename of pprof dump
    file</p><p><code class="option">-p</code> print out all functions with their
    attributes</p><p><code class="option">-o</code> filename specify filename for select file output
    (default: print to screen</p><p><code class="option">-r</code> filename specify filename for rule file</p><p><code class="option">-v</code> verbose mode (for each rule, print out rule and
    all functions that it excludes)
    </p></div><div class="refsect1" lang="en"><a name="d0e8057"></a><h2>Examples</h2><p>
      To print to the screen the selective instrumentation list for the
      paraprof dump file app.prf with default selection rules use:
      </p><pre class="screen">
tau_reduce -f app.prf
      </pre><p>
      To create a selection file, app.sel, from the paraprof dump file
      app.prf using rules specified in foo.rlf use:
      </p><pre class="screen">
tau_reduce -f app.prf -r foo.rlf -o app.sel
      </pre><p>
    </p></div><div class="refsect1" lang="en"><a name="d0e8068"></a><h2>See Also</h2><p>
      
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_ompcheck"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_ompcheck &#8212; Completes uncompleted do/for/parallel omp directives</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_ompcheck</code>  {
	<em class="replaceable"><code>pdbfile</code></em>
      } {
	<em class="replaceable"><code>sourcefile</code></em>
      } [
	<code class="option">-o</code>
	<em class="replaceable"><code>outfile</code></em>
      ] [
	<code class="option">-v</code>
      ] [
	<code class="option">-d</code>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e8116"></a><h2>Description</h2><p>
  Finds uncompleted do/for omp directives and inserts closing
	directives for each one uncompleted. do/for directives are
	expected immediately before a do/for loop. Closing directives are
	then placed immediately following the same do/for loop.
	</p></div><div class="refsect1" lang="en"><a name="d0e8121"></a><h2>Options</h2><p>
    <code class="option">pdbfile</code>
  A pdbfile generated from the source file you wish to check.
	This pdbfile must contain comments from which the omp
	directives are gathered. See pdbcomment for information on
	how to obtain comment from a pdbfile.
	</p><p>
    <code class="option">sourcefile</code>
	A fortran, C or C++ source file to analyzed.	
  </p><p>
    <code class="option">-o</code>
  write the output to the specified outfile.
	</p><p>	
    <code class="option">-v</code>verbose output, will say which directive where added.
  </p><p>	
    <code class="option">-d</code>
  debuging information, we suggest you pipe this unrestrained output to a file.
	</p></div><div class="refsect1" lang="en"><a name="d0e8149"></a><h2>Examples</h2><p>
    To check file: source.f90 do: (you will need pdtoolkit/&lt;arch&gt;/bin and
		tau/utils/ in your path).
    </p><pre class="screen">
%&gt;f95parse source.f90
%&gt;pdbcomment source.pdb &gt; source.comment.pdb
%&gt;tau_omp source.comment.pdb source.f90 -o source.chk.f90
    </pre><p>
  </p></div><div class="refsect1" lang="en"><a name="d0e8157"></a><h2>See Also</h2><p>
    f95parse pdbcomment
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_poe"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_poe &#8212; Instruments a MPI application while it is being executed with poe.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_poe</code>  [
	<code class="option">-XrunTAUsh-</code>
	<em class="replaceable"><code>tauOptions</code></em>
      ] {
	<em class="replaceable"><code>applcation</code></em>
			} [
	<em class="replaceable"><code>poe options</code></em>
			]</p></div></div><div class="refsect1" lang="en"><a name="d0e8195"></a><h2>Description</h2><p>
	This tool dynamically instruments a mpi application by loading a specific mpi
	library file. 
	</p></div><div class="refsect1" lang="en"><a name="d0e8200"></a><h2>Options</h2><p>
    <code class="option">tauOptions</code>
	To instrument a mpi application a specific TAU library file is loaded when the
	application is executed.
	To select which library is loaded use this option. The library files are build
	according to the options set when TAU is configured. The library file that have
	been build and thus available for use are in the [TAU_HOME]/[arch]/lib directory. The
	file are listed as libTAUsh-*.so where * is the instrumentation options. For
	example to use the libTAUsh-pdt-openmp-opari.so file let the comman line
	option be -XrunTAUsh-pdt-openmp-opari.
	</p></div><div class="refsect1" lang="en"><a name="d0e8208"></a><h2>Examples</h2><p>
    Instrument a.out wit the currently configured options and then run it on
		four nodes:
		</p><pre class="screen">
%&gt;tau_poe ./a.out -procs 4
    </pre><p>
  </p><p>
		Select the libTAUsh-mpi.so library to instrument a.out with:
		</p><pre class="screen">
%&gt;tau_poe -XrunTAUsh-mpi ./a.out -procs 4
		</pre><p>
	</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_validate"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_validate &#8212; Validates a TAU installation by performing
    various tests on each TAU stub Makefile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_validate</code>  [
	<code class="option">-v</code>
      ] [
	<code class="option">--html</code>
      ] [
	<code class="option">--build</code>
      ] [
	<code class="option">--run</code>
      ] [
	<code class="option">--tag</code>
      ] {
	<em class="replaceable"><code>arch directory</code></em>
			}</p></div></div><div class="refsect1" lang="en"><a name="d0e8266"></a><h2>Description</h2><p>
  tau_validate will attempt to validate a TAU installation by performing
  various tests on each TAU stub Makefile.  Some degree of logic exists
  to know where a given test applies to a given makefile, but it's not
  perfect.
	</p></div><div class="refsect1" lang="en"><a name="d0e8271"></a><h2>Options</h2><p>
    <code class="option">v</code>
	  Verbose output
  </p><p>
    <code class="option">html</code>
    Output results in HTML
  </p><p>
    <code class="option">build</code>
    Only build
  </p><p>
    <code class="option">run</code>
    Only run
  </p><p>
    <code class="option">tag</code>
    Only check configurations containing the tag. ie. <code class="literal">--tag
		papi</code> checks only
		libraries with the <code class="literal">-papi</code> in their name. 
  </p><p>
    <code class="option">arch directory</code>
    Specify an arch directory (e.g. rs6000), or the lib
    directory (rs6000/lib), or a specific makefile.
    Relative or absolute paths are ok.                          
  </p></div><div class="refsect1" lang="en"><a name="d0e8310"></a><h2>Example</h2><p>
    There is a few examples:
</p><pre class="screen">    
bash : ./tau_validate --html x86_64 &amp;&gt; results.html
tcsh : ./tau_validate --html x86_64 &gt;&amp; results.html
</pre><p>     
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tauex"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tauex &#8212; Allows you to choose a tau configuration at runtime</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tauex</code>  [
	<em class="replaceable"><code>OPTION</code></em>
      ] [--] {
  <em class="replaceable"><code>executable</code></em>
      } [
  <em class="replaceable"><code>executable options</code></em>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e8350"></a><h2>Description</h2><p>
    Use this script to dynamically load a TAU profiling/tracing library or to
      select which papi events/domain to use during execuation of the
      application. At runtime tauex will set the LD_LIBRARY_PATH and pass any
      other parameters (or papi events) to the program and execute it with the
      specified TAU measurement options.
  </p></div><div class="refsect1" lang="en"><a name="d0e8355"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term">-d</span></dt><dd><p>Enable debugging output, use repeatedly for more output.</p></dd><dt><span class="term">-h</span></dt><dd><p>Print help message.</p></dd><dt><span class="term">-i</span></dt><dd><p>Print information about the host machine.</p></dd><dt><span class="term">-s</span></dt><dd><p>Dump the shell environment variables and exit.</p></dd><dt><span class="term">-U</span></dt><dd><p>User mode counts</p></dd><dt><span class="term">-K</span></dt><dd><p>Kernel mode counts</p></dd><dt><span class="term">-S</span></dt><dd><p>Supervisor mode counts</p></dd><dt><span class="term">-I</span></dt><dd><p>Interrupt mode counts</p></dd><dt><span class="term">-l</span></dt><dd><p>List events</p></dd><dt><span class="term">-L &lt;event&gt;</span></dt><dd><p>Describe event</p></dd><dt><span class="term">-a</span></dt><dd><p>Count all native events (implies -m)</p></dd><dt><span class="term">-n</span></dt><dd><p>Multiple runs (enough runs of exe to gather all events)</p></dd><dt><span class="term">-e &lt;event&gt;</span></dt><dd><p>Specify PAPI preset or native event</p></dd><dt><span class="term">-T &lt;option&gt;</span></dt><dd><p>Specify TAU option</p></dd><dt><span class="term">-v</span></dt><dd><p>Debug/Verbose mode</p></dd><dt><span class="term">-XrunTAU-&lt;options&gt;</span></dt><dd><p>specify TAU library directly</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e8455"></a><h2>Notes</h2><p>Defaults if unspecified: -U -T MPI,PROFILE -e P_WALL_CLOCK_TIME
        MPI is assumed unless SERIAL is specified
        PROFILE is assumed unless one of TRACE, VAMPIRTRACE or EPILOG is specified
        P_WALL_CLOCK_TIME means count real time using fastest available timer</p></div><div class="refsect1" lang="en"><a name="d0e8460"></a><h2>Example</h2><p><code class="literal">mpirun -np 2 tauex -e PAPI_TOT_CYC -e PAPI_FP_OPS -T MPI,PROFILE --
     ./ring</code></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_exec"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_exec &#8212; TAU execution wrapping script</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_exec</code>  [
	<em class="replaceable"><code>options</code></em>
      ] [--] {
  <em class="replaceable"><code>exe</code></em>
      } [
  <em class="replaceable"><code>exe options</code></em>
      ]</p></div></div><div class="refsect1" lang="en"><a name="d0e8498"></a><h2>Description</h2><p>
    Use this script to perform memory or IO tracking on either an instrumented or
      uninstrumented executable.
  </p></div><div class="refsect1" lang="en"><a name="d0e8503"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term">-v</span></dt><dd><p>verbose mode</p></dd><dt><span class="term">-qsub</span></dt><dd><p>BG/P qsub mode</p></dd><dt><span class="term">-io</span></dt><dd><p>track io</p></dd><dt><span class="term">-memory</span></dt><dd><p>track memory</p></dd><dt><span class="term">-cuda</span></dt><dd><p>track GPU events via CUDA (Must be configured with -cuda=&lt;dir&gt;, Preferred of CUDA 4.0 or earlier)</p></dd><dt><span class="term">-cupti</span></dt><dd><p>track GPU events via Nvidia's CUPTI interface (Must be configured with -cupti=&lt;dir&gt;, Preferred for CUDA 4.1 or later).</p></dd><dt><span class="term">-um</span></dt><dd><p>in conjunction with -cupti adds support for the Unified Memory GPUs. Requires CUDA 6.5 or later.</p></dd><dt><span class="term">-opencl</span></dt><dd><p>track GPU events via OpenCL</p></dd><dt><span class="term">-openacc</span></dt><dd><p>track openacc events. Supports TAU configurations with -arch=craycnl or PGI compilers on x86_64 Linux</p></dd><dt><span class="term">-armci</span></dt><dd><p>track ARMCI events via PARMCI (Must be configured with -armci=&lt;dir&gt;)</p></dd><dt><span class="term">-ebs</span></dt><dd><p> enable Event-based sampling.  See README.sampling for more information</p></dd><dt><span class="term">-ebs_period=&lt;count &gt; </span></dt><dd><p>sampling period (default 1000)</p></dd><dt><span class="term">-ebs_source=&lt;counter&gt; </span></dt><dd><p>sets sampling metric (default "itimer")</p></dd><dt><span class="term">-T&lt;option&gt; </span></dt><dd><p>: specify TAU option</p></dd><dt><span class="term">-loadlib=&lt;file.so &gt; </span></dt><dd><p>: specify additional load library</p></dd><dt><span class="term">-XrunTAU-&lt;options&gt;</span></dt><dd><p>specify TAU library directly</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e8603"></a><h2>Notes</h2><p>Defaults if unspecified: -T MPI.
        MPI is assumed unless SERIAL is specified
      </p><p>CUDA kernel tracking is included, if A CUDA SYNC call is made after
			each kernel launch and <code class="literal">cudaThreadExit()</code> is called before the exit of each thread that uses CUDA.
			</p><p>OPENCL kernel tracking is included, if A OPENCL SYNC call is made after
			each kernel launch and <code class="literal">clReleaseContext()</code> is called before the exit of each thread that uses CUDA.
			</p></div><div class="refsect1" lang="en"><a name="d0e8618"></a><h2>Examples</h2><p><code class="literal">mpirun -np 2 tau_exec -io ./ring</code></p><p><code class="literal">mpirun -np 8 tau_exec -ebs -ebs_period=1000000 -ebs_source=PAPI_FP_INS ./ring</code></p><p><code class="literal">tau_exec -T serial,cupti -cupti ./matmult (Preferred for CUDA 4.1 or later)</code></p><p><code class="literal">tau_exec -T serial -cuda ./matmult (Preferred for CUDA 4.0 or earlier)</code></p><p><code class="literal">tau_exec -T serial -opencl (OPENCL)</code></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_timecorrect"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_timecorrect &#8212; Corrects and reorders the records of tau trace files.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_timecorrect</code>  {
	<em class="replaceable"><code>trace input file</code></em>
			} {
	<em class="replaceable"><code>EDF input file</code></em>
			} {
	<em class="replaceable"><code>trace output file</code></em>
			} {
	<em class="replaceable"><code>EDF input file</code></em>
			}</p></div></div><div class="refsect1" lang="en"><a name="d0e8671"></a><h2>Description</h2><p>
    This program takes in tau trace files, reorders and corrects the times of
    these records and then outputs the records to new trace files.  The time
    correction algorithm uses a logical clock algorithm with amortization. 
    This is done by adjusting the times of
    events such that the product of an effect happens after the cause of that
    effect.
	</p></div><div class="refsect1" lang="en"><a name="d0e8676"></a><h2>Options</h2><p>
    <code class="option">trace input file</code>
  </p><p>
    <code class="option">EDF input file</code>
  </p><p>
    <code class="option">trace output file</code>
  </p><p>
    <code class="option">EDF output file</code>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_throttle.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_throttle.sh &#8212; This tool generates a selective instrumentation file (called
    throttle.tau) from a program output that has "Disabling"
    messages.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_throttle.sh</code> </p></div></div><div class="refsect1" lang="en"><a name="d0e8714"></a><h2>Description</h2><p>
	    This tools will auto-generates a selective instrumenation file basied on
      output from a program that has the profiling of some its functions throttled. 
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_portal.py"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_portal.py &#8212; 
      This tool is design to interact with the TAU web portal (http://tau.nic.uoregon.edu). There are commands
      for uploading or downloading packed profile files form the TAU portal.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_portal.py</code>  [-help] [--help] {<em class="replaceable"><code>command</code></em>} {<em class="replaceable"><code>options</code></em>} [<em class="replaceable"><code>argument</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e8747"></a><h2>Description</h2><p>
   Each command will initate a transfer to profile data btween the TAU portal and either the filesytem (to be stored as ppk file) or to a PerfDMF database. See <code class="literal">tau_portal --help</code>
    for more information.
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="taudb_configure"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>taudb_configure &#8212; 
     Configuration program for a PerfDMF database.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">taudb_configure</code>  [-h,--help] [--create-default] [-g, --configFile <em class="replaceable"><code>configFile</code></em>] [-c, --config <em class="replaceable"><code>configuration_name</code></em>] [-t, --tauroot <em class="replaceable"><code>path</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e8786"></a><h2>Description</h2><p>
    This configuration script will create a new TAUdb database. 
  </p></div><div class="refsect1" lang="en"><a name="d0e8791"></a><h2>Options</h2><p>-h, --help    show help
    </p><p>--create-default creates a H2 database with all the default values
     </p><p>-g, --configFile <em class="parameter"><code>configFile </code></em>
    specify the path to the file that defines the TAUdb
    configuration.
    </p><p>-c, --config <em class="parameter"><code>configuration_name </code></em>
    specify the name of the TAUdb
    configuration -c foo is equalivent to -g
    <code class="literal">&lt;home&gt;/.ParaProf/perfdmf.cfg.foo</code>.
    </p><p>-t, --tauroot <em class="parameter"><code>path </code></em> Path to the root directory of tau.
        </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="perfdmf_createapp"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>perfdmf_createapp &#8212; <span class="emphasis"><em>Deprecated</em></span>
      Command line tool to create a application in the perfdmf database. <span class="emphasis"><em>(Deprecated)</em></span>
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">perfdmf_createapp</code>  [-h, --help ] [-g, --configFile <em class="replaceable"><code>configFile</code></em>] [-c, --config <em class="replaceable"><code>configuration_name</code></em>] [-a, --applicationid <em class="replaceable"><code>applicationID</code></em>] {-n, --name <em class="replaceable"><code>name</code></em>}</p></div></div><div class="refsect1" lang="en"><a name="d0e8854"></a><h2>Description</h2><p>
    This script will create a new application in the perfdmf database. 
  </p></div><div class="refsect1" lang="en"><a name="d0e8859"></a><h2>Options</h2><p>-g, --configFile <em class="parameter"><code>configFile </code></em>
    specify the path to the file that defines the perfdmf
    configuration.
    </p><p>-c, --config <em class="parameter"><code>configuration_name </code></em>
    specify the name of the perfdmf
    configuration -c foo is equalivent to -g
    <code class="literal">&lt;home&gt;/.ParaProf/perfdmf.cfg.foo</code>.
    </p><p>-a, --applicationid <em class="parameter"><code>applicationID </code></em>
    specify the id number of the newly added application (default uses 
    auto-increment).
    </p><p>-n, --name <em class="parameter"><code>name </code></em> the name of the
    application.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="perfdmf_createexp"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>perfdmf_createexp &#8212; <span class="emphasis"><em>Deprecated</em></span>
      Command line tool to create a experiment in the perfdmf database. <span class="emphasis"><em>(Deprecated)</em></span>
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">perfdmf_createexp</code>  [-h, --help ] [-g, --configFile <em class="replaceable"><code>configFile</code></em>] [-c, --config <em class="replaceable"><code>configuration_name</code></em>] {-a, --applicationid <em class="replaceable"><code>applicationID</code></em>} {-n, --name <em class="replaceable"><code>name</code></em>}</p></div></div><div class="refsect1" lang="en"><a name="d0e8923"></a><h2>Description</h2><p>
    This script will create a new experiment in the perfdmf database. 
  </p></div><div class="refsect1" lang="en"><a name="d0e8928"></a><h2>Options</h2><p>-g, --configFile <em class="parameter"><code>configFile </code></em>
    specify the path to the file that defines the perfdmf
    configuration.
    </p><p>-c, --config <em class="parameter"><code>configuration_name </code></em>
    specify the name of the perfdmf
    configuration -c foo is equalivent to -g
    &lt;home&gt;/.ParaProf/perfdmf.cfg.foo.
    </p><p>-a, --applicationid <em class="parameter"><code>applicationID </code></em>
    specify the id number of the application to associate with the new
    experiment.
    </p><p>-n, --name <em class="parameter"><code>name </code></em> the name of the
    application.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="taudb_loadtrial"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>taudb_loadtrial &#8212; 
      Command line tool to load a trial into the TAUdb database.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">taudb_loadtrial</code>  {-a <em class="replaceable"><code>appName</code></em>} {-x <em class="replaceable"><code>experimentName</code></em>} {-n <em class="replaceable"><code>name</code></em>} [options]</p></div></div><div class="refsect1" lang="en"><a name="d0e8980"></a><h2>Description</h2><p>
    This script will create a new trial in the TAUdb database. 
  </p></div><div class="refsect1" lang="en"><a name="d0e8985"></a><h2>Options</h2><p>-n, --name <em class="parameter"><code>name </code></em> the name of the
    application.</p><p> -a, --applicationname <em class="parameter"><code> name </code></em>  
    specify associated application name for this trial
    </p><p>-x, --experimentname <em class="parameter"><code>experimentName </code></em>
    specify the name of the experiment to associate with newly uploaded trial.
    </p><p>-e, --experimentid <em class="parameter"><code>experimentID </code></em>
    specify the id number of the experiment to associate with the new
    trial.
    </p><p>-g, --configFile <em class="parameter"><code>configFile </code></em>
    specify the path to the file that defines the TAUdb
    configuration.  (overrides -c)
    </p><p>-c, --config <em class="parameter"><code>configuration_name </code></em>
    specify the name of the TAUdb
    configuration -c foo is equalivent to -g &lt;.
    </p><p>-t, --trialid <em class="parameter"><code>experimentID </code></em>
    specify the id number of the newly uploaded trial.
    </p><p>-m, --metadata <em class="parameter"><code>filename </code></em>
    specify the filename of the XML metadata for this trial.
    </p><p>-f, --filetype <em class="parameter"><code>filetype</code></em> 
         Specify type of performance data, options are:
                                    profiles (default), pprof, dynaprof, mpip,
                                    gprof, psrun, hpm, packed, cube, hpc, ompp,
                                    snap, perixml, gptl, paraver, ipm, google
   </p><p>
  -i, --fixnames                  Use the fixnames option for gprof
</p></div><div class="refsect1" lang="en"><a name="d0e9035"></a><h2>Notes</h2><p>  For the TAU profiles type, you can specify either a specific set of profile
files on the commandline, or you can specify a directory (by default the current
directory).  The specified directory will be searched for profile.*.*.* files,
or, in the case of multiple counters, directories named MULTI_* containing
profile data.
</p></div><div class="refsect1" lang="en"><a name="d0e9040"></a><h2>Examples</h2><p>  taudb_loadtrial -e 12 -n "Batch 001"
  </p><p>
    This will load profile.* (or multiple counters directories MULTI_*) into
    experiment 12 and give the trial the name "Batch 001"
</p><p>
  taudb_loadtrial -e 12 -n "HPM data 01" -f hpm perfhpm*
  </p><p>
    This will load perfhpm* files of type HPMToolkit into experiment 12 and give
    the trial the name "HPM data 01"
</p><p>
  taudb_loadtrial -a "NPB2.3" -x "parametric" -n "64" par64.ppk
  </p><p>
    This will load packed profile par64.ppk into the experiment named
    "parametric" under the application named "NPB2.3" and give the trial
    the name "64".  The application and experiment will be created if not found.
</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="perfexplorer"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>perfexplorer &#8212; 
      Launches TAU's Performance Data Mining Analyzer.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">perfexplorer</code>  [-n, --nogui] [-i, --script <em class="replaceable"><code>script</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e9076"></a><h2>Documentation</h2><p>
      Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="perfexplorer_configure"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>perfexplorer_configure &#8212; 
	Configures a TAUdb database for use with perfexplorer, and installs necessary JAR files.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">perfexplorer_configure</code> </p></div></div><div class="refsect1" lang="en"><a name="d0e9099"></a><h2>Description</h2><p>
    Configures a TAUdb database for use with perfexplorer, and installs necessary JAR files.
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="taucc.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>taucc &#8212; 
      C compiler wrapper for TAU
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">taucc</code>  [options]  ... </p></div></div><div class="refsect1" lang="en"><a name="d0e9124"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-tau:help</code></span></dt><dd><p>Displays help</p></dd><dt><span class="term"><code class="option">-tau:verbose</code></span></dt><dd><p>Enable verbose mode</p></dd><dt><span class="term"><code class="option">-tau:keepfiles</code></span></dt><dd><p>Keep intermediate files</p></dd><dt><span class="term"><code class="option">-tau:show</code></span></dt><dd><p>Do not invoke, just show what would be done</p></dd><dt><span class="term"><code class="option">-tau:pdtinst</code></span></dt><dd><p>Use PDT instrumentation</p></dd><dt><span class="term"><code class="option">-tau:compinst</code></span></dt><dd><p>Use compiler instrumentation</p></dd><dt><span class="term"><code class="option">-tau:headerinst</code></span></dt><dd><p>Instrument headers</p></dd><dt><span class="term"><code class="option">-tau:&lt;options&gt;</code></span></dt><dd><p>Specify measurement/instrumentation options.  Sample options: mpi,pthread,openmp,profile,callpath,trace,vampirtrace,epilog</p></dd><dt><span class="term"><code class="option">-tau:makefile <em class="parameter"><code>tau_stub_makefile</code></em></code></span></dt><dd><p>Specify tau stub makefile</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9193"></a><h2>Notes</h2><p>
    If the -tau:makefile option is not used, the TAU_MAKEFILE
    environment variable will be checked, if it is not specified,
    then the -tau:&lt;options&gt; will be used to identify a binding.
  </p></div><div class="refsect1" lang="en"><a name="d0e9198"></a><h2>Examples</h2><p>taucc foo.c -o foo</p><p>taucc -tau:MPI,OPENMP,TRACE foo.c -o foo</p><p>taucc -tau:verbose -tau:PTHREAD foo.c -o foo</p></div><div class="refsect1" lang="en"><a name="d0e9207"></a><h2>Documentation</h2><p>
    Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tauupc.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tauupc &#8212; 
      UPC wrapper for TAU
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tauupc</code>  [options]  ... </p></div></div><div class="refsect1" lang="en"><a name="d0e9235"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-tau:help</code></span></dt><dd><p>Displays help</p></dd><dt><span class="term"><code class="option">-tau:verbose</code></span></dt><dd><p>Enable verbose mode</p></dd><dt><span class="term"><code class="option">-tau:keepfiles</code></span></dt><dd><p>Keep intermediate files</p></dd><dt><span class="term"><code class="option">-tau:show</code></span></dt><dd><p>Do not invoke, just show what would be done</p></dd><dt><span class="term"><code class="option">-tau:pdtinst</code></span></dt><dd><p>Use PDT instrumentation</p></dd><dt><span class="term"><code class="option">-tau:compinst</code></span></dt><dd><p>Use compiler instrumentation</p></dd><dt><span class="term"><code class="option">-tau:headerinst</code></span></dt><dd><p>Instrument headers</p></dd><dt><span class="term"><code class="option">-tau:&lt;options&gt;</code></span></dt><dd><p>Specify measurement/instrumentation options.  Sample options: mpi,pthread,openmp,profile,callpath,trace,vampirtrace,epilog</p></dd><dt><span class="term"><code class="option">-tau:makefile <em class="parameter"><code>tau_stub_makefile</code></em></code></span></dt><dd><p>Specify tau stub makefile</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9304"></a><h2>Notes</h2><p>
    If the -tau:makefile option is not used, the TAU_MAKEFILE
    environment variable will be checked, if it is not specified,
    then the -tau:&lt;options&gt; will be used to identify a binding.
  </p></div><div class="refsect1" lang="en"><a name="d0e9309"></a><h2>Documentation</h2><p>
    Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="taucxx.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>taucxx &#8212; 
      C++ compiler wrapper for TAU
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">taucxx</code>  [options]  ... </p></div></div><div class="refsect1" lang="en"><a name="d0e9338"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-tau:help</code></span></dt><dd><p>Displays help</p></dd><dt><span class="term"><code class="option">-tau:verbose</code></span></dt><dd><p>Enable verbose mode</p></dd><dt><span class="term"><code class="option">-tau:keepfiles</code></span></dt><dd><p>Keep intermediate files</p></dd><dt><span class="term"><code class="option">-tau:show</code></span></dt><dd><p>Do not invoke, just show what would be done</p></dd><dt><span class="term"><code class="option">-tau:pdtinst</code></span></dt><dd><p>Use PDT instrumentation</p></dd><dt><span class="term"><code class="option">-tau:compinst</code></span></dt><dd><p>Use compiler instrumentation</p></dd><dt><span class="term"><code class="option">-tau:headerinst</code></span></dt><dd><p>Instrument headers</p></dd><dt><span class="term"><code class="option">-tau:&lt;options&gt;</code></span></dt><dd><p>Specify measurement/instrumentation options.  Sample options: mpi,pthread,openmp,profile,callpath,trace,vampirtrace,epilog</p></dd><dt><span class="term"><code class="option">-tau:makefile <em class="parameter"><code>tau_stub_makefile</code></em></code></span></dt><dd><p>Specify tau stub makefile</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9407"></a><h2>Notes</h2><p>
    If the -tau:makefile option is not used, the TAU_MAKEFILE
    environment variable will be checked, if it is not specified,
    then the -tau:&lt;options&gt; will be used to identify a binding.
  </p></div><div class="refsect1" lang="en"><a name="d0e9412"></a><h2>Examples</h2><p>taucxx foo.cpp -o foo</p><p>taucxx -tau:MPI,OPENMP,TRACE foo.cpp -o foo</p><p>taucxx -tau:verbose -tau:PTHREAD foo.cpp -o foo</p></div><div class="refsect1" lang="en"><a name="d0e9421"></a><h2>Documentation</h2><p>
    Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tauf90.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tauf90 &#8212; 
      Fortran compiler wrapper for TAU
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tauf90</code>  [options]  ... </p></div></div><div class="refsect1" lang="en"><a name="d0e9450"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-tau:help</code></span></dt><dd><p>Displays help</p></dd><dt><span class="term"><code class="option">-tau:verbose</code></span></dt><dd><p>Enable verbose mode</p></dd><dt><span class="term"><code class="option">-tau:keepfiles</code></span></dt><dd><p>Keep intermediate files</p></dd><dt><span class="term"><code class="option">-tau:show</code></span></dt><dd><p>Do not invoke, just show what would be done</p></dd><dt><span class="term"><code class="option">-tau:pdtinst</code></span></dt><dd><p>Use PDT instrumentation</p></dd><dt><span class="term"><code class="option">-tau:compinst</code></span></dt><dd><p>Use compiler instrumentation</p></dd><dt><span class="term"><code class="option">-tau:headerinst</code></span></dt><dd><p>Instrument headers</p></dd><dt><span class="term"><code class="option">-tau:&lt;options&gt;</code></span></dt><dd><p>Specify measurement/instrumentation options.  Sample options: mpi,pthread,openmp,profile,callpath,trace,vampirtrace,epilog</p></dd><dt><span class="term"><code class="option">-tau:makefile <em class="parameter"><code>tau_stub_makefile</code></em></code></span></dt><dd><p>Specify tau stub makefile</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9519"></a><h2>Notes</h2><p>
    If the -tau:makefile option is not used, the TAU_MAKEFILE
    environment variable will be checked, if it is not specified,
    then the -tau:&lt;options&gt; will be used to identify a binding.
  </p></div><div class="refsect1" lang="en"><a name="d0e9524"></a><h2>Examples</h2><p>tauf90 foo.f90 -o foo</p><p>tauf90 -tau:MPI,OPENMP,TRACE foo.f90 -o foo</p><p>tauf90 -tau:verbose -tau:PTHREAD foo.f90 -o foo</p></div><div class="refsect1" lang="en"><a name="d0e9533"></a><h2>Documentation</h2><p>
    Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="paraprof.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>paraprof &#8212; 
      Launches TAU's Java-based performance data viewer.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">paraprof</code>  [-h, --help] [-f, --filetype <em class="replaceable"><code>filetype</code></em>] [--pack <em class="replaceable"><code>file</code></em>] [--dump] [-o, --oss] [-s, --summary]</p></div></div><div class="refsect1" lang="en"><a name="d0e9573"></a><h2>Notes</h2><p>
 For the TAU profiles type, you can specify either a specific set of profile
files on the commandline, or you can specify a directory (by default the current
directory).  The specified directory will be searched for profile.*.*.* files,
or, in the case of multiple counters, directories named MULTI_* containing
profile data. 
  </p></div><div class="refsect1" lang="en"><a name="d0e9578"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-h</code></span></dt><dd><p>Display help</p></dd><dt><span class="term"><code class="option">-f, --filetype <em class="parameter"><code>filetype</code></em></code></span></dt><dd><p>Specify type of performance data.  Options are: profiles (default), pprof, dynaprof, mpip, gprof, psrun, hpm, packed, cube, hpc, ompp, snap, perixml, gptl</p></dd><dt><span class="term"><code class="option">--pack <em class="parameter"><code>file</code></em></code></span></dt><dd><p>Pack the data into packed (.ppk) format (does not launch ParaProf GUI)</p></dd><dt><span class="term"><code class="option">--dump</code></span></dt><dd><p>Dump profile data to TAU profile format (does not launch ParaProf GUI).</p></dd><dt><span class="term"><code class="option">-o, --oss</code></span></dt><dd><p>Print profile data in OSS style text output</p></dd><dt><span class="term"><code class="option">-s, --summary</code></span></dt><dd><p>Print only summary statistics (only applies to OSS output)</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9628"></a><h2>Documentation</h2><p>
    Complete documentation can be found at <span class="emphasis"><em>http://www.cs.uoregon.edu/research/tau/tau-usersguide.pdf</em></span>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="pprof.man"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>pprof &#8212; 
      Quickly diplays profile data.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">pprof</code>  [-a] [-c] [-b] [-m] [-t] [-e] [-i] [-v] [-r] [-s] [-n <em class="replaceable"><code>num</code></em>] [-f <em class="replaceable"><code>filename</code></em>] [-p] [-l] [-d]</p></div></div><div class="refsect1" lang="en"><a name="d0e9685"></a><h2>Description</h2><p>
  </p></div><div class="refsect1" lang="en"><a name="d0e9690"></a><h2>Options</h2><p>-a  Show all location information available</p><p>-c  Sort according to number of Calls </p><p>-b  Sort according to number of suBroutines called by a function
  </p><p>-m  Sort according to Milliseconds (exclusive time total)</p><p>-t  Sort according to Total milliseconds (inclusive time total)
  (default)</p><p>-e Sort according to Exclusive time per call (msec/call)</p><p>-i Sort according to Inclusive time per call (total msec/call)</p><p>-v Sort according to Standard Deviation (excl usec)</p><p>-r Reverse sorting order</p><p>-s print only Summary profile information </p><p>-n num  print only first num number of functions </p><p>-f filename  specify full path and Filename without node ids</p><p>-p suPpress conversion to hhmmssmmm format</p><p>-l List all functions and exit</p><p>-d Dump output format (for tau_reduce) [node numbers]  prints only
  info about all contexts/threads of given node numbers</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_instrumentor"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_instrumentor &#8212; 
      automaticly instruments a source basied on information provided by pdt.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_instrumentor</code>  [--help] {<em class="replaceable"><code>pdbfile</code></em>} {<em class="replaceable"><code>sourcefile</code></em>} [-c] [-b] [-m] [-t] [-e] [-i] [-v] [-r] [-s] [-n <em class="replaceable"><code>num</code></em>] [-f <em class="replaceable"><code>filename</code></em>] [-p] [-l] [-d]</p></div></div><div class="refsect1" lang="en"><a name="d0e9778"></a><h2>Description</h2><p>
  </p></div><div class="refsect1" lang="en"><a name="d0e9783"></a><h2>Options</h2><p>-a  Show all location information available</p><p>-c  Sort according to number of Calls </p><p>-b  Sort according to number of suBroutines called by a function
  </p><p>-m  Sort according to Milliseconds (exclusive time total)</p><p>-t  Sort according to Total milliseconds (inclusive time total)
  (default)</p><p>-e Sort according to Exclusive time per call (msec/call)</p><p>-i Sort according to Inclusive time per call (total msec/call)</p><p>-v Sort according to Standard Deviation (excl usec)</p><p>-r Reverse sorting order</p><p>-s print only Summary profile information </p><p>-n num  print only first num number of functions </p><p>-f filename  specify full path and Filename without node ids</p><p>-p suPpress conversion to hhmmssmmm format</p><p>-l List all functions and exit</p><p>-d Dump output format (for tau_reduce) [node numbers]  prints only
  info about all contexts/threads of given node numbers</p></div><div class="refsect1" lang="en"><a name="d0e9816"></a><h2>Example</h2><p><code class="literal">%&gt; tau_instrumentor foo.pdb foo.cpp -o foo.inst.cpp -f
  select.tau</code></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="vtfconverter"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>vtfconverter &#8212; 
      
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">vtfconverter</code>  [-h] [-c] [-f <em class="replaceable"><code>file</code></em>] [-p <em class="replaceable"><code>path</code></em>] [-i <em class="replaceable"><code>from</code></em> <em class="replaceable"><code>to</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e9856"></a><h2>Description</h2><p>
    Converts VTF profile to TAU profiles and launches an interactive VTF prompt. 
  </p></div><div class="refsect1" lang="en"><a name="d0e9861"></a><h2>Options</h2><p>-c Opens command line interface.</p><p>-f Converts trace [file] to TAU profiles.</p><p>-p Places the resulting profiles in the directory [path].</p><p>-i States that the interval [from],[to] should be profiled.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_setup"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_setup &#8212; 
      Launches GUI interface to configure TAU.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_setup</code> </p></div></div><div class="refsect1" lang="en"><a name="d0e9887"></a><h2>Options</h2><p>-v Verbose output.</p><p>--html Output results in HTML.</p><p>--build Only build.</p><p>--run Only run.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_wrap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_wrap &#8212; 
      Instruments an external library with TAU without needing to recompile
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_wrap</code>  {<em class="replaceable"><code>pdbfile</code></em>} {<em class="replaceable"><code>sourcefile</code></em>} [-o <em class="replaceable"><code>outputfile</code></em>] [-g <em class="replaceable"><code>groupname</code></em>] [-i <em class="replaceable"><code>headerfile</code></em>] [-f <em class="replaceable"><code>selectivefile</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e9937"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term">pdbfile</span></dt><dd><p>A pdb file generated by cparse, cxxparse, or f90parse;
        these commands are found in the [PDT_HOME]/[arch]/bin directory.</p></dd><dt><span class="term">sourcefile</span></dt><dd><p>The source file corresponding to the pdbfile.
        </p></dd><dt><span class="term">-o outputfile</span></dt><dd><p>The filename of the resulting instrumented source file.
        </p></dd><dt><span class="term">-g groupname</span></dt><dd><p>This associates all the functions profiled as belonging
        to the this group. Once profiled you will be able to analysis these
        functions separately.
        </p></dd><dt><span class="term">-i headerfile</span></dt><dd><p>By default <code class="literal">tau_wrap</code> will include
        Profile/Profile.h; use this option to specify a different header file.
        </p></dd><dt><span class="term">-f selectivefile</span></dt><dd><p>You can specify a selective instrumentation file that
        defines how the source file is to be instrumented.
        </p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e9980"></a><h2>Examples</h2><pre class="screen">
%&gt; tau_wrap hdf5.h.pdb hdf5.h -o hdf5.inst.c -f select.tau -g hdf5
</pre><p>
    </p><p>
      This specifies the instrumented wrapper library source (hdf5.inst.c), the instrumentation specification
      file (select.tau) and the group (hdf5). It creates the wrapper/
      directory.</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_gen_wrapper"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_gen_wrapper &#8212; 
     Generates a wrapper library that can intercept 
 at link time or at runtime routines specified in a header file
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_gen_wrapper</code>  {<em class="replaceable"><code>headerfile</code></em>} {<em class="replaceable"><code>library</code></em>} [-w | -d | -r <em class="replaceable"><code></code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e10013"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term">headerfile</span></dt><dd><p>Name of the headerfile to be wrapped</p></dd><dt><span class="term">library</span></dt><dd><p>Name of the library to wrap
        </p></dd><dt><span class="term">-w </span></dt><dd><p>(default)  generates wrappers for re-linking the application
        </p></dd><dt><span class="term">-d </span></dt><dd><p>generates wrappers by redefining routines during compilation in header files
        </p></dd><dt><span class="term">-r </span></dt><dd><p>generates wrappers that may be pre-loaded using tau_exec at runtime
        </p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e10047"></a><h2>Examples</h2><pre class="screen">
%&gt;  tau_gen_wrapper hdf5.h /usr/lib/libhdf5.a 
</pre><p>
    </p><p>
      This  generates a wrapper library that may be linked in using TAU_OPTIONS -optTauWrapFile=&lt;wrapperdir&gt;/link_options.tau
</p></div><div class="refsect1" lang="en"><a name="d0e10056"></a><h2>Notes</h2><p>tau_gen_wrapper reads the TAU_MAKEFILE  environment variable to get PDT settings</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_pin"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_pin &#8212; 
      Instruments application at run time using Intel's PIN library
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_pin</code>  [-n <em class="replaceable"><code>proc_num</code></em>] [-r <em class="replaceable"><code>rules</code></em>] {--} [<em class="replaceable"><code>myapp</code></em>] [<em class="replaceable"><code>myargs</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e10092"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-n</code> <em class="parameter"><code>proc_num</code></em></span></dt><dd><p> This argument enables multple instances of MPI applications launched with MPIEXEC.  proc_num is the parameter indicating number of MPI process instances to be launched.  This argument is optional and one can profile MPI application even with single process instance without this argument. </p></dd><dt><span class="term"><code class="option">-r</code> <em class="parameter"><code>rule</code></em></span></dt><dd><p>This argument is specification rule for profiling the application. It allows selective profiling by specifying the "rule". The rule is a wildcard expression token which will indicate the area of profiling. It can be only the routine specification like "*" which indicates it'll instrument all the routines in the EXE or MPI routines. One can further specify the routines on a particular dll by the rule "somedll.dll!*". The dll name can also be in regular expression. We treat the application exe and MPI routines as special cases and specifying only the routines is allowed.    </p></dd><dt><span class="term"><em class="parameter"><code>myapp</code></em></span></dt><dd><p>It's the application exe. This application can be Windows or console application. Profiling large Windows applications might suffer from degraded performance and interactability. Specifying a limited number of interesting routines can help. </p></dd><dt><span class="term"><em class="parameter"><code>myargs</code></em></span></dt><dd><p>It's the command line arguments of the application.
        </p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e10130"></a><h2>Examples</h2><p>To profile routines in mytest.exe with prefix "myf":
</p><pre class="screen">
tau_pin -r myf.*  -- mytest.exe
</pre><p>
    </p><p>To profile all routines in mpitest.exe ( no need to specify any rule
		for all ):
</p><pre class="screen">
tau_pin  mpitest.exe
</pre><p>
    </p><p>to profile only MPI routines in mpitest.exe by launching two instances:
</p><pre class="screen">
tau_pin -n 2 -r _MPI_.* -- mpitest.exe
</pre><p>
    </p><div class="refsect2" lang="en"><a name="d0e10148"></a><h3>Wildcards</h3><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">*</code> for anything, for example *MPI* means any string having MPI
				in between any other characters.</p></li><li><p><code class="literal">?</code> It's a placeholder wild card ?MPI* means any
			character followed by MPI and followed by any string, example:
			<code class="literal">??Try</code> could be <code class="literal">__Try</code> or
			<code class="literal">MyTry</code> or <code class="literal">MeTry</code> etc. </p></li></ul></div></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_java"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_java &#8212; 
      Instruments java applications at runtime using JVMTI
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_java</code>  [<em class="replaceable"><code>options</code></em>javaprogram] [  <em class="replaceable"><code>args</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e10197"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-help</code></em></span></dt><dd><p> Displays help information. </p></dd><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-verbose</code></em></span></dt><dd><p>     Report the arguments of the script before it runs. </p></dd><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-tau:agentlib=&lt;agentlib&gt;</code></em></span></dt><dd><p>   By default tau_java uses the most recently configured jdk, you can specify a different one here.
 </p></dd><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-tau:java=&lt;javapath&gt;</code></em></span></dt><dd><p>      Path to a java binary, by default uses the one corresponding to the most recently configured jdk.
</p></dd><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-tau:bootclasspath= &lt;bootclasspath&gt;</code></em></span></dt><dd><p>         To modify the bootclasspath to point to a different jar, not usually necessary.

</p></dd><dt><span class="term"><code class="option"></code> <em class="parameter"><code>-tau:include=&lt;item&gt;</code></em></span></dt><dd><p> Only instrument these methods or classes.  Separate multiple classes
        and methods with semicolons</p></dd><dt><span class="term"><em class="parameter"><code>-tau:exclude=&lt;item&gt;</code></em></span></dt><dd><p> Exclude the listed classes and methods.  Separate multiple classes
        and methods with semicolons</p></dd><dt><span class="term"><em class="parameter"><code>args</code></em></span></dt><dd><p>the command line arguments of the java application.
        </p></dd></dl></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_cupti_avail"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_cupti_avail &#8212; 
			Detects the available CUPTI counters on the a each GPU device.
    </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">tau_cupti_avail</code>  [-c <em class="replaceable"><code>counter names</code></em>]</p></div></div><div class="refsect1" lang="en"><a name="d0e10288"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-c</code> <em class="parameter"><code>counter names</code></em></span></dt><dd><p>Checks which of a colon seperated list of CUPTI counter
				names can be recorded.</p></dd></dl></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_run"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_run &#8212; 
 Instruments and executes binaries to generate performance data. (DyninstAPI based instrumentor)
    </p></div><div class="refsect1" lang="en"><a name="d0e10313"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-v</code> <em class="parameter"><code></code></em></span></dt><dd><p>
  		optional verbose option
	</p></dd><dt><span class="term"><code class="option">-o</code> <em class="parameter"><code>outfile</code></em></span></dt><dd><p>
		for binary rewriting
	</p></dd><dt><span class="term">-T&lt;option&gt; </span></dt><dd><p>: specify TAU option</p></dd><dt><span class="term">-loadlib=&lt;file.so &gt; </span></dt><dd><p>: specify additional load library</p></dd><dt><span class="term">-XrunTAU-&lt;options&gt;</span></dt><dd><p>specify TAU library directly</p></dd></dl></div></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="tau_rewrite"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>tau_rewrite &#8212; 
           Rewrites binaries using Maqao if Tau is configured using PDT 3.17+ at the routine level. 
          If it doesn't find the Maqao package from PDT 3.17, it reverts to tau_run (DyninstAPI based instrumentor). 
    </p></div><div class="refsect1" lang="en"><a name="d0e10365"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">-o</code> <em class="parameter"><code>outfile</code></em></span></dt><dd><p> specify instrumented output file
				</p></dd><dt><span class="term"><code class="option">-T</code> <em class="parameter"><code></code></em></span></dt><dd><p>specify TAU option (CUPTI, DISABLE, MPI, OPENMP, PDT, PGI, PROFILE, SCOREP, SERIAL)
				</p></dd><dt><span class="term"><code class="option">-loadlib=</code> <em class="parameter"><code>file.so</code></em></span></dt><dd><p>specify additional load library
				</p></dd><dt><span class="term"><code class="option">-s</code> <em class="parameter"><code></code></em></span></dt><dd><p>dryrun without executing
				</p></dd><dt><span class="term"><code class="option">-v</code> <em class="parameter"><code></code></em></span></dt><dd><p>long verbose mode
				</p></dd><dt><span class="term"><code class="option">-v1</code> <em class="parameter"><code></code></em></span></dt><dd><p>short verbose mode
				</p></dd><dt><span class="term"><code class="option">-XrunTAUsh-</code> <em class="parameter"><code>options</code></em></span></dt><dd><p>specify TAU library directly
				</p></dd></dl></div></div><div class="refsect1" lang="en"><a name="d0e10435"></a><h2>Notes</h2><p>	Defaults if unspecified: -T MPI</p><p>
	MPI is assumed unless SERIAL is specified
</p></div><div class="refsect1" lang="en"><a name="d0e10442"></a><h2>Example</h2><p> 
</p><pre class="screen">	
    tau_rewrite -T papi,pdt a.out -o a.inst
</pre><p>
</p><pre class="screen">
    mpirun -np 4 ./a.inst
</pre><p>
</p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUdbDoc"></a>Part&nbsp;I.&nbsp;TAUdb</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#taudb.intro">8. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">8.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">8.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">9. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">9.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">9.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">9.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">9.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">10. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">10.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">11. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">11.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">11.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">11.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">11.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">11.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">11.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.intro"></a>Chapter&nbsp;8.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.prereq">8.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">8.2. Installation</a></span></dt></dl></div><p>
	TAUdb (TAU Database), formerly known as PerfDMF (Performance Data
	Management Framework) is a an API/Toolkit that sits atop a DBMS to manage
	and analyze performance data.  The API is available in its native Java form
	as well as C.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.prereq"></a>8.1.&nbsp;Prerequisites</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p>A supported Database Management System (DBMS).  TAUdb
	  currently supports PostgreSQL, MySQL, Oracle, H2, and Derby. For
	  use with the C API, only PostgreSQL is supported (SQLite support is
	  currently being evaluated). Because they are Java only, H2 and Derby
	  can NO  be accessed with the C API.</p></li><li><p>Java 1.5.</p></li><li><p>If the C API is desired, a working C compiler is
	  required, along with the following libraries: libpq (PostgreSQL
	  libraries), libxml2, libz, libuuid. These libraries are all commonly
	  installed by default on *NIX systems.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.installation"></a>8.2.&nbsp;Installation</h2></div></div></div><p>The TAUdb utilities and applications are installed as part of the
    standard TAU release.  Shell scripts are installed in the TAU bin directory
    to configure and run the utilities.  It is assumed that the user has
    installed TAU and run TAU's configure and 'make install'.
    </p><div class="orderedlist"><ol type="1"><li><p>(Optionally) Create a database.  This step will depend on the user's
		chosen DBMS.
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>H2:</strong></span>
	  Because it is an embedded, file-based DBMS, H2 does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. TAUdb takes advantage of the "auto-server"
	  capabilities in H2, so multiple clients can connect to the same database
	  at the same time. Users should use the H2 DBMS if they expect to
	  maintain a small to moderate local repository of performance data, and
	  want the convenience of connecting to the database from multiple clients.
	  </p></li><li><p><span class="bold"><strong>Derby:</strong></span>
	  Because it is an embedded, file-based DBMS, Derby does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. Be advised that the Derby DBMS does <span class="bold"><strong>not</strong></span> allow multiple clients to connect to the same
	  database. For that reason, we suggest users use the H2 DBMS if a
	  file-based database is desired. Derby support is maintained for backwards
	  compatability.
	  </p></li><li><p><span class="bold"><strong>PostgreSQL:</strong></span>
	  </p><pre class="screen">$ createdb -O taudb taudb</pre><p>
	  Or, from <span><strong class="command">psql</strong></span>
	  </p><pre class="screen">psql=# create database taudb with owner = taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>MySQL:</strong></span>  From the MySQL prompt
	  </p><pre class="screen">mysql&gt; create database taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>Oracle:</strong></span> It is recommended that
	  you create a tablespace for taudb: 
	  </p><pre class="screen">create tablespace taudb 
datafile '/path/to/somewhere' size 500m reuse;</pre><p>

	  Then, create a user that has this tablespace as default:
	  </p><pre class="screen">create user amorris identified by db;
grant create session to amorris;
grant create table to amorris;
grant create sequence to amorris;
grant create trigger to amorris;
alter user amorris quota unlimited on taudb;
alter user amorris default tablespace taudb;</pre><p>
	  
TAUdb is set up to use the Oracle Thin Java driver.  You will have
to obtain this jar file for your DBMS.  In our case, it was
ojdbc14.jar.
	  </p></li></ul></div></li><li><p>Configure a TAUdb connection.  To configure TAUdb, run the
	<span><strong class="command">taudb_configure</strong></span> program from the TAU bin directory.</p><p>The configuration program will prompt the user for several values.  The
	default values will work for most users.  When configuration is complete,
	it will connect to the database and test the configuration.  If the
	configuration is valid and the schema is not already found in the database
	(as will be the case on initial configuration), the schema will be
	uploaded.  Be sure to specify the correct version of the schema for your
	DBMS.
	</p><p>An example session for configuring a database is below. The user
	is creating an H2 database, with default settings including no username
	and no password (recommended for file-based databases when security is not
	an issue).
	</p><pre class="screen">
$ taudb_configure
Configuration file NOT found...
a new configuration file will be created.

Welcome to the configuration program for PerfDMF.
This program will prompt you for some information necessary to 
ensure the desired behavior for the PerfDMF tools.


You will now be prompted for new values, if desired.  The current 
or default values for each prompt are shown in parenthesis.
To accept the current/default value, just press Enter/Return.

Please enter the name of this configuration.
():documentation_example
Please enter the database vendor (oracle, postgresql, mysql, db2, 
derby or h2).
(h2):
Please enter the JDBC jar file.
(/Users/khuck/src/tau2/apple/lib/h2.jar):
Please enter the JDBC Driver name.
(org.h2.Driver):
Please enter the path to the database directory.
(/Users/khuck/.ParaProf/documentation_example):
Please enter the database username.
():
Store the database password in CLEAR TEXT in your configuration 
file? (y/n):y
Please enter the database password: 
Please enter the PerfDMF schema file.
(/Users/khuck/src/tau2/etc/taudb.sql):

Writing configuration file: 
/Users/khuck/.ParaProf/perfdmf.cfg.documentation_example

Now testing your database connection.

Database created, command: 
jdbc:h2:/Users/khuck/.ParaProf/documentation_example/perfdmf;AUTO_SERVER=TRUE;create=true

Uploading Schema: /Users/khuck/src/tau2/etc/taudb.sql
Found /Users/khuck/src/tau2/etc/taudb.sql  ... Loading
Successfully uploaded schema

Database connection successful.
Configuration complete.
	</pre><p>
	</p></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.using"></a>Chapter&nbsp;9.&nbsp;Using TAUdb</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#perfdmf.createapp">9.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">9.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">9.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">9.4. TAUdb Views</a></span></dt></dl></div><p>The easiest way to interact with TAUdb is to use ParaProf which
    provides a GUI interface to all of the database information.  In addition,
    the following commandline utilities are provided.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createapp"></a>9.1.&nbsp;perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates applications with a given name</p><pre class="screen">$ perfdmf_createapp -n "New Application"
Created Application, ID: 24</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createexp"></a>9.2.&nbsp;perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates experiments with a given name, under a specified application</p><pre class="screen">$ perfdmf_createexp -a 24 -n "New Experiment"
Created Experiment, ID: 38</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.loadtrial"></a>9.3.&nbsp;taudb_loadtrial</h2></div></div></div><p>This utility uploads a trial to the database with a given name, under
    a specified experiment</p><pre class="screen">
$ taudb_loadtrial -h
Usage: perfdmf_loadtrial -a &lt;appName&gt; -x &lt;expName&gt; -n &lt;name&gt; 
[options] &lt;files&gt;

Required Arguments:

  -n, --name &lt;text&gt;              Specify the name of the trial
  -a, --applicationname &lt;string&gt; Specify associated application name
                                 for this trial
  -x, --experimentname &lt;string&gt;  Specify associated experiment name
                                 for this trial
               ...or...

  -n, --name &lt;text&gt;              Specify the name of the trial
  -e, --experimentid &lt;number&gt;    Specify associated experiment ID
                                 for this trial

Optional Arguments:

  -c, --config &lt;name&gt;       Specify the name of the configuration to use
  -g, --configFile &lt;file&gt;   Specify the configuration file to use
                            (overrides -c)
  -f, --filetype &lt;filetype&gt; Specify type of performance data, options 
                            are: profiles (default), pprof, dynaprof, 
                            mpip, gprof, psrun, hpm, packed, cube, 
                            hpc, ompp, snap, perixml, gptl, paraver, 
                            ipm, google
  -t, --trialid &lt;number&gt;    Specify trial ID
  -i, --fixnames            Use the fixnames option for gprof
  -z, --usenull             Include NULL values as 0 for mean 
                            calculation
  -r, --reduce &lt;percentage&gt; Aggregate all timers less than percentage 
                            as "other"
  -m, --metadata &lt;filename&gt; XML metadata for the trial

Notes:
  For the TAU profiles type, you can specify either a specific set 
of profile files on the commandline, or you can specify a directory 
(by default the current directory).  The specified directory will be 
searched for profile.*.*.* files, or, in the case of multiple counters, 
directories named MULTI_* containing profile data.

Examples:

  perfdmf_loadtrial -e 12 -n "Batch 001"
    This will load profile.* (or multiple counters directories 
    MULTI_*) into experiment 12 and give the trial the name 
    "Batch 001"

  perfdmf_loadtrial -e 12 -n "HPM data 01" -f hpm perfhpm*
    This will load perfhpm* files of type HPMToolkit into experiment 
    12 and give the trial the name "HPM data 01"

  perfdmf_loadtrial -a "NPB2.3" -x "parametric" -n "64" par64.ppk
    This will load packed profile par64.ppk into the experiment named
    "parametric" under the application named "NPB2.3" and give the 
    trial the name "64".  The application and experiment will be 
    created if not found.
  </pre><p>TAUdb supports a large number of parallel profile formats:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>TAU Profiles (profiles)</strong></span>
	  - Output from the TAU measurement library, these files generally take the
		form of <code class="filename">profile.X.X.X</code>, one for each
		node/context/thread combination.  When multiple counters are used, each
		metric is located in a directory prefixed with "MULTI__".  To launch
		ParaProf with all the metrics, simply launch it from the root of the
		MULTI__ directories.</p></li><li><p><span class="bold"><strong>ParaProf Packed Format
	  (ppk)</strong></span> - Export format supported by PerfDMF/ParaProf.
	  Typically .ppk.  </p></li><li><p><span class="bold"><strong>TAU Merged Profiles
	  (snap)</strong></span> - Merged and snapshot profile format supported by
	  TAU.  Typically tauprofile.xml.</p></li><li><p><span class="bold"><strong>TAU pprof (pprof)</strong></span> - Dump
	  Output from TAU's <span><strong class="command">pprof -d</strong></span>.  Provided for backward
	  compatibility only.</p></li><li><p><span class="bold"><strong>DynaProf (dynaprof)</strong></span> -
	  Output From DynaProf's wallclock and papi probes.  </p></li><li><p><span class="bold"><strong>mpiP (mpip)</strong></span> - Output
	  from mpiP.  </p></li><li><p><span class="bold"><strong>gprof (gprof)</strong></span> - Output
	  from gprof, see also the --fixnames option.  </p></li><li><p><span class="bold"><strong>PerfSuite (psrun)</strong></span> -
	  Output from PerfSuite psrun files.</p></li><li><p><span class="bold"><strong>HPM Toolkit (hpm)</strong></span> -
	  Output from IBM's HPM Toolkit.  </p></li><li><p><span class="bold"><strong>Cube (cube)</strong></span> - Output
	  from Kojak Expert tool for use with Cube.  </p></li><li><p><span class="bold"><strong>Cube3 (cube3)</strong></span> - Output
	  from Kojak Expert tool for use with Cube3 and Cube4.  </p></li><li><p><span class="bold"><strong>HPCToolkit (hpc)</strong></span> - XML
	  data from hpcquick.  Typically, the user runs hpcrun, then hpcquick on
	  the resulting binary file.  </p></li><li><p><span class="bold"><strong>OpenMP Profiler (ompp)</strong></span> -
	  CSV format from the ompP OpenMP Profiler (http://www.ompp-tool.com).  The
	  user must use OMPP_OUTFORMAT=CVS.</p></li><li><p><span class="bold"><strong>PERI XML (perixml)</strong></span> -
	  Output from the PERI data exchange format.</p></li><li><p><span class="bold"><strong>General Purpose Timing Library
	  (gptl)</strong></span> - Output from the General Purpose Timing
	  Library.</p></li><li><p><span class="bold"><strong>Paraver (paraver)</strong></span> -
	  2D output from the Paraver trace analysis tool from
	  BSC.</p></li><li><p><span class="bold"><strong>IPM (ipm)</strong></span> -
	  Integrated Performance Monitoring format, from NERSC.</p></li><li><p><span class="bold"><strong>Google (google)</strong></span> -
	  Google Profiles.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.views"></a>9.4.&nbsp;TAUdb Views</h2></div></div></div><p>In order to provide flexible data management, the application /
	experiment / trial hierarchy was removed in the conversion from PerfDMF to
	TAUdb. In addition, trial metadata was promoted from an XML blob in PerfDMF
	to queryable tables. Users can now organize their data in arbitrary
	hierarchies using Views and SubViews.  Creating and using Views is outlined
	in the ParaProf User Manual, in Chapter 2.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.schema"></a>Chapter&nbsp;10.&nbsp;Database Schema</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.schema.sql">10.1. SQL for TAUdb</a></span></dt></dl></div><p>
    The database schema in TAUdb is designed to flexibly and efficiently store
    multidimensional parallel performance data. There are 5 dimensions to the
    actual timer measurements, and 4 dimensions to the counter measurements
    </p><p>Timer dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Metric of interest (i.e. FP_OPS, TIME)</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><p>Counter dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.schema.sql"></a>10.1.&nbsp;SQL for TAUdb</h2></div></div></div><p>Below is the SQL schema definition for TAUdb.</p><pre class="screen">
/****************************/
/* CREATE THE STATIC TABLES */
/****************************/

CREATE TABLE schema_version (
 version     INT NOT NULL,
 description VARCHAR NOT NULL
);
/* IF THE SCHEMA IS MODIFIED, INCREMENT THIS VALUE */
/* 0 = PERFDMF (ORIGINAL) */
/* 1 = TAUDB (APRIL, 2012) */
/*VALUES (1, 'TAUdb redesign from Spring, 2012');*/
INSERT INTO schema_version (version, description) 
  VALUES (2, 'Changes after Nov. 9, 2012 release');

/* These are our supported parsers. */
CREATE TABLE data_source (
 id          INT UNIQUE NOT NULL,
 name        VARCHAR NOT NULL,
 description VARCHAR
);

INSERT INTO data_source (name,id,description) 
  VALUES ('ppk',0,'TAU Packed profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('TAU profiles',1,'TAU profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('DynaProf',2,'PAPI DynaProf profiles (UTK)');
INSERT INTO data_source (name,id,description) 
  VALUES ('mpiP',3,'mpiP: Lightweight, Scalable MPI Profiling (Vetter, Chambreau)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPM',4,'HPM Toolkit profiles (IBM)');
INSERT INTO data_source (name,id,description) 
  VALUES ('gprof',5,'gprof profiles (GNU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('psrun',6,'PerfSuite psrun profiles (NCSA)');
INSERT INTO data_source (name,id,description) 
  VALUES ('pprof',7,'TAU pprof.dat output (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube',8,'Cube data (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPCToolkit',9,'HPC Toolkit profiles (Rice Univ.)');
INSERT INTO data_source (name,id,description) 
  VALUES ('SNAP',10,'TAU Snapshot profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('OMPP',11,'OpenMP Profiler profiles (Fuerlinger)');
INSERT INTO data_source (name,id,description) 
  VALUES ('PERIXML',12,'Data Exchange Format (PERI)');
INSERT INTO data_source (name,id,description) 
  VALUES ('GPTL',13,'General Purpose Timing Library (ORNL)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Paraver',14,'Paraver profiles (BSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('IPM',15,'Integrated Performance Monitoring (NERSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Google',16,'Google profiles (Google)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube3',17,'Cube 3D profiles (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Gyro',100,'Self-timing profiles from Gyro application');
INSERT INTO data_source (name,id,description) 
  VALUES ('GAMESS',101,'Self-timing profiles from GAMESS application');
INSERT INTO data_source (name,id,description) 
  VALUES ('Other',999,'Other profiles');

/* threads make it convenient to identify timer values.
   Special values for thread_index:
   -1 mean (nulls ignored)
   -2 total
   -3 stddev (nulls ignored)
   -4 min
   -5 max
   -6 mean (nulls are 0 value)
   -7 stddev (nulls are 0 value)
*/

CREATE TABLE derived_thread_type (
 id INT NOT NULL,
 name VARCHAR NOT NULL,
 description VARCHAR NOT NULL
);

INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-1, 'MEAN', 'MEAN (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-2, 'TOTAL', 'TOTAL');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-3, 'STDDEV', 'STDDEV (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-4, 'MIN', 'MIN');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-5, 'MAX', 'MAX');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-6, 'MEAN', 'MEAN (nulls are 0 value)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-7, 'STDDEV', 'STDDEV (nulls are 0 value)');

/**************************/
/* CREATE THE TRIAL TABLE */
/**************************/

/* trials are the top level table */

CREATE TABLE trial (
 id                  SERIAL NOT NULL PRIMARY KEY,
 name                VARCHAR,
 /* where did this data come from? */
 data_source         INT,
 /* number of processes */
 node_count          INT,
 /* legacy values - these are actually "max" values - i.e. not all nodes have
  * this many threads */
 contexts_per_node   INT,
 /* how many threads per node? */
 threads_per_context INT,
 /* total number of threads */
 total_threads       INT,
 /* reference to the data source table. */
 FOREIGN KEY(data_source) REFERENCES data_source(id) 
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/******************************/
/* CREATE THE DATA DIMENSIONS */
/******************************/

/* threads are the "location" dimension */

CREATE TABLE thread (
 id           SERIAL NOT NULL PRIMARY KEY,
 /* trial this thread belongs to */
 trial        INT NOT NULL,
 /* process rank, really */
 node_rank    INT NOT NULL,
 /* legacy value */
 context_rank INT NOT NULL,
 /* thread rank relative to the process */
 thread_rank  INT NOT NULL,
 /* thread index from 0 to N-1 */
 thread_index INT NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id) ON DELETE 
   NO ACTION ON UPDATE NO ACTION
);

/* metrics are things like num_calls, num_subroutines, TIME, PAPI
   counters, and derived metrics. */

CREATE TABLE metric (
 id      SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial   INT NOT NULL,
 /* name of the metric */
 name    VARCHAR NOT NULL,
 /* if this metric is derived by one of the tools */
 derived BOOLEAN NOT NULL DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timers are timers, capturing some interval value.  For callpath or
   phase profiles, the parent refers to the calling function or phase. */

CREATE TABLE timer (
 id                SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial             INT NOT NULL,
 /* name of the timer */
 name              VARCHAR NOT NULL,
 /* short name of the timer - without source or parameter info */
 short_name        VARCHAR NOT NULL,
 /* filename */
 source_file       VARCHAR,
 /* line number of the start of the block of code */
 line_number       INT,
 /* line number of the end of the block of code */
 line_number_end   INT,
 /* column number of the start of the block of code */
 column_number     INT,
 /* column number of the end of the block of code */
 column_number_end INT,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer index on the trial and name columns */
CREATE INDEX timer_trial_index on timer (trial, name);

/***********************************/
/* CREATE THE TIMER RELATED TABLES */
/***********************************/

/* timer groups are the groups such as TAU_DEFAULT,
   MPI, OPENMP, TAU_PHASE, TAU_CALLPATH, TAU_PARAM, etc. 
   This mapping table allows for NxN mappings between timers
   and groups */

CREATE TABLE timer_group (
 timer INT,
 group_name  VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* index for faster queries into groups */
CREATE INDEX timer_group_index on timer_group (timer, group_name);

/* timer parameters are parameter based profile values. 
 * an example is foo (x,y) where x=4 and y=10. In that example,
 * timer would be the index of the timer with the
 * name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. This table would have two
 * entries, one for the x value and one for the y value. */

CREATE TABLE timer_parameter (
 timer     INT,
 parameter_name  VARCHAR NOT NULL,
 parameter_value VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer callpath have the information about the call graph in a trial.
 * If the profile is "flat", these will all have no parents. Otherwise,
 * the parent points to a node in the callgraph, the calling timer 
 * (function). */

CREATE TABLE timer_callpath (
 id        SERIAL NOT NULL PRIMARY KEY,
 /* what timer is this? */
 timer     INT NOT NULL,
 /* what is the parent timer? */
 parent    INT,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* By definition, profiles have no time data. However, there are a few
 * examples where time ranges make sense, such as tracking call stacks
 * or associating metadata to a particular phase. The time_range table
 * is used to give other measurements a time context. The iteration
 * start and end can be used to indicate which loop iterations or 
 * calls to a function are relevant for this time range. */

CREATE TABLE time_range (
 id SERIAL NOT NULL PRIMARY KEY,
 /* starting iteration */
 iteration_start INT NOT NULL,
 /* ending iteration. */
 iteration_end INT,
 /* starting timestamp */
 time_start BIGINT NOT NULL,
 /* ending timestamp. */
 time_end BIGINT
);

/* timer_call_data records have the dynamic information for when a node
 * in the callgraph is visited by a thread. If you are tracking dynamic
 * callstacks, you would use the time_range field. If you are storing
 * snapshot data, you would use the time_range field. */

CREATE TABLE timer_call_data (
 id          SERIAL NOT NULL PRIMARY KEY,
 /* what callgraph node is this? */
 timer_callpath       INT NOT NULL,
 /* what thread is this? */
 thread      INT NOT NULL,
 /* how many times this timer was called */
 calls       INT,
 /* how many subroutines this timer called */
 subroutines INT,
 /* what is the time_range? this is for supporting snapshots */
 time_range  INT,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer values have the timer of one timer
   on one thread for one metric, at one location on the callgraph. */

CREATE TABLE timer_value (
 /* what node in the callgraph and thread is this? */
 timer_call_data       INT NOT NULL,
 /* what metric is this? */
 metric                INT NOT NULL,
 /* The inclusive value for this timer */
 inclusive_value       DOUBLE PRECISION,
 /* The exclusive value for this timer */
 exclusive_value       DOUBLE PRECISION,
 /* The inclusive percent for this timer */
 inclusive_percent     DOUBLE PRECISION,
 /* The exclusive percent for this timer */
 exclusive_percent     DOUBLE PRECISION,
 /* The variance for this timer */
 sum_exclusive_squared DOUBLE PRECISION,
 FOREIGN KEY(timer_call_data) REFERENCES timer_call_data(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(metric) REFERENCES metric(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one metric, one thread, one timer */
CREATE INDEX timer_value_index on timer_value (timer_call_data, metric);

/*************************************/
/* CREATE THE COUNTER RELATED TABLES */
/*************************************/

/* counters measure some counted value. */

CREATE TABLE counter (
 id          SERIAL      NOT NULL PRIMARY KEY,
 trial       INT         NOT NULL,
 name        VARCHAR        NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* counter index on the trial and name columns */
CREATE INDEX counter_trial_index on counter (trial, name);

CREATE TABLE counter_value (
 /* what counter is this? */
 counter            INT NOT NULL,
 /* where in the callgraph? */
 timer_callpath     INT,
 /* what thread is this? */
 thread             INT NOT NULL,
 /* The total number of samples */
 sample_count       INT,         
 /* The maximum value seen */
 maximum_value      DOUBLE PRECISION,
 /* The minimum value seen */
 minimum_value      DOUBLE PRECISION,
 /* The mean value seen */
 mean_value         DOUBLE PRECISION,
 /* The variance for this counter */
 standard_deviation DOUBLE PRECISION,
 FOREIGN KEY(counter) REFERENCES counter(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one thread, one counter */
CREATE INDEX counter_value_index on counter_value (counter, thread);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

CREATE TABLE primary_metadata (
 trial    INT NOT NULL,
 name     VARCHAR NOT NULL,
 value    VARCHAR,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the primary_metadata table */
CREATE INDEX primary_metadata_index on primary_metadata (trial, name);

/* secondary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

CREATE TABLE secondary_metadata (
 id       VARCHAR NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial    INT NOT NULL,
 /* this metadata value could be associated with a thread */
 thread   INT,
 /* this metadata value could be associated with a timer that happened */
 timer_callpath    INT,
 /* which call to the context timer was this? */
 time_range    INT,
 /* this metadata value could be a nested structure */
 parent   VARCHAR,
 /* the name of the metadata field */
 name     VARCHAR NOT NULL,
 /* the value of the metadata field */
 value    VARCHAR,
 /* this metadata value could be an array - so tokenize it */
 is_array BOOLEAN DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES secondary_metadata(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the secondary_metadata table */
CREATE INDEX secondary_metadata_index on secondary_metadata 
   (trial, name, thread, parent);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* this is the view table, which organizes and filters trials */
create table taudb_view (
    id                    SERIAL            NOT NULL    PRIMARY KEY,
    /* views can be nested */
    parent                INTEGER            NULL,
    /* name of the view */
    name                VARCHAR    NOT NULL,
    /* view conjoin type for parameters */
    conjoin                VARCHAR    NOT NULL,
    FOREIGN KEY (parent) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

create table taudb_view_parameter (
    /* the view ID */
    taudb_view            INTEGER    NOT NULL,
    /* the table name for the where clause */
    table_name            VARCHAR    NOT NULL,
    /* the column name for the where clause.
       If the table_name is one of the metadata tables, this is the 
       value of the "name" column */
    column_name            VARCHAR    NOT NULL,
    /* the operator for the where clause */
    operator            VARCHAR    NOT NULL,
    /* the value for the where clause */
    value                VARCHAR    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

/* simple view of all trials */
INSERT INTO taudb_view (parent, name, conjoin) 
    VALUES (NULL, 'All Trials', 'and');
/* must have a parameter or else the sub views for this view 
   do not work correctly*/
INSERT INTO taudb_view_parameter 
    (taudb_view, table_name, column_name, operator, value) 
	VALUES (1, 'trial', 'total_threads', '&gt;', '-1');

/* the application and experiment columns are not used in the 
   latest schema, but keeping them makes the code in 
   PerfExplorer simpler. */
create table analysis_settings (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    taudb_view          INTEGER         NULL,
    application         INTEGER         NULL,
    experiment          INTEGER         NULL,
    trial               INTEGER         NULL,
    metric              INTEGER         NULL,
    method              VARCHAR(255)    NOT NULL,
    dimension_reduction VARCHAR(255)    NOT NULL,
    normalization       VARCHAR(255)    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (trial) REFERENCES trial(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (metric) REFERENCES metric(id)
        ON DELETE CASCADE ON UPDATE CASCADE
);

create table analysis_result (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    analysis_settings   INTEGER         NOT NULL,
    description         VARCHAR(255)    NOT NULL,
    thumbnail_size      INTEGER         NULL,
    image_size          INTEGER         NULL,
    thumbnail           BYTEA           NULL,
    image               BYTEA           NULL,
    result_type         INTEGER         NOT NULL
);

 /* Performance indexes! */
create index trial_name_index on trial(name);
create index timer_name_index on timer(name);
CREATE INDEX timer_callpath_parent on timer_callpath(parent);
CREATE INDEX thread_trial on thread(trial);
CREATE INDEX timer_call_data_timer_callpath on 
    timer_call_data(timer_callpath);
CREATE INDEX counter_name_index on counter(name);
CREATE INDEX timer_call_data_thread on timer_call_data(thread);

/* SHORT TERM FIX! These views make sure that charts 
   (mostly) work... for now. */

DROP VIEW IF EXISTS interval_location_profile;
DROP VIEW IF EXISTS interval_mean_summary;
DROP VIEW IF EXISTS interval_total_summary;
DROP VIEW IF EXISTS interval_event_value;
DROP VIEW IF EXISTS interval_event;
DROP VIEW IF EXISTS atomic_location_profile;
DROP VIEW IF EXISTS atomic_mean_summary;
DROP VIEW IF EXISTS atomic_total_summary;
DROP VIEW IF EXISTS atomic_event_value;
DROP VIEW IF EXISTS atomic_event;

CREATE OR REPLACE VIEW interval_event 
(id, trial, name, group_name, source_file, line_number, line_number_end) 
AS  
SELECT tcp.id, t.trial, t.name, tg.group_name,  
t.source_file, t.line_number, t.line_number_end  
FROM timer_callpath tcp  
INNER JOIN timer t ON tcp.timer = t.id  
INNER JOIN timer_group tg ON tg.timer = t.id; 

CREATE OR REPLACE VIEW interval_event_value 
(interval_event, node, context, thread, metric, inclusive_percentage,  
inclusive, exclusive_percentage, exclusive, call, subroutines,  
inclusive_per_call, sum_exclusive_squared) 
AS SELECT tcd.timer_callpath, t.node_rank, t.context_rank,  
t.thread_rank, tv.metric, tv.inclusive_percent,  
tv.inclusive_value, tv.exclusive_percent, tv.exclusive_value, tcd.calls, 
tcd.subroutines, tv.inclusive_value / tcd.calls, tv.sum_exclusive_squared 
FROM timer_value tv 
INNER JOIN timer_call_data tcd on tv.timer_call_data = tcd.id 
INNER JOIN thread t on tcd.thread = t.id; 

CREATE OR REPLACE VIEW interval_location_profile 
AS SELECT * from interval_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW interval_total_summary 
AS SELECT * from interval_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW interval_mean_summary 
AS SELECT * from interval_event_value WHERE thread = -1; 
 
 
CREATE OR REPLACE VIEW atomic_event  
(id, trial, name, group_name, source_file, line_number) 
AS SELECT c.id, c.trial, c.name, NULL, NULL, NULL 
FROM counter c; 

CREATE OR REPLACE VIEW atomic_event_value 
(atomic_event, node, context, thread, sample_count, 
maximum_value, minimum_value, mean_value, standard_deviation) 
AS SELECT cv.counter, t.node_rank, t.context_rank, t.thread_rank, 
cv.sample_count, cv.maximum_value, cv.minimum_value, cv.mean_value, 
cv.standard_deviation FROM counter_value cv 
INNER JOIN thread t ON cv.thread = t.id;
 
CREATE OR REPLACE VIEW atomic_location_profile 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW atomic_total_summary 
AS SELECT * FROM atomic_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW atomic_mean_summary 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= -1; 
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.capi"></a>Chapter&nbsp;11.&nbsp;TAUdb C API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.capi.overview">11.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">11.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">11.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">11.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">11.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">11.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.overview"></a>11.1.&nbsp;TAUdb C API Overview</h2></div></div></div><p>The C API for TAUdb is currently under development, but there is a
	beta version of the API available.  The API provides the following
    capabilities: </p><div class="itemizedlist"><ul type="disc"><li><p>Loading trials from the database</p></li><li><p>Inserting trials into the database</p></li><li><p>Parsing TAU profile files</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.structs"></a>11.2.&nbsp;TAUdb C Structures</h2></div></div></div><p>The C structures are roughly organized as a tree, with a trial
        object at the root.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>taudb_trial: </strong></span>
A top-level structure which contains the collections of all the performance data
dimensions.</p></li><li><p><span class="bold"><strong>taudb_primary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial.</p></li><li><p><span class="bold"><strong>taudb_secondary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial. Unlike primary_metadata
values, secondary_metadata objects can have complex value types. They are also associated
with a measurement context - a thread of execution, a timer, a timestamp, an iteration,
etc.</p></li><li><p><span class="bold"><strong>taudb_thread: </strong></span>
A structure which represents a thread of execution in the parallel
measurement.</p></li><li><p><span class="bold"><strong>taudb_time_range: </strong></span>
A structure which holds a time-range value of beginning and ending iteration
numbers or timestamps.</p></li><li><p><span class="bold"><strong>taudb_metric: </strong></span>
A structure which represents a unit of measurement, such as TIME, FP_OPS,
L1_DCM, etc.</p></li><li><p><span class="bold"><strong>taudb_timer: </strong></span>
A structure which represents a region of code. For example, a phase, a 
function, a loop, a basic block, or even a line of code.</p></li><li><p><span class="bold"><strong>taudb_timer_parameter: </strong></span>
A structure which represents parameter values, when parameter based profiling
is used.</p></li><li><p><span class="bold"><strong>taudb_timer_group: </strong></span>
A structure which represents a semantic grouping of timers, such as "I/O",
"MPI", "OpenMP", etc.</p></li><li><p><span class="bold"><strong>taudb_timer_callpath: </strong></span>
A structure which represents a node in the dynamic callpath tree. Timer_callpaths
with a null parent are either top level timers, or a timers in a flat
profile.</p></li><li><p><span class="bold"><strong>taudb_timer_call_data: </strong></span>
A structure which represents a tuple between a thread of execution and a node
on the timer callpath tree.</p></li><li><p><span class="bold"><strong>taudb_timer_value: </strong></span>
A structure which represents a tuple between a timer_call_data object and a
metric. The timer_value contains the measurement of one metric for one timer on
one thread of execution.</p></li><li><p><span class="bold"><strong>taudb_counter: </strong></span>
A structure which represents a counter in the profile. For example, 
the number of bytes transferred on an MPI_Send() timer.</p></li><li><p><span class="bold"><strong>taudb_counter_value: </strong></span>
A structure which represents a counter measurement on one thread of
execution.</p></li></ul></div><p>Below are the object definitions, from the TAUdb C header file.</p><pre class="screen">
#ifndef TAUDB_STRUCTS_H
#define TAUDB_STRUCTS_H 1

#include "time.h"
#include "uthash.h"
#include "taudb_structs.h"

#if defined __TAUDB_POSTGRESQL__
#include "libpq-fe.h"
#elif defined __TAUDB_SQLITE__
#include "sqlite3.h"
#endif

#ifndef boolean
#define TRUE  1
#define FALSE 0
typedef int boolean;
#endif

typedef struct taudb_prepared_statement {
 char* name;
 UT_hash_handle hh; /* hash index for hashing by name */
} TAUDB_PREPARED_STATEMENT;

/* forward declarations to ease objects that need to know about 
 * each other and have doubly-linked relationships */

struct taudb_timer_call_data;
struct taudb_timer_value;
struct taudb_timer_callpath;
struct taudb_timer_group;
struct taudb_timer_parameter;
struct taudb_timer;
struct taudb_counter_value;
struct taudb_counter;
struct taudb_primary_metadata;
struct taudb_secondary_metadata;
struct taudb_time_range;
struct taudb_thread;
struct taudb_metric;
struct taudb_trial;
struct perfdmf_experiment;
struct perfdmf_application;

typedef struct taudb_configuration {
  char* jdbc_db_type;    /* to identify DBMS vendor. 
                          * postgresql, mysql, h2, derby, etc. */
  char* db_hostname;     /* server host name */
  char* db_portnum;      /* server port number */
  char* db_dbname;       /* the database name at the server */
  char* db_schemaprefix; /* the schema prefix. This is appended to 
                          * all table names for some DBMSs */
  char* db_username;     /* the database username */
  char* db_password;     /* the database password for username */
  char* db_schemafile;   /* full or relative path to the schema file, 
                          * used for configuration, not used in C API */
} TAUDB_CONFIGURATION;

typedef enum taudb_database_schema_version {
  TAUDB_2005_SCHEMA,
  TAUDB_2012_SCHEMA
} TAUDB_SCHEMA_VERSION;

typedef struct taudb_data_source {
 int id;
 char* name;
 char*description;
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_DATA_SOURCE;

typedef struct taudb_connection {
  TAUDB_CONFIGURATION *configuration;
#if defined __TAUDB_POSTGRESQL__
  PGconn *connection;
  PGresult *res;
  TAUDB_PREPARED_STATEMENT *statements;
#elif defined __TAUDB_SQLITE__
  sqlite3 *connection;
  sqlite3_stmt *ppStmt;
  int rc; 
#endif
  TAUDB_SCHEMA_VERSION schema_version;
  boolean inTransaction;
  boolean inPortal;
  TAUDB_DATA_SOURCE* data_sources_by_id;
  TAUDB_DATA_SOURCE* data_sources_by_name;
} TAUDB_CONNECTION;

/* these are the derived thread indexes. */

#define TAUDB_MEAN_WITHOUT_NULLS -1
#define TAUDB_TOTAL -2
#define TAUDB_STDDEV_WITHOUT_NULLS -3
#define TAUDB_MIN -4
#define TAUDB_MAX -5
#define TAUDB_MEAN_WITH_NULLS -6
#define TAUDB_STDDEV_WITH_NULLS -7

/* trials are the top level structure */

typedef struct taudb_trial {
 /* actual data from the database */
 int id;
 char* name;
 struct taudb_data_source* data_source;
 int node_count;             /* i.e. number of processes. */
 int contexts_per_node;      /* rarely used, usually 1. */
 int threads_per_context;    /* max number of threads per process 
                              * (can be less on individual processes) */
 int total_threads;          /* total number of threads */
 /* arrays of data for this trial */
 struct taudb_metric* metrics_by_id;
 struct taudb_metric* metrics_by_name;
 struct taudb_thread* threads;
 struct taudb_time_range* time_ranges;
 struct taudb_timer* timers_by_id;
 struct taudb_timer* timers_by_name;
 struct taudb_timer_group* timer_groups;
 struct taudb_timer_callpath* timer_callpaths_by_id;
 struct taudb_timer_callpath* timer_callpaths_by_name;
 struct taudb_timer_call_data* timer_call_data_by_id;
 struct taudb_timer_call_data* timer_call_data_by_key;
 struct taudb_counter* counters_by_id;
 struct taudb_counter* counters_by_name;
 struct taudb_counter_value* counter_values;
 struct taudb_primary_metadata* primary_metadata;
 struct taudb_secondary_metadata* secondary_metadata;
 struct taudb_secondary_metadata* secondary_metadata_by_key;
} TAUDB_TRIAL;

/*********************************************/
/* data dimensions */
/*********************************************/

/* thread represents one physical &amp; logical 
 * location for a measurement. */

typedef struct taudb_thread {
 int id; /* database id, also key to hash */
 struct taudb_trial* trial;
 int node_rank;    /* which process does this thread belong to? */
 int context_rank; /* which context? USUALLY 0 */
 int thread_rank;  /* what is this thread's rank in the process */
 int index;        /* what is this threads OVERALL index? 
                    * ranges from 0 to trial.thread_count-1 */
 struct taudb_secondary_metadata* secondary_metadata;
 UT_hash_handle hh;
} TAUDB_THREAD;

/* metrics are things like TIME, PAPI counters, and derived metrics. */

typedef struct taudb_metric {
 int id; /* database value, also key to hash */
 char* name; /* key to hash hh2 */
 boolean derived;  /* was this metric measured, or created by a 
                    * post-processing tool? */
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_METRIC;

/* Time ranges are ways to delimit the profile data within time ranges.
   They are also useful for secondary metadata which is associated with
   a specific call to a function. */

typedef struct taudb_time_range {
 int id; /* database value, also key to hash */
 int iteration_start;
 int iteration_end;
 uint64_t time_start;
 uint64_t time_end;  /* was this metric measured, 
                      * or created by a post-processing tool? */
 UT_hash_handle hh;
} TAUDB_TIME_RANGE;

/* timers are interval timers, capturing some interval value.  
 * For callpath or phase profiles, the parent refers to the calling 
 * function or phase.  Timers can also be sample locations, or 
 * phases (dynamic or static), or sample aggregations (intermediate) */

typedef struct taudb_timer {
 int id; /* database value, also key to hash */
 struct taudb_trial* trial;  /* pointer back to trial - NOTE: Necessary? */
 char* name;  /* the full timer name, can have file, line, etc. */
 char* short_name;  /* just the function name, for example */
 char* source_file;  /* what source file does this function live in? */
 int line_number;  /* what line does the timer start on? */
 int line_number_end;  /* what line does the timer end on? */
 int column_number;  /* what column number does the timer start on? */
 int column_number_end;  /* what column number does the timer end on? */
 struct taudb_timer_group* groups; /* hash of groups, 
                                    * using group hash handle hh2 */
 struct taudb_timer_parameter* parameters; /* array of parameters */
 UT_hash_handle trial_hash_by_id;  /* hash key for id lookup */
 UT_hash_handle trial_hash_by_name;  /* hash key for name lookup 
                                      * in temporary hash */
 UT_hash_handle group_hash_by_name;  /* hash key for name lookup 
                                      * in timer group */
} TAUDB_TIMER;

/*********************************************/
/* timer related structures  */
/*********************************************/

/* timer groups are the groups such as tau_default,
   mpi, openmp, tau_phase, tau_callpath, tau_param, etc. 
   this mapping table allows for nxn mappings between timers
   and groups */

typedef struct taudb_timer_group {
 char* name;
 struct taudb_timer* timers;   /* hash of timers, 
                                * using timer hash handle hh3 */
 UT_hash_handle trial_hash_by_name;  // hash handle for trial
 UT_hash_handle timer_hash_by_name;  // hash handle for timers
} TAUDB_TIMER_GROUP;

/* timer parameters are parameter based profile values. 
   an example is foo (x,y) where x=4 and y=10. in that example,
   timer would be the index of the timer with the
   name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. this table would have two
   entries, one for the x value and one for the y value.
   The parameter can also be a phase / iteration index.
*/

typedef struct taudb_timer_parameter {
 char* name;
 char* value;
 UT_hash_handle hh;
} TAUDB_TIMER_PARAMETER;

/* callpath objects contain the merged dynamic callgraph tree seen
 * during execution */

typedef struct taudb_timer_callpath {
 int id; /* link back to database, and hash key */
 struct taudb_timer* timer; /* which timer is this? */
 struct taudb_timer_callpath *parent; /* callgraph parent */
 char* name; /* a string which has the aggregated callpath. */
 UT_hash_handle hh1; /* hash key for hash by id */
 UT_hash_handle hh2; /* hash key for name (a =&gt; b =&gt; c...) lookup */
} TAUDB_TIMER_CALLPATH;

/* timer_call_data objects are observations of a node of the callgraph
   for one of the threads. */

typedef struct taudb_call_data_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_TIMER_CALL_DATA_KEY;

typedef struct taudb_timer_call_data {
 int id; /* link back to database */
 TAUDB_TIMER_CALL_DATA_KEY key; /* hash table key */
 int calls;  /* number of times this timer was seen */
 int subroutines;  /* number of timers this timer calls */
 struct taudb_timer_value* timer_values;
 UT_hash_handle hh1;
 UT_hash_handle hh2;
} TAUDB_TIMER_CALL_DATA;

/* finally, timer_values are specific measurements during one of the
   observations of the node of the callgraph on a thread. */

typedef struct taudb_timer_value {
 struct taudb_metric* metric;   /* which metric is this? */
 double inclusive;              /* the inclusive value of this metric */
 double exclusive;              /* the exclusive value of this metric */
 double inclusive_percentage;   /* the inclusive percentage of 
                                 * total time of the application */
 double exclusive_percentage;   /* the exclusive percentage of 
                                 * total time of the application */
 double sum_exclusive_squared;  /* how much variance did we see 
                                 * every time we measured this timer? */
 char *key; /* hash table key - metric name */
 UT_hash_handle hh;
} TAUDB_TIMER_VALUE;

/*********************************************/
/* counter related structures  */
/*********************************************/

/* counters measure some counted value. An example would be MPI message size
 * for an MPI_Send.  */

typedef struct taudb_counter {
 int id; /* database reference */
 struct taudb_trial* trial;
 char* name;
 UT_hash_handle hh1; /* hash key for hashing by id */
 UT_hash_handle hh2; /* hash key for hashing by name */
} TAUDB_COUNTER;

/* counters are atomic counters, not just interval timers */

typedef struct taudb_counter_value_key {
 struct taudb_counter* counter; /* the counter we are measuring */
 struct taudb_thread* thread;   /* where this measurement is */
 struct taudb_timer_callpath* context; /* the calling context (can be null) */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_COUNTER_VALUE_KEY;

typedef struct taudb_counter_value {
 TAUDB_COUNTER_VALUE_KEY key;
 int sample_count;          /* how many times did we see take this count? */
 double maximum_value;      /* what was the max value we saw? */
 double minimum_value;      /* what was the min value we saw? */
 double mean_value;         /* what was the average value we saw? */
 double standard_deviation; /* how much variance was there? */
 UT_hash_handle hh1; /* hash key for hashing by key */
} TAUDB_COUNTER_VALUE;

/*********************************************/
/* metadata related structures  */
/*********************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

typedef struct taudb_primary_metadata {
 char* name;
 char* value;
 UT_hash_handle hh; /* uses the name as the key */
} TAUDB_PRIMARY_METADATA;

/* primary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

typedef struct taudb_secondary_metadata_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 struct taudb_secondary_metadata* parent; /* self-referencing */
 struct taudb_time_range* time_range;
 char* name;
} TAUDB_SECONDARY_METADATA_KEY;

typedef struct taudb_secondary_metadata {
 char* id; /* link back to database */
 TAUDB_SECONDARY_METADATA_KEY key;
 int num_values; /* can have arrays of data */
 char** value;
 int child_count;
 struct taudb_secondary_metadata* children; /* self-referencing  */
 UT_hash_handle hh; /* uses the id as a compound key */
 UT_hash_handle hh2; /* uses the key as a compound key */
} TAUDB_SECONDARY_METADATA;

/* these are for supporting the older schema */

typedef struct perfdmf_experiment {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_EXPERIMENT;

typedef struct perfdmf_application {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_APPLICATION;

#endif /* TAUDB_STRUCTS_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.api"></a>11.3.&nbsp;TAUdb C API</h2></div></div></div><pre class="screen">
#ifndef TAUDB_API_H
#define TAUDB_API_H 1

#include "taudb_structs.h"

/* when a "get" function is called, this global has the number of 
   top-level objects that are returned. */
extern int taudb_numItems;

/* the database version */
extern enum taudb_database_schema_version taudb_version;

/* to connect to the database */
extern TAUDB_CONNECTION* taudb_connect_config(char* config_name);
extern TAUDB_CONNECTION* taudb_connect_config_file(char* config_file_name);

/* test the connection status */
extern int taudb_check_connection(TAUDB_CONNECTION* connection);

/* disconnect from the database */
extern int taudb_disconnect(TAUDB_CONNECTION* connection);

/************************************************/
/* query functions */
/************************************************/

/* functions to support the old database schema - avoid these if you can */
extern PERFDMF_APPLICATION* 
    perfdmf_query_applications(TAUDB_CONNECTION* connection);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiments(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application);
extern PERFDMF_APPLICATION* 
    perfdmf_query_application(TAUDB_CONNECTION* connection, char* name);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiment(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application, char* name);
extern TAUDB_TRIAL* perfdmf_query_trials(TAUDB_CONNECTION* connection, 
    PERFDMF_EXPERIMENT* experiment);

/* get the data sources */
extern TAUDB_DATA_SOURCE* 
    taudb_query_data_sources(TAUDB_CONNECTION* connection);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_id(TAUDB_DATA_SOURCE* data_sources, 
	const int id);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_name(TAUDB_DATA_SOURCE* data_sources, 
	const char* name);

/* using the properties set in the filter, find a set of trials */
extern TAUDB_TRIAL* 
    taudb_query_trials(TAUDB_CONNECTION* connection, boolean complete, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_query_primary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_get_primary_metadata_by_name(TAUDB_PRIMARY_METADATA* primary_metadata, 
	const char* name);
extern TAUDB_SECONDARY_METADATA* 
    taudb_query_secondary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);

/* get the threads for a trial */
extern TAUDB_THREAD* 
    taudb_query_threads(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_query_derived_threads(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_get_thread(TAUDB_THREAD* threads, int thread_index);
extern int taudb_get_total_threads(TAUDB_THREAD* threads);

/* get the metrics for a trial */
extern TAUDB_METRIC* 
    taudb_query_metrics(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_METRIC* 
    taudb_get_metric_by_name(TAUDB_METRIC* metrics, const char* name);
extern TAUDB_METRIC* 
    taudb_get_metric_by_id(TAUDB_METRIC* metrics, const int id);

/* get the time_ranges for a trial */
extern TAUDB_TIME_RANGE* 
    taudb_query_time_range(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIME_RANGE* 
    taudb_get_time_range(TAUDB_TIME_RANGE* time_ranges, const int id);

/* get the timers for a trial */
extern TAUDB_TIMER* 
    taudb_query_timers(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_TIMER* 
    taudb_get_timer_by_id(TAUDB_TIMER* timers, int id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER_GROUP* 
    taudb_query_timer_groups(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern void 
    taudb_parse_timer_group_names(TAUDB_TRIAL* trial, TAUDB_TIMER* timer, 
	char* group_names);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_trial_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_timer_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER* timer);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_id(TAUDB_TIMER_CALLPATH* timers, int id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_name(TAUDB_TIMER_CALLPATH* timers, 
	const char* id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_all_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern char* taudb_get_callpath_string(TAUDB_TIMER_CALLPATH* timer_callpath);

/* get the counters for a trial */
extern TAUDB_COUNTER* 
    taudb_query_counters(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_id(TAUDB_COUNTER* counters, int id);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_name(TAUDB_COUNTER* counters, const char* id);
extern TAUDB_COUNTER_VALUE* 
    taudb_query_counter_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
TAUDB_COUNTER_VALUE* 
    taudb_get_counter_value(TAUDB_COUNTER_VALUE* counter_values, 
	TAUDB_COUNTER* counter, TAUDB_THREAD* thread, 
	TAUDB_TIMER_CALLPATH* context, char* timestamp);

/* get the timer call data for a trial */
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_id(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	int id);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_key(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_TIMER_CALLPATH* callpath, TAUDB_THREAD* thread, char* timestamp);

/* get the timer values for a trial */
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_get_timer_value(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_METRIC* metric);

/* find main */
extern TAUDB_TIMER* 
    taudb_query_main_timer(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);

/* save everything */
extern void taudb_save_trial(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update, boolean cascade);
extern void taudb_save_threads(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_metrics(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timers(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_time_ranges(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_groups(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_parameters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_callpaths(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_call_data(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counter_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_primary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_secondary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);

/************************************************/
/* memory functions */
/************************************************/

extern char* taudb_strdup(const char* in_string);
extern TAUDB_TRIAL* taudb_create_trials(int count);
extern TAUDB_METRIC*             taudb_create_metrics(int count);
extern TAUDB_TIME_RANGE*         taudb_create_time_ranges(int count);
extern TAUDB_THREAD*             taudb_create_threads(int count);
extern TAUDB_SECONDARY_METADATA* taudb_create_secondary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_create_primary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_resize_primary_metadata(int count, 
    TAUDB_PRIMARY_METADATA* old_primary_metadata);
extern TAUDB_COUNTER*            taudb_create_counters(int count);
extern TAUDB_COUNTER_VALUE*      taudb_create_counter_values(int count);
extern TAUDB_TIMER*              taudb_create_timers(int count);
extern TAUDB_TIMER_PARAMETER*    taudb_create_timer_parameters(int count);
extern TAUDB_TIMER_GROUP*        taudb_create_timer_groups(int count);
extern TAUDB_TIMER_GROUP*        taudb_resize_timer_groups(int count, 
    TAUDB_TIMER_GROUP* old_groups);
extern TAUDB_TIMER_CALLPATH*     taudb_create_timer_callpaths(int count);
extern TAUDB_TIMER_CALL_DATA*    taudb_create_timer_call_data(int count);
extern TAUDB_TIMER_VALUE*        taudb_create_timer_values(int count);

extern void taudb_delete_trials(TAUDB_TRIAL* trials, int count);

/************************************************/
/* Adding objects to the hierarchy */
/************************************************/

extern void taudb_add_metric_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_METRIC* metric);
extern void taudb_add_time_range_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIME_RANGE* time_range);
extern void taudb_add_thread_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_THREAD* thread);
extern void taudb_add_secondary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_SECONDARY_METADATA* secondary_metadata);
extern void taudb_add_secondary_metadata_to_secondary_metadata
    (TAUDB_SECONDARY_METADATA* parent, TAUDB_SECONDARY_METADATA* child);
extern void taudb_add_primary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_PRIMARY_METADATA* primary_metadata);
extern void taudb_add_counter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER* counter);
extern void taudb_add_counter_value_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER_VALUE* counter_value);
extern void taudb_add_timer_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_parameter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_PARAMETER* timer_parameter);
extern void taudb_add_timer_group_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_GROUP* timer_group);
extern void taudb_add_timer_to_timer_group(TAUDB_TIMER_GROUP* timer_group, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_callpath_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALLPATH* timer_callpath);
extern void taudb_add_timer_call_data_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALL_DATA* timer_call_data);
extern void taudb_add_timer_value_to_timer_call_data
    (TAUDB_TIMER_CALL_DATA* timer_call_data, TAUDB_TIMER_VALUE* timer_value);

/* Profile parsers */
extern TAUDB_TRIAL* taudb_parse_tau_profiles(const char* directory_name);

/* Analysis routines */
extern void taudb_compute_statistics(TAUDB_TRIAL* trial);

/* iterators */
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_name_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_id_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_THREAD* 
    taudb_next_thread_by_index_from_trial(TAUDB_THREAD* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_name_from_trial(TAUDB_METRIC* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_id_from_trial(TAUDB_METRIC* current);
extern TAUDB_TIME_RANGE* 
    taudb_next_time_range_by_id_from_trial(TAUDB_TIME_RANGE* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_id_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_group(TAUDB_TIMER* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_trial
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_timer
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_PARAMETER* 
    taudb_next_timer_parameter_by_name_from_timer
	(TAUDB_TIMER_PARAMETER* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_name_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_id_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_key_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_id_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_VALUE* 
    taudb_next_timer_value_by_metric_from_timer_call_data
	(TAUDB_TIMER_VALUE* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_name_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_id_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER_VALUE* 
    taudb_next_counter_value_by_key_from_trial(TAUDB_COUNTER_VALUE* current);
extern TAUDB_PRIMARY_METADATA* 
    taudb_next_primary_metadata_by_name_from_trial
	(TAUDB_PRIMARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_key_from_trial
	(TAUDB_SECONDARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_id_from_trial
	(TAUDB_SECONDARY_METADATA* current);

#endif /* TAUDB_API_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.examples"></a>11.4.&nbsp;TAUdb C API Examples</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.insert"></a>11.4.1.&nbsp;Creating a trial and inserting into the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include "dump_functions.h"

int main (int argc, char** argv) {
  TAUDB_CONNECTION* connection = NULL;
  if (argc &gt;= 2) {
    connection = taudb_connect_config(argv[1]);
  } else {
    fprintf(stderr, "Please specify a TAUdb config file.\n");
    exit(1);
  }
  printf("Checking connection...\n");
  taudb_check_connection(connection);

  // create a trial
  TAUDB_TRIAL* trial = taudb_create_trials(1);
  trial-&gt;name = taudb_strdup("TEST TRIAL");
  // set the data source to "other"
  trial-&gt;data_source = taudb_get_data_source_by_id(
      taudb_query_data_sources(connection), 999);
  
  // create some metadata
  TAUDB_PRIMARY_METADATA* pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Application");
  pm-&gt;value = taudb_strdup("Test Application");
  taudb_add_primary_metadata_to_trial(trial, pm);

  pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Start Time");
  pm-&gt;value = taudb_strdup("2012-11-07 12:30:00");
  taudb_add_primary_metadata_to_trial(trial, pm);

  // alternatively, you can allocate the primary metadata in blocks
  pm = taudb_create_primary_metadata(10);
  pm[0].name = taudb_strdup("ClientID");
  pm[0].value = taudb_strdup("joe_user");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[0]));
  pm[1].name = taudb_strdup("hostname");
  pm[1].value = taudb_strdup("hopper04");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[1]));
  pm[2].name = taudb_strdup("Operating System");
  pm[2].value = taudb_strdup("Linux");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[2]));
  pm[3].name = taudb_strdup("Release");
  pm[3].value = taudb_strdup("2.6.32.36-0.5-default");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[3]));
  pm[4].name = taudb_strdup("Machine");
  pm[4].value = taudb_strdup("Hopper.nersc.gov");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[4]));
  pm[5].name = taudb_strdup("CPU Cache Size");
  pm[5].value = taudb_strdup("512 KB");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[5]));
  pm[6].name = taudb_strdup("CPU Clock Frequency");
  pm[6].value = taudb_strdup("800.000 MHz");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[6]));
  pm[7].name = taudb_strdup("CPU Model");
  pm[7].value = taudb_strdup("Quad-Core AMD Opteron(tm) Processor 8378");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[7]));

  // create a metric
  TAUDB_METRIC* metric = taudb_create_metrics(1);
  metric-&gt;name = taudb_strdup("TIME");
  taudb_add_metric_to_trial(trial, metric);

  // create a thread
  TAUDB_THREAD* thread = taudb_create_threads(1);
  thread-&gt;node_rank = 1;
  thread-&gt;context_rank = 1;
  thread-&gt;thread_rank = 1;
  thread-&gt;index = 1;
  taudb_add_thread_to_trial(trial, thread);

  // create a timer, timer_callpath, timer_call_data, timer_value
  TAUDB_TIMER_GROUP* timer_group = taudb_create_timer_groups(1);
  TAUDB_TIMER* timer = taudb_create_timers(1);
  TAUDB_TIMER_CALLPATH* timer_callpath = taudb_create_timer_callpaths(1);
  TAUDB_TIMER_CALL_DATA* timer_call_data = taudb_create_timer_call_data(1);
  TAUDB_TIMER_VALUE* timer_value = taudb_create_timer_values(1);

  timer-&gt;name = taudb_strdup(
      "int main(int, char **) [{kernel.c} {134,1}-{207,1}]");
  timer-&gt;short_name = taudb_strdup("main");
  timer-&gt;source_file = taudb_strdup("kernel.c");
  timer-&gt;line_number = 134;
  timer-&gt;column_number = 1;
  timer-&gt;line_number_end = 207;
  timer-&gt;column_number_end = 1;
  taudb_add_timer_to_trial(trial, timer);

  timer_group-&gt;name = taudb_strdup("TAU_DEFAULT");
  taudb_add_timer_group_to_trial(trial, timer_group);
  taudb_add_timer_to_timer_group(timer_group, timer);

  timer_callpath-&gt;timer = timer;
  timer_callpath-&gt;parent = NULL;
  taudb_add_timer_callpath_to_trial(trial, timer_callpath);

  timer_call_data-&gt;key.timer_callpath = timer_callpath;
  timer_call_data-&gt;key.thread = thread;
  timer_call_data-&gt;calls = 1;
  timer_call_data-&gt;subroutines = 0;
  taudb_add_timer_call_data_to_trial(trial, timer_call_data);

  timer_value-&gt;metric = metric;
  // 5 seconds, or 5 million microseconds
  timer_value-&gt;inclusive = 5000000; 
  timer_value-&gt;exclusive = 5000000;
  timer_value-&gt;inclusive_percentage = 100.0;
  timer_value-&gt;exclusive_percentage = 100.0;
  timer_value-&gt;sum_exclusive_squared = 0.0;
  taudb_add_timer_value_to_timer_call_data(timer_call_data, timer_value);

  // compute stats
  printf("Computing Stats...\n");
  taudb_compute_statistics(trial);

  // save the trial!
  printf("Testing inserts...\n");
  boolean update = FALSE;
  boolean cascade = TRUE;
  taudb_save_trial(connection, trial, update, cascade);
  
  printf("Disconnecting...\n");
  taudb_disconnect(connection);
  printf("Done.\n");
  return 0;
}
	    </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.query"></a>11.4.2.&nbsp;Querying a trial from the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void dump_metadata(TAUDB_PRIMARY_METADATA *metadata) {
   printf("%d metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_PRIMARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_primary_metadata_by_name_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;name, current-&gt;value);
   }
}

void dump_secondary_metadata(TAUDB_SECONDARY_METADATA *metadata) {
   printf("%d secondary metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_SECONDARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_secondary_metadata_by_key_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;key.name, current-&gt;value[0]);
   }
}

void dump_trial(TAUDB_CONNECTION* connection, TAUDB_TRIAL* filter, 
                boolean haveTrial) {
   TAUDB_TRIAL* trial;
   if (haveTrial) {
     trial = filter;
   } else {
     trial = taudb_query_trials(connection, FALSE, filter);
   }
   TAUDB_TIMER* timer = taudb_query_main_timer(connection, trial);
   printf("Trial name: '%s', id: %d, main: '%s'\n\n", 
          trial-&gt;name, trial-&gt;id, timer-&gt;name);
}

int main (int argc, char** argv) {
   printf("Connecting...\n");
   TAUDB_CONNECTION* connection = NULL;
   if (argc &gt;= 2) {
     connection = taudb_connect_config(argv[1]);
   } else {
     fprintf(stderr, "Please specify a TAUdb config file.\n");
     exit(1);
   }
   printf("Checking connection...\n");
   taudb_check_connection(connection);
   printf("Testing queries...\n");

   int t;

   // test the "find trials" method to populate the trial
   TAUDB_TRIAL* filter = taudb_create_trials(1);
   filter-&gt;id = atoi(argv[2]);
   TAUDB_TRIAL* trials = taudb_query_trials(connection, TRUE, filter);
   int numTrials = taudb_numItems;
   for (t = 0 ; t &lt; numTrials ; t = t+1) {
      printf("  Trial name: '%s', id: %d\n", 
	         trials[t].name, trials[t].id);
      dump_metadata(trials[t].primary_metadata);
      dump_secondary_metadata(trials[t].secondary_metadata);
      dump_trial(connection, &amp;(trials[t]), TRUE);
   }

   printf("Disconnecting...\n");
   taudb_disconnect(connection);
   printf("Done.\n");
   return 0;
}
	    </pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e10848"></a>Chapter&nbsp;12.&nbsp;Windows</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TAUonWin">12.1. TAU on Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e10854">12.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#d0e10865">12.1.2. Instrumenting an application with Visual Studio C/C++</a></span></dt><dt><span class="sect2"><a href="#UsingMINGW">12.1.3. Using MINGW  with TAU</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TAUonWin"></a>12.1.&nbsp;TAU on Windows</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10854"></a>12.1.1.&nbsp;Installation</h3></div></div></div><p>We provide a binary release build for Windows on the <a href="http://www.cs.uoregon.edu/research/tau/downloads.php" target="_top">download
    page</a>. TAU can also be built form source using
    <code class="literal">Makefile.win32</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10865"></a>12.1.2.&nbsp;Instrumenting an application with Visual Studio C/C++</h3></div></div></div><p>Here is a step by step guide for retrieving a standard profile from a
    threaded program.</p><div class="orderedlist"><ol type="1"><li><p>Download TAU (see previous section)</p></li><li><p>Open
      <code class="literal">[TAU-HOME]/examples/threads/threads.sln</code> in VC 7 or
      greater.</p></li><li><p>Open <code class="literal">testTau.cpp</code> source file.</p></li><li><p>Uncomment the pragma element at the top of the file so that it
      reads:</p><pre class="screen">
#define PROFILING_ON 1
#pragma comment(lib, "tau-profile-static-mt.lib")
</pre></li><li><p>Edit these properties of this project:
        </p><div class="orderedlist"><ol type="a"><li><p>Add the <code class="literal">..\..\lib\vc7\</code> directory to the
          Linker's Additional Library Directories.</p></li><li><p>Set the Runtime Library to <code class="literal">Multi-threaded DLL
          (MD)</code>in the C/C++ Code Generation section.</p></li></ol></div><p>
      </p></li><li><p>Build and run the application.</p></li><li><p>Launch Visual Studio's command line prompt Move to the
      <code class="literal">[TAU-HOME]/examples/threads/directory/</code> this is where
      the profile files where written. Type: </p><pre class="screen">
%&gt; [TAU-HOME]/bin/paraprof
</pre><p> To view these profiles in pararprof</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="UsingMINGW"></a>12.1.3.&nbsp;Using MINGW  with TAU</h3></div></div></div><pre class="screen">
Building TAU with the MinGW cross-compilers for 32- or 64-bit Windows

Requirements:

MinGW compilers must be in your path.  For example (64-bit):
* x86_64-w64-mingw32-gcc
* x86_64-w64-mingw32-g++
* x86_64-w64-mingw32-ar
* x86_64-w64-mingw32-ld
* x86_64-w64-mingw32-ranlib

Limitations:

* No signal processing
* No event-based sampling (EBS)

Instructions:

See ./configure -help.
</pre></div></div></div><div class="reference" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e10925"></a>TAU Instrumentation API</h1></div></div><hr></div><div class="partintro" lang="en"><div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10929"></a>Introduction</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>C++</strong></span></p><p>The C++ API is a set of macros that can be inserted in the C++
	source code. An extension of the same API is available to instrument C
	and Fortran sources.</p><p>At the beginning of each instrumented source file, include the
	following header</p><pre class="screen">
#include &lt;TAU.h&gt;
	</pre></li><li><p><span class="bold"><strong>C</strong></span></p><p>The API for instrumenting C source code is similar to the C++
        API. The primary difference is that the <code class="literal">TAU_PROFILE()</code> macro
	is not available for identifying an entire block of code or function.
	Instead, routine transitions are explicitly specified using
	<code class="literal">TAU_PROFILE_TIMER()</code> macro with
	<code class="literal">TAU_PROFILE_START()</code> and
	<code class="literal">TAU_PROFILE_STOP()</code> macros to indicate the entry and
	exit from a routine. Note that, <code class="literal">TAU_TYPE_STRING()</code> and
	CT() macros are not applicable for C. It is important to declare the
	<code class="literal">TAU_PROFILE_TIMER()</code> macro after all the variables
	have been declared in the function and before the execution of the first
        C statement. 
      </p><p>Example:</p><pre class="screen">

#include &lt;TAU.h&gt;

int main (int argc, char **argv) {
  int ret;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  pthread_attr_init(&amp;attr);
  printf("Started Main...\n");
  // other statements
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
      </pre></li><li><p><span class="bold"><strong>Fortran 77/90/95</strong></span></p><p>The Fortran90 TAU API allows source code written in Fortran to
       be instrumented for TAU. This API is comprised of Fortran routines. As
       explained in Chapter 2, the instrumentation can be disabled in the
       program by using the TAU stub makefile variable
       <code class="literal">TAU_DISABLE</code> on the link command line. This points to
       a library that contains empty TAU instrumentation routines.</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10982"></a>Timers</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Static timers</strong></span></p><p>These are commonly used in most profilers where all invocations of a
		routine are recorded. The name and group registration takes place when the
		timer is created (typically the first time a routine is entered). A given
		timer is started and stopped at routine entry and exit points. A user
		defined timer can also measure the time spent in a group of statements.
		Timers may be nested but they may not overlap. The performance data
		generated can typically answer questions such as: <span class="emphasis"><em>what is the 
		total time spent in MPI_Send() across all invocations?</em></span></p></li><li><p><span class="bold"><strong>Dynamic timers</strong></span></p><p>To record the execution of each invocation of a routine, TAU
		provides dynamic timers where a unique name may be constructed for a
		dynamic timer for each iteration by embedding the iteration count in it.
		It uses the start/stop calls around the code to be examined, similar to
		static timers. The performance data generated can typically answer
		questions such as:<span class="emphasis"><em>what is the time spent in the routine foo() in
		iterations 24, 25, and 40?</em></span></p></li><li><p><span class="bold"><strong>Static phases</strong></span></p><p>An application typically goes through several phases in its
	    execution. To track the performance of the application based on
	    phases, TAU provides static and dynamic phase profiling. A profile
	    based on phases highlights the context in which a routine is
	    called. An application has a default phase within which other
	    routines and phases are invoked. A phase based profile shows the
	    time spent in a routine when it was in a given phase. So, if a set
	    of instrumented routines are called directly or indirectly by a
	    phase, we'd see the time spent in each of those routines under the
	    given phase. Since phases may be nested, a routine may belong to
	    only one phase. When more than one phase is active for a given
	    routine, the closest ancestor phase of a routine along its
	    callstack is its phase for that invocation. The performance data
	    generated can answer questions such as: <span class="emphasis"><em>what is the total
	    time spent in MPI_Send() when it was invoked in all invocations of
	    the IO (IO =&gt; MPI_Send()) phase?  </em></span></p></li><li><p><span class="bold"><strong>Dynamic phases</strong></span></p><p>Dynamic phases borrow from dynamic timers and static phases to
		create performance data for all routines that are invoked in a given
		invocation of a phase. If we instrument a routine as a dynamic phase,
		creating a unique name for each of its invocations (by embedding the
		invocation count in the name), we can examine the time spent in all
		routines and child phases invoked directly or indirectly from the given
		phase. The performance data generated can typically answer questions such
		as: 
		<span class="emphasis"><em>what is the total time spent in MPI_Send() when it was invoked
		directly or indirectly in iteration 24?</em></span> 
		Dynamic phases are useful for
		tracking per-iteration profiles for an adaptive computation where
		iterations may differ in their execution times.</p></li><li><p><span class="bold"><strong>Callpaths</strong></span></p><p>In phase-based profiles, we see the relationship between routines
		and parent phases. Phase profiles do not show the calling structure
		between different routines as is represented in a callgraph. To do so, TAU
		provides callpath profiling capabilities where the time spent in a routine
		along an edge of a callgraph is captured. Callpath profiles present the
		full flat profiles of routines (or nodes in the callgraph), as well as
		routines along a callpath. A callpath is represented syntactically as a
		list of routines separated by a delimiter. The maximum depth of a callpath
		is controlled by an environment variable.</p></li><li><p><span class="bold"><strong>User-defined Events</strong></span></p><p>Besides timers and phases that measure the time spent between a pair
		of start and stop calls in the code, TAU also provides support for
		user-defined atomic events. After an event is registered with a name, it
		may be triggered with a value at a given point in the source code. At the
		application level, we can use user-defined events to track the progress of
		the simulation by keeping track of application specific parameters that
		explain program dynamics, for example, the number of iterations required
		for convergence of a solver at each time step, or the number of cells in
		each iteration of an adaptive mesh refinement application.</p></li></ul></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#TAU_START">TAU_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STOP">TAU_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE">TAU_PROFILE</a></span><span class="refpurpose"> - Profile a C++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PROFILE">TAU_DYNAMIC_PROFILE</a></span><span class="refpurpose"> - dynamic_profile a c++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_DYNAMIC">TAU_PROFILE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Creates a dynamic timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_DYNAMIC_AUTO">TAU_CREATE_DYNAMIC_AUTO</a></span><span class="refpurpose"> - Creates a dynamic timer for C/C++</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DYNAMIC_ITER">TAU_PROFILE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic timer in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_DYNAMIC_ITER">TAU_PHASE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic phase in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER">TAU_PROFILE_TIMER</a></span><span class="refpurpose"> - Defines a static timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_START">TAU_PROFILE_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STOP">TAU_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_START">TAU_STATIC_TIMER_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_STOP">TAU_STATIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_START">TAU_DYNAMIC_TIMER_START</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_STOP">TAU_DYNAMIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_DYNAMIC">TAU_PROFILE_TIMER_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DECLARE_TIMER">TAU_PROFILE_DECLARE_TIMER</a></span><span class="refpurpose"> - Declares a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_TIMER">TAU_PROFILE_CREATE_TIMER</a></span><span class="refpurpose"> - Creates a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER">TAU_GLOBAL_TIMER</a></span><span class="refpurpose"> - Declares a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_EXTERNAL">TAU_GLOBAL_TIMER_EXTERNAL</a></span><span class="refpurpose"> - Declares a global timer from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_START">TAU_GLOBAL_TIMER_START</a></span><span class="refpurpose"> - Starts a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_STOP">TAU_GLOBAL_TIMER_STOP</a></span><span class="refpurpose"> - Stops a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE">TAU_PHASE</a></span><span class="refpurpose"> - Profile a C++ function as a phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE">TAU_DYNAMIC_PHASE</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_DYNAMIC">TAU_PHASE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_STATIC">TAU_PHASE_CREATE_STATIC</a></span><span class="refpurpose"> - Defines a static phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_START">TAU_PHASE_START</a></span><span class="refpurpose"> - Enters a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_STOP">TAU_PHASE_STOP</a></span><span class="refpurpose"> - Exits a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_START">TAU_DYNAMIC_PHASE_START</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_STOP">TAU_DYNAMIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_START">TAU_STATIC_PHASE_START</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_STOP">TAU_STATIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE">TAU_GLOBAL_PHASE</a></span><span class="refpurpose"> - Declares a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_EXTERNAL">TAU_GLOBAL_PHASE_EXTERNAL</a></span><span class="refpurpose"> - Declares a global phase from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_START">TAU_GLOBAL_PHASE_START</a></span><span class="refpurpose"> - Starts a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_STOP">TAU_GLOBAL_PHASE_STOP</a></span><span class="refpurpose"> - Stops a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_EXIT">TAU_PROFILE_EXIT</a></span><span class="refpurpose"> - Alerts the profiling system to an exit call</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_THREAD">TAU_REGISTER_THREAD</a></span><span class="refpurpose"> - Register a thread with the profiling system</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_NODE">TAU_PROFILE_GET_NODE</a></span><span class="refpurpose"> - Returns the measurement system's node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_CONTEXT">TAU_PROFILE_GET_CONTEXT</a></span><span class="refpurpose"> - Gives the measurement system's context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_THREAD">TAU_PROFILE_SET_THREAD</a></span><span class="refpurpose"> - Informs the measurement system of the THREAD id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_THREAD">TAU_PROFILE_GET_THREAD</a></span><span class="refpurpose"> - Gives the measurement system's thread id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_NODE">TAU_PROFILE_SET_NODE</a></span><span class="refpurpose"> - Informs the measurement system of the node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_CONTEXT">TAU_PROFILE_SET_CONTEXT</a></span><span class="refpurpose"> - Informs the measurement system of the context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_FORK">TAU_REGISTER_FORK</a></span><span class="refpurpose"> - Informs the measurement system that a fork has taken place</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_EVENT">TAU_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_REGISTER_EVENT">TAU_PROFILER_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_THREAD">TAU_EVENT_THREAD</a></span><span class="refpurpose"> - Triggers a user event on a given thread</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_CONTEXT_EVENT">TAU_REGISTER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Registers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_CONTEXT_EVENT">TAU_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT">TAU_TRIGGER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a context user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_CONTEXT_EVENT">TAU_ENABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Enable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_CONTEXT_EVENT">TAU_DISABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Disable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_SET_NAME">TAU_EVENT_SET_NAME</a></span><span class="refpurpose"> - Sets the name of an event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MAX">TAU_EVENT_DISABLE_MAX</a></span><span class="refpurpose"> - Disables tracking of maximum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MEAN">TAU_EVENT_DISABLE_MEAN</a></span><span class="refpurpose"> - Disables tracking of mean statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MIN">TAU_EVENT_DISABLE_MIN</a></span><span class="refpurpose"> - Disables tracking of minimum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_STDDEV">TAU_EVENT_DISABLE_STDDEV</a></span><span class="refpurpose"> - Disables tracking of standard deviation statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_STATISTICS">TAU_REPORT_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_THREAD_STATISTICS">TAU_REPORT_THREAD_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics, plus thread statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_INSTRUMENTATION">TAU_ENABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Enables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_INSTRUMENTATION">TAU_DISABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Disables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP">TAU_ENABLE_GROUP</a></span><span class="refpurpose"> - Enables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP">TAU_DISABLE_GROUP</a></span><span class="refpurpose"> - Disables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP">TAU_PROFILE_TIMER_SET_GROUP</a></span><span class="refpurpose"> - Change the group of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME">TAU_PROFILE_TIMER_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name for a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_NAME">TAU_PROFILE_TIMER_SET_NAME</a></span><span class="refpurpose"> - Changes the name of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_TYPE">TAU_PROFILE_TIMER_SET_TYPE</a></span><span class="refpurpose"> - Changes the type of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_GROUP_NAME">TAU_PROFILE_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name of a profiled section</span></dt><dt><span class="refentrytitle"><a href="#TAU_INIT">TAU_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_INIT">TAU_PROFILE_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_PROFILE_GROUP">TAU_GET_PROFILE_GROUP</a></span><span class="refpurpose"> - Creates groups based on names</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP_NAME">TAU_ENABLE_GROUP_NAME</a></span><span class="refpurpose"> - Enables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP_NAME">TAU_DISABLE_GROUP_NAME</a></span><span class="refpurpose"> - Disables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_ALL_GROUPS">TAU_ENABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Enables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_ALL_GROUPS">TAU_DISABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Disables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_NAMES">TAU_GET_EVENT_NAMES</a></span><span class="refpurpose"> - Gets the registered user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_VALS">TAU_GET_EVENT_VALS</a></span><span class="refpurpose"> - Gets user event data for given user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_COUNTER_NAMES">TAU_GET_COUNTER_NAMES</a></span><span class="refpurpose"> - Gets the counter names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_NAMES">TAU_GET_FUNC_NAMES</a></span><span class="refpurpose"> - Gets the function names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_VALS">TAU_GET_FUNC_VALS</a></span><span class="refpurpose"> - Gets detailed performance data for given functions</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY">TAU_ENABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Enables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY">TAU_DISABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Disables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER">TAU_TRACK_POWER</a></span><span class="refpurpose"> - Initializes POWER tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER_HERE">TAU_TRACK_POWER_HERE</a></span><span class="refpurpose"> - Triggers power tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_POWER">TAU_ENABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Enables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_POWER">TAU_DISABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Disables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY">TAU_TRACK_MEMORY</a></span><span class="refpurpose"> - Initializes memory tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HERE">TAU_TRACK_MEMORY_HERE</a></span><span class="refpurpose"> - Triggers memory tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT">TAU_TRACK_MEMORY_FOOTPRINT</a></span><span class="refpurpose"> - Initializes memory footprint tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE">TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span><span class="refpurpose"> - Triggers memory footprint tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Enables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Disables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM">TAU_TRACK_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM_HERE">TAU_TRACK_MEMORY_HEADROOM_HERE</a></span><span class="refpurpose"> - Takes a sample of the amount of memory available at a given point.</span></dt><dt><span class="refentrytitle"><a href="#TAU_SET_INTERRUPT_INTERVAL">TAU_SET_INTERRUPT_INTERVAL</a></span><span class="refpurpose"> - Change the inter-interrupt interval for tracking memory and headroom</span></dt><dt><span class="refentrytitle"><a href="#CT">CT</a></span><span class="refpurpose"> - Returns the type information for a variable</span></dt><dt><span class="refentrytitle"><a href="#TAU_TYPE_STRING">TAU_TYPE_STRING</a></span><span class="refpurpose"> - Creates a type string</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP">TAU_DB_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_MERGED_DUMP">TAU_DB_MERGED_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_INCR">TAU_DB_DUMP_INCR</a></span><span class="refpurpose"> - Dumps profile database into timestamped profiles on disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX">TAU_DB_DUMP_PREFIX</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given prefix</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX_TASK">TAU_DB_DUMP_PREFIX_TASK</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given task</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_PURGE">TAU_DB_PURGE</a></span><span class="refpurpose"> - Purges the performance data.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_NAMES">TAU_DUMP_FUNC_NAMES</a></span><span class="refpurpose"> - Dumps function names to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS">TAU_DUMP_FUNC_VALS</a></span><span class="refpurpose"> - Dumps performance data for given functions to disk.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS_INCR">TAU_DUMP_FUNC_VALS_INCR</a></span><span class="refpurpose"> - Dumps function values with a timestamp</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STMT">TAU_PROFILE_STMT</a></span><span class="refpurpose"> - Executes a statement only when TAU is used.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CALLSTACK">TAU_PROFILE_CALLSTACK</a></span><span class="refpurpose"> - Generates a callstack trace at a given location.</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_RECVMSG">TAU_TRACE_RECVMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_SENDMSG">TAU_TRACE_SENDMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_PARAM1L">TAU_PROFILE_PARAM1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT">TAU_PROFILE_SNAPSHOT</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT_1L">TAU_PROFILE_SNAPSHOT_1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_CREATE">TAU_PROFILER_CREATE</a></span><span class="refpurpose"> - Creates a profiler object referenced as a standard pointer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_TASK">TAU_CREATE_TASK</a></span><span class="refpurpose"> - Creates a task id.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START">TAU_PROFILER_START</a></span><span class="refpurpose"> - starts a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START_TASK">TAU_PROFILER_START_TASK</a></span><span class="refpurpose"> - Starts a profiler object created by  on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP">TAU_PROFILER_STOP</a></span><span class="refpurpose"> - stops a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP_TASK">TAU_PROFILER_STOP_TASK</a></span><span class="refpurpose"> - Stops a profiler object on a task</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS">TAU_PROFILER_GET_CALLS</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS_TASK">TAU_PROFILER_GET_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS">TAU_PROFILER_GET_CHILD_CALLS</a></span><span class="refpurpose"> - Gets the number of calls made while this timer was running</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK">TAU_PROFILER_GET_CHILD_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of child call for this timer, created by , is started on a task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES">TAU_PROFILER_GET_INCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES">TAU_PROFILER_GET_EXCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO">TAU_PROFILER_GET_COUNTER_INFO</a></span><span class="refpurpose"> - Returns information about all the timers created.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK">TAU_PROFILER_GET_COUNTER_INFO_TASK</a></span><span class="refpurpose"> - Returns information about all the timers created on a task. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_DECLARE_EVENT">TAU_QUERY_DECLARE_EVENT</a></span><span class="refpurpose"> - Returns a event handle.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_CURRENT_EVENT">TAU_QUERY_GET_CURRENT_EVENT</a></span><span class="refpurpose"> - set event to be the current TAU event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_EVENT_NAME">TAU_QUERY_GET_EVENT_NAME</a></span><span class="refpurpose"> - Gets the name of a given event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_PARENT_EVENT">TAU_QUERY_GET_PARENT_EVENT</a></span><span class="refpurpose"> - gets the parent of the current event. 
	</span></dt></dl></div></div><div class="refentry" lang="en"><a name="TAU_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>character <var class="pdparam">name</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e11066"></a><h2>Description</h2><p>Starts the timer given by <em class="parameter"><code>name</code></em></p></div><div class="refsect1" lang="en"><a name="d0e11073"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  
	call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e11086"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STOP" title="TAU_STOP"><span class="refentrytitle">TAU_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STOP &#8212; Stops a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>character <var class="pdparam">name</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e11130"></a><h2>Description</h2><p>Stops the timer given by <em class="parameter"><code>timer</code></em>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</p></div><div class="refsect1" lang="en"><a name="d0e11138"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e11151"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_START" title="TAU_START"><span class="refentrytitle">TAU_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE &#8212; Profile a C++ function</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11187"></a><h2>Description</h2><p><code class="function">TAU_PROFILE</code> profiles a function.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e11194"></a><h2>Example</h2><pre class="screen">
int foo(char *str) {
  TAU_PROFILE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e11199"></a><h2>See Also</h2><p><a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PROFILE &#8212; dynamic_profile a c++ function</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PROFILE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11231"></a><h2>description</h2><p><code class="function">TAU_DYNAMIC_PROFILE</code> profiles a function dynamically
    creating a separate profile for each time the function is called.  this macro
    defines the function and takes care of the timer start and stop as well.
    the timer will stop when the macro goes out of scope (as in c++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e11238"></a><h2>example</h2><pre class="screen">
int foo(char *str) {
  tau_dynamic_profile("foo","int (char *)",tau_default);
  ...
}
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CREATE_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CREATE_DYNAMIC &#8212; Creates a dynamic timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11298"></a><h2>description</h2><p><code class="function">TAU_PROFILE_CREATE_DYNAMIC</code> creates a dynamic
    timer the name of the timer should be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e11305"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
</pre><p>&gt;<span class="bold"><strong>Fortran:</strong></span></p><pre class="screen">
 subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
</pre></div><div class="refsect1" lang="en"><a name="d0e11320"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CREATE_DYNAMIC_AUTO"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CREATE_DYNAMIC_AUTO &#8212; Creates a dynamic timer for C/C++</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CREATE_DYNAMIC_AUTO</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11358"></a><h2>description</h2><p><code class="function">TAU_CREATE_DYNAMIC_AUTO</code> creates a dynamic
    timer automatically incrementing the name each time the timer is executed.</p></div><div class="refsect1" lang="en"><a name="d0e11365"></a><h2>example</h2><pre class="screen">
int tau_ret_val;
TAU_PROFILE_CREATE_DYNAMIC_AUTO(tautimer, "int foo1(int) C [{foo.c} {22,1}-{29,1}]", " ",TAU_USER);
TAU_PROFILE_START(tautimer);
{
printf("inside foo1: calling bar: x = %d\n", x);
printf("before calling bar in foo1\n");
bar(x-1); /* 26 */
printf("after calling bar in foo1\n");
{ tau_ret_val =  x; TAU_PROFILE_STOP(tautimer); return (tau_ret_val); }</pre></div><div class="refsect1" lang="en"><a name="d0e11370"></a><h2>see also</h2><p><a href="#TAU_PROFILE_CREATE_DYNAMIC" title="TAU_PROFILE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_CREATE_DYNAMIC</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_DYNAMIC_ITER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_DYNAMIC_ITER &#8212; Creates a dynamic timer in Fortran.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_DYNAMIC_ITER</b>(</code></td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iterator</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11408"></a><h2>description</h2><p><code class="function">TAU_PROFILE_DYNAMIC_ITER</code> creates a dynamic
    timer the name of the timer is appended by the iterator.</p></div><div class="refsect1" lang="en"><a name="d0e11415"></a><h2>example</h2><pre class="screen">
  integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PROFILE_DYNAMIC_ITER(tau_iter, profiler, '               &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PROFILE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</pre></div><div class="refsect1" lang="en"><a name="d0e11420"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_DYNAMIC_ITER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_DYNAMIC_ITER &#8212; Creates a dynamic phase in Fortran.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_DYNAMIC_ITER</b>(</code></td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iterator</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11456"></a><h2>description</h2><p><code class="function">TAU_PHASE_DYNAMIC_ITER</code> creates a dynamic
    phase the name of which is appended by the iterator.</p></div><div class="refsect1" lang="en"><a name="d0e11463"></a><h2>example</h2><pre class="screen">
          integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PHASE_DYNAMIC_ITER(tau_iter, profiler, '                 &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PHASE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</pre></div><div class="refsect1" lang="en"><a name="d0e11468"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER &#8212; Defines a static timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">profiler</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11527"></a><h2>Description</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><p>With <code class="literal">TAU_PROFILE_TIMER</code>, a group of one or more
    statements is profiled. This macro has a timer variable as its first
    argument, and then strings for name and type, as described earlier. It
    associates the timer to the profile group specified in the last
    parameter. </p><p><span class="bold"><strong>Fortran :</strong></span></p><p>To profile a block of Fortran code, such as a function, subroutine,
    loop etc., the user must first declare a profiler, which is an integer array
    of two elements (pointer) with the save attribute, and pass it as the first
    parameter to the <code class="literal">TAU_PROFILE_TIMER</code> subroutine. The second
    parameter must contain the name of the routine, which is enclosed in a single
    quote. <code class="literal">TAU_PROFILE_TIMER</code> declares the profiler that must
    be used to profile a block of code. The profiler is used to profile the
    statements using <code class="literal">TAU_PROFILE_START</code> and
    <code class="literal">TAU_PROFILE_STOP</code> as explained later.
    </p></div><div class="refsect1" lang="en"><a name="d0e11555"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt; class T, unsigned Dim &gt;
void BareField&lt;T,Dim&gt;::fillGuardCells(bool reallyFill)
{y
 // profiling macros
 TAU_TYPE_STRING(taustr, CT(*this) + " void (bool)" );
 TAU_PROFILE("BareField::fillGuardCells()", taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(sendtimer, "fillGuardCells-send", 
                   taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(localstimer, "fillGuardCells-locals",
                   taustr, TAU_FIELD);
 ...
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine bcast_inputs
implicit none
integer profiler(2)
save profiler
					
include 'mpinpb.h'
include 'applu.incl'
					
interger IERR
					
call TAU_PROFILE_TIMER(profiler, 'bcast_inputs')
  </pre></div><div class="refsect1" lang="en"><a name="d0e11568"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER_DYNAMIC" title="TAU_PROFILE_TIMER_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_TIMER_DYNAMIC</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>, 
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_START</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e11614"></a><h2>Description</h2><p>Starts the timer given by <em class="parameter"><code>timer</code></em></p></div><div class="refsect1" lang="en"><a name="d0e11621"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e11634"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_STOP &#8212; Stops a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STOP</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e11678"></a><h2>Description</h2><p>Stops the timer given by <em class="parameter"><code>timer</code></em>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</p></div><div class="refsect1" lang="en"><a name="d0e11686"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e11699"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_TIMER_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_START</b>(</code></td><td><var class="pdparam">profiler</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11743"></a><h2>Description</h2><p>Starts a static timer defined by <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e11750"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </pre></div><div class="refsect1" lang="en"><a name="d0e11763"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STATIC_PHASE_START" title="TAU_STATIC_PHASE_START"><span class="refentrytitle">TAU_STATIC_PHASE_START</span></a>,
      <a href="#TAU_STATIC_PHASE_STOP" title="TAU_STATIC_PHASE_STOP"><span class="refentrytitle">TAU_STATIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_TIMER_STOP &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_STOP</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e11809"></a><h2>Description</h2><p>Starts a static timer defined by <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e11816"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </pre></div><div class="refsect1" lang="en"><a name="d0e11829"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STATIC_PHASE_START" title="TAU_STATIC_PHASE_START"><span class="refentrytitle">TAU_STATIC_PHASE_START</span></a>,
      <a href="#TAU_STATIC_PHASE_STOP" title="TAU_STATIC_PHASE_STOP"><span class="refentrytitle">TAU_STATIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_TIMER_START &#8212; Starts a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>String <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_START</b>(</code></td><td><var class="pdparam">iteration</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iteration</var>;</td></tr><tr><td>char &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11879"></a><h2>Description</h2><p>Starts a new dynamic timer concating the iterator to the end of the
    name.</p></div><div class="refsect1" lang="en"><a name="d0e11884"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e11897"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_TIMER_STOP &#8212; Starts a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>String <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_STOP</b>(</code></td><td><var class="pdparam">iteration</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iteration</var>;</td></tr><tr><td>char &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e11945"></a><h2>Description</h2><p>Stops a new dynamic timer concating the iterator to the end of the
    name.<em class="parameter"><code>timer</code></em></p></div><div class="refsect1" lang="en"><a name="d0e11952"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e11965"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_DYNAMIC &#8212; Defines a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_DYNAMIC</b>(</code></td><td><var class="pdparam">profiler</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12026"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_TIMER_DYNAMIC</code> operates similar to
  <code class="literal">TAU_PROFILE_TIMER</code> except that the timer is created each
  time the statement is invoked.  This way, the name of the timer can be
  different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e12036"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_TIMER_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_TIMER_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e12049"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_DECLARE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_DECLARE_TIMER &#8212; Declares a timer for C</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_DECLARE_TIMER</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e12083"></a><h2>Description</h2><p>Because C89 does not allow mixed code and declarations,
    <code class="literal">TAU_PROFILE_TIMER</code> can only be used once in a function.  To
    declare two timers in a C function, use
    <code class="literal">TAU_PROFILE_DECLARE_TIMER</code> and
    <code class="literal">TAU_PROFILE_CREATE_TIMER</code>.</p></div><div class="refsect1" lang="en"><a name="d0e12097"></a><h2>Example</h2><p><span class="bold"><strong>C :</strong></span></p><pre class="screen">int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12105"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_CREATE_TIMER" title="TAU_PROFILE_CREATE_TIMER"><span class="refentrytitle">TAU_PROFILE_CREATE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CREATE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CREATE_TIMER &#8212; Creates a timer for C</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_TIMER</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e12133"></a><h2>Description</h2><p>Because C89 does not allow mixed code and declarations,
  <code class="literal">TAU_PROFILE_TIMER</code> can only be used once in a function.  To
  declare two timers in a C function, use
  <code class="literal">TAU_PROFILE_DECLARE_TIMER</code> and
  <code class="literal">TAU_PROFILE_CREATE_TIMER</code>.</p></div><div class="refsect1" lang="en"><a name="d0e12147"></a><h2>Example</h2><p><span class="bold"><strong>C :</strong></span></p><pre class="screen">int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}</pre></div><div class="refsect1" lang="en"><a name="d0e12155"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_DECLARE_TIMER" title="TAU_PROFILE_DECLARE_TIMER"><span class="refentrytitle">TAU_PROFILE_DECLARE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER &#8212; Declares a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12201"></a><h2>Description</h2><p>As <code class="literal">TAU_PROFILE_TIMER</code> is used within the scope of a
    block (typically a routine), <code class="literal">TAU_GLOBAL_TIMER</code> can be used
    across different routines. </p></div><div class="refsect1" lang="en"><a name="d0e12212"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12220"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_EXTERNAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_EXTERNAL &#8212; Declares a global timer from an external compilation unit</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_EXTERNAL</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e12252"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_EXTERNAL</code> allows you to access a
    timer defined in another compilation unit.</p></div><div class="refsect1" lang="en"><a name="d0e12259"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12267"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_START &#8212; Starts a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e12301"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_START</code> starts a global timer.</p></div><div class="refsect1" lang="en"><a name="d0e12308"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12316"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_STOP &#8212; Stops a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_STOP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e12347"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_STOP</code> stops a global timer.</p></div><div class="refsect1" lang="en"><a name="d0e12354"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12362"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE &#8212; Profile a C++ function as a phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12402"></a><h2>Description</h2><p><code class="function">TAU_PHASE</code> profiles a function as a phase.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e12409"></a><h2>Example</h2><pre class="screen">
int foo(char *str) {
  TAU_PHASE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e12414"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE &#8212; Defines a dynamic phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12475"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE</code> creates a dynamic phase.
  The name of the timer can be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e12482"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_DYNAMIC_PHASE(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_DYNAMIC_PHASE(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e12495"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_DYNAMIC_PHASE_START" title="TAU_DYNAMIC_PHASE_START"><span class="refentrytitle">TAU_DYNAMIC_PHASE_START</span></a>,
      <a href="#TAU_DYNAMIC_PHASE_STOP" title="TAU_DYNAMIC_PHASE_STOP"><span class="refentrytitle">TAU_DYNAMIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_CREATE_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_CREATE_DYNAMIC &#8212; Defines a dynamic phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12558"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_CREATE_DYNAMIC</code> creates a dynamic phase.
  The name of the timer can be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e12565"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PHASE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PHASE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e12578"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_CREATE_STATIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_CREATE_STATIC &#8212; Defines a static phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_STATIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_STATIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e12641"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_CREATE_STATIC</code> creates a static phase.
  Static phases (and timers) are more efficient than dynamic ones because the
  function registration only takes place once.</p></div><div class="refsect1" lang="en"><a name="d0e12648"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.phase("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e12667"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_START &#8212; Enters a phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>integer <var class="pdparam">phase</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e12713"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_START</code> enters a phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e12720"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre></div><div class="refsect1" lang="en"><a name="d0e12733"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_STOP &#8212; Exits a phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>integer <var class="pdparam">phase</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e12779"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_STOP</code> exits a phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e12786"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre></div><div class="refsect1" lang="en"><a name="d0e12799"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE_START &#8212; Enters a DYNAMIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e12845"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE_START</code> enters a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e12852"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e12865"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE_STOP &#8212; Enters a DYNAMIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e12911"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE_STOP</code> leaves a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e12918"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e12931"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_PHASE_START &#8212; Enters a STATIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e12977"></a><h2>Description</h2><p><code class="literal">TAU_STATIC_PHASE_START</code> enters a static phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e12984"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e12997"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_PHASE_STOP &#8212; Enters a STATIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e13043"></a><h2>Description</h2><p><code class="literal">TAU_STATIC_PHASE_STOP</code> leaves a static phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e13050"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e13063"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE &#8212; Declares a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e13109"></a><h2>Description</h2><p>Declares a global phase to be used in multiple compilation units.</p></div><div class="refsect1" lang="en"><a name="d0e13114"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e13122"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_EXTERNAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_EXTERNAL &#8212; Declares a global phase from an external compilation unit</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_EXTERNAL</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13156"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_EXTERNAL</code> allows you to access a
    phase defined in another compilation unit.</p></div><div class="refsect1" lang="en"><a name="d0e13163"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e13171"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_START &#8212; Starts a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13205"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_START</code> starts a global phase.</p></div><div class="refsect1" lang="en"><a name="d0e13212"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e13220"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_STOP &#8212; Stops a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13254"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_STOP</code> stops a global phase.</p></div><div class="refsect1" lang="en"><a name="d0e13261"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_STOP(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e13269"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_EXIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_EXIT &#8212; Alerts the profiling system to an exit call</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_EXIT</b>(</code><var class="pdparam">message</var><code>)</code>;<br>const char * <var class="pdparam">message</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_EXIT</b>(</code><var class="pdparam">message</var><code>)</code>;<br>character <var class="pdparam">message</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e13316"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_EXIT</code> should be called prior to an
    error exit from the program so that any profiles or event traces can be
    dumped to disk before quitting.</p></div><div class="refsect1" lang="en"><a name="d0e13324"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if ((ret = open(...)) &lt; 0) {
  TAU_PROFILE_EXIT("ERROR in opening a file");
  perror("open() failed");
  exit(1);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_EXIT('abort called')
    </pre></div><div class="refsect1" lang="en"><a name="d0e13337"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_THREAD &#8212; Register a thread with the profiling system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REGISTER_THREAD</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REGISTER_THREAD</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13372"></a><h2>Description</h2><p>To register a thread with the profiling system, invoke the
    <code class="literal">TAU_REGISTER_THREAD</code> macro in the run method of the
    thread prior to executing any other TAU macro. This sets up thread
    identifiers that are later used by the instrumentation system.</p></div><div class="refsect1" lang="en"><a name="d0e13380"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void * threaded_func(void *data) {
  TAU_REGISTER_THREAD();
  { /**** NOTE WE START ANOTHER BLOCK IN THREAD */
    TAU_PROFILE_TIMER(tautimer, "threaded_func()", "int ()", 
                      TAU_DEFAULT);
    TAU_PROFILE_START(tautimer);
    work(); /* work done by this thread */
    TAU_PROFILE_STOP(tautimer);
  }
  return NULL;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REGISTER_THREAD()
    </pre></div><div class="refsect1" lang="en"><a name="d0e13393"></a><h2>Caveat</h2><p>PDT based tau_instrumentor does not insert <code class="literal">TAU_REGISTER_THREAD</code> calls,
    they must be inserted manually</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_NODE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_NODE &#8212; Returns the measurement system's node id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>int <var class="pdparam">node</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>integer <var class="pdparam">node</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13435"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_NODE</code> gives the node id for the
		processes in which it is called. When using MPI node id is the same as MPI
		rank.</p></div><div class="refsect1" lang="en"><a name="d0e13442"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
	int nodeid;
  TAU_PROFILE_GET_NODE(nodeid);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: N
      call TAU_PROFILE_GET_NODE(N)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setNode(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e13460"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_GET_CONTEXT" title="TAU_PROFILE_GET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_GET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_CONTEXT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_CONTEXT &#8212; Gives the measurement system's context id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>int <var class="pdparam">context</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>integer <var class="pdparam">context</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13501"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_CONTEXT</code> gives the context id for the
		processes in which it is called.
		</p></div><div class="refsect1" lang="en"><a name="d0e13508"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_CONTEXT(i);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: C 
        call TAU_PROFILE_GET_CONTEXT(C)
      END PROGRAM SUM_OF_CUBES
    </pre></div><div class="refsect1" lang="en"><a name="d0e13521"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_THREAD &#8212; Informs the measurement system of the THREAD id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>int <var class="pdparam">THREAD</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>integer <var class="pdparam">THREAD</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13562"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_THREAD</code> macro sets the thread
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;THREAD&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_THREAD</code> when you
		configued with a threading package (including OpenMP).</p></div><div class="refsect1" lang="en"><a name="d0e13573"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_THREAD(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_THREAD(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setThread(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e13591"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_NODE" title="TAU_PROFILE_SET_NODE"><span class="refentrytitle">TAU_PROFILE_SET_NODE</span></a>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_THREAD &#8212; Gives the measurement system's thread id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_THREAD</b>(</code><var class="pdparam">thread</var><code>)</code>;<br>int <var class="pdparam">thread</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>integer <var class="pdparam">THREAD</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13634"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_THREAD</code> gives the thread id for the
		processes in which it is called.
		</p></div><div class="refsect1" lang="en"><a name="d0e13641"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_THREAD(i);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: T
        call TAU_PROFILE_GET_THREAD(T)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
pytau.getThread(i)
		</pre></div><div class="refsect1" lang="en"><a name="d0e13659"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_GET_NODE" title="TAU_PROFILE_GET_NODE"><span class="refentrytitle">TAU_PROFILE_GET_NODE</span></a>
      <a href="#TAU_PROFILE_GET_CONTEXT" title="TAU_PROFILE_GET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_GET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_NODE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_NODE &#8212; Informs the measurement system of the node id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>int <var class="pdparam">node</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>integer <var class="pdparam">node</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13702"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_NODE</code> macro sets the node
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_NODE</code> when using the
    TAU MPI wrapper library.</p></div><div class="refsect1" lang="en"><a name="d0e13713"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setNode(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e13731"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_CONTEXT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_CONTEXT &#8212; Informs the measurement system of the context id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>int <var class="pdparam">context</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>integer <var class="pdparam">context</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e13772"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_CONTEXT</code> macro sets the context
    identifier of the executing task for profiling and tracing. Tasks are
    identified using context, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;context&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_CONTEXT</code> when using the
    TAU MPI wrapper library.</p></div><div class="refsect1" lang="en"><a name="d0e13783"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_SET_CONTEXT(1);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
        call TAU_PROFILE_SET_CONTEXT(1)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre></div><div class="refsect1" lang="en"><a name="d0e13796"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_NODE" title="TAU_PROFILE_SET_NODE"><span class="refentrytitle">TAU_PROFILE_SET_NODE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_FORK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_FORK &#8212; Informs the measurement system that a fork has taken place</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_FORK</b>(</code></td><td><var class="pdparam">pid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">option</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">pid</var>;</td></tr><tr><td>enum TauFork_t &nbsp;</td><td><var class="pdparam">option</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e13830"></a><h2>Description</h2><p>To register a child process obtained from the fork()
    syscall, invoke the  <code class="literal">TAU_REGISTER_FORK</code>  macro. It takes 
    two parameters, the first is the node id of the child process (typically
    the process id returned by the fork call or any 0..N-1 range integer).
    The second parameter specifies whether the performance data for the
    child process should be derived from the parent at the time of fork
    ( <code class="literal">TAU_INCLUDE_PARENT_DATA</code> ) or should be independent of
    its parent at the time of fork
    ( <code class="literal">TAU_EXCLUDE_PARENT_DATA</code> ). If the process id is used as
    the node id, before any analysis is done, all profile files should be
    converted to contiguous node numbers (from 0..N-1). It is highly
    recommended to use flat contiguous node numbers in this call for
    profiling and tracing. </p></div><div class="refsect1" lang="en"><a name="d0e13844"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
pID = fork();
if (pID == 0) {
  printf("Parent : pid returned %d\n", pID)
}  else { 
  // If we'd used the TAU_INCLUDE_PARENT_DATA, we get
  // the performance data from the parent in this process
  // as well.
  TAU_REGISTER_FORK(pID, TAU_EXCLUDE_PARENT_DATA);        
  printf("Child : pid = %d", pID);
}
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_EVENT &#8212; Registers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e13896"></a><h2>Description</h2><p>TAU can profile user-defined events using
    <code class="literal">TAU_REGISTER_EVENT</code>. The meaning of the event is
    determined by the user. The first argument to
    <code class="literal">TAU_REGISTER_EVENT</code> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e13907"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e13920"></a><h2>See Also</h2><p>
      <a href="#TAU_EVENT" title="TAU_EVENT"><span class="refentrytitle">TAU_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_REGISTER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_REGISTER_EVENT &#8212; Registers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>void *&nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e13985"></a><h2>Description</h2><p>TAU can profile user-defined events using
    <code class="literal">TAU_PROFILER_REGISTER_EVENT</code>. The meaning of the event is
    determined by the user. The first argument to
    <code class="literal">TAU_PROFILER_REGISTER_EVENT</code> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e13996"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  void *ue1;
	TAU_PROFILER_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_PROFILER_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e14009"></a><h2>See Also</h2><p>
      <a href="#TAU_EVENT" title="TAU_EVENT"><span class="refentrytitle">TAU_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_EVENT &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14070"></a><h2>Description</h2><p>Triggers an named event with the given value</p></div><div class="refsect1" lang="en"><a name="d0e14075"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_EVENT(count, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_EVENT_THREAD &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT_THREAD</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT_THREAD</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14141"></a><h2>Description</h2><p>Triggers an named event with the given value on a given thead or task.</p></div><div class="refsect1" lang="en"><a name="d0e14146"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count, workTask);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_EVENT(count, workTask, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT</b>(</code><var class="pdparam">variable</var>, <var class="pdparam">value</var><code>)</code>;<br>integer <var class="pdparam">variable</var>(2);<br>real <var class="pdparam">value</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e14202"></a><h2>Description</h2><p>Triggers an event that was registered with
    <code class="literal">TAU_REGISTER_EVENT</code>.</p></div><div class="refsect1" lang="en"><a name="d0e14210"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e14223"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_THREAD &#8212; Triggers a user event on a given thread</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_THREAD</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread id</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEVENT_THREAD &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread id</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_THREAD</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread id</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">thread id</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14281"></a><h2>Description</h2><p>Triggers an event that was registered with
    <code class="literal">TAU_REGISTER_EVENT</code> on a given thread.</p></div><div class="refsect1" lang="en"><a name="d0e14289"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT_THREAD(ue1, count * count, threadid);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT_THREAD(eventid, count, threadid)
    </pre></div><div class="refsect1" lang="en"><a name="d0e14302"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_CONTEXT_EVENT &#8212; Registers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14353"></a><h2>Description</h2><p>Creates a context event with name. A context event appends the 
     names of routines executing on the callstack to the name specified by
     the user. Whenver a context event is triggered, the callstack is 
     examined to determine the context of execution. Starting from the parent
     function where the event is triggered, TAU walks up the callstack to a 
     depth specified by the user in the environment variable 
     <code class="literal">TAU_CALLPATH_DEPTH </code>. If this environment variable is 
     not specified, TAU uses 2 as the default depth. For e.g., if the user 
     registers a context event with the name "memory used" and specifies 3 as 
     the callpath depth, and if the event is triggered in two locations 
     (in routine a, when it was called by b, when it was called by c, and in 
     routine h, when it was called by g, when it was called by i), then, we'd 
     see the user defined event information for 
     "memory used: c() =&gt; b() =&gt; a()" and "memory used: i() =&gt; g() =&gt; h()".
 
      </p></div><div class="refsect1" lang="en"><a name="d0e14361"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine foo(id)
  integer id
       
  integer profiler(2) / 0, 0 /
  integer maev(2) / 0, 0 /
  integer mdev(2) / 0, 0 /
  save profiler, maev, mdev

  integer :: ierr
  integer :: h, t, u
  INTEGER, ALLOCATABLE :: STORAGEARY(:)
  DOUBLEPRECISION   edata

  call TAU_PROFILE_TIMER(profiler, 'FOO')
  call TAU_PROFILE_START(profiler)
  call TAU_PROFILE_SET_NODE(0)

  call TAU_REGISTER_CONTEXT_EVENT(maev, "STORAGEARY Alloc [cubes.f:20]")
  call TAU_REGISTER_CONTEXT_EVENT(mdev, "STORAGEARY Dealloc [cubes.f:37]")

  allocate(STORAGEARY(1:999), STAT=IERR)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(maev, edata)
  ...
  deallocate(STORAGEARY)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(mdev, edata)
  call TAU_PROFILE_STOP(profiler)
  end subroutine foo
     </pre></div><div class="refsect1" lang="en"><a name="d0e14374"></a><h2>See Also</h2><p>
      <a href="#TAU_CONTEXT_EVENT" title="TAU_CONTEXT_EVENT"><span class="refentrytitle">TAU_CONTEXT_EVENT</span></a>,
      <a href="#TAU_ENABLE_CONTEXT_EVENT" title="TAU_ENABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_ENABLE_CONTEXT_EVENT</span></a>,
      <a href="#TAU_DISABLE_CONTEXT_EVENT" title="TAU_DISABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_DISABLE_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CONTEXT_EVENT &#8212; Triggers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14438"></a><h2>Description</h2><p>Triggers a context event. A context event associates the name with 
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e14446"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer memevent(2) / 0, 0 /
save memevent
call TAU_REGISTER_CONTEXT_EVENT(memevent, "STORAGEARY mem allocated')
call TAU_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER))
    </pre></div><div class="refsect1" lang="en"><a name="d0e14459"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_CONTEXT_EVENT &#8212; Triggers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14509"></a><h2>Description</h2><p>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e14517"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_TRIGGER_CONTEXT_EVENT("Iteration count", 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer memevent(2) / 0, 0 /
save memevent
call TAU_TRIGGER_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER), "STORAGEARY mem allocated")
    </pre></div><div class="refsect1" lang="en"><a name="d0e14530"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_CONTEXT_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_CONTEXT_EVENT_THREAD &#8212; Triggers a context user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT_THREAD</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT_THREAD</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14590"></a><h2>Description</h2><p>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e14598"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_CONTEXT_EVENT_THREAD("Error in Iteration", count * count, workTask);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRIGGER_CONTEXT_EVENT_THREAD(count, workTask, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_CONTEXT_EVENT &#8212; Enable a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_ENABLE_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14634"></a><h2>Description</h2><p>Enables a context event.</p></div><div class="refsect1" lang="en"><a name="d0e14639"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e14647"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_DISABLE_CONTEXT_EVENT" title="TAU_DISABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_DISABLE_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_CONTEXT_EVENT &#8212; Disable a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DISABLE_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14679"></a><h2>Description</h2><p>Disables a context event.</p></div><div class="refsect1" lang="en"><a name="d0e14684"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e14692"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_ENABLE_CONTEXT_EVENT" title="TAU_ENABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_ENABLE_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_SET_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_SET_NAME &#8212; Sets the name of an event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_SET_NAME</b>(</code></td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>const char *&nbsp;</td><td><var class="pdparam">name</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14728"></a><h2>Description</h2><p>Changes the name of an event.</p></div><div class="refsect1" lang="en"><a name="d0e14733"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_SET_NAME(event, "new name");
    </pre></div><div class="refsect1" lang="en"><a name="d0e14741"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MAX"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MAX &#8212; Disables tracking of maximum statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MAX</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e14771"></a><h2>Description</h2><p>Disables tracking of maximum statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e14776"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MAX(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e14784"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MEAN"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MEAN &#8212; Disables tracking of mean statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MEAN</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e14814"></a><h2>Description</h2><p>Disables tracking of mean statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e14819"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MEAN(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e14827"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MIN"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MIN &#8212; Disables tracking of minimum statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MIN</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e14857"></a><h2>Description</h2><p>Disables tracking of minimum statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e14862"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MIN(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e14870"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_STDDEV"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_STDDEV &#8212; Disables tracking of standard deviation statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_STDDEV</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e14900"></a><h2>Description</h2><p>Disables tracking of standard deviation statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e14905"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_STDDEV(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e14913"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REPORT_STATISTICS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REPORT_STATISTICS &#8212; Outputs statistics</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_STATISTICS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_STATISTICS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e14948"></a><h2>Description</h2><p> <code class="literal">TAU_REPORT_STATISTICS</code>  prints the aggregate
    statistics of user events across all threads in each node. Typically,
    this should be called just before the main thread exits. </p></div><div class="refsect1" lang="en"><a name="d0e14956"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_REPORT_STATISTICS();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REPORT_STATISTICS()
    </pre></div><div class="refsect1" lang="en"><a name="d0e14969"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REPORT_THREAD_STATISTICS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REPORT_THREAD_STATISTICS &#8212; Outputs statistics, plus thread statistics</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_THREAD_STATISTICS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_THREAD_STATISTICS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15008"></a><h2>Description</h2><p><code class="literal">TAU_REPORT_THREAD_STATISTICS</code> prints the
    aggregate, as well as per thread user event statistics.  Typically, this
    should be called just before the main thread exits. </p></div><div class="refsect1" lang="en"><a name="d0e15015"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_REPORT_THREAD_STATISTICS();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REPORT_THREAD_STATISTICS()
    </pre></div><div class="refsect1" lang="en"><a name="d0e15028"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_INSTRUMENTATION"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_INSTRUMENTATION &#8212; Enables instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15067"></a><h2>Description</h2><p> <code class="literal">TAU_ENABLE_INSTRUMENTATION</code>  macro re-enables
    all TAU instrumentation. All instances of functions and statements that
    occur between the disable/enable section are ignored by TAU. This allows
    a user to limit the trace size, if the macros are used to disable
    recording of a set of iterations that have the same characteristics as,
    for example, the first recorded instance.</p></div><div class="refsect1" lang="en"><a name="d0e15075"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_ENABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_ENABLE_INSTRUMENTATION()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</pre></div><div class="refsect1" lang="en"><a name="d0e15093"></a><h2>See Also</h2><p>
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_INSTRUMENTATION"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_INSTRUMENTATION &#8212; Disables instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15136"></a><h2>Description</h2><p> <code class="literal">TAU_DISABLE_INSTRUMENTATION</code>  macro disables
    all entry/exit instrumentation within all threads of a context. This
    allows the user to selectively enable and disable instrumentation in
    parts of his/her code. It is important to re-enable the instrumentation
    within the same basic block and scope. </p></div><div class="refsect1" lang="en"><a name="d0e15144"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_DISABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_DISABLE_INSTRUMENTATION()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</pre></div><div class="refsect1" lang="en"><a name="d0e15162"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_GROUP &#8212; Enables tracking of a given group</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>TauGroup_t <var class="pdparam">group</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>integer <var class="pdparam">group</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15211"></a><h2>Description</h2><p>Enables the instrumentation for a given group.  By default, it is already on.</p></div><div class="refsect1" lang="en"><a name="d0e15216"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_ENABLE_GROUP(TAU_USER);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  include 'Profile/TauFAPI.h'
  call TAU_ENABLE_GROUP(TAU_USER)
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableGroup(TAU_USER)
		</pre></div><div class="refsect1" lang="en"><a name="d0e15234"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_GROUP &#8212; Disables tracking of a given group</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>TauGroup_t <var class="pdparam">group</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>integer <var class="pdparam">group</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15283"></a><h2>Description</h2><p>Disables the instrumentation for a given group.  By default, it is on.</p></div><div class="refsect1" lang="en"><a name="d0e15288"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_DISABLE_GROUP(TAU_USER);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  include 'Profile/TauFAPI.h'
  call TAU_DISABLE_GROUP(TAU_USER)
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableGroup(TAU_USER)
		</pre></div><div class="refsect1" lang="en"><a name="d0e15306"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_GROUP &#8212; Change the group of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_GROUP</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15348"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP</code> changes the group
    associated with a timer.</p></div><div class="refsect1" lang="en"><a name="d0e15356"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(t, "foo loop timer", " ", TAU_USER1);
  ...
  TAU_PROFILE_TIMER_SET_GROUP(t, TAU_USER3);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e15364"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME" title="TAU_PROFILE_TIMER_SET_GROUP_NAME"><span class="refentrytitle">TAU_PROFILE_TIMER_SET_GROUP_NAME</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_GROUP_NAME &#8212; Changes the group name for a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_GROUP_NAME</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15400"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP_NAME</code> changes the
    group name associated with a given timer.</p></div><div class="refsect1" lang="en"><a name="d0e15408"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(looptimer, "foo: loop1", " ", TAU_USER);
  TAU_PROFILE_START(looptimer);
  for (int i = 0; i &lt; N; i++) { /* do something */ }
  TAU_PROFILE_STOP(looptimer);
  TAU_PROFILE_TIMER_SET_GROUP_NAME("Field");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e15416"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_TIMER_SET_GROUP" title="TAU_PROFILE_TIMER_SET_GROUP"><span class="refentrytitle">TAU_PROFILE_TIMER_SET_GROUP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_NAME &#8212; Changes the name of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_NAME</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">newname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>string &nbsp;</td><td><var class="pdparam">newname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15452"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_NAME</code> macro changes the name
    associated with a timer to the newname argument. </p></div><div class="refsect1" lang="en"><a name="d0e15460"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo:loop1", " ", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_NAME(timer1, "foo:lines 21-34");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e15468"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_TYPE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_TYPE &#8212; Changes the type of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_TYPE</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">newname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>string &nbsp;</td><td><var class="pdparam">newname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15502"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_TYPE</code> macro changes the type
    associated with a timer to the newname argument. </p></div><div class="refsect1" lang="en"><a name="d0e15510"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo", "int", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_TYPE(timer1, "long");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e15518"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_GROUP_NAME &#8212; Changes the group name of a profiled section</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15548"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_SET_GROUP_NAME</code>  macro allows
    the user to change the group name associated with the instrumented
    routine. This macro must be called within the instrumented routine. 
    </p></div><div class="refsect1" lang="en"><a name="d0e15556"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", "void ()", TAU_USER);
  TAU_PROFILE_SET_GROUP_NAME("Particle"); 
  /* gives a more meaningful group name */
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e15564"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_INIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_INIT &#8212; Processes command-line arguments for selective instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_INIT</b>(</code><var class="pdparam">argc</var>, <var class="pdparam">argv</var><code>)</code>;<br>int *<var class="pdparam">argc</var>;<br>char ***<var class="pdparam">argv</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15598"></a><h2>Description</h2><p><code class="literal">TAU_INIT</code> parses and removes the command-line
    arguments for the names of profile groups that are to be selectively
    enabled for instrumentation. By default, if this macro is not used,
    functions belonging to all profile groups are
    enabled. <code class="literal">TAU_INIT</code> differs from
    <code class="literal">TAU_PROFILE_INIT</code> only in the argument types.</p></div><div class="refsect1" lang="en"><a name="d0e15611"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_GROUP_12);
  TAU_INIT(&amp;argc, &amp;argv);
  ...
}

% ./a.out --profile 12+14
    </pre></div><div class="refsect1" lang="en"><a name="d0e15619"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_INIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_INIT &#8212; Processes command-line arguments for selective instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_INIT</b>(</code><var class="pdparam">argc</var>, <var class="pdparam">argv</var><code>)</code>;<br>int <var class="pdparam">argc</var>;<br>char **<var class="pdparam">argv</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_INIT</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15661"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_INIT</code> parses the
    command-line arguments for the names of profile groups that are to be
    selectively enabled for instrumentation. By default, if this macro is not
    used, functions belonging to all profile groups are
    enabled. <code class="literal">TAU_INIT</code> differs from
    <code class="literal">TAU_PROFILE_INIT</code> only in the argument types.</p></div><div class="refsect1" lang="en"><a name="d0e15674"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  TAU_PROFILE_INIT(argc, argv);
  ...
}

% ./a.out --profile 12+14
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
PROGRAM SUM_OF_CUBES
  integer profiler(2)
  save profiler
      
  call TAU_PROFILE_INIT()
  ...
    </pre></div><div class="refsect1" lang="en"><a name="d0e15687"></a><h2>See Also</h2><p>
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_PROFILE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_PROFILE_GROUP &#8212; Creates groups based on names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GET_PROFILE_GROUP</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15717"></a><h2>Description</h2><p> <code class="literal">TAU_GET_PROFILE_GROUP</code>  allows the user to
    dynamically create groups based on strings, rather than use predefined,
    statically assigned groups such as  <code class="literal">TAU_USER1, TAU_USER2</code> 
    etc. This allows names to be associated in creating unique groups that
    are more meaningful, using names of files or directories for instance.
    </p></div><div class="refsect1" lang="en"><a name="d0e15728"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
#define PARTICLES TAU_GET_PROFILE_GROUP("PARTICLES")

void foo() {
  TAU_PROFILE("foo()", " ", PARTICLES);
}

void bar() {
  TAU_PROFILE("bar()", " ", PARTICLES);
}
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.getProfileGroup("PARTICLES")
		</pre></div><div class="refsect1" lang="en"><a name="d0e15741"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_GROUP_NAME &#8212; Enables a group based on name</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP_NAME</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">groupname</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15789"></a><h2>Description</h2><p> <code class="literal">TAU_ENABLE_GROUP_NAME</code> macro can turn on the
    instrumentation associated with routines based on a dynamic group assigned
    to them. It is important to note that this and the
    <code class="literal">TAU_DISABLE_GROUP_NAME</code> macros apply to groups created
    dynamically using <code class="literal">TAU_GET_PROFILE_GROUP.</code> </p></div><div class="refsect1" lang="en"><a name="d0e15803"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE&gt;DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableGroupName("DTM")
		</pre></div><div class="refsect1" lang="en"><a name="d0e15821"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_GROUP_NAME &#8212; Disables a group based on name</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP_NAME</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">groupname</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e15869"></a><h2>Description</h2><p>Similar to <code class="literal">TAU_ENABLE_GROUP_NAME</code> , this macro
    turns off the instrumentation in all routines associated with the dynamic
    group created using the tau_instrumentor -g &lt;group_name&gt; argument. 
    </p></div><div class="refsect1" lang="en"><a name="d0e15877"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE&gt;DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableGroupName("DTM")
		</pre></div><div class="refsect1" lang="en"><a name="d0e15895"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_ALL_GROUPS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_ALL_GROUPS &#8212; Enables instrumentation in all groups</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e15936"></a><h2>Description</h2><p>This macro turns on instrumentation in all groups</p></div><div class="refsect1" lang="en"><a name="d0e15941"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_ENABLE_ALL_GROUPS();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_ALL_GROUPS();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableAllGroups()
     </pre></div><div class="refsect1" lang="en"><a name="d0e15959"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_ALL_GROUPS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_ALL_GROUPS &#8212; Disables instrumentation in all groups</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16000"></a><h2>Description</h2><p>This macro turns off instrumentation in all groups.</p></div><div class="refsect1" lang="en"><a name="d0e16005"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_DISABLE_ALL_GROUPS();
  TAU_ENABLE_GROUP_NAME("PARTICLES");
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_ALL_GROUPS();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableAllGroups()
		</pre></div><div class="refsect1" lang="en"><a name="d0e16023"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_EVENT_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_EVENT_NAMES &#8212; Gets the registered user events.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_EVENT_NAMES</b>(</code></td><td><var class="pdparam">eventList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numEvents</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char ***&nbsp;</td><td><var class="pdparam">eventList</var>;</td></tr><tr><td>int *&nbsp;</td><td><var class="pdparam">numEvents</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e16063"></a><h2>Description</h2><p>Retrieves user event names for all user-defined events</p></div><div class="refsect1" lang="en"><a name="d0e16068"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **eventList;
int numEvents;

TAU_GET_EVENT_NAMES(eventList, numEvents);

cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

    </pre></div><div class="refsect1" lang="en"><a name="d0e16076"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_EVENT_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_EVENT_VALS &#8212; Gets user event data for given user events.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_EVENT_VALS</b>(</code></td><td><var class="pdparam">inUserEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numUserEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">max</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">min</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mean</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">sumSqe</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char **&nbsp;</td><td><var class="pdparam">inUserEvents</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numUserEvents</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numEvents</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">max</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">min</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">mean</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">sumSqe</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e16134"></a><h2>Description</h2><p>Retrieves user defined event data for the specified user defined events. The list of events are specified by the first parameter (eventList) and the user specifies the number of events in the second parameter (numUserEvents). TAU returns the number of times the event was invoked in the numUserEvents. The max, min, mean values are returned in the following parameters. TAU computes the sum of squares of the given event and returns this value in the next argument (sumSqe). </p></div><div class="refsect1" lang="en"><a name="d0e16139"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
  const char **eventList;
  int numEvents;

  TAU_GET_EVENT_NAMES(eventList, numEvents);

  cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

  if (numEvents &gt; 0) {
    int *numSamples;
    double *max;
    double *min;
    double *mean;
    double *sumSqr;

    TAU_GET_EVENT_VALS(eventList, numEvents, numSamples, 
      max, min, mean, sumSqr);
    for (int i=0; i&lt;numEvents; i++) {
      cout &lt;&lt; "-------------------\n";
      cout &lt;&lt; "User Event:        " &lt;&lt; eventList[i] &lt;&lt; endl;
      cout &lt;&lt; "Number of Samples: " &lt;&lt; numSamples[i] &lt;&lt; endl;
      cout &lt;&lt; "Maximum Value:     " &lt;&lt; max[i] &lt;&lt; endl;
      cout &lt;&lt; "Minimum Value:     " &lt;&lt; min[i] &lt;&lt; endl;
      cout &lt;&lt; "Mean Value:        " &lt;&lt; mean[i] &lt;&lt; endl;
      cout &lt;&lt; "Sum Squared:       " &lt;&lt; sumSqr[i] &lt;&lt; endl;
    }
  }
}

    </pre></div><div class="refsect1" lang="en"><a name="d0e16147"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_COUNTER_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_COUNTER_NAMES &#8212; Gets the counter names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_COUNTER_NAMES</b>(</code></td><td><var class="pdparam">counterList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numCounters</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">counterList</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numCounters</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e16185"></a><h2>Description</h2><p> <code class="literal">TAU_GET_COUNTER_NAMES</code> returns the list of counter
    names and the number of counters used for measurement. When wallclock time
    is used, the counter name of "default" is returned.</p></div><div class="refsect1" lang="en"><a name="d0e16193"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int numOfCounters;
const char ** counterList;

TAU_GET_COUNTER_NAMES(counterList, numOfCounters);

for(int j=0;j&lt;numOfCounters;j++){ 
  cout &lt;&lt; "The counter names so far are: " &lt;&lt; counterList[j] &lt;&lt; endl;
}
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.getCounterNames(counterList, numOfCounters);
		</pre></div><div class="refsect1" lang="en"><a name="d0e16206"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_FUNC_NAMES" title="TAU_GET_FUNC_NAMES"><span class="refentrytitle">TAU_GET_FUNC_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_VALS" title="TAU_GET_FUNC_VALS"><span class="refentrytitle">TAU_GET_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_FUNC_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_FUNC_NAMES &#8212; Gets the function names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_FUNC_NAMES</b>(</code></td><td><var class="pdparam">functionList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">functionList</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e16242"></a><h2>Description</h2><p>This macro fills the funcList argument with the list of
    timer and routine names. It also records the number of routines active
    in the numFuncs argument. </p></div><div class="refsect1" lang="en"><a name="d0e16247"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
  const char ** functionList;
  int numOfFunctions;

  TAU_GET_FUNC_NAMES(functionList, numOfFunctions);

  for(int i=0;i&lt;numOfFunctions;i++){
    cout &lt;&lt; "This function names so far are: " &lt;&lt; functionList[i] &lt;&lt; endl;
  }

    </pre><p><span class="role">Python:</span></p><pre class="screen">
import pytau

pytau.getFuncNames(functionList, numOfFunctions)
		</pre></div><div class="refsect1" lang="en"><a name="d0e16260"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_COUNTER_NAMES" title="TAU_GET_COUNTER_NAMES"><span class="refentrytitle">TAU_GET_COUNTER_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_VALS" title="TAU_GET_FUNC_VALS"><span class="refentrytitle">TAU_GET_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_FUNC_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_FUNC_VALS &#8212; Gets detailed performance data for given functions</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_FUNC_VALS</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterExclusiveValues</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterInclusiveValues</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfCalls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfSubRoutines</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterNames</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfCounters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numOfFuncs</var>;</td></tr><tr><td>double ***&nbsp;</td><td><var class="pdparam">counterExclusiveValues</var>;</td></tr><tr><td>double ***&nbsp;</td><td><var class="pdparam">counterInclusiveValues</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numOfCalls</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numOfSubRoutines</var>;</td></tr><tr><td>const char ***&nbsp;</td><td><var class="pdparam">counterNames</var>;</td></tr><tr><td>int *&nbsp;</td><td><var class="pdparam">numOfCounters</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e16328"></a><h2>Description</h2><p>It gets detailed performance data for the list of
    routines. The user specifies inFuncs and the number of routines; TAU
    then returns the other arguments with the performance data.
    counterExclusiveValues and counterInclusiveValues are two dimensional
    arrays: the first dimension is the routine id and the second is counter
    id. The value is indexed by these two dimensions. numCalls and numSubrs
    (or child routines) are one dimensional arrays. </p></div><div class="refsect1" lang="en"><a name="d0e16333"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **inFuncs;
/* The first dimension is functions, and the 
second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;
      
TAU_GET_FUNC_NAMES(functionList, numOfFunctions);
      
/* We are only interested in the first two routines 
that are executing in this context. So, we allocate 
space for two routine names and get the performance 
data for these two routines at runtime. */
if (numOfFunctions &gt;=2 ) {
  inFuncs = (const char **) malloc(sizeof(const char *) * 2);
      
  inFuncs[0] = functionList[0];
  inFuncs[1] = functionList[1];
      
  //Just to show consistency.
  TAU_DB_DUMP();
      
  TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);
      
  TAU_DUMP_FUNC_VALS_INCR(inFuncs, 2);
      
      
  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
  cout &lt;&lt; "The number of counters is: " &lt;&lt; numOfCouns &lt;&lt; endl;
  cout &lt;&lt; "The first counter is: " &lt;&lt; counterNames[0] &lt;&lt; endl;
      
  cout &lt;&lt; "The Exclusive value of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; counterExclusiveValues[0][0] &lt;&lt; endl;
  cout &lt;&lt; "The numOfSubRoutines of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; numOfSubRoutines[0]
  &lt;&lt; endl;
      
      
  cout &lt;&lt; "The Inclusive value of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; counterInclusiveValues[1][0]
  &lt;&lt; endl;
  cout &lt;&lt; "The numOfCalls of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; numOfCalls[1]
  &lt;&lt; endl;

  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
}
      
TAU_DB_DUMP_INCR();
    </pre><p>Python:</p><pre class="screen">
import pytau

pytau.dumpFuncVals("foo", "bar", "bar2")
		</pre></div><div class="refsect1" lang="en"><a name="d0e16345"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_COUNTER_NAMES" title="TAU_GET_COUNTER_NAMES"><span class="refentrytitle">TAU_GET_COUNTER_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_NAMES" title="TAU_GET_FUNC_NAMES"><span class="refentrytitle">TAU_GET_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_MEMORY &#8212; Enables memory tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16386"></a><h2>Description</h2><p>Enables tracking of the heap memory utilization in the program. TAU takes a sample of the heap memory utilized (as reported by the mallinfo system call) and associates it with a single global user defined event. An interrupt is generated every 10 seconds and the value of the heap memory used is recorded in the user defined event. The inter-interrupt interval (default of 10 seconds) may be set by the user using the call <code class="literal">TAU_SET_INTERRUPT_INTERVAL</code>.</p></div><div class="refsect1" lang="en"><a name="d0e16394"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_ENABLE_TRACKING_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingMemory()
		</pre></div><div class="refsect1" lang="en"><a name="d0e16412"></a><h2>See Also</h2><p>
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_MEMORY &#8212; Disables memory tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16453"></a><h2>Description</h2><p>Disables tracking of heap memory utilization. This call may be used in sections of code where TAU should not interrupt the execution to periodically track the heap memory utilization.</p></div><div class="refsect1" lang="en"><a name="d0e16458"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingMemory()

		</pre></div><div class="refsect1" lang="en"><a name="d0e16476"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_POWER &#8212; Initializes POWER tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16517"></a><h2>Description</h2><p>For power profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_POWER_HERE() calls in the source code and the
    power event is triggered at those locations, and 2) the user enables
    tracking POWER by calling TAU_TRACK_POWER() and an interrupt is generated
    every 10 seconds and the POWER event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of power events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_POWER() or TAU_DISABLE_TRACKING_()
    respectively.</p></div><div class="refsect1" lang="en"><a name="d0e16522"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_POWER();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_POWER()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackPower()
    </pre></div><div class="refsect1" lang="en"><a name="d0e16540"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_POWER" title="TAU_ENABLE_TRACKING_POWER"><span class="refentrytitle">TAU_ENABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_DISABLE_TRACKING_POWER" title="TAU_DISABLE_TRACKING_POWER"><span class="refentrytitle">TAU_DISABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_POWER_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_POWER_HERE &#8212; Triggers power tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16583"></a><h2>Description</h2><p>Triggers power tracking at a given execution point</p></div><div class="refsect1" lang="en"><a name="d0e16588"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_POWER_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_POWER_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap POWER 
! utilization at this point, invoke the following call:
call TAU_TRACK_POWER_HERE()

    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackPowerHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e16606"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_POWER &#8212; Enables power headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16641"></a><h2>Description</h2><p>
      <code class="literal">TAU_ENABLE_TRACKING_POWER()</code> enables power 
      tracking after a
      <code class="literal">TAU_DISABLE_TRACKING_POWER()</code>.
    </p></div><div class="refsect1" lang="en"><a name="d0e16652"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_POWER();
/* do some work */
...
/* re-enable tracking POWER */
TAU_ENABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingPowerHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e16670"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>,
      <a href="#TAU_DISABLE_TRACKING_POWER" title="TAU_DISABLE_TRACKING_POWER"><span class="refentrytitle">TAU_DISABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_POWER &#8212; Disables power headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16711"></a><h2>Description</h2><p>
      <code class="literal">TAU_DISABLE_TRACKING_POWER()</code> disables
      power tracking.
    </p></div><div class="refsect1" lang="en"><a name="d0e16719"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_POWER()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingPowerHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e16737"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>,
      <a href="#TAU_ENABLE_TRACKING_POWER" title="TAU_ENABLE_TRACKING_POWER"><span class="refentrytitle">TAU_ENABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY &#8212; Initializes memory tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16778"></a><h2>Description</h2><p>For memory profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_MEMORY_HERE() calls in the source code and the
    memory event is triggered at those locations, and 2) the user enables
    tracking memory by calling TAU_TRACK_MEMORY() and an interrupt is generated
    every 10 seconds and the memory event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of memory events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_MEMORY() or TAU_DISABLE_TRACKING_MEMORY()
    respectively.</p></div><div class="refsect1" lang="en"><a name="d0e16783"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemory()
    </pre></div><div class="refsect1" lang="en"><a name="d0e16801"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HERE &#8212; Triggers memory tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16844"></a><h2>Description</h2><p>Triggers memory tracking at a given execution point</p></div><div class="refsect1" lang="en"><a name="d0e16849"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap memory 
! utilization at this point, invoke the following call:
call TAU_TRACK_MEMORY_HERE()

    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e16867"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_FOOTPRINT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_FOOTPRINT &#8212; Initializes memory footprint tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16902"></a><h2>Description</h2><p>Similar to TAU_TRACK_MEMORY but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="refsect1" lang="en"><a name="d0e16907"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY_FOOTPRINT();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY_FOOTPRINT()
    </pre></div><div class="refsect1" lang="en"><a name="d0e16920"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE" title="TAU_TRACK_MEMORY_FOOTPRINT_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_FOOTPRINT_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_FOOTPRINT_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_FOOTPRINT_HERE &#8212; Triggers memory footprint tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e16967"></a><h2>Description</h2><p>Similar to TAU_TRACK_MEMORY_HERE but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="refsect1" lang="en"><a name="d0e16972"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_FOOTPRINT_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_FOOTPRINT_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)


call TAU_TRACK_MEMORY_FOOTPRINT_HERE()

    </pre></div><div class="refsect1" lang="en"><a name="d0e16985"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_FOOTPRINT" title="TAU_TRACK_MEMORY_FOOTPRINT"><span class="refentrytitle">TAU_TRACK_MEMORY_FOOTPRINT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_MEMORY_HEADROOM &#8212; Enables memory headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17020"></a><h2>Description</h2><p>
      <code class="literal">TAU_ENABLE_TRACKING_MEMORY_HEADROOM()</code> enables memory
      headroom tracking after a
      <code class="literal">TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</code>.
    </p></div><div class="refsect1" lang="en"><a name="d0e17031"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
/* do some work */
...
/* re-enable tracking memory headroom */
TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17049"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM" title="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_MEMORY_HEADROOM &#8212; Disables memory headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17090"></a><h2>Description</h2><p>
      <code class="literal">TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</code> disables memory
      headroom tracking.
    </p></div><div class="refsect1" lang="en"><a name="d0e17098"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_MEMORY_HEADROOM()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17116"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM" title="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HEADROOM &#8212; Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17157"></a><h2>Description</h2><p>Tracks the amount of memory available for the process before it runs
    out of free memory on the heap. This call sets up a signal handler that is
    invoked every 10 seconds by an interrupt (this interval may be altered by
    using the <code class="literal">TAU_SET_INTERRUPT_INTERVAL</code> call). Inside the
    interrupt handler, TAU evaluates how much memory it can allocate and
    associates it with the callstack using the TAU context events (See <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>). The user can vary the size of the
    callstack by setting the environment variable
    <code class="literal">TAU_CALLPATH_DEPTH</code> (default is 2). This call is useful
    on machines like IBM BG/L where no virtual memory (or paging using the swap
    space) is present. The amount of heap memory available to the program is
    limited by the amount of available physical memory. TAU executes a series
    of malloc calls with a granularity of 1MB and determines the amount of
    memory available for the program to grow.</p></div><div class="refsect1" lang="en"><a name="d0e17170"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY_HEADROOM()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17188"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM" title="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM" title="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HEADROOM_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HEADROOM_HERE &#8212; Takes a sample of the amount of memory available at a given point.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17231"></a><h2>Description</h2><p>Instead of relying on a periodic interrupt to track the amount of memory available to grow, this call may be used to take a sample at a given location in the source code. Context events are used to track the amount of memory headroom.</p></div><div class="refsect1" lang="en"><a name="d0e17236"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
ary = new double [1024*1024*50];
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHeadroomHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e17254"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_SET_INTERRUPT_INTERVAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_SET_INTERRUPT_INTERVAL &#8212; Change the inter-interrupt interval for tracking memory and headroom</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_SET_INTERRUPT_INTERVAL</b>(</code><var class="pdparam">value</var><code>)</code>;<br>int <var class="pdparam">value</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_SET_INTERRUPT_INTERVAL</b>(</code><var class="pdparam">value</var><code>)</code>;<br>integer <var class="pdparam">value</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17295"></a><h2>Description</h2><p>Set the interrupt interval for tracking memory and headroom (See <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a> and <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>). By default an inter-interrupt interval of 10 seconds is used in TAU. This call allows the user to set it to a different value specified by the argument value.</p></div><div class="refsect1" lang="en"><a name="d0e17304"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_SET_INTERRUPT_INTERVAL(2)
/* invokes the interrupt handler for memory every 2s */
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_SET_INTERRUPT_INTERVAL(2)
    </pre><p><span class="bold"><strong>Python: </strong></span></p><pre class="screen">
import pytau

pytau.setInterruptTnterval(2)
		</pre></div><div class="refsect1" lang="en"><a name="d0e17322"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="CT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>CT &#8212; Returns the type information for a variable</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">CT</b>(</code><var class="pdparam">variable</var><code>)</code>;<br>&lt;type&gt; <var class="pdparam">variable</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17355"></a><h2>Description</h2><p>The <code class="literal">CT</code> macro returns the runtime type
    information string of a variable. This is useful in constructing the
    type parameter of the  <code class="literal">TAU_PROFILE</code>  macro. For templates,
    the type information can be constructed using the type of the return and
    the type of each of the arguments (parameters) of the template. The
    example in the following macro will clarify this.</p></div><div class="refsect1" lang="en"><a name="d0e17366"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("foo::memberfunc()", CT(*this), TAU_DEFAULT);
    </pre></div><div class="refsect1" lang="en"><a name="d0e17374"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_TYPE_STRING" title="TAU_TYPE_STRING"><span class="refentrytitle">TAU_TYPE_STRING</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TYPE_STRING"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TYPE_STRING &#8212; Creates a type string</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TYPE_STRING</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type_string</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>string &amp;&nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>string &amp;&nbsp;</td><td><var class="pdparam">type_string</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e17412"></a><h2>Description</h2><p>This macro assigns the string constructed in type_string to
    the variable. The + operator and the CT macro can be used to construct
    the type string of an object. This is useful in identifying templates
    uniquely, as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e17417"></a><h2>Example</h2><p><span class="bold"><strong>C++ :</strong></span></p><pre class="screen">
template&lt;class PLayout&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const ParticleBase&lt;PLayout&gt;&amp; P) {
  TAU_TYPE_STRING(taustr, "ostream (ostream, " + CT(P) + " )");
  TAU_PROFILE("operator&lt;&lt;()"taustr, TAU_PARTICLE | TAU_IO);
  ... 
}
    </pre><p>When PLayout is instantiated with
    " <code class="literal">UniformCartesian&lt;3U, double&gt;</code> ",this generates the
    unique template name: </p><pre class="screen">
operator&lt;&lt;() ostream const 
ParticleBase&lt;UniformCartesian&lt;3U, double&gt; &gt; )
    </pre><p>The following example illustrates the usage of the CT macro
    to extract the name of the class associated with the given object using
    CT(*this);</p><pre class="screen">
template&lt;class PLayout&gt;
unsigned ParticleBase&lt;PLayout7&gt;::GetMessage(Message&amp; msg, int node) {
  TAU_TYPE_STRING(taustr, CT(*this) + "unsigned (Message, int)");
  TAU_PROFILE("ParticleBase::GetMessage()", taustr, TAU_PARTICLE);
  ...
}
    </pre><p>When PLayout is instantiated with " <code class="literal">UniformCartesian&lt;3U,
    double&gt;</code> ",this generates the unique template name:</p><pre class="screen">
ParticleBase::GetMessage() ParticleBase&lt;UniformCartesian&lt;3U, 
double&gt; &gt; unsigned (Message, int)
    </pre></div><div class="refsect1" lang="en"><a name="d0e17443"></a><h2>See Also</h2><p>
    <a href="#CT" title="CT"><span class="refentrytitle">CT</span></a>,
    <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
    <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP &#8212; Dumps the profile database to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17482"></a><h2>Description</h2><p>Dumps the profile database to disk.  The format of the files is the
    same as regular profiles, they are simply prefixed with "dump" instead of
    "profile".</p></div><div class="refsect1" lang="en"><a name="d0e17487"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17500"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DB_DUMP_INCR" title="TAU_DB_DUMP_INCR"><span class="refentrytitle">TAU_DB_DUMP_INCR</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_MERGED_DUMP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_MERGED_DUMP &#8212; Dumps the profile database to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_MERGED_DUMP</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_MERGED_DUMP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17547"></a><h2>Description</h2><p>Dumps the profile database to disk.  The format of the files is the
    same as merged profiles: tauprofile.xml </p></div><div class="refsect1" lang="en"><a name="d0e17552"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_MERGED_DUMP();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_MERGED_DUMP()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17565"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DB_DUMP_INCR" title="TAU_DB_DUMP_INCR"><span class="refentrytitle">TAU_DB_DUMP_INCR</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_INCR"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_INCR &#8212; Dumps profile database into timestamped profiles on disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_INCR</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17604"></a><h2>Description</h2><p>This is similar to the TAU_DB_DUMP macro but it produces
    dump files that have a timestamp in their names. This allows the user to
    record timestamped incremental dumps as the application executes.
    </p></div><div class="refsect1" lang="en"><a name="d0e17609"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_INCR();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dbDumpIncr("prefix")
    </pre></div><div class="refsect1" lang="en"><a name="d0e17622"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_PREFIX"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_PREFIX &#8212; Dumps the profile database into profile files with a given prefix</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX</b>(</code><var class="pdparam">prefix</var><code>)</code>;<br>char *<var class="pdparam">prefix</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX</b>(</code><var class="pdparam">prefix</var><code>)</code>;<br>character <var class="pdparam">prefix</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e17676"></a><h2>Description</h2><p>The <code class="literal">TAU_DB_DUMP_PREFIX</code> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</p></div><div class="refsect1" lang="en"><a name="d0e17684"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_PREFIX("prefix");      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP_PREFIX("prefix")
    </pre><p><span class="bold"><strong>Python :</strong></span></p><pre class="screen">
import pytau

pytau.dbDump("prefix")
    </pre></div><div class="refsect1" lang="en"><a name="d0e17702"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_PREFIX_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_PREFIX_TASK &#8212; Dumps the profile database into profile files with a given task</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX_TASK</b>(</code><var class="pdparam">PREFIX_TASK</var><code>)</code>;<br>char *<var class="pdparam">PREFIX_TASK</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX_TASK</b>(</code></td><td><var class="pdparam">prefix</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">task</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">prefix</var>(size);</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">task</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e17749"></a><h2>Description</h2><p>The <code class="literal">TAU_DB_DUMP_PREFIX_TASK</code> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics on a
		particular task at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</p></div><div class="refsect1" lang="en"><a name="d0e17757"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid);      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid)
    </pre><p><span class="bold"><strong>Python :</strong></span></p><pre class="screen">
import pytau

pytau.dbDump("PREFIX", taskid)
    </pre></div><div class="refsect1" lang="en"><a name="d0e17775"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_PURGE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_PURGE &#8212; Purges the performance data.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_PURGE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17802"></a><h2>Description</h2><p>Purges the performance data collected so far.</p></div><div class="refsect1" lang="en"><a name="d0e17807"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_PURGE();
    </pre></div><div class="refsect1" lang="en"><a name="d0e17815"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_NAMES &#8212; Dumps function names to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_NAMES</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e17842"></a><h2>Description</h2><p>This macro writes the names of active functions to a file named dump_functionnames_&lt;node&gt;.&lt;context&gt;.</p></div><div class="refsect1" lang="en"><a name="d0e17847"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DUMP_FUNC_NAMES();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dumpFuncNames()
    </pre></div><div class="refsect1" lang="en"><a name="d0e17860"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_VALS &#8212; Dumps performance data for given functions to disk.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_VALS</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e17898"></a><h2>Description</h2><p> <code class="literal">TAU_DUMP_FUNC_VALS</code>  writes the data
    associated with the routines listed in inFuncs to disk. The number of
    routines is specified by the user in numFuncs.</p></div><div class="refsect1" lang="en"><a name="d0e17906"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">

    </pre></div><div class="refsect1" lang="en"><a name="d0e17914"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_VALS_INCR"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_VALS_INCR &#8212; Dumps function values with a timestamp</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_VALS_INCR</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e17952"></a><h2>Description</h2><p>Similar to <code class="literal">TAU_DUMP_FUNC_VALS</code>. This macro
    creates an incremental selective dump and dumps the results with a date
    stamp to the filename such as
    sel_dump__Thu-Mar-28-16:30:48-2002__.0.0.0. In this manner the previous
    <code class="literal">TAU_DUMP_FUNC_VALS_INCR(...)</code> are not overwritten
    (unless they occur within a second).</p></div><div class="refsect1" lang="en"><a name="d0e17963"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **inFuncs;
/* The first dimension is functions, and the second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;

TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);

TAU_DUMP_FUNC_VALS(inFuncs, 2);
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dumpFuncValsIncr("foo", "bar", "bar2")
		</pre></div><div class="refsect1" lang="en"><a name="d0e17976"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_STMT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_STMT &#8212; Executes a statement only when TAU is used.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STMT</b>(</code><var class="pdparam">statement</var><code>)</code>;<br>statement <var class="pdparam">statement</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18010"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_STMT</code> executes a statement, or declares
    a variable that is used only during profiling or for execution of a
    statement that takes place only when the instrumentation is active.  When
    instrumentation is inactive (i.e., when profiling and tracing are turned
    off as described in Chapter 2), all macros are defined as null. </p></div><div class="refsect1" lang="en"><a name="d0e18017"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE_STMT(T obj;); // T is a template parameter)
TAU_TYPE_STRING(str, "void () " + CT(obj) );
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CALLSTACK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CALLSTACK &#8212; Generates a callstack trace at a given location.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CALLSTACK</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18045"></a><h2>Description</h2><p>When TAU is configured with <code class="literal">-PROFILECALLSTACK</code>
    configuration option, and this call is invoked, a callpath trace is
    generated. A GUI for viewing this trace is included in TAU's utils/csUI
    directory. This option is deprecated.</p></div><div class="refsect1" lang="en"><a name="d0e18053"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE_CALLSTACK();
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACE_RECVMSG"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACE_RECVMSG &#8212; Traces a receive operation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_RECVMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_RECVMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18111"></a><h2>Description</h2><p> <code class="literal">TAU_TRACE_RECVMSG</code>  traces a receive operation where tag represents the type of the message received from the source process.</p><p><span class="emphasis"><em>NOTE:</em></span> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <code class="literal">TAU_TRACE_RECVMSG</code>  and
    <code class="literal">TAU_TRACE_SENDMSG</code>  macros are not required. The wrapper
    interposition library in </p><pre class="screen">$(TAU_MPI_LIBS)</pre><p> uses these
    macros internally for logging messages. </p></div><div class="refsect1" lang="en"><a name="d0e18132"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </pre></div><div class="refsect1" lang="en"><a name="d0e18145"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACE_SENDMSG" title="TAU_TRACE_SENDMSG"><span class="refentrytitle">TAU_TRACE_SENDMSG</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACE_SENDMSG"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACE_SENDMSG &#8212; Traces a receive operation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_SENDMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_SENDMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18202"></a><h2>Description</h2><p><code class="literal">TAU_TRACE_SENDMSG</code> traces an inter-process message communication when a tagged message is sent to a destination process. </p><p><span class="emphasis"><em>NOTE:</em></span> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <code class="literal">TAU_TRACE_SENDMSG</code>  and
    <code class="literal">TAU_TRACE_SENDMSG</code>  macros are not required. The wrapper
    interposition library in </p><pre class="screen">$(TAU_MPI_LIBS)</pre><p> uses these
    macros internally for logging messages. </p></div><div class="refsect1" lang="en"><a name="d0e18222"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </pre></div><div class="refsect1" lang="en"><a name="d0e18235"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACE_RECVMSG" title="TAU_TRACE_RECVMSG"><span class="refentrytitle">TAU_TRACE_RECVMSG</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_PARAM1L"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_PARAM1L &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_PARAM1L</b>(</code><var class="pdparam">number</var>, <var class="pdparam">name</var><code>)</code>;<br>long <var class="pdparam">number</var>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_PARAM1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">number</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18288"></a><h2>Description</h2><p>Track the a given numerial parameter to a function and records each
		value as a seperate event. <code class="literal">number</code> is the parameter to be
		tracked. <code class="literal">name</code> is the name of this event.</p></div><div class="refsect1" lang="en"><a name="d0e18299"></a><h2>Example</h2><p><span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
int f1(int x)
{
  TAU_PROFILE("f1()", "", TAU_USER);
  TAU_PROFILE_PARAM1L((long) x, "x");
	...
</pre><p><span class="bold"><strong>Fortran:</strong></span></p><pre class="screen">
 subroutine ITERATION(val)
  integer val
  integer profiler(2) / 0, 0 /
  save profiler

  call TAU_PROFILE_TIMER(profiler, 'INTERATION')
  call TAU_PROFILE_START(profiler)

 	call TAU_PROFILE_PARAM1L('value', val, 4) 

	....

	call TAU_PROFILE_STOP(profiler)
  return
end
</pre></div><div class="refsect1" lang="en"><a name="d0e18312"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER_DYNAMIC" title="TAU_PROFILE_TIMER_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_TIMER_DYNAMIC</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SNAPSHOT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SNAPSHOT &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18357"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_SNAPSHOT</code> writes a snapshot profile
    representing the program's execution up to this point. These file are
    written the system as snapshot.[node].[context].[thread] format. They can be
    merged by appending one to another. Uploading a snapshot to a PerfDMF
    database or packing them into a PPK file will condense them to a single
    profile (the last one).
    </p></div><div class="refsect1" lang="en"><a name="d0e18364"></a><h2>Examples</h2><p>C/C++:</p><pre class="screen">
TAU_PROFILE_SNAPSHOT(name);
</pre><p>Fortran:</p><pre class="screen">
TAU_PROFILE_SNAPSHOT(name, length);
</pre><p>Python:</p><pre class="screen">
import pytau;

pytau.snapshot("name")
</pre></div><div class="refsect1" lang="en"><a name="d0e18379"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SNAPSHOT_1L" title="TAU_PROFILE_SNAPSHOT_1L"><span class="refentrytitle">TAU_PROFILE_SNAPSHOT_1L</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SNAPSHOT_1L"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SNAPSHOT_1L &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT_1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">number</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT_1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">number</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18432"></a><h2>Description</h2><p>Calls <code class="literal">TAU_PROFILE_SNAPSHOT</code> giving it the as a name
    the name with a number appended.</p></div><div class="refsect1" lang="en"><a name="d0e18440"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SNAPSHOT" title="TAU_PROFILE_SNAPSHOT"><span class="refentrytitle">TAU_PROFILE_SNAPSHOT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_CREATE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_CREATE &#8212; Creates a profiler object referenced as a standard pointer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_CREATE</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18480"></a><h2>description</h2><p><code class="function">TAU_PROFILER_CREATE</code> creates a
    timer the that can be controlled by the Timer pointer object.</p><p>The TAU_PROFILER_* API is intended for applications to easily layer
		their legacy timing measurements APIs on top of TAU, Unlike other TAU API
		calls (TAU_PROFILE_TIMER) that are statically expanded in the source code,
		these calls allocate TAU entities on the heap. So the pointer to the TAU
		timer may be used as a handle to access the TAU performance data.</p></div><div class="refsect1" lang="en"><a name="d0e18489"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e18504"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CREATE_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CREATE_TASK &#8212; Creates a task id.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_CREATE_TASK</b>(</code><var class="pdparam">taskid</var><code>)</code>;<br>Integer <var class="pdparam">taskid</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18544"></a><h2>description</h2><p><code class="function">TAU_CREATE_TASK</code> creates a task with id 'taskid'
	this task is an independent event stream for which Profiler objects can be
	started and stop on. TAU will increment the taskids as needed an write out
	profiles and traces from the task as if they were thread.
	</p></div><div class="refsect1" lang="en"><a name="d0e18551"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e18560"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_START &#8212; starts a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a></p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18601"></a><h2>description</h2><p><code class="function">TAU_PROFILER_START</code>starts a profiler
    timer by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e18610"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e18625"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_START_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_START_TASK &#8212; Starts a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> on a given task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_START_TASK</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18667"></a><h2>description</h2><p><code class="function">TAU_PROFILER_START_TASK</code>starts a profiler timer on
		a task by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> and a task created by <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a> on a given task.</p></div><div class="refsect1" lang="en"><a name="d0e18678"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e18687"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_STOP &#8212; stops a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a></p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18728"></a><h2>description</h2><p><code class="function">TAU_PROFILER_STOP</code>stops a profiler
    timer by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e18737"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e18752"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_STOP_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_STOP_TASK &#8212; Stops a profiler object on a task</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_STOP_TASK</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e18792"></a><h2>description</h2><p><code class="function">TAU_PROFILER_STOP_TASK</code>STOPs a profiler timer on a
		task by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> and a task created by <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e18803"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e18812"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CALLS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CALLS &#8212; Gets the number of times this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CALLS</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18858"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CALLS</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</p></div><div class="refsect1" lang="en"><a name="d0e18865"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS(ptr, &amp;calls); 
</pre></div><div class="refsect1" lang="en"><a name="d0e18874"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CALLS_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CALLS_TASK &#8212; Gets the number of times this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started on a given task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CALLS_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18924"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CALLS_TASK</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed) on a given task.</p></div><div class="refsect1" lang="en"><a name="d0e18931"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS_TASK(ptr, &amp;calls, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e18940"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CHILD_CALLS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CHILD_CALLS &#8212; Gets the number of calls made while this timer was running</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CHILD_CALLS</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e18984"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CHILD_CALLS</code>
    Gets the number of timers started while <code class="literal">timer</code> was
		running. This is non-recursive, only timers started directly count.</p></div><div class="refsect1" lang="en"><a name="d0e18994"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

long calls;
TAU_PROFILER_GET_CHILD_CALLS(ptr, &amp;calls); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19003"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CHILD_CALLS_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CHILD_CALLS_TASK &#8212; Gets the number of child call for this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started on a task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CHILD_CALLS_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">child_calls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">child_calls</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19053"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CHILD_CALLS_TASK</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</p></div><div class="refsect1" lang="en"><a name="d0e19060"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long child_calls;
TAU_PROFILER_GET_CHILD_CALLS_TASK(ptr, &amp;child_calls, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19069"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_INCLUSIVE_VALUES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_INCLUSIVE_VALUES &#8212; Returns the inclusive amount of a metric spend by this timer.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_INCLUSIVE_VALUES</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">incl</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">incl</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19113"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_INCLUSIVE_VALUES</code>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer.)
		</p></div><div class="refsect1" lang="en"><a name="d0e19120"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES(ptr, &amp;incl); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19129"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK &#8212; Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">incl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">incl</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19177"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</code>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer) on a given
	task.
		</p></div><div class="refsect1" lang="en"><a name="d0e19184"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK(ptr, &amp;incl, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19193"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_EXCLUSIVE_VALUES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_EXCLUSIVE_VALUES &#8212; Returns the exclusive amount of a metric spend by this timer.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_EXCLUSIVE_VALUES</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">excl</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">excl</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19237"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_EXCLUSIVE_VALUES</code>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running.)
		</p></div><div class="refsect1" lang="en"><a name="d0e19244"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES(ptr, &amp;excl); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19253"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK &#8212; Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">excl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">excl</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19301"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</code>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running) on a given
	task.
		</p></div><div class="refsect1" lang="en"><a name="d0e19308"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK(ptr, &amp;excl, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e19317"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_COUNTER_INFO"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_COUNTER_INFO &#8212; Returns information about all the timers created.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_COUNTER_INFO</b>(</code></td><td><var class="pdparam">counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">num_counters</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">counters</var>;</td></tr><tr><td>int &amp;&nbsp;</td><td><var class="pdparam">num_counters</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19361"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_COUNTER_INFO</code>
		  Gets the number of counters created and an array of the counters
			containing information about the counters.
		</p></div><div class="refsect1" lang="en"><a name="d0e19368"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO(&amp;counters, &amp;numcounters);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf("&gt;&gt;&gt;");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</pre></div><div class="refsect1" lang="en"><a name="d0e19377"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_COUNTER_INFO_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_COUNTER_INFO_TASK &#8212; Returns information about all the timers created on a task. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_COUNTER_INFO_TASK</b>(</code></td><td><var class="pdparam">counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">num_counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">counters</var>;</td></tr><tr><td>int &amp;&nbsp;</td><td><var class="pdparam">num_counters</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19425"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_COUNTER_INFO_TASK</code>
		  Gets the number of counters created and an array of the counters
			containing information about the counters on a given task.
		</p></div><div class="refsect1" lang="en"><a name="d0e19432"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr, taskid);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO_TASK(&amp;counters, &amp;numcounters, taskid);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf("&gt;&gt;&gt;");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</pre></div><div class="refsect1" lang="en"><a name="d0e19441"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_DECLARE_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_DECLARE_EVENT &#8212; Returns a event handle.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_DECLARE_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e19481"></a><h2>description</h2><p><code class="function">TAU_QUERY_DECLARE_EVENT</code>
			Creates a event handle for querying TAU events.
		</p></div><div class="refsect1" lang="en"><a name="d0e19488"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e19497"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_CURRENT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_CURRENT_EVENT &#8212; set event to be the current TAU event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_CURRENT_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e19531"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_CURRENT_EVENT</code>
			Set event to be the current TAU event in the context in which this call is
			made.
		</p></div><div class="refsect1" lang="en"><a name="d0e19538"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e19547"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_EVENT_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_EVENT_NAME &#8212; Gets the name of a given event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_EVENT_NAME</b>(</code></td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">str</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void * &nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>char * &nbsp;</td><td><var class="pdparam">str</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19585"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_EVENT_NAME</code>
			Set str to be the event name to the given event name.
		</p></div><div class="refsect1" lang="en"><a name="d0e19592"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e19601"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_PARENT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_PARENT_EVENT &#8212; gets the parent of the current event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_PARENT_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e19635"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_PARENT_EVENT</code>
			Set event to be the parent  event to the current event.
		</p></div><div class="refsect1" lang="en"><a name="d0e19642"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_PARENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("parent event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e19651"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div></div><div class="reference" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e19666"></a>TAU Mapping API</h1></div></div><hr></div><div class="partintro" lang="en"><div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19670"></a>Introduction</h2></div></div></div><p>TAU allows the user to map performance data of entities from one
      layer to another in multi-layered software. Mapping is used in profiling
      (and tracing) both synchronous and asynchronous models of
      computation.</p><p>For mapping, the following macros are used.  First locate and
      identify the higher-level statement using the <a href="#TAU_MAPPING" title="TAU_MAPPING"><span class="refentrytitle">TAU_MAPPING</span></a> macro. Then, associate a function identifier with it using the <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>.  Associate the high level statement to a
      FunctionInfo object that will be visible to lower level code, using <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>, and then profile entire blocks using <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>. Independent sets of statements can be
      profiled using <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>, <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>, and <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a> macros using the FunctionInfo
      object.</p><p>The TAU <code class="filename">examples/mapping</code> directory has two
      examples (embedded and external) that illustrate the use of this mapping
      API for generating object-oriented profiles.</p></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#TAU_MAPPING">TAU_MAPPING</a></span><span class="refpurpose"> - Encapsulates a C++ statement for profiling</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_CREATE">TAU_MAPPING_CREATE</a></span><span class="refpurpose"> - Creates a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_LINK">TAU_MAPPING_LINK</a></span><span class="refpurpose"> - Creates a mapping link</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_OBJECT">TAU_MAPPING_OBJECT</a></span><span class="refpurpose"> - Declares a mapping object</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE">TAU_MAPPING_PROFILE</a></span><span class="refpurpose"> - Profiles a block based on a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_START">TAU_MAPPING_PROFILE_START</a></span><span class="refpurpose"> - Starts a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_STOP">TAU_MAPPING_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_TIMER">TAU_MAPPING_PROFILE_TIMER</a></span><span class="refpurpose"> - Declares a mapping timer</span></dt></dl></div></div><div class="refentry" lang="en"><a name="TAU_MAPPING"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING &#8212; Encapsulates a C++ statement for profiling</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING</b>(</code></td><td><var class="pdparam">statement</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>statement &nbsp;</td><td><var class="pdparam">statement</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">key</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19723"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING</code> is used to encapsulate a C++ statement
    as a timer.  A timer will be made, named by the statment, and will profile
    the statement.  The key given can be used with <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a> to retrieve the timer.</p></div><div class="refsect1" lang="en"><a name="d0e19732"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  Array &lt;2&gt; A(N, N), B(N, N), C(N,N), D(N, N);
  // Original statement:
  // A = B + C + D;
  //Instrumented statement:
  TAU_MAPPING(A = B + C + D; , TAU_USER);
  ... 
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e19740"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_CREATE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_CREATE &#8212; Creates a mapping</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_CREATE</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">groupname</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char *&nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr><tr><td>unsigned long &nbsp;</td><td><var class="pdparam">key</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19788"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_CREATE</code> creates a mapping and
    associates it with the key that is specified.  Later, this key may be used
    to retrieve the FunctionInfo object associated with this key for timing
    purposes. The thread identifier is specified in the <code class="literal">tid</code>
    parameter.</p></div><div class="refsect1" lang="en"><a name="d0e19798"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
class MyClass {
  public:
    MyClass() {
      TAU_MAPPING_LINK(runtimer, TAU_USER); 
    } 
    ~MyClass() {}

    void Run(void) {
      TAU_MAPPING_PROFILE(runtimer); // For one object
      TAU_PROFILE("MyClass::Run()", " void (void)", TAU_USER1);
	
      cout &lt;&lt;"Sleeping for 2 secs..."&lt;&lt;endl;
      sleep(2);
    }
  private:
    TAU_MAPPING_OBJECT(runtimer)  // EMBEDDED ASSOCIATION
};

int main(int argc, char **argv) {
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  MyClass x, y, z;
  TAU_MAPPING_CREATE("MyClass::Run() for object a", " " , TAU_USER, 
                     "TAU_USER", 0);
  MyClass a;
  TAU_PROFILE_SET_NODE(0);
  cout &lt;&lt;"Inside main"&lt;&lt;endl;

  a.Run();
  x.Run();
  y.Run();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e19806"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_LINK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_LINK &#8212; Creates a mapping link</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_LINK</b>(</code></td><td><var class="pdparam">FuncIdVar</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">Key</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>FunctionInfo &nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr><tr><td>unsigned long &nbsp;</td><td><var class="pdparam">Key</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19844"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_LINK </code>creates a link between
    the object defined in <code class="literal">TAU_MAPPING_OBJECT</code> (that
    identifies a statement) and the actual higher-level statement that is
    mapped with <code class="literal">TAU_MAPPING</code>. The Key argument represents a
    profile group to which the statement belongs, as specified in the
    <code class="literal">TAU_MAPPING</code> macro argument. For the example of array
    statements, this link should be created in the constructor of the class
    that represents the expression. <code class="literal">TAU_MAPPING_LINK</code>
    should be executed before any measurement takes place. It assigns the
    identifier of the statement to the object to which FuncIdVar refers. For
    example</p></div><div class="refsect1" lang="en"><a name="d0e19863"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
class MyClass {
  public:
    MyClass() { }
    ~MyClass() { }

    void Run(void) {
      TAU_MAPPING_OBJECT(runtimer)
      TAU_MAPPING_LINK(runtimer, (unsigned long) this);
      TAU_MAPPING_PROFILE(runtimer); // For one object
      TAU_PROFILE("MyClass::Run()", " void (void)", TAU_USER1);
      
      /* ... */
    }
};

int main(int argc, char **argv) {
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  MyClass x, y, z;
  MyClass a;
  TAU_MAPPING_CREATE("MyClass::Run() for object a", " " , 
                     (TauGroup_t) &amp;a, "TAU_USER", 0);
  TAU_MAPPING_CREATE("MyClass::Run() for object x", " " , 
                     (TauGroup_t) &amp;x, "TAU_USER", 0);
  TAU_PROFILE_SET_NODE(0);
  cout &lt;&lt;"Inside main"&lt;&lt;endl;

  a.Run();
  x.Run();
  y.Run();


    </pre></div><div class="refsect1" lang="en"><a name="d0e19871"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_OBJECT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_OBJECT &#8212; Declares a mapping object</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_MAPPING_OBJECT</b>(</code><var class="pdparam">FuncIdVar</var><code>)</code>;<br>FunctionInfo <var class="pdparam">FuncIdVar</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e19905"></a><h2>Description</h2><p>To create storage for an identifier associated with a higher
    level statement that is mapped using <code class="literal">TAU_MAPPING</code>, we
    use the <code class="literal">TAU_MAPPING_OBJECT</code> macro. For example, in the
    <code class="literal">TAU_MAPPING</code> example, the array expressions are
    created into objects of a class ExpressionKernel, and each statement is
    an object that is an instance of this class. To embed the identity of
    the statement we store the mapping object in a data field in this class.
    This is shown below:</p></div><div class="refsect1" lang="en"><a name="d0e19919"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
class ExpressionKernel : public Pooma::Iterate_t {
  public:
      
    typedef ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt; This_t;
    //
    // Construct from an Expr.
    // Build the kernel that will evaluate the expression on the 
    // given domain.
    // Acquire locks on the data referred to by the expression.
    //
    ExpressionKernel(const LHS&amp;,const Op&amp;,const RHS&amp;,
    Pooma::Scheduler_t&amp;);
      
      
    virtual ~ExpressionKernel();
    
    // Do the loop.
    virtual void run();
    
  private:
      
    // The expression we will evaluate.
    LHS lhs_m;
    Op  op_m;
    RHS rhs_m;
    TAU_MAPPING_OBJECT(TauMapFI)
};
    </pre></div><div class="refsect1" lang="en"><a name="d0e19927"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE &#8212; Profiles a block based on a mapping</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE</b>(</code></td><td><var class="pdparam">FuncIdVar</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>FunctionInfo *&nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e19961"></a><h2>Description</h2><p>The <code class="literal">TAU_MAPPING_PROFILE</code> macro measures the
    time and attributes it to the statement mapped in
    <code class="literal">TAU_MAPPING</code> macro. It takes as its argument the
    identifier of the higher level statement that is stored using
    <code class="literal">TAU_MAPPING_OBJECT</code> and linked to the statement using
    <code class="literal">TAU_MAPPING_LINK</code> macros. 
    <code class="literal">TAU_MAPPING_PROFILE</code> measures the time spent in the
    entire block in which it is invoked. For example, if the time spent in
    the run method of the class does work that must be associated with the
    higher-level array expression, then, we can instrument it as
    follows:</p></div><div class="refsect1" lang="en"><a name="d0e19981"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
// Evaluate the kernel
// Just tell an InlineEvaluator to do it.
      
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE(TauMapFI)
      
  // Just evaluate the expression.
  KernelEvaluator&lt;EvalTag&gt;().evalate(lhs_m,op_m,rhs_m);
  // we could release the locks here or in dtor 
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e19989"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_START &#8212; Starts a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_START</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e20027"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_START</code> starts the
    timer that is created using
    <code class="literal">TAU_MAPPING_PROFILE_TIMER</code>. This will measure the
    elapsed time in groups of statements, instead of the entire block. A
    corresponding stop statement stops the timer as described next. The
    thread identifier is specified in the tid parameter.</p></div><div class="refsect1" lang="en"><a name="d0e20037"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e20045"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>,
      <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_STOP &#8212; Stops a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_STOP</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e20081"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_STOP</code> stops the
    timer that is created using
    <code class="literal">TAU_MAPPING_PROFILE_TIMER</code>. This will measure the
    elapsed time in groups of statements, instead of the entire block. A
    corresponding stop statement stops the timer as described next. The
    thread identifier is specified in the tid parameter.</p></div><div class="refsect1" lang="en"><a name="d0e20091"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e20099"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>,
      <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_TIMER &#8212; Declares a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">FuncIdVar</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>FunctionInfo *&nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e20135"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_TIMER</code> enables timing
    of individual statements, instead of complete blocks. It will attribute
    the time to a higher-level statement. The second argument is the
    identifier of the statement that is obtained after
    <code class="literal">TAU_MAPPING_OBJECT</code> and
    <code class="literal">TAU_MAPPING_LINK</code> have executed. The timer argument in
    this macro is any variable that is used subsequently to start and stop
    the timer.</p></div><div class="refsect1" lang="en"><a name="d0e20148"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e20156"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>,
      <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a>
    </p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e20170"></a>Appendix&nbsp;A.&nbsp;Environment Variables</h2></div></div></div><div class="table"><a name="d0e20173"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;TAU Environment Variables</b></p><table summary="TAU Environment Variables" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">VARIABLE NAME</th><th align="left">DESCRIPTION</th></tr></thead><tbody><tr><td align="left">TAU_PROFILE</td><td align="left">Set to 1 to have TAU profile your code</td></tr><tr><td align="left">TAU_TRACE</td><td align="left">Set to 1 to have TAU trace your code</td></tr><tr><td align="left">TAU_METRICS</td><td align="left">Colon delimited list of TAU/PAPI metrics to profile</td></tr><tr><td align="left">PAPI_EVENT</td><td align="left">Sets the hardware counter to use when TAU is
								configured with -PAPI. See <a href="#HardwarePerformanceCounters" title="2.6.&nbsp;Using Hardware Performance Counters">Section&nbsp;2.6, &#8220;Using Hardware Performance Counters&#8221;</a></td></tr><tr><td align="left">PCL_EVENT</td><td align="left">Sets the hardware counter to use when TAU is
								configured with -PCL. See <a href="#HardwarePerformanceCounters" title="2.6.&nbsp;Using Hardware Performance Counters">Section&nbsp;2.6, &#8220;Using Hardware Performance Counters&#8221;</a></td></tr><tr><td align="left">PROFILEDIR</td><td align="left">Selectively measure groups of routines and
								statements. Use with -profile command line option. See
								<a href="#Profiling" title="Chapter&nbsp;2.&nbsp;Profiling">Chapter&nbsp;2, <i>Profiling</i></a>
								</td></tr><tr><td align="left">TAU_CALLPATH</td><td align="left">When set to 1 TAU will generate call-path data. Use with TAU_CALLPATH_DEPTH.							</td></tr><tr><td align="left">TAU_CALLPATH_DEPTH</td><td align="left">Sets the depth of the callpath profiling. Use
								with TAU_CALLPATH environment variable.</td></tr><tr><td align="left">TAU_TRACK_MESSAGE</td><td align="left">Track MPI message  statistics (profiling), messages lines
								(tracing).</td></tr><tr><td align="left">TAU_COMM_MATRIX</td><td align="left">Generate MPI communication matrix data.</td></tr><tr><td align="left">TAU_COMPENSATE</td><td align="left">Attempt to compensate for profiling overhead in profiles.</td></tr><tr><td align="left">TAU_COMPENSATE_ITERATIONS</td><td align="left">Set the number of iterations TAU uses to estimate
								the measurement overhead. A larger number of iteration will
								increases profiling precision (default 1000).</td></tr><tr><td align="left">TAU_KEEP_TRACEFILES</td><td align="left">Retains the intermediate trace files. Use with
								-TRACE TAU configuration option. See <a href="#GeneratingEventTraces" title="3.1.&nbsp;Generating Event Traces">Section&nbsp;3.1, &#8220;Generating Event Traces&#8221;</a></td></tr><tr><td align="left">TAU_MUSE_PACKAGE</td><td align="left">Sets the MAGNET/MUSE package name. Use with the
								-muse TAU configuration option. See <a href="#MultipleHardwareCounters" title="2.4.&nbsp;Using Hardware Counters for Measurement">Section&nbsp;2.4, &#8220;Using Hardware Counters for Measurement&#8221;</a></td></tr><tr><td align="left">TAU_THROTTLE</td><td align="left">Enables the runtime throttling of events that are
								lightweight. See <a href="#SelectiveProfiling" title="1.3.&nbsp;Selectively Profiling an Application">Section&nbsp;1.3, &#8220;Selectively Profiling an Application&#8221;</a></td></tr><tr><td align="left">TAU_THROTTLE_NUMCALLS</td><td align="left">Set the maximum number of calls that will be profiled
								for any function when TAU_THROTTLE is enabled. See <a href="#SelectiveProfiling" title="1.3.&nbsp;Selectively Profiling an Application">Section&nbsp;1.3, &#8220;Selectively Profiling an Application&#8221;</a></td></tr><tr><td align="left">TAU_THROTTLE_PERCALL</td><td align="left">Set the minimum inclusive time (in milliseconds)
								a function has to have to be instrumented when TAU_THROTTLE is enabled. 
								See <a href="#SelectiveProfiling" title="1.3.&nbsp;Selectively Profiling an Application">Section&nbsp;1.3, &#8220;Selectively Profiling an Application&#8221;</a></td></tr><tr><td align="left">TAU_TRACEFILE</td><td align="left">Specifies the name of Vampir trace file. Use with
								-TRACE TAU configuration option. See <a href="#GeneratingEventTraces" title="3.1.&nbsp;Generating Event Traces">Section&nbsp;3.1, &#8220;Generating Event Traces&#8221;</a></td></tr><tr><td align="left">TRACEDIR</td><td align="left">Specifies the directory where trace file are to
								be stored. See <a href="#GeneratingEventTraces" title="3.1.&nbsp;Generating Event Traces">Section&nbsp;3.1, &#8220;Generating Event Traces&#8221;</a></td></tr><tr><td align="left">TAU_VERBOSE</td><td align="left">When set TAU will print out information about the
                its configuration when running a instrumented application.
								</td></tr><tr><td align="left">TAU_PROFILE_FORMAT</td><td align="left">When set to <code class="literal">snapshot</code> TAU will
                generate condensed snapshot profiles (they merge together different
                metrics so there is only one file per node.) Instead of the default
                kind. When set to <code class="literal">merged</code>, TAU will pre-compute mean 
                and std. dev. at the end of execution. 
								</td></tr><tr><td align="left">TAU_TRACK_MEMORY_FOOTPRINT</td><td align="left">When set TAU will track resident set size (VmRSS) and peak memory usage (VmHWM) or the
    high water mark of resident set size, the same values provided by the 'top' command.
                </td></tr><tr><td align="left">TAU_TRACK_POWER</td><td align="left">
								Enables tracking of power consumption via periodic interrupt.
								</td></tr><tr><td align="left">TAU_SYNCHRONIZE_CLOCKS</td><td align="left">When set TAU will correct for any time discrepancies
                between nodes because of their CPU clock lag. This should
                produce more reliable trace data.
                </td></tr><tr><td align="left">TAU_SAMPLING</td><td align="left">

<p>Default value is 0 (off). When TAU_SAMPLING is set, we collect
additional profile or trace information (depending on whether
TAU_PROFILE or TAU_TRACE is set respectively) via periodic sampling at
runtime. Metrics collected and sampling period is controlled by
TAU_EBS_SOURCE and TAU_EBS_PERIOD variables respectively. The
TAU_EBS_UNWIND variable determines if callstack unwinding is enabled
at each sample.
</p><p> For TAU_PROFILE, in addition to regular TAU instrumented profile
output, samples will show up as additional events prefixed by [SAMPLE]
for each unique function, file and source line number combination.
These events are grouped under [INTERMEDIATE] event nodes for the
instrumented TAU context where the samples occured. In addition, if
TAU_EBS_UNWIND is active, [UNWIND] event nodes may be generated for
each discovered callstack entry found by the callstack unwinder.
</p><p> TAU_SAMPLING is dependent on the availability of BFD as determined by
the -bfd configuration option when building TAU. Its ability to
resolve sample addresses into function, file name and source line
number information may be limited or missing if BFD is missing or is
installed with limited functionality. If in doubt, please try building
TAU with "-bfd=download". Any one of function, file name and source
line number may be missing. In the event all three are, the event is
marked as "UNRESOLVED". The TAU_EBS_KEEP_UNRESOLVED_ADDR variable
enables addresses to be retained for unresolved results.
</p>
                </td></tr><tr><td align="left">TAU_EBS_SOURCE</td><td align="left">
Default value is "itimer". This variable sets the metric that
determines the period of sampling.  If the value is "itimer"
(default), it represents the number of microseconds between samples
(as determined by TAU_EBS_PERIOD). If the value is a PAPI metric
(eg. PAPI_FP_INS), then it represents the number of counts of that
metric between samples (eg. every 10,000 floating-point instructions
if PAPI_FP_INS is used). For "itimer", the samples occur as a result
of system timer interrupts while for PAPI they occur in response to
PAPI counter overflow interrupts set to the value of the
TAU_EBS_PERIOD.

                </td></tr><tr><td align="left">TAU_EBS_PERIOD</td><td align="left">
Default value is 1,000. This variable sets the period between
samples. The semantics of this value is discussed in the section above
on TAU_EBS_SOURCE.
</td></tr><tr><td align="left">TAU_EBS_UNWIND</td><td align="left">
Default value is 0 (off). This enables callstack unwinding for each
sample using the callstack unwinder specified at TAU configuration
time. As of this writing, only the libunwind tool is
supported. Support for other callstack unwinders like StackwalkerAPI
will be included. The TAU_EBS_UNWIND_DEPTH variable is used to control
how many times the TAU sampling framework will be allowed to unwind
the callstack.
								</td></tr><tr><td align="left">TAU_EBS_UNWIND_DEPTH</td><td align="left">Default value is 10. This controls how many layers of the callstack
TAU should unwind before attaching the result to the appropriate TAU
event context.
								</td></tr><tr><td align="left">TAU_EBS_KEEP_UNRESOLVED_ADDR</td><td align="left">Default value is 0 (off). When set, this variable allows sample
addresses that fail to be resolved by BFD to be recorded as
"UNRESOLVED &lt;modulename&gt; ADDR &lt;addr&gt; instead of "UNRESOLVED
&lt;modulename&gt;". This provides nominally more information than the
default scenario in light of missing BFD information.
                </td></tr><tr><td align="left">TAU_TRACK_SIGNALS</td><td align="left">Set this variables to 1 to capture callstack as metadata at
                 point of failure.
                </td></tr><tr><td align="left">TAU_SUMMARY</td><td align="left">Set this variables to 1 to generate just min/max/stddev/mean 
								statistics instead of per-node data.  Use paraprof -dumpsummary and 
								then pprof -f profile.Max/Min to see the data. 
           					
                </td></tr><tr><td align="left">TAU_IBM_BG_HWP_COUNTERS</td><td align="left">Set this variables to 1 to include IBM's UPC
								Hardware Performance counters in the metadata for process 0.
								Requires the use of MPI.
                </td></tr><tr><td align="left">TAU_CUPTI_API</td><td align="left">Default: <code class="literal">runtime</code>, options:
								<code class="literal">runtime,driver,both</code>.
								Controls which layer of CUDA is tracked within the CUPTI
								measurement system. See for example: <code class="literal">tau_exec -T
								serial,cupti -cupti ./matmult</code>. Option should be set
								basied on which layer the CUDA program
								uses&#8212;<code class="literal">runtime</code> when the program uses the
								CUDA runtime API, <code class="literal">driver</code> when the program
								uses the driver API. NOTE: Both the PGI accelerator and the HMPP
								compilers use the driver API.</td></tr></tbody></table></div></div></div></div>
       </div>
       <?php include("../../footer.php") ?>
    </body></html>
