<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>TAU User Guides</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
       <?php include("../../header.php") ?>
       <div id="content">
    <div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauUsersGuide"></a>TAU User Guides</h1></div><div><div class="legalnotice"><a name="d0e26"></a><p>Updated May 4th, 2015 for use with version 2.24.1 or greater.</p><p>Copyright &copy; 1997-2012
      Department of Computer and Information Science, University of Oregon 
      Advanced Computing Laboratory, LANL, NM 
      Research Centre Juelich, ZAM, Germany</p><p>Permission to use, copy, modify, and distribute this software and
	its documentation for any purpose and without fee is hereby granted,
	provided that the above copyright notice appear in all copies and that
	both that copyright notice and this permission notice appear in
	supporting documentation, and that the name of University of Oregon (UO)
	Research Centre Juelich, (ZAM) and Los Alamos National Laboratory (LANL)
	not be used in advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.  The University of
	Oregon, ZAM and LANL make no representations about the suitability of
	this software for any purpose.  It is provided "as is" without express or
	implied warranty.</p><p>UO, ZAM AND LANL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
	SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	FITNESS. IN NO EVENT SHALL THE UNIVERSITY OF OREGON, ZAM OR LANL BE
	LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d0e35"></a></span></dt><dt><span class="part"><a href="#TAUUSERMANUAL">I. Tau User Guide</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tauInstrumentation">1. Tau Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e160">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e165">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e193">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Profiling">2. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Analysis">4. Analyzing Parallel Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></dd><dt><span class="chapter"><a href="#StartersGuide">5. Quick Reference</a></span></dt><dt><span class="chapter"><a href="#ApplicationScenario">6. Some Common Application Scenario</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e614">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e633">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e655">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e677">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e699">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e721">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e740">6.7. Q. How does my application scale?
</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#ParaProfDoc">II. ParaProf - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#paraprof.intro">7. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.views">8. Views and Sub-Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.trialmanagement">9. Profile Data Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.3d">10. 3-D Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.threaddisplays">11. Thread Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.functiondisplays">12. Function Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.phasedisplays">13. Phase Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.comparison">14. Comparative Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.otherdisplays">15. Miscellaneous Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.preferences">16. Preferences</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#PerfExplorerDoc">III. PerfExplorer - User's Manual</a></span></dt><dd><dl><dt><span class="chapter"><a href="#Introduction">17. Introduction</a></span></dt><dt><span class="chapter"><a href="#InstallPerfExplorer">18. Installation and Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RunningPerfExplorer">19. Running PerfExplorer</a></span></dt><dt><span class="chapter"><a href="#ClusterAnalysis">20. Cluster Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#CorrelationAnalysis">21. Correlation Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Charts">22. Charts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CustomCharts">23. Custom Charts</a></span></dt><dt><span class="chapter"><a href="#Visualization">24. Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Views">25. Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Scripting">26. Running PerfExplorer Scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Derived Metrics">27. Derived Metrics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#TAUdbDoc">IV. TAUdb</a></span></dt><dd><dl><dt><span class="chapter"><a href="#taudb.intro">28. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">29. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">30. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">31. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>4.1. <a href="#paraprof.maindatawindow1.figure">Main Data Window</a></dt><dt>4.2. <a href="#jumpshot.overview.figure">Main Data Window</a></dt><dt>6.1. <a href="#d0e619">Flat Profile</a></dt><dt>6.2. <a href="#d0e638">Flat Profile with Loops</a></dt><dt>6.3. <a href="#d0e660">MFlops per loop</a></dt><dt>6.4. <a href="#d0e682">Callpath Profile</a></dt><dt>6.5. <a href="#d0e726">Tracing with Vampir</a></dt><dt>6.6. <a href="#d0e745">Scalability chart</a></dt><dt>8.1. <a href="#d0e947">Add View</a></dt><dt>8.2. <a href="#d0e958">View Creator Window</a></dt><dt>9.1. <a href="#paraprof.mainwindow.figure">ParaProf Manager Window</a></dt><dt>9.2. <a href="#d0e995">Loading Profile Data</a></dt><dt>9.3. <a href="#paraprof.derivedmetrics.figure">Creating Derived Metrics</a></dt><dt>9.4. <a href="#paraprof.maindatawindow.figure">Main Data Window</a></dt><dt>9.5. <a href="#d0e1054">Unstacked Bars</a></dt><dt>10.1. <a href="#d0e1074">Triangle Mesh Plot</a></dt><dt>10.2. <a href="#paraprof.3dbarplot.figure">3-D Mesh Plot</a></dt><dt>10.3. <a href="#d0e1115">3-D Scatter Plot</a></dt><dt>10.4. <a href="#d0e1128">3-D Topology Plot</a></dt><dt>10.5. <a href="#d0e1155">3-D Commication Matrix</a></dt><dt>11.1. <a href="#d0e1178">Thread Bar Graph</a></dt><dt>11.2. <a href="#d0e1192">Thread Statistics Text Window</a></dt><dt>11.3. <a href="#paraprof.thread.treetable1">Thread Statistics Table, inclusive and exclusive</a></dt><dt>11.4. <a href="#paraprof.thread.treetable2">Thread Statistics Table</a></dt><dt>11.5. <a href="#paraprof.thread.treetable3">Thread Statistics Table</a></dt><dt>11.6. <a href="#d0e1239">Call Graph Window</a></dt><dt>11.7. <a href="#paraprof.thread.callpathrelations">Thread Call Path Relations Window</a></dt><dt>11.8. <a href="#d0e1279">User Event Statistics Window</a></dt><dt>11.9. <a href="#d0e1294">User Event Thread Bar Chart Window</a></dt><dt>12.1. <a href="#d0e1313">Function Bar Graph</a></dt><dt>12.2. <a href="#d0e1327">Function Histogram</a></dt><dt>13.1. <a href="#d0e1356">Initial Phase Display</a></dt><dt>13.2. <a href="#d0e1367">Phase Ledger</a></dt><dt>13.3. <a href="#d0e1375">Function Data over Phases</a></dt><dt>14.1. <a href="#d0e1394">Comparison Window (initial)</a></dt><dt>14.2. <a href="#d0e1402">Comparison Window (2 trials)</a></dt><dt>14.3. <a href="#d0e1408">Comparison Window (3 threads)</a></dt><dt>15.1. <a href="#d0e1423">User Event Bar Graph</a></dt><dt>15.2. <a href="#d0e1439">Function Ledger</a></dt><dt>15.3. <a href="#d0e1450">Group Ledger</a></dt><dt>15.4. <a href="#d0e1467">User Event Ledger</a></dt><dt>15.5. <a href="#d0e1480">Selective Instrumentation Dialog</a></dt><dt>16.1. <a href="#d0e1503">ParaProf Preferences Window</a></dt><dt>16.2. <a href="#d0e1543">Edit Default Colors</a></dt><dt>16.3. <a href="#d0e1554">Color Map</a></dt><dt>20.1. <a href="#perfexplorer.mainwindow.dimensionreduction1">Selecting a dimension reduction method</a></dt><dt>20.2. <a href="#perfexplorer.mainwindow.dimensionreduction2">Entering a minimum threshold for exclusive percentage</a></dt><dt>20.3. <a href="#perfexplorer.mainwindow.maxclusters">Entering a maximum number of clusters</a></dt><dt>20.4. <a href="#perfexplorer.mainwindow.clustering">Selecting a
	Metric to Cluster</a></dt><dt>20.5. <a href="#perfexplorer.confirm.clustering">Confirm
	Clustering Options</a></dt><dt>20.6. <a href="#perfexplorer.cluster.results">Cluster
	Results</a></dt><dt>20.7. <a href="#perfexplorer.cluster.histogram">Cluster
	Membership Histogram</a></dt><dt>20.8. <a href="#perfexplorer.cluster.scatterplot">Cluster
	Membership Scatterplot</a></dt><dt>20.9. <a href="#perfexplorer.cluster.topology">Cluster
	Virtual Topology</a></dt><dt>20.10. <a href="#perfexplorer.cluster.averages">Cluster
	Average Behavior</a></dt><dt>21.1. <a href="#perfexplorer.mainwindow.dimensionreduction1b">Selecting a dimension reduction method</a></dt><dt>21.2. <a href="#perfexplorer.mainwindow.dimensionreduction2b">Entering a minimum threshold for exclusive percentage</a></dt><dt>21.3. <a href="#perfexplorer.mainwindow.correlation">Selecting a
	Metric to Cluster</a></dt><dt>21.4. <a href="#perfexplorer.correlation.results">Correlation
	Results</a></dt><dt>21.5. <a href="#perfexplorer.correlation.example">Correlation
	Example</a></dt><dt>22.1. <a href="#perfexplorer.charts.groupofinterest">Setting Group of Interest</a></dt><dt>22.2. <a href="#perfexplorer.charts.metricofinterest">Setting Metric of Interest</a></dt><dt>22.3. <a href="#perfexplorer.charts.eventofinterest">Setting Event of Interest</a></dt><dt>22.4. <a href="#perfexplorer.charts.timesteps">Setting Timesteps</a></dt><dt>22.5. <a href="#perfexplorer.charts.timestepspersecond">Timesteps per Second</a></dt><dt>22.6. <a href="#perfexplorer.charts.relativeefficiency">Relative Efficiency</a></dt><dt>22.7. <a href="#perfexplorer.charts.relativeefficiencybyevent">Relative Efficiency by Event</a></dt><dt>22.8. <a href="#perfexplorer.charts.relativeefficiencyoneevent">Relative Efficiency one Event</a></dt><dt>22.9. <a href="#perfexplorer.charts.relativespeedup">Relative Speedup</a></dt><dt>22.10. <a href="#perfexplorer.charts.relativespeedupbyevent">Relative Speedup by Event</a></dt><dt>22.11. <a href="#perfexplorer.charts.relativespeeduponeevent">Relative Speedup one Event</a></dt><dt>22.12. <a href="#perfexplorer.charts.percentoftotal">Group % of Total Runtime</a></dt><dt>22.13. <a href="#perfexplorer.charts.runtimebreakdown">Runtime Breakdown</a></dt><dt>22.14. <a href="#perfexplorer.charts.relativeefficiencybyphase">Relative Efficiency per Phase</a></dt><dt>22.15. <a href="#perfexplorer.charts.relativespeedupbyphase">Relative Speedup per Phase</a></dt><dt>22.16. <a href="#perfexplorer.charts.phasebreakdown">Phase Fraction of Total Runtime</a></dt><dt>23.1. <a href="#perfexplorer.customcharts.interface">The Custom Charts
	Interface</a></dt><dt>24.1. <a href="#perfexplorer.visualization.threed">3D
		Visualization of multivariate data</a></dt><dt>24.2. <a href="#perfexplorer.visualization.datasummary">Data
		Summary Window</a></dt><dt>24.3. <a href="#perfexplorer.visualization.boxchart">Boxchart</a></dt><dt>24.4. <a href="#perfexplorer.visualization.histogram">Histogram</a></dt><dt>24.5. <a href="#perfexplorer.visualization.normalprobability">Normal
		Probability</a></dt><dt>25.1. <a href="#perfexplorer.views.parametricexample">Potential
	scalability data organized as a parametric study</a></dt><dt>25.2. <a href="#perfexplorer.views.viewslevel">Selecting a table</a></dt><dt>25.3. <a href="#perfexplorer.views.viewscolumn">Selecting a
	column</a></dt><dt>25.4. <a href="#perfexplorer.views.viewsoperator">Selecting an
	operator</a></dt><dt>25.5. <a href="#perfexplorer.views.viewsvalue">Selecting a value</a></dt><dt>25.6. <a href="#perfexplorer.views.viewsname">Entering a name
	for the view</a></dt><dt>25.7. <a href="#perfexplorer.views.completedview">The completed
	view</a></dt><dt>25.8. <a href="#perfexplorer.views.subview">Selecting the base
	view</a></dt><dt>25.9. <a href="#perfexplorer.views.completedsubview">Completed
	sub-views</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#d0e63">Different methods of instrumenting applications</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"></div><p>TAU Performance System&reg;  is a portable profiling and tracing
      toolkit for performance analysis of parallel programs written in Fortran,
      C, C++, Java, and Python.
      
      TAU (Tuning and Analysis Utilities) is capable of gathering performance
      information through instrumentation of functions, methods, basic blocks,
      and statements. The TAU API also provides selection of profiling groups
      for organizing and controlling instrumentation. Calls to the TAU API are
      made by probes inserted into the execution of the application via source
      transformation, compiler directives or by library interposition.</p><p>This guide is organized into different sections. Readers wanting to
      get started right way can skip to
      the <a href="#ApplicationScenario" title="Chapter&nbsp;6.&nbsp;Some Common Application Scenario">Common Profile Requests</a>
      section for step-by-step instructions for obtaining difference kinds of
      performance data. Or browse the <a href="#StartersGuide" title="Chapter&nbsp;5.&nbsp;Quick Reference">starters
      guide</a> for a quick reference to common TAU commands and
      variables.</p><p>TAU can be found on the web at: <a href="http://tau.uoregon.edu" target="_top">http://tau.uoregon.edu</a></p></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUUSERMANUAL"></a>Part&nbsp;I.&nbsp;Tau User Guide</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tauInstrumentation">1. Tau Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e160">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e165">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e193">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Profiling">2. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">3. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Analysis">4. Analyzing Parallel Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></dd><dt><span class="chapter"><a href="#StartersGuide">5. Quick Reference</a></span></dt><dt><span class="chapter"><a href="#ApplicationScenario">6. Some Common Application Scenario</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e614">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e633">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e655">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e677">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e699">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e721">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e740">6.7. Q. How does my application scale?
</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tauInstrumentation"></a>Chapter&nbsp;1.&nbsp;Tau Instrumentation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TauLibraryInterposition">1.1. Dynamic instrumentation through library pre-loading</a></span></dt><dt><span class="sect1"><a href="#d0e160">1.2. TAU scripted compilation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e165">1.2.1. Compiler Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#d0e193">1.2.2. Source Based Instrumentation</a></span></dt><dt><span class="sect2"><a href="#TAUCompilerOptions">1.2.3. Options to TAU compiler scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SelectiveProfiling">1.3. Selectively Profiling an Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ManualSelectiveProfiling">1.3.1. Custom Profiling</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p>
          </p><p>TAU provides three methods to track the performance of your
	application. Library interposition using tau_exec, 
	compiler directives or source transformation using PDT. Here is a
	table that lists the features/requirement for each method:</p><div class="table"><a name="d0e63"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Different methods of instrumenting applications</b></p><table summary="Different methods of instrumenting applications" border="1"><colgroup><col width="12%"><col width="13%"><col width="12%"><col width="13%"><col width="12%"><col width="13%"><col width="12%"><col width="13%"></colgroup><thead><tr><th><span class="emphasis"><em>Method</em></span></th><th>Requires
					recompiling</th><th>Requires
					PDT</th><th>Shows MPI events</th><th>Routine-level event</th><th>Low level
					events (loops, phases, etc...)</th><th>Throttling to reduce
					overhead</th><th>Ability to exclude file from
					instrumentation</th><th>Ability to exclude
			    other regions of code</th></tr></thead><tbody><tr><td>Interposition</td><td>&nbsp;</td><td>&nbsp;</td><td>Yes</td><td>&nbsp;</td><td>&nbsp;</td><td>Yes</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Compiler</td><td>Yes</td><td>&nbsp;</td><td>Yes</td><td>Yes</td><td>&nbsp;</td><td>Yes</td><td>Yes</td><td>&nbsp;</td></tr><tr><td>Source</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></div>


		The requirements for each method increases as we move down the table: tau_exec
		only requires a system with shared library support. Compiler based
		instrumentation requires re-compiling that target application and Source
		instrumentation aditionally requires PDT. For this reason we often recommend that users
		start with Library interposition and move down the table if more features
		are needed.
		
</div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TauLibraryInterposition"></a>1.1.&nbsp;Dynamic instrumentation through library pre-loading</h2></div></div></div><p>Dynamic instrumentation is achieved through library pre-loading. The
		libraries chosen for pre-loading determine the scope of instrumentation.
		Some options include tracking MPI, io, memory, cuda, opencl library
		calls. MPI instrumentation is included by default the others are enabled by command-line options to
		<code class="literal">tau_exec</code>. More info at the <a href="#"><code class="literal">tau_exec</code> manual page</a>. Dynamic
		instrumentation can be used on both uninstrumented binaries and binaries
		instrumented via one of the methods below, in this way different layers of
		instrumentation can be combined.</p><p>To use <code class="literal">tau_exec</code> place this command before the
		application executable when running the application. In this example IO
		instrumentation is requested.
		</p><pre class="screen">
%&gt; tau_exec -io ./a.out
%&gt; mpirun -np 4 tau_exec -io ./a.out
</pre><p>
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e160"></a>1.2.&nbsp;TAU scripted compilation</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"></div>For more detailed profiles, TAU provides two means to compile your
	application with TAU: through your compiler or through source transformation
	using PDT.</div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e165"></a>1.2.1.&nbsp;Compiler Based Instrumentation</h3></div></div></div><p>TAU provides these scripts: tau_f90.sh, tau_cc.sh, and tau_cxx.sh to
    instrument and compile Fortran, C, and C++ programs respectively. You might
    use tau_cc.sh to compile a C program by typing: 
    </p><pre class="screen">
%&gt; module load tau
%&gt; tau_cc.sh -tau_options=-optCompInst samplecprogram.c
    </pre><p>
	    On machines where a TAU module is not available, you will need to set the
			tau makefile and/or options. The makefile and options controls how will
			TAU will compile you application. Use
		</p><pre class="screen">
%&gt;tau_cc.sh -tau_makefile=[path to makefile] \
            -tau_options=[option] samplecprogram.c
    </pre><p>
    The Makefile can be found in the <code class="literal">/[arch]/lib</code>
		directory of your TAU distribution, for example
    <code class="literal">/x86_64/lib/Makefile.tau-mpi-pdt</code>.</p><p>You can also use a Makefile
    specified in an environment variable. To run tau_cc.sh so it uses the
    Makefile specified by environment variable <code class="literal">TAU_MAKEFILE</code>,
    type:
    
    </p><pre class="screen">
%&gt;export TAU_MAKEFILE=[path to tau]/[arch]/lib/[makefile]
%&gt;export TAU_OPTIONS=-optCompInst
%&gt;tau_cc.sh sampleCprogram.c
    </pre><p>

    Similarly, if you want to set compile time options like
    selective instrumentation you can use the <code class="literal">TAU_OPTIONS</code>
    environment variable.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e193"></a>1.2.2.&nbsp;Source Based Instrumentation</h3></div></div></div><p>TAU provides these scripts: tau_f90.sh, tau_cc.sh, and tau_cxx.sh to
    instrument and compile Fortran, C, and C++ programs respectively. You might
    use tau_cc.sh to compile a C program by typing: 
    </p><pre class="screen">
%&gt; module load tau
%&gt; tau_cc.sh samplecprogram.c
    </pre><p>
    When setting the TAU_MAKEFILE make sure the Makefile name contains
		<code class="literal">pdt</code> because you will need a version of TAU built with
		PDT.</p><p>A list of options for the TAU compiler scripts can be found by typing
		<code class="literal">man tau_compiler.sh</code> or in this chapter of the <a href="#">reference guide</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TAUCompilerOptions"></a>1.2.3.&nbsp;Options to TAU compiler scripts</h3></div></div></div><p>These are some commonly used options available to the TAU compiler
		scripts. Either set them via the <code class="literal">TAU_OPTIONS</code> environment
		variable or the <code class="literal">-tau_options=</code> option to
		<code class="literal">tau_f90.sh, tau_cc.sh, or tau_cxx.sh</code></p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-optVerbose</code></span></dt><dd>Enable verbose output (default: on)</dd><dt><span class="term"><code class="literal">-optKeepFiles</code></span></dt><dd>Do not remove intermediate files</dd><dt><span class="term"><code class="literal">-optShared</code></span></dt><dd>Use shared library of TAU (consider when using
				<code class="literal">tau_exec</code></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SelectiveProfiling"></a>1.3.&nbsp;Selectively Profiling an Application</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ManualSelectiveProfiling"></a>1.3.1.&nbsp;Custom Profiling</h3></div></div></div><p>TAU allows you to customize the instrumentation of a program by using a
		selective instrumentation file. This instrumentation file is used to
      manually control which parts of the application are profiled and how they
      are profiled. If you are using one of the TAU compiler wrapper scripts to instrument your
			application you can use the <code class="literal">-tau_options=-optTauSelectFile=&lt;file&gt;</code>
			option to enable selective instrumentation. 
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">Selective instrumentation is only available when using source-level
		instrumentation (PDT).</td></tr></table></div>
      To specify a selective instrumentation file, create a text file and use
			the following guide to fill it in:
			<div class="itemizedlist"><ul type="disc"><li>Wildcards for routine names are specified with the
				<code class="literal">#</code> mark (because <code class="literal">*</code>
				symbols show up in routine signatures.)  The <code class="literal">#</code> mark is unfortunately the comment character
				as well, so to specify a leading wildcard, place the entry in quotes.
				</li><li>
					Wildcards for file names are specified with <code class="literal">*</code> symbols.  
				</li></ul></div><pre class="screen"> 
		<p>Here is a example file:</p>
#Tell tau to not profile these functions
BEGIN_EXCLUDE_LIST

void quicksort(int *, int, int)
# The next line excludes all functions beginning with "sort_" and having 
# arguments "int *"
void sort_#(int *)
void interchange(int *, int *)

END_EXCLUDE_LIST

#Exclude these files from profiling
BEGIN_FILE_EXCLUDE_LIST

*.so

END_FILE_EXCLUDE_LIST

BEGIN_INSTRUMENT_SECTION

# A dynamic phase will break up the profile into phase where
# each events is recorded according to what phase of the application
# in which it occured.
dynamic phase name="foo1_bar" file="foo.c" line=26 to line=27

# instrument all the outer loops in this routine
loops file="loop_test.cpp" routine="multiply"

# tracks memory allocations/deallocations as well as potential leaks
memory file="foo.f90" routine="INIT"

# tracks the size of read, write and print statements in this routine
io file="foo.f90" routine="RINB"

END_INSTRUMENT_SECTION
</pre><p>Selective instrumentation files can be created automatically from
<code class="literal"><a href="#ParaProfDoc" title="Part&nbsp;II.&nbsp;ParaProf - User's Manual">ParaProf</a></code>
by right clicking on a trial and selecting the <code class="literal">Create Selective Instrumentation File</code> menu
item.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Profiling"></a>Chapter&nbsp;2.&nbsp;Profiling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#RunningApplication">2.1. Running the Application</a></span></dt><dt><span class="sect1"><a href="#TauThrottle">2.2. Reducing Performance Overhead with TAU_THROTTLE</a></span></dt><dt><span class="sect1"><a href="#callpathProfiling">2.3. Profiling each event callpath</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">2.4. Using Hardware Counters for Measurement</a></span></dt></dl></div><p>This chapter describes running an instrumented application,
  generating profile data and analyzing that data. Profiling
  shows the summary statistics of performance metrics that characterize
  application performance behavior. Examples of performance metrics are
  the CPU time associated with a routine, the count of the secondary data
  cache misses associated with a group of statements, the number of times
  a routine executes, etc. </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningApplication"></a>2.1.&nbsp;Running the Application</h2></div></div></div><p>After instrumentation and compilation are completed, the profiled
    application is run to generate the profile data files. These files can be
    stored in a directory specified by the environment variable
    <code class="literal">PROFILEDIR</code>. By default, profiles are placed in the
		current directory. You can also set the <code class="literal">TAU_VERBOSE</code>
		enviroment variable to see the steps the TAU measurement systems takes
		when your application is running.

    Example: </p><pre class="screen">
% setenv TAU_VERBOSE 1
% setenv PROFILEDIR /home/sameer/profiledata/experiment55
% mpirun -np 4 matrix 
</pre><p>Other environment variables you can set to enable these
		advanced MPI measurement features are <code class="literal">TAU_TRACK_MESSAGE</code>
		to track MPI message statistics when profiling or messages lines when tracing, and
		<code class="literal">TAU_COMM_MATRIX</code> to generate MPI communication matrix
		data.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TauThrottle"></a>2.2.&nbsp;Reducing Performance Overhead with TAU_THROTTLE</h2></div></div></div><p>TAU automatically throttles short running functions in an effort
			to reduce the amount of overhead associated with profiles of such functions.
			This feature may be turned off by setting the environment variable
			<code class="literal">TAU_THROTTLE</code> to 0.
      The default rules TAU uses to determine which functions to throttle is:
      <code class="literal">numcalls &gt; 100000 &amp;&amp; usecs/call &lt; 10</code>
      which means that if a function executes more than 100000 times and has
      an inclusive time per call of less than 10 microseconds, then profiling of
      that function will be disabled after that threshold is reached. To change the values of
      numcalls
      and usecs/call the user may optionally set environment variables:
      </p><pre class="screen">
% setenv TAU_THROTTLE_NUMCALLS 2000000
% setenv TAU_THROTTLE_PERCALL  5
  </pre><p>
      The changes the values to 2 million and 5 microseconds per call.  Functions that are throttled
      are marked explicitly in there names as THROTTLED. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="callpathProfiling"></a>2.3.&nbsp;Profiling each event callpath</h2></div></div></div><p>You can enable callpath profiling by setting the environment variable
		<code class="literal">TAU_CALLPATH</code>. In this mode TAU will recorded the each
		event callpath to the depth set by the <code class="literal">TAU_CALLPATH_DEPTH</code>
		environment variable (default is two). Because instrumentation overhead will increase with 
		the depth of the callpath, you should use the shortest call path that is sufficient.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MultipleHardwareCounters"></a>2.4.&nbsp;Using Hardware Counters for Measurement</h2></div></div></div><p>Performance counters exist on many modern microprocessors. They can
    count hardware performance events such as cache misses, floating point
    operations, etc. while the program executes on the processor. The
    Performance Data Standard and <code class="literal">API (<a href="http://icl.cs.utk.edu/papi/" target="_top">PAPI</a>)</code>
    package provides a uniform interface to access these performance
    counters.</p><p>To use these counters, you must first find out which PAPI events your system supports.
    To do so type:</p><pre class="screen">
%&gt; papi_avail 
Available events and hardware information.
-------------------------------------------------------------------------
Vendor string and code   : AuthenticAMD (2)
Model string and code    : AMD K8 Revision C (15)
CPU Revision             : 2.000000
CPU Megahertz            : 2592.695068
CPU's in this Node       : 4
Nodes in this System     : 1
Total CPU's              : 4
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------------------------------------
The following correspond to fields in the PAPI_event_info_t structure.

Name            Code            Avail   Deriv   Description (Note)
PAPI_L1_DCM     0x80000000      Yes     Yes     Level 1 data cache misses
PAPI_L1_ICM     0x80000001      Yes     Yes     Level 1 instruction cache misses
...

</pre><p>Next, to test the compatibility between each metric you wish papi to profile,
    use <code class="literal">papi_event_chooser:</code></p><pre class="screen">
papi/utils&gt; papi_event_chooser PAPI_LD_INS PAPI_SR_INS PAPI_L1_DCM
Test case eventChooser: Available events which can be added with given
events.
-------------------------------------------
Vendor string and code   : GenuineIntel (1)
Model string and code    : Itanium 2 (2)
CPU Revision             : 1.000000
CPU Megahertz            : 1500.000000
CPU's in this Node       : 16
Nodes in this System     : 1
Total CPU's              : 16
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------
Event PAPI_L1_DCM can't be counted with others
</pre><p>Here the event chooser tells us that PAPI_LD_INS, PAPI_SR_INS, and PAPI_L1_DCM 
    are incompatible metrics. Let try again this time removing PAPI_L1_DCM:</p><pre class="screen">
% papi/utils&gt; papi_event_chooser PAPI_LD_INS PAPI_SR_INS
Test case eventChooser: Available events which can be added with given
events.
-------------------------------------------
Vendor string and code   : GenuineIntel (1)
Model string and code    : Itanium 2 (2)
CPU Revision             : 1.000000
CPU Megahertz            : 1500.000000
CPU's in this Node       : 16
Nodes in this System     : 1
Total CPU's              : 16
Number Hardware Counters : 4
Max Multiplex Counters   : 32
-------------------------------------------
Usage: eventChooser NATIVE|PRESET evt1 evet2 ...
</pre><p>Here the event chooser verifies that PAPI_LD_INS and PAPI_SR_INS are compatible
    metrics.</p><p>Next, make sure that you are using a makefile with
		<code class="literal">papi</code> in its
		name. Then set the environment variable <code class="literal">TAU_METRICS</code> to a
		colon delimited list of PAPI metrics
		you would like to use.
	  </p><pre class="screen">
setenv TAU_METRICS PAPI_FP_OPS\:PAPI_L1_DCM
</pre><p>		
		
		</p><p>In addition to PAPI counters, we support TIME (via unix gettimeofday).
		On Linux and CrayCNL systems, we provide the high resolution LINUXTIMERS metric and 
		on BGL/BGP systems we provide BGLTIMERS and
		BGPTIMERS. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Tracing"></a>Chapter&nbsp;3.&nbsp;Tracing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">3.1. Generating Event Traces</a></span></dt></dl></div><p>Typically, profiling shows the distribution of execution
  time across routines. It can show the code locations associated with
  specific bottlenecks, but it can not show the temporal aspect of
  performance variations. Tracing the execution of a parallel program
  shows when and where an event occurred, in terms of the process that
  executed it and the location in the source code. This chapter discusses
  how TAU can be used to generate event traces.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GeneratingEventTraces"></a>3.1.&nbsp;Generating Event Traces</h2></div></div></div><p>To enable tracing with TAU, set the environment variable
		<code class="literal">TAU_TRACE</code> to 1. Similarly you can enable/disable profile
		with the <code class="literal">TAU_PROFILE</code> variable. Just like with profiling, you can set
		the output directory with a environment variable:

		</p><pre class="screen">
% setenv TRACEDIR /users/sameer/tracedata/experiment56
</pre><p>

    This will generate a trace file and an event file for each processor. To
		merge these files, use the <code class="literal">tau_treemerge.pl</code> script. If you
		want to convert TAU trace file into another format use the
		<code class="literal">tau2otf</code>, <code class="literal">tau2vtf</code>, or
		<code class="literal">tau2slog2</code> scripts.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Analysis"></a>Chapter&nbsp;4.&nbsp;Analyzing Parallel Applications</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#pprof">4.1. Text summary</a></span></dt><dt><span class="sect1"><a href="#ParaProf.brief">4.2. ParaProf</a></span></dt><dt><span class="sect1"><a href="#Jumpshot.brief">4.3. Jumpshot</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pprof"></a>4.1.&nbsp;Text summary</h2></div></div></div><p>For a quick view summary of TAU performance, use
		<code class="literal">pprof</code> It reads and prints a summary of the TAU data in the
		current directory. For performance data with multiple metrics, move into one
		of the directories to get information about that metric:</p><pre class="screen">
%&gt; cd MULTI__P_WALL_CLOCK_TIME
%&gt; pprof
Reading Profile files in profile.*

NODE 0;CONTEXT 0;THREAD 0: 
--------------------------------------------------------------------------------------- 
%Time    Exclusive    Inclusive       #Call      #Subrs  Inclusive Name 
              msec   total msec                          usec/call  
--------------------------------------------------------------------------------------- 
100.0           24          590           1           1     590963 main 
 95.9           26          566           1           2     566911 multiply 
 47.3          279          279           1           0     279280 multiply-opt 
 44.1          260          260           1           0     260860 multiply-regular 
 </pre><p>

   </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ParaProf.brief"></a>4.2.&nbsp;ParaProf</h2></div></div></div><p>To launch ParaProf, execute paraprof from the command line where
		 the profiles are located. Launching ParaProf will bring up the manager window and 
		 a window displaying the profile data as shown below. </p><div class="figure"><a name="paraprof.maindatawindow1.figure"></a><p class="title"><b>Figure&nbsp;4.1.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/maindatawindow.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div><p>For more information see the <a href="#ParaProfDoc" title="Part&nbsp;II.&nbsp;ParaProf - User's Manual">ParaProf section in the reference
		 guide</a>.
		 </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Jumpshot.brief"></a>4.3.&nbsp;Jumpshot</h2></div></div></div><p>To use Argonne's Jumpshot (bundled with TAU), first merge and convert TAU traces to slog2  
format:  
</p><pre class="screen"> 
% tau_treemerge.pl 
% tau2slog2 tau.trc tau.edf -o tau.slog2 
% jumpshot tau.slog2 
</pre><p> 
Launching Jumpshot will bring up the main display window showing the entire trace, zoom in  
to see more detail.</p><div class="figure"><a name="jumpshot.overview.figure"></a><p class="title"><b>Figure&nbsp;4.2.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/jumpshot-overview.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="StartersGuide"></a>Chapter&nbsp;5.&nbsp;Quick Reference</h2></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal"><a href="#">tau_run</a></code></span></dt><dd>TAU's binary instrumentation tool</dd><dt><span class="term"><code class="literal">tau_cc.sh -tau_options=-optCompInst / tau_cxx.sh -tau_options=-optCompInst / tau_f90.sh -tau_options=-optCompInst</code></span></dt><dd><a href="#">Compiler wrappers</a> (Compiler instrumentation)</dd><dt><span class="term"><code class="literal">tau_cc.sh / tau_cxx.sh / tau_f90.sh</code></span></dt><dd><a href="#">Compiler wrappers</a> (PDT instrumentation)</dd><dt><span class="term"><code class="literal">TAU_MAKEFILE</code></span></dt><dd>Set instrumentation definition file</dd><dt><span class="term"><code class="literal">TAU_OPTIONS</code></span></dt><dd>Set instrumentation options</dd><dt><span class="term"><code class="literal">dynamic phase name=<span class="emphasis"><em>'name'</em></span>
		  file=<span class="emphasis"><em>'filename'</em></span>
			line=<span class="emphasis"><em>start_line_#</em></span> to
			line=<span class="emphasis"><em>end_line_#</em></span>	
			</code></span></dt><dd>Specify dynamic Phase</dd><dt><span class="term"><code class="literal">loops file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Instrument outer loops</dd><dt><span class="term"><code class="literal">memory file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Track memory</dd><dt><span class="term"><code class="literal">io file=<span class="emphasis"><em>'filename'</em></span>
			routine=<span class="emphasis"><em>'routine name'</em></span>	
			</code></span></dt><dd>Track IO</dd><dt><span class="term"><code class="literal">TAU_PROFILE / TAU_TRACE</code></span></dt><dd>Enable profiling and/or tracing</dd><dt><span class="term"><code class="literal">PROFILEDIR / TRACEDIR</code></span></dt><dd>Set profile/trace output directory</dd><dt><span class="term"><code class="literal">TAU_CALLPATH=1 / TAU_CALLPATH_DEPTH</code></span></dt><dd>Enable Callpath profiling, set callpath depth</dd><dt><span class="term"><code class="literal">TAU_THROTTLE=1 / TAU_THROTTLE_NUMCALLS / TAU_THROTTLE_PERCALL</code></span></dt><dd>Enable event throttling, set number of call, percall (us)
			threshold</dd><dt><span class="term"><code class="literal">TAU_METRICS</code></span></dt><dd>List of PAPI metrics to profile</dd><dt><span class="term"><code class="literal"><a href="#">tau_treemerge.pl</a></code></span></dt><dd>Merge traces to one file</dd><dt><span class="term"><code class="literal"><a href="#">tau2otf</a> / <a href="#">tau2vtf</a> / <a href="#">tau2slog2</a></code></span></dt><dd>Trace conversion tools</dd></dl></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ApplicationScenario"></a>Chapter&nbsp;6.&nbsp;Some Common Application Scenario</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e614">6.1. Q. What routines account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e633">6.2. Q. What loops account for the most time? How much?</a></span></dt><dt><span class="sect1"><a href="#d0e655">6.3. Q. What MFlops am I getting in all loops?</a></span></dt><dt><span class="sect1"><a href="#d0e677">6.4. Q. Who calls MPI_Barrier() Where?</a></span></dt><dt><span class="sect1"><a href="#d0e699">6.5. Q. How do I instrument Python Code?</a></span></dt><dt><span class="sect1"><a href="#d0e721">6.6. Q. What happens in my code at a given time?
</a></span></dt><dt><span class="sect1"><a href="#d0e740">6.7. Q. How does my application scale?
</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e614"></a>6.1.&nbsp;Q. What routines account for the most time? How much?</h2></div></div></div><p>A. Create a flat profile with wallclock time.</p><div class="figure"><a name="d0e619"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;Flat Profile</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/flat_profile.png" align="middle" alt="Flat Profile"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e625"></a>Here is how to generate a flat profile with MPI</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-<span class="emphasis"><em>pdt</em></span>-pgi
 
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 

% paraprof app.ppk
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e633"></a>6.2.&nbsp;Q. What loops account for the most time? How much?</h2></div></div></div><p>A. Create a flat profile with wallclock time with loop instrumentation.</p><div class="figure"><a name="d0e638"></a><p class="title"><b>Figure&nbsp;6.2.&nbsp;Flat Profile with Loops</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/loop_profile.png" align="middle" alt="Flat Profile with Loops"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e644"></a>Here is how to instrument loops in an application</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
<span class="emphasis"><em>% setenv TAU_OPTIONS &#8216;-optTauSelectFile=select.tau &#8211;optVerbose&#8217;</em></span>
% cat select.tau
  BEGIN_INSTRUMENT_SECTION
  <span class="emphasis"><em>loops routine=&#8220;#&#8221;</em></span>
  END_INSTRUMENT_SECTION

% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 

% paraprof app.ppk
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e655"></a>6.3.&nbsp;Q. What MFlops am I getting in all loops?</h2></div></div></div><p>A. Create a flat profile with PAPI_FP_INS/OPS and time with loop instrumentation.</p><div class="figure"><a name="d0e660"></a><p class="title"><b>Figure&nbsp;6.3.&nbsp;MFlops per loop</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/mflops_profile.png" align="middle" alt="MFlops per loop"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e666"></a>Here is how to generate a flat profile with FP operations</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-<span class="emphasis"><em>papi</em></span>-mpi-pdt-pgi
% setenv TAU_OPTIONS &#8216;-optTauSelectFile=select.tau &#8211;optVerbose&#8217;
% cat select.tau
  BEGIN_INSTRUMENT_SECTION
  loops routine=&#8220;#&#8221;
  END_INSTRUMENT_SECTION

% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_METRICS GET_TIME_OF_DAY\:PAPI_FP_INS</em></span>
% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 
% paraprof app.ppk
  Choose 'Options' -&gt; 'Show Derived Panel' -&gt; Arg 1 = PAPI_FP_INS, Arg 2 =
	GET_TIME_OF_DAY, Operation = Divide -&gt; Apply, close.
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e677"></a>6.4.&nbsp;Q. Who calls MPI_Barrier() Where?</h2></div></div></div><p>A. Create a callpath profile with given depth.</p><div class="figure"><a name="d0e682"></a><p class="title"><b>Figure&nbsp;6.4.&nbsp;Callpath Profile</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/callpath_profile.png" align="middle" alt="Callpath Profile"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e688"></a>Here is how to generate a callpath profile with MPI</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE
% /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_CALLPATH 1</em></span>
<span class="emphasis"><em>% setenv TAU_CALLPATH_DEPTH 100</em></span>

% qsub  run.job
% paraprof -&#8211;pack app.ppk
	Move the app.ppk file to your desktop. 
% paraprof app.ppk
(Windows -&gt; Thread -&gt; Call Graph)
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e699"></a>6.5.&nbsp;Q. How do I instrument Python Code?</h2></div></div></div><p>A. Create an python wrapper library.</p><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e704"></a>Here to instrument python code</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-icpc-python-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% setenv TAU_OPTIONS &#8216;<span class="emphasis"><em>-optShared</em></span> -optVerbose'
(Python needs shared object based TAU library)
% make F90=tau_f90.sh CXX=tau_cxx.sh CC=tau_cc.sh  (build pyMPI w/TAU)
% cat <span class="emphasis"><em>wrapper.py</em></span>
  import tau
  def OurMain():
      import App
  tau.run(&#8216;OurMain()&#8217;)
Uninstrumented:
% mpirun.lsf /pyMPI-2.4b4/bin/pyMPI ./App.py
Instrumented:
<span class="emphasis"><em>% setenv PYTHONPATH&lt;taudir&gt;/x86_64/&lt;lib&gt;/bindings-python-mpi-pdt-pgi</em></span>
(same options string as TAU_MAKEFILE)
<span class="emphasis"><em>setenv LD_LIBRARY_PATH &lt;taudir&gt;/x86_64/lib/bindings-icpc-python-mpi-pdt-pgi\:$LD_LIBRARY_PATH
% mpirun &#8211;np 4 &lt;dir&gt;/pyMPI-2.4b4-TAU/bin/pyMPI ./wrapper.py</em></span>
(Instrumented pyMPI with wrapper.py)
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e721"></a>6.6.&nbsp;Q. What happens in my code at a given time?
</h2></div></div></div><p>A. Create an event trace.</p><div class="figure"><a name="d0e726"></a><p class="title"><b>Figure&nbsp;6.5.&nbsp;Tracing with Vampir</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/vampir_trace.png" align="middle" alt="Tracing with Vampir"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e732"></a>How to create a trace</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE
% /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt-pgi
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
<span class="emphasis"><em>% setenv TAU_TRACE 1</em></span>
% qsub  run.job
% tau_treemerge.pl
(merges binary traces to create tau.trc and tau.edf files)
JUMPSHOT:
% tau2slog2 tau.trc tau.edf &#8211;o app.slog2 
% jumpshot app.slog2
   OR
VAMPIR:
% tau2otf tau.trc tau.edf app.otf &#8211;n 4 &#8211;z
(4 streams, compressed output trace)
% vampir app.otf
(or vng client with vngd server).
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e740"></a>6.7.&nbsp;Q. How does my application scale?
</h2></div></div></div><p>A. Examine profiles in PerfExplorer.</p><div class="figure"><a name="d0e745"></a><p class="title"><b>Figure&nbsp;6.6.&nbsp;Scalability chart</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="270"><tr><td align="center"><img src="images/scalability.png" align="middle" alt="Scalability chart"></td></tr></table></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e751"></a>How to examine a series of profiles in PerfExplorer</h3></div></div></div><pre class="screen">
% setenv TAU_MAKEFILE /opt/apps/tau/tau-2.17.1/x86_64/lib/Makefile.tau-mpi-pdt
% set path=(/opt/apps/tau/tau-2.17.1/x86_64/bin $path)
% make F90=tau_f90.sh
(Or edit Makefile and change F90=tau_f90.sh)
% qsub  run1p.job
% paraprof -&#8211;pack 1p.ppk
% qsub run2p.job 
% paraprof -&#8211;pack 2p.ppk ...and so on.
On your client:
% <span class="emphasis"><em>perfdmf_configure</em></span>
(Choose derby, blank user/password, yes to save password, defaults)
% perfexplorer_configure
(Yes to load schema, defaults)
% paraprof 
(load each trial: Right click on trial -&gt;<span class="emphasis"><em>Upload trial to DB</em></span>
<span class="emphasis"><em>% perfexplorer </em></span>
(Charts -&gt; Speedup)
</pre></div></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="ParaProfDoc"></a>Part&nbsp;II.&nbsp;ParaProf - User's Manual</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#paraprof.intro">7. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.views">8. Views and Sub-Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.trialmanagement">9. Profile Data Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.3d">10. 3-D Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.threaddisplays">11. Thread Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.functiondisplays">12. Function Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.phasedisplays">13. Phase Based Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.comparison">14. Comparative Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.otherdisplays">15. Miscellaneous Displays</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paraprof.preferences">16. Preferences</a></span></dt><dd><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.intro"></a>Chapter&nbsp;7.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.usage">7.1. Using ParaProf from the command line</a></span></dt><dt><span class="sect1"><a href="#paraprof.formats">7.2. Supported Formats</a></span></dt><dt><span class="sect1"><a href="#paraprof.options">7.3. Command line options</a></span></dt></dl></div><p>ParaProf is a portable, scalable performance analysis tool
  included with the TAU distribution.
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top"><p>ParaProf requires <span class="emphasis"><em>Oracle / Sun's</em></span> Java 1.5
	Runtime Environment for basic functionality.  Java JOGL (included) is
    required for 3d visualization and image export.  Additionally, OpenGL is
    required for 3d visualization.</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Most windows in ParaProf can export bitmap (png/jpg) and vector
  (svg/eps) images to disk (png/jpg) or print directly to a printer.  This are
  available through the <span class="emphasis"><em>File</em></span> menu.</p></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usage"></a>7.1.&nbsp;Using ParaProf from the command line</h2></div></div></div><p>ParaProf is a java program that is run from the supplied
      <span><strong class="command">paraprof</strong></span> script (<span><strong class="command">paraprof.bat</strong></span> for
      windows binary release).
    </p><pre class="screen">% paraprof --help
Usage: paraprof [options] &lt;files/directory&gt;

Options:

  -f, --filetype &lt;filetype&gt;       Specify type of performance data, options are:
                                    profiles (default), pprof, dynaprof, mpip,
                                    gprof, psrun, hpm, packed, cube, hpc, ompp
                                    snap, perixml, gptl, ipm, google
  --range a-b:c                   Load only profiles from the given range(s) of processes
                                    Seperate individual ids or dash-defined ranges with colons
  -h, --help                      Display this help message

The following options will run only from the console (no GUI will launch):

  --merge &lt;file.gz&gt;               Merges snapshot profiles
  --pack &lt;file&gt;                   Pack the data into packed (.ppk) format
  --dump                          Dump profile data to TAU profile format
  --dumprank &lt;rank&gt;               Dump profile data for &lt;rank&gt; to TAU profile format
  -v, --dumpsummary               Dump derived statistical data to TAU profile format
  --overwrite                     Allow overwriting of profiles
  -o, --oss                       Print profile data in OSS style text output
  -q, --dumpmpisummary            Print high level time and communication summary
  -d, --metadump                  Print profile metadata (works with --dumpmpisummary)
  -x, --suppressmetrics           Exclude child calls and exclusive time from --dumpmpisummary
  -s, --summary                   Print only summary statistics
                                    (only applies to OSS output)

Notes:
  For the TAU profiles type, you can specify either a specific set of profile
files on the commandline, or you can specify a directory (by default the current
directory).  The specified directory will be searched for profile.*.*.* files,
or, in the case of multiple counters, directories named MULTI_* containing
profile data.

</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.formats"></a>7.2.&nbsp;Supported Formats</h2></div></div></div><p>ParaProf can load profile date from many sources.  The types
      currently supported are:
    </p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>TAU Profiles (profiles)</strong></span>
	  - Output from the TAU measurement library, these files generally take the
		form of <code class="filename">profile.X.X.X</code>, one for each
		node/context/thread combination.  When multiple counters are used, each
		metric is located in a directory prefixed with "MULTI__".  To launch
		ParaProf with all the metrics, simply launch it from the root of the
		MULTI__ directories.</p></li><li><p><span class="bold"><strong>ParaProf Packed Format
	  (ppk)</strong></span> - Export format supported by PerfDMF/ParaProf.
	  Typically .ppk.  </p></li><li><p><span class="bold"><strong>TAU Merged Profiles
	  (snap)</strong></span> - Merged and snapshot profile format supported by
	  TAU.  Typically tauprofile.xml.</p></li><li><p><span class="bold"><strong>TAU pprof (pprof)</strong></span> - Dump
	  Output from TAU's <span><strong class="command">pprof -d</strong></span>.  Provided for backward
	  compatibility only.</p></li><li><p><span class="bold"><strong>DynaProf (dynaprof)</strong></span> -
	  Output From DynaProf's wallclock and papi probes.  </p></li><li><p><span class="bold"><strong>mpiP (mpip)</strong></span> - Output
	  from mpiP.  </p></li><li><p><span class="bold"><strong>gprof (gprof)</strong></span> - Output
	  from gprof, see also the --fixnames option.  </p></li><li><p><span class="bold"><strong>PerfSuite (psrun)</strong></span> -
	  Output from PerfSuite psrun files.</p></li><li><p><span class="bold"><strong>HPM Toolkit (hpm)</strong></span> -
	  Output from IBM's HPM Toolkit.  </p></li><li><p><span class="bold"><strong>Cube (cube)</strong></span> - Output
	  from Kojak Expert tool for use with Cube.  </p></li><li><p><span class="bold"><strong>Cube3 (cube3)</strong></span> - Output
	  from Kojak Expert tool for use with Cube3 and Cube4.  </p></li><li><p><span class="bold"><strong>HPCToolkit (hpc)</strong></span> - XML
	  data from hpcquick.  Typically, the user runs hpcrun, then hpcquick on
	  the resulting binary file.  </p></li><li><p><span class="bold"><strong>OpenMP Profiler (ompp)</strong></span> -
	  CSV format from the ompP OpenMP Profiler (http://www.ompp-tool.com).  The
	  user must use OMPP_OUTFORMAT=CVS.</p></li><li><p><span class="bold"><strong>PERI XML (perixml)</strong></span> -
	  Output from the PERI data exchange format.</p></li><li><p><span class="bold"><strong>General Purpose Timing Library
	  (gptl)</strong></span> - Output from the General Purpose Timing
	  Library.</p></li><li><p><span class="bold"><strong>Paraver (paraver)</strong></span> -
	  2D output from the Paraver trace analysis tool from
	  BSC.</p></li><li><p><span class="bold"><strong>IPM (ipm)</strong></span> -
	  Integrated Performance Monitoring format, from NERSC.</p></li><li><p><span class="bold"><strong>Google (google)</strong></span> -
	  Google Profiles.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.options"></a>7.3.&nbsp;Command line options</h2></div></div></div><p>In addition to specifying the profile format, the user can also
      specify the following options</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>--fixnames</strong></span> - Use the fixnames option
	  for gprof.  When C and Fortran code are mixed, the C routines have to be mapped
	  to either .function or function_.  Strip the leading period or trailing underscore, if it is there.  
	</p></li><li><p><span class="bold"><strong>--pack &lt;file&gt;</strong></span> - Rather
	  than load the data and launch the GUI, pack the data into the specified file.
	</p></li><li><p><span class="bold"><strong>--dump</strong></span> - Rather than
	  load the data and launch the GUI, dump the data to TAU Profiles.
	  This can be used to convert supported formats to TAU Profiles.
	</p></li><li><p><span class="bold"><strong>--oss</strong></span> - Outputs profile
	  data in OSS Style.  Example:

	  </p><pre class="screen">
-------------------------------------------------------------------------------
Thread: n,c,t 0,0,0
-------------------------------------------------------------------------------
 excl.secs  excl.%   cum.%    PAPI_TOT_CYC     PAPI_FP_OPS     calls  function
     0.005   56.0%   56.0%        13475345         4194518         1  foo
     0.003   40.1%   96.1%         9682185         4205367         1  bar
         0    3.6%   99.7%          223173           17445         1  baz
   2.2E-05    0.3%  100.0%           14663             206         1  main
</pre><p>

	</p></li><li><p><span class="bold"><strong>--summary</strong></span> - Output only summary
	  information for OSS style output.
	</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.views"></a>Chapter&nbsp;8.&nbsp;Views and Sub-Views</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.createviews">8.1. To Create a (Sub-)Views</a></span></dt></dl></div><p>
 In the past, PerfDMF used a hierarchy of Applications and Experiments to organize Trials.  This approach was too rigid, so in TAUdb, trials are organized by dynamic Views.  Views are lists of Trials that share a given metadata value.  For example, a View could contain all the Trials where the total number of threads is less than 16.    Views can also have Sub-Views.  For example, it might be useful to have a View of all Trials from a certain machine and then Sub-Views for each executable ran on that machine.  Trials can belong to any number of VIews and Sub-Views and new Trials loaded to the database will be sorted into Views automatically.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.createviews"></a>8.1.&nbsp;To Create a (Sub-)Views</h2></div></div></div><p>
Launch ParaProf and Right click on a database or an existing View and select "Add View" or "Add Sub-View."  
</p><div class="figure"><a name="d0e947"></a><p class="title"><b>Figure&nbsp;8.1.&nbsp;Add View</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/AddView.png" align="middle" alt="Add View"></td></tr></table><div class="caption"><p>
 In ParaProf and PerfExplorer, Views are marked by the Folder Icon and Trials are now marked with a yellow ball.  (The "All Trials" View is created when a database is created.)  
</p></div></div></div><p>
This will launch the View Creator window.  
</p><div class="figure"><a name="d0e958"></a><p class="title"><b>Figure&nbsp;8.2.&nbsp;View Creator Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/ViewCreator.png" align="middle" alt="View Creator Window"></td></tr></table></div></div><p>
Here you can create the rule(s) for which Trials appear in this new View.  At the top you can choose to match all of the rules ("and") or to match any of the rules.  The "-" or "=" buttons will remove the current rule or add a new one.  The first drop down box  chooses which metadata field to use.  The second box chooses whether the field should be read as a string or a number.  Depending on whether it is read as a string or a number, the fourth box will give options on how to compare the metadata field.  So to create a View for all trials that have less than 16 threads, select total_threads, read as a string, is less than, 16.  Then click Save and give the View a name.  
</p><p>
The 'Edit' context menu option on an existing view will allow you to view and alter the view's criteria in the same interface. 
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.trialmanagement"></a>Chapter&nbsp;9.&nbsp;Profile Data Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.mainwindow">9.1. ParaProf Manager Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.loading">9.2. Loading Profiles</a></span></dt><dt><span class="sect1"><a href="#paraprof.database">9.3. Database Interaction</a></span></dt><dt><span class="sect1"><a href="#paraprof.derivedmetrics">9.4. Creating Derived Metrics</a></span></dt><dt><span class="sect1"><a href="#paraprof.maindatawindow">9.5. Main Data Window</a></span></dt></dl></div><p>ParaProf uses <em class="firstterm">PerfDMF</em> to manage profile
  data.  This enables it to read the various profile formats as well as
  store and retrieve them from a database.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.mainwindow"></a>9.1.&nbsp;ParaProf Manager Window</h2></div></div></div><p>Upon launching ParaProf, the user is greeted with the ParaProf Manager Window.</p><div class="figure"><a name="paraprof.mainwindow.figure"></a><p class="title"><b>Figure&nbsp;9.1.&nbsp;ParaProf Manager Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/manager.gif" align="middle" alt="ParaProf Manager Window"></td></tr></table></div></div><p>This window is used to manage profile data.  The user can
      upload/download profile data, edit meta-data, launch visual displays,
      export data, derive new metrics, etc.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.loading"></a>9.2.&nbsp;Loading Profiles</h2></div></div></div><p>To load profile data, select File-&gt;Open, or right click on the
    Application's tree and select "Add Trial".
    </p><div class="figure"><a name="d0e995"></a><p class="title"><b>Figure&nbsp;9.2.&nbsp;Loading Profile Data</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="216"><tr><td align="center"><img src="images/loadtrial.gif" align="middle" alt="Loading Profile Data"></td></tr></table></div></div><p>Select the type of data from the "Trial Type" drop-down box.  For TAU
    Profiles, select a directory, for other types, files.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.database"></a>9.3.&nbsp;Database Interaction</h2></div></div></div><p>
      Database interaction is done through the tree view of the ParaProf
      Manager Window.  Applications expand to Experiments, Experiments to
      Trials, and Trials are loaded directly into ParaProf just as if they were
      read off disk.  Additionally, the meta-data associated with each element
      is show on the right, as in <a href="#paraprof.mainwindow.figure" title="Figure&nbsp;9.1.&nbsp;ParaProf Manager Window">Figure&nbsp;9.1, &#8220;ParaProf Manager Window&#8221;</a>.  A trial can be exported by right clicking on it and selecting
      "Export as Packed Profile".
    </p><p>
      New trials can be uploaded to the database by either right-clicking on an
      entity in the database and selecting "Add Trial", or by right-clicking
      on an Application/Experiment/Trial hierarchy from the "Standard
      Applications" and selecting "Upload Application/Experiment/Trial to DB".
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.derivedmetrics"></a>9.4.&nbsp;Creating Derived Metrics</h2></div></div></div><p>ParaProf can created derived metrics using the <span class="emphasis"><em>Derived
	Metric Panel</em></span>, available from the <span class="emphasis"><em>Options</em></span>
      menu of the ParaProf Manager Window.
    </p><div class="figure"><a name="paraprof.derivedmetrics.figure"></a><p class="title"><b>Figure&nbsp;9.3.&nbsp;Creating Derived Metrics</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/derivedmetric.gif" align="middle" alt="Creating Derived Metrics"></td></tr></table></div></div><p>In <a href="#paraprof.derivedmetrics.figure" title="Figure&nbsp;9.3.&nbsp;Creating Derived Metrics">Figure&nbsp;9.3, &#8220;Creating Derived Metrics&#8221;</a>, we have just
      divided Floating Point Instructions by Wall-clock time, creating FLOPS
      (Floating Point Operations per Second).  The 2nd argument is a user
      editable text-box and can be filled in with scalar values by using the
      keyword 'val' (e.g. "val 1.5").
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.maindatawindow"></a>9.5.&nbsp;Main Data Window</h2></div></div></div><p>Upon loading a profile, or double-clicking on a metric, the
        <em class="firstterm">Main Data Window</em> will be displayed.</p><div class="figure"><a name="paraprof.maindatawindow.figure"></a><p class="title"><b>Figure&nbsp;9.4.&nbsp;Main Data Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="340"><tr><td align="center"><img src="images/maindatawindow.gif" align="middle" alt="Main Data Window"></td></tr></table></div></div><p>This window shows each thread as well as statistics as a combined bar
      graph.  Each function is represented by a different color (though
      possibly cycled).  From anywhere in ParaProf, you can right-click on
      objects representing threads or functions to launch displays associated
      with those objects.  For example, in <a href="#paraprof.maindatawindow.figure" title="Figure&nbsp;9.4.&nbsp;Main Data Window">Figure&nbsp;9.4, &#8220;Main Data Window&#8221;</a>, right click on the text
      <span class="emphasis"><em>n,c,t, 8,0,0</em></span> to launch thread based displays for
      node 8.
    </p><div class="figure"><a name="d0e1054"></a><p class="title"><b>Figure&nbsp;9.5.&nbsp;Unstacked Bars</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/unstacked.gif" align="middle" alt="Unstacked Bars"></td></tr></table></div></div><p>
      You may also turn off the stacking of bars so that individual functions
      can be compared across threads in a global display.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.3d"></a>Chapter&nbsp;10.&nbsp;3-D Visualization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.trianglemesh">10.1. Triangle Mesh Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.3dbarplot">10.2. 3-D Bar Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.scatterplot">10.3. 3-D Scatter Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.top)ology">10.4. 3-D Topology Plot</a></span></dt><dt><span class="sect1"><a href="#paraprof.commicationmatrix">10.5. 3-D Commication Matrix</a></span></dt></dl></div><p>ParaProf displays massive parallel profiles through the use of OpenGL
    hardware acceleration through the <em class="firstterm">3D Visualization</em>
    window.  Each window is fully configurable with rotation, translation, and
    zooming capabilities.  Rotation is accomplished by holding the left mouse
    button down and dragging the mouse.  Translation is done likewise with the
    right mouse button.  Zooming is done with the mousewheel and the + and -
    keyboard buttons.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.trianglemesh"></a>10.1.&nbsp;Triangle Mesh Plot</h2></div></div></div><div class="figure"><a name="d0e1074"></a><p class="title"><b>Figure&nbsp;10.1.&nbsp;Triangle Mesh Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/trianglemeshplot.gif" align="middle" alt="Triangle Mesh Plot"></td></tr></table></div></div><p>This visualization method shows two metrics for all functions, all
      threads.  The height represents one chosen metric, and the color,
      another.  These are selected from the drop-down boxes on the right.
    </p><p>To pinpoint a specific value in the plot, move the
      <span class="emphasis"><em>Function</em></span> and <span class="emphasis"><em>Thread</em></span> sliders to
      cycle through the available functions/threads.  The values for the two
      metrics, in this case for <code class="function">MPI_Recv()</code> on
      <code class="literal">Node 351</code>, the value is <code class="literal">14.37</code>
      seconds.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.3dbarplot"></a>10.2.&nbsp;3-D Bar Plot</h2></div></div></div><div class="figure"><a name="paraprof.3dbarplot.figure"></a><p class="title"><b>Figure&nbsp;10.2.&nbsp;3-D Mesh Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3dvew1.png" align="middle" alt="3-D Mesh Plot"></td></tr></table></div></div><p>This visualization method is similar to the triangle mesh plot.  It
      simply displays the data using 3d bars instead of a mesh.  The controls
      works the same.  Note that in <a href="#paraprof.3dbarplot.figure" title="Figure&nbsp;10.2.&nbsp;3-D Mesh Plot">Figure&nbsp;10.2, &#8220;3-D Mesh Plot&#8221;</a>
      the transparency option is selected, which changes the way in which the
      selection model operates. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.scatterplot"></a>10.3.&nbsp;3-D Scatter Plot</h2></div></div></div><div class="figure"><a name="d0e1115"></a><p class="title"><b>Figure&nbsp;10.3.&nbsp;3-D Scatter Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/scatterplot2.gif" align="middle" alt="3-D Scatter Plot"></td></tr></table></div></div><p>This visualization method plots the value of each thread along up to
      4 axes (each a different function/metric).  This view allows you to
      discern clustering of values and relationships between functions across
      threads.</p><p>Select functions using the button for each dimension, then select a
    metric.  A single function across 4 metrics could be used, for
    example.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.top)ology"></a>10.4.&nbsp;3-D Topology Plot</h2></div></div></div><div class="figure"><a name="d0e1128"></a><p class="title"><b>Figure&nbsp;10.4.&nbsp;3-D Topology Plot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/topology2.gif" align="middle" alt="3-D Topology Plot"></td></tr></table></div></div><p> In this visualization, you can either define the layout with a MESP topology definition 
         file or you can fill a rectangular prism of user-defined volume with rank-points in order of rank.
         For more information, please see the etc/topology directory for additional details on MESP 
         topology definitions.
       </p><p> If the loaded profile is a cube file or a profile from a BGB, then this visualizations 
        groups the threads in two or three dimensional space using topology
        information supplied by the profile.</p><p>
When topology metadata is available a trial-specific topological layout may be visualized by selecting Windows-&gt;gt;3D Visualization and selecting Topology Plot on the visualization pane.
</p><p>
The layout tab allows control of the layout and display of visualized cores/processes.

</p><p>
Minimum/Maximum Visible (restricts display of nodes with measured values above/below the selected levels).  Lock Range causes the sliders to move in unison.

</p><p>
The X/Y/Z Axis sliders allow selection of planes, lines and individual points in the topology for examination of specific values in the display, listed in the Avg. Color Value field.

</p><p>
The topology selection dropdown box allows selection of either trial-specific topologies contained in the metadata, mapped topologies stored in an external file or a custom topology defined by the size of the prism containing the visualized cores.  The ... button allows selection of a custom topology mapping file while the map button allows selection of a map file (see &lt;tau2&gt;/etc/topology/README.cray_map for more information on generating map files).

</p><p>
If a Custom is selected the dimensions of the rectangular prism containing the cores are defined by the X/Y/Z axis control widgets.

</p><p>
The Events tab controls which events are used to define the color values and positions of cores/processes in the display.  For trail-specific and Custom topologies only event3(Color) can be changed.  For topologies loaded in MESP definition files all four events may be used in calculation of the topology layout.  In either case, interval, atomic or metadata values may be used to color or position points in the display.
    
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.commicationmatrix"></a>10.5.&nbsp;3-D Commication Matrix</h2></div></div></div><div class="figure"><a name="d0e1155"></a><p class="title"><b>Figure&nbsp;10.5.&nbsp;3-D Commication Matrix</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3DCommMatrix.png" align="middle" alt="3-D Commication Matrix"></td></tr></table></div></div><p> 
   If a Trial has commication information (set  TAU_COMM_MATRIX=1 at runtime of your application), then you can launch the 3D Commication window as shown.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.threaddisplays"></a>Chapter&nbsp;11.&nbsp;Thread Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.threaddatawindow">11.1. Thread Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.threadstatwindow">11.2. Thread Statistics Text Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.treetablewindow">11.3. Thread Statistics Table</a></span></dt><dt><span class="sect1"><a href="#paraprof.callgraphwindow">11.4. Call Graph Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.callpaththreadrelations">11.5. Thread Call Path Relations Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventstats">11.6. User Event Statistics Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.usereventthreadbar">11.7. User Event Thread Bar Chart</a></span></dt></dl></div><p>ParaProf displays several windows that show data for one thread of
      execution.  In addition to per thread values, the users may also select
      <span class="emphasis"><em>mean</em></span> or <span class="emphasis"><em>standard deviation</em></span> as
      the "thread" to display.  In this mode, the mean or standard deviation of
      the values across the threads will be used as the value.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.threaddatawindow"></a>11.1.&nbsp;Thread Bar Graph</h2></div></div></div><div class="figure"><a name="d0e1178"></a><p class="title"><b>Figure&nbsp;11.1.&nbsp;Thread Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="304"><tr><td align="center"><img src="images/threaddatawindow.gif" align="middle" alt="Thread Bar Graph"></td></tr></table></div></div><p>This display graphs each function on a particular thread for
      comparison.  The metric, units, and sort order can be changed from the
      <span class="emphasis"><em>Options</em></span> menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.threadstatwindow"></a>11.2.&nbsp;Thread Statistics Text Window</h2></div></div></div><div class="figure"><a name="d0e1192"></a><p class="title"><b>Figure&nbsp;11.2.&nbsp;Thread Statistics Text Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="477"><tr><td align="center"><img src="images/threadstatwindow.gif" align="middle" alt="Thread Statistics Text Window"></td></tr></table></div></div><p>This display shows a <span><strong class="command">pprof</strong></span> style text view of the
      data.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.treetablewindow"></a>11.3.&nbsp;Thread Statistics Table</h2></div></div></div><div class="figure"><a name="paraprof.thread.treetable1"></a><p class="title"><b>Figure&nbsp;11.3.&nbsp;Thread Statistics Table, inclusive and exclusive</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable1.gif" align="middle" alt="Thread Statistics Table, inclusive and exclusive"></td></tr></table></div></div><p>
      This display shows the callpath data in a table.  Each callpath can be traced
      from root to leaf by opening each node in the tree view.  A colorscale
      immediately draws attention to "hot spots", areas that contain highest values.
    </p><div class="figure"><a name="paraprof.thread.treetable2"></a><p class="title"><b>Figure&nbsp;11.4.&nbsp;Thread Statistics Table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable2.gif" align="middle" alt="Thread Statistics Table"></td></tr></table></div></div><div class="figure"><a name="paraprof.thread.treetable3"></a><p class="title"><b>Figure&nbsp;11.5.&nbsp;Thread Statistics Table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="387"><tr><td align="center"><img src="images/treetable3.gif" align="middle" alt="Thread Statistics Table"></td></tr></table></div></div><p>
      The display can be used in one of two ways, in "inclusive/exclusive"
      mode, both the inclusive and exclusive values are shown for each path,
      see <a href="#paraprof.thread.treetable1" title="Figure&nbsp;11.3.&nbsp;Thread Statistics Table, inclusive and exclusive">Figure&nbsp;11.3, &#8220;Thread Statistics Table, inclusive and exclusive&#8221;</a> for an example.
    </p><p>
      When this option is off, the inclusive value for a node is show when it
      is closed, and the exclusive value is shown when it is open.  This allows
      the user to more easily see where the time is spent since the total time
      for the application will always be represented in one column.  See <a href="#paraprof.thread.treetable2" title="Figure&nbsp;11.4.&nbsp;Thread Statistics Table">Figure&nbsp;11.4, &#8220;Thread Statistics Table&#8221;</a> and <a href="#paraprof.thread.treetable3" title="Figure&nbsp;11.5.&nbsp;Thread Statistics Table">Figure&nbsp;11.5, &#8220;Thread Statistics Table&#8221;</a> for examples.
      
      This display also functions as a regular statistics table without
      callpath data.  The data can be sorted by columns by clicking on the
      column heading.  When multiple metrics are available, you can add and
      remove columns for the display using the menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.callgraphwindow"></a>11.4.&nbsp;Call Graph Window</h2></div></div></div><div class="figure"><a name="d0e1239"></a><p class="title"><b>Figure&nbsp;11.6.&nbsp;Call Graph Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="274"><tr><td align="center"><img src="images/callgraph.gif" align="middle" alt="Call Graph Window"></td></tr></table></div></div><p>This display shows callpath data in a graph using two metrics, one
      determines the width, the other the color.  The full name of the function
      as well as the two values (color and width) are displayed in a tooltip
      when hovering over a box.  By clicking on a box, the actual ancestors and
      descendants for that function and their paths (arrows) will be
      highlighted with blue.  This allows you to see which functions are called
      by which other functions since the interplay of multiple paths may
      obscure it.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.callpaththreadrelations"></a>11.5.&nbsp;Thread Call Path Relations Window</h2></div></div></div><div class="figure"><a name="paraprof.thread.callpathrelations"></a><p class="title"><b>Figure&nbsp;11.7.&nbsp;Thread Call Path Relations Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="432"><tr><td align="center"><img src="images/callpaththreadrelations.gif" align="middle" alt="Thread Call Path Relations Window"></td></tr></table></div></div><p>This display shows callpath data in a <span><strong class="command">gprof</strong></span> style
      view.  Each function is shown with its immediate parents.  For example,
      <a href="#paraprof.thread.callpathrelations" title="Figure&nbsp;11.7.&nbsp;Thread Call Path Relations Window">Figure&nbsp;11.7, &#8220;Thread Call Path Relations Window&#8221;</a> shows that
      <code class="function">MPI_Recv()</code> is call from two places for a total of
      <code class="literal">9.052</code> seconds.  Most of that time comes from the 30
      calls when <code class="function">MPI_Recv()</code> is called by
      <code class="function">MPIScheduler::postMPIRecvs()</code>.  The other 60 calls do
      not amount to much time.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usereventstats"></a>11.6.&nbsp;User Event Statistics Window</h2></div></div></div><div class="figure"><a name="d0e1279"></a><p class="title"><b>Figure&nbsp;11.8.&nbsp;User Event Statistics Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="504"><tr><td align="center"><img src="images/usereventstats.gif" align="middle" alt="User Event Statistics Window"></td></tr></table></div></div><p>This display shows a <span><strong class="command">pprof</strong></span> style text view of the
      user event data.  Right clicking on a User Event will give you the option
      to open a Bar Graph for that particular User Event across all threads.  See
      <a href="#paraprof.userevent.bargraph" title="15.1.&nbsp;User Event Bar Graph">Section&nbsp;15.1, &#8220;User Event Bar Graph&#8221;</a></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.usereventthreadbar"></a>11.7.&nbsp;User Event Thread Bar Chart</h2></div></div></div><div class="figure"><a name="d0e1294"></a><p class="title"><b>Figure&nbsp;11.9.&nbsp;User Event Thread Bar Chart Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="504"><tr><td align="center"><img src="images/usereventthreadbargraph.gif" align="middle" alt="User Event Thread Bar Chart Window"></td></tr></table></div></div><p>This display shows a particular thread's user defined event
    statistics as a bar chart.  This is the same data from the <a href="#paraprof.usereventstats" title="11.6.&nbsp;User Event Statistics Window">Section&nbsp;11.6, &#8220;User Event Statistics Window&#8221;</a>, in graphical form.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.functiondisplays"></a>Chapter&nbsp;12.&nbsp;Function Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.function.bargraph">12.1. Function Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.function.histogram">12.2. Function Histogram</a></span></dt></dl></div><p>ParaProf has two displays for showing a single function across all
  threads of execution.  This chapter describes the Function Bar Graph
  Window and the Function Histogram Window.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.function.bargraph"></a>12.1.&nbsp;Function Bar Graph</h2></div></div></div><div class="figure"><a name="d0e1313"></a><p class="title"><b>Figure&nbsp;12.1.&nbsp;Function Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="277"><tr><td align="center"><img src="images/functionbargraph.gif" align="middle" alt="Function Bar Graph"></td></tr></table></div></div><p>This display graphs the values that the particular function had for
      each thread along with the mean and standard deviation across the
      threads.  You may also change the units and metric displayed from the
      <span class="emphasis"><em>Options</em></span> menu.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.function.histogram"></a>12.2.&nbsp;Function Histogram</h2></div></div></div><div class="figure"><a name="d0e1327"></a><p class="title"><b>Figure&nbsp;12.2.&nbsp;Function Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="342"><tr><td align="center"><img src="images/functionhistogram.gif" align="middle" alt="Function Histogram"></td></tr></table></div></div><p>This display shows a histogram of each thread's value for the given
      function.  Hover the mouse over a given bar to see the range minimum and
      maximum and how many threads fell into that range.  You may also change
      the units and metric displayed from the <span class="emphasis"><em>Options</em></span>
      menu.
    </p><p>
      You may also dynamically change how many bins are used (1-100) in the
      histogram.  This option is available from the
      <span class="emphasis"><em>Options</em></span> menu.  Changing the number of bins can
      dramatically change the shape of the histogram, play around with it to
      get a feel for the true distribution of the data.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.phasedisplays"></a>Chapter&nbsp;13.&nbsp;Phase Based Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.phase.mainwindow">13.1. Using Phase Based Displays</a></span></dt></dl></div><p>When a profile contains phase data, ParaProf will automatically run in
  phase mode.  Most displays will show data for a particular phase.  This phase
  will be displayed in teh top left corner in the meta data panel.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.phase.mainwindow"></a>13.1.&nbsp;Using Phase Based Displays</h2></div></div></div><p>The initial window will default to top level phase, usually <span class="emphasis"><em>main</em></span></p><div class="figure"><a name="d0e1356"></a><p class="title"><b>Figure&nbsp;13.1.&nbsp;Initial Phase Display</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="401"><tr><td align="center"><img src="images/phase_main.gif" align="middle" alt="Initial Phase Display"></td></tr></table></div></div><p>To access other phases, either right click on the phase and select,
    "Open Profile for this Phase", or go to the <span class="emphasis"><em>Phase
    Ledger</em></span> and select it there.
    </p><div class="figure"><a name="d0e1367"></a><p class="title"><b>Figure&nbsp;13.2.&nbsp;Phase Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="189"><tr><td align="center"><img src="images/phase_ledger.gif" align="middle" alt="Phase Ledger"></td></tr></table></div></div><p>ParaProf can also display a particular function's value across all of
    the phases.  To do so, right click on a function and select, "Show Function Data over Phases".
    </p><div class="figure"><a name="d0e1375"></a><p class="title"><b>Figure&nbsp;13.3.&nbsp;Function Data over Phases</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="325"><tr><td align="center"><img src="images/phase_function.gif" align="middle" alt="Function Data over Phases"></td></tr></table></div></div><p>Because Phase information is implemented as callpaths, many of the
    callpath displays will show phase data as well.  For example, the Call Path
    Text Window is useful for showing how functions behave across phases.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.comparison"></a>Chapter&nbsp;14.&nbsp;Comparative Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.comparison.using">14.1. Using Comparitive Analysis</a></span></dt></dl></div><p>ParaProf can perform cross-thread and cross-trial anaylsis.  In this
  way, you can compare two or more trials and/or threads in a single display.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.comparison.using"></a>14.1.&nbsp;Using Comparitive Analysis</h2></div></div></div><p>Comparative analysis in ParaProf is based on individual threads of
    execution.  There is a maximum of one Comparison window for a given
    ParaProf session.  To add threads to the window, right click on them and
    select "Add Thread to Comparison Window".  The Comparison Window will pop
    up with the thread selected.  Note that "mean" and "std. dev." are
    considered threads for this any most other purposes.
    </p><div class="figure"><a name="d0e1394"></a><p class="title"><b>Figure&nbsp;14.1.&nbsp;Comparison Window (initial)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison1.gif" align="middle" alt="Comparison Window (initial)"></td></tr></table></div></div><p>Add additional threads, from any trial, by the same means.
    </p><div class="figure"><a name="d0e1402"></a><p class="title"><b>Figure&nbsp;14.2.&nbsp;Comparison Window (2 trials)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison2.gif" align="middle" alt="Comparison Window (2 trials)"></td></tr></table></div></div><div class="figure"><a name="d0e1408"></a><p class="title"><b>Figure&nbsp;14.3.&nbsp;Comparison Window (3 threads)</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="352"><tr><td align="center"><img src="images/comparison3.gif" align="middle" alt="Comparison Window (3 threads)"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.otherdisplays"></a>Chapter&nbsp;15.&nbsp;Miscellaneous Displays</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.userevent.bargraph">15.1. User Event Bar Graph</a></span></dt><dt><span class="sect1"><a href="#paraprof.ledgers">15.2. Ledgers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#paraprof.ledgers.function">15.2.1. Function Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.group">15.2.2. Group Ledger</a></span></dt><dt><span class="sect2"><a href="#paraprof.ledgers.userevent">15.2.3. User Event Ledger</a></span></dt></dl></dd><dt><span class="sect1"><a href="#paraprof.createselectivefile">15.3. Selective Instrumentation File Generator</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.userevent.bargraph"></a>15.1.&nbsp;User Event Bar Graph</h2></div></div></div><p>In addition to displaying the text statistics for User Defined
      Events, ParaProf can also graph a particular User Event across all
      threads.</p><div class="figure"><a name="d0e1423"></a><p class="title"><b>Figure&nbsp;15.1.&nbsp;User Event Bar Graph</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="284"><tr><td align="center"><img src="images/usereventbargraph.gif" align="middle" alt="User Event Bar Graph"></td></tr></table></div></div><p>This display graphs the value that the particular user event had for each thread.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.ledgers"></a>15.2.&nbsp;Ledgers</h2></div></div></div><p>ParaProf has three ledgers that show the functions, groups, and user events.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.function"></a>15.2.1.&nbsp;Function Ledger</h3></div></div></div><div class="figure"><a name="d0e1439"></a><p class="title"><b>Figure&nbsp;15.2.&nbsp;Function Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="248"><tr><td align="center"><img src="images/functionledger.gif" align="middle" alt="Function Ledger"></td></tr></table></div></div><p>The function ledger shows each function along with its current
	color.  As with other displays showing functions, you may right-click on
	a function to launch other function-specific displays.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.group"></a>15.2.2.&nbsp;Group Ledger</h3></div></div></div><div class="figure"><a name="d0e1450"></a><p class="title"><b>Figure&nbsp;15.3.&nbsp;Group Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/groupledger.gif" align="middle" alt="Group Ledger"></td></tr></table></div></div><p>The group ledger shows each group along with its current color.
	This ledger is especially important because it gives you the ability to
	mask all of the other displays based on group membership.  For example,
	you can right-click on the <code class="literal">MPI</code> group and select
	"Show This Group Only" and all of the windows will now mask to only
	those functions which are members of the <code class="literal">MPI</code> group.
	You may also mask by the inverse by selecting "Show All Groups Except
	This One" to mask out a particular group.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="paraprof.ledgers.userevent"></a>15.2.3.&nbsp;User Event Ledger</h3></div></div></div><div class="figure"><a name="d0e1467"></a><p class="title"><b>Figure&nbsp;15.4.&nbsp;User Event Ledger</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="185"><tr><td align="center"><img src="images/usereventledger.gif" align="middle" alt="User Event Ledger"></td></tr></table></div></div><p>
	The user event ledger shows each user event along with its current color.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.createselectivefile"></a>15.3.&nbsp;Selective Instrumentation File Generator</h2></div></div></div><p>ParaProf can also help you refine your program performance by
		excluding some functions from instrumentation. You can select rules to
		determine which function get excluded; both rules must be true for a given
		function to be excluded. Below each function that will be excluded based
		on these rules are listed. 
		</p><div class="figure"><a name="d0e1480"></a><p class="title"><b>Figure&nbsp;15.5.&nbsp;Selective Instrumentation Dialog</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="284"><tr><td align="center"><img src="images/ParaProfSelectiveFile.gif" align="middle" alt="Selective Instrumentation Dialog"></td></tr></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Only the functions profilied in ParaProf can be excluded. If you
		had previously setup selective instrumentation for this application the
		functions that where previously excluded will not longer be excluded.</p></td></tr></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paraprof.preferences"></a>Chapter&nbsp;16.&nbsp;Preferences</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#paraprof.preferences.window">16.1. Preferences Window</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.defaultcolors">16.2. Default Colors</a></span></dt><dt><span class="sect1"><a href="#paraprof.preferences.colormap">16.3. Color Map</a></span></dt></dl></div><p>Preferences are modified from
  the ParaProf Preferences Window, launched from the File menu. Preferences
  are saved between sessions in the
  <code class="filename">.ParaProf/ParaProf.prefs</code> 
  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.window"></a>16.1.&nbsp;Preferences Window</h2></div></div></div><p>In addition to displaying the text statistics for User Defined
      Events, ParaProf can also graph a particular User Event across all
      threads. </p><div class="figure"><a name="d0e1503"></a><p class="title"><b>Figure&nbsp;16.1.&nbsp;ParaProf Preferences Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="298"><tr><td align="center"><img src="images/preferences.gif" align="middle" alt="ParaProf Preferences Window"></td></tr></table></div></div><p>The preferences window allows the user to modify the behavior and
      display style of ParaProf's windows.  The font size affects bar height, a
      sample display is shown in the upper-right.
    </p><p>The Window defaults section will determine the initial settings for
      new windows.  You may change the initial units selection and whether you
      want values displayed as percentages or as raw values.
    </p><p>The Settings section controls the following</p><div class="itemizedlist"><ul type="disc"><li><p>Show Path Title in Reverse - Path title will normally be
	  shown in normal order (/home/amorris/data/etc).  They can be reverse
	  using this option (etc/data/amorris/home).  This only affects loaded
	  trials and the titlebars of new windows.</p></li><li><p>Reverse Call Paths - This option will immediately change
	  the display of all callpath functions between <code class="literal">Root =&gt;
	    Leaf</code> and <code class="literal">Leaf &lt;= Root</code>.</p></li><li><p>Statistics Computation - Turning this option on causes
	  the mean computation to take the sum of value for a function across all
	  threads and divide it by the total number of threads.  With this option
	  off the sum will only be divided by the number of threads that actively
	  participated in the sum.  This way the user can control whether or not
	  threads which do not call a particular function are consider as a
	  <code class="literal">0</code> in the computation of statistics.</p></li><li><p>
	  Generate Reverse Calltree Data - This option will enable
	  the generation of reverse callpath data necessary for the reverse callpath option of the statistics tree-table window.
	</p></li><li><p>
	  Show Source Locations - This option will enable the display of source code locations in event names.
	</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.defaultcolors"></a>16.2.&nbsp;Default Colors</h2></div></div></div><div class="figure"><a name="d0e1543"></a><p class="title"><b>Figure&nbsp;16.2.&nbsp;Edit Default Colors</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="443"><tr><td align="center"><img src="images/defaultcolors.gif" align="middle" alt="Edit Default Colors"></td></tr></table></div></div><p>The default color editor changes how colors are distributed to
      functions whose color has not been specifically assigned.  It is
      accessible from the File menu of the Preferences Window. 
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof.preferences.colormap"></a>16.3.&nbsp;Color Map</h2></div></div></div><div class="figure"><a name="d0e1554"></a><p class="title"><b>Figure&nbsp;16.3.&nbsp;Color Map</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="229"><tr><td align="center"><img src="images/colormap.gif" align="middle" alt="Color Map"></td></tr></table></div></div><p>The color map shows specifically assigned colors.  These values are
      used across all trials loaded so that the user can identify a particular
      function across multiple trials.  In order to map an entire trial's
      function set, Select "Assign Defaults from -&gt;" and select a loaded trial.
    </p><p>Individual functions can be assigned a particular color by
      clicking on them in any of the other ParaProf Windows.
    </p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="PerfExplorerDoc"></a>Part&nbsp;III.&nbsp;PerfExplorer - User's Manual</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#Introduction">17. Introduction</a></span></dt><dt><span class="chapter"><a href="#InstallPerfExplorer">18. Installation and Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RunningPerfExplorer">19. Running PerfExplorer</a></span></dt><dt><span class="chapter"><a href="#ClusterAnalysis">20. Cluster Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#CorrelationAnalysis">21. Correlation Analysis</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Charts">22. Charts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#CustomCharts">23. Custom Charts</a></span></dt><dt><span class="chapter"><a href="#Visualization">24. Visualization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Views">25. Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Scripting">26. Running PerfExplorer Scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Derived Metrics">27. Derived Metrics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Introduction"></a>Chapter&nbsp;17.&nbsp;Introduction</h2></div></div></div><p>PerfExplorer is a framework for parallel performance data
        mining and knowledge discovery. The framework architecture
        enables the development and integration of data mining
        operations that will be applied to large-scale parallel
        performance profiles.</p><p>The overall goal of the PerfExplorer project is to create
        a software to integrate sophisticated data mining techniques in
        the analysis of large-scale parallel performance data.</p><p>PerfExplorer supports clustering, summarization,
        association, regression, and correlation.  Cluster analysis is
        the process of organizing data points into logically similar
        groupings, called clusters.  Summarization is the process of
        describing the similarities within, and dissimilarities between,
        the  discovered clusters.  Association is the process of finding
        relationships in the data.  One such method of association is
        regression analysis, the process of finding independent and
        dependent correlated variables in the data.  In addition,
        comparative analysis extends these operations to   compare
        results from different experiments, for instance, as part of a
        parametric study.</p><p>In addition to the data mining operations available, the
        user may optionally choose to perform comparative analysis.  The
        types of charts available include time-steps per second,
        relative efficiency and speedup of the entire application,
        relative efficiency and speedup of one event, relative
        efficiency and speedup for all events, relative efficiency and
        speedup for all phases and runtime breakdown of the application
        by event or by phase.  In addition, when the events are grouped
        together, such as in the case of communication routines, yet
        another chart shows the percentage of total runtime spent in
        that group of events.  These analyses can be conducted across
        different combinations of parallel profiles and across phases
        within an execution.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="InstallPerfExplorer"></a>Chapter&nbsp;18.&nbsp;Installation and Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ConfigurationOptions">18.1. Available configuration options</a></span></dt></dl></div><p>PerfExplorer uses TAUdb and PerfDMF databases so if you have not already you
        will need to install TAUdb, see <a href="#taudb.intro" title="Chapter&nbsp;28.&nbsp;Introduction">Chapter&nbsp;28, <i>Introduction</i></a>.

        To configure PerfExplorer move to the
        <code class="literal">tools/src/PerfExplorer/</code> directory in you TAU
        distribution. Type:</p><pre class="screen"> %&gt;./configure</pre><p>

        If you haven't already done so for other TAU tools, add
        <code class="literal">[path to tau]/tau2/apple/bin</code> to your
        path.</p><p>The following command-line options are available to
        configure:</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigurationOptions"></a>18.1.&nbsp;Available configuration options</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">-engine=&lt;analysis engine&gt;</code></p><p>Specifies the data-mining engine to use.  The
            supported options include weka and R.</p></li><li><p><code class="literal">-rroot=&lt;directory&gt;</code></p><p>Specifies the directory where R is installed.
            Specifically, it should be the directory where the
            <code class="literal">bin</code>, <code class="literal">include</code>,
            <code class="literal">lib</code>, <code class="literal">library</code> and 
            <code class="literal">share</code> directories are located.</p></li><li><p><code class="literal">-objectport=&lt;available network
            port&gt;</code></p><p>Specifies the port that the PerfExplorer server should
            use, when running PerfExplorer in client-server mode.
            Select an available network port, and make sure that other
            appropriate network configurations are made (firewalls,
            etc.).  The default port is 9999.</p></li><li><p><code class="literal">-registryport=&lt;available network
            port&gt;</code></p><p>Specifies the port that the rmiregistry should
            use, when ruining PerfExplorer in client-server mode.
            Select an available network port, and make sure that other
            appropriate network configurations are made (firewalls,
            etc.).  The default port is 1099.</p></li><li><p><code class="literal">-server=&lt;server name&gt;</code></p><p>Specifies the fully qualified domain name of the
            server where PerfExplorer is run, when running PerfExplorer
            in client-server mode.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="RunningPerfExplorer"></a>Chapter&nbsp;19.&nbsp;Running PerfExplorer</h2></div></div></div><p>To run PerfExplorer type: </p><pre class="screen">
%&gt;perfexplorer
</pre><p>

        When PerfExplorer loads you will see on the left window all the 
        experiments that where loaded into PerfDMF. You can select which 
        performance data you are interested by navigating the tree structure. 
        PerfExplorer will allow you to 
        run analysis operations on these experiments. Also the cluster analysis
        results are visible on the right side of the window.  Various types of
        comparative analysis are available from the drop down menu
        selected.</p><p>To run an analysis operation, first select the metric of interest
        form the experiments on the left. Then perform the operation by selecting it
        from the <code class="literal">Analysis</code> menu. If you would like you can set 
        the <code class="literal"> clustering method, dimension reduction, normalization method
		</code> and the <code class="literal"> number of clusters </code>from the same
		menu.</p><p>The options under the Charts menu provide analysis over one or
		more applications, experiments, views or trials. To view these charts
		first choose a metric of interest by selecting a trial form the tree on
		the left. Then optionally choose the <code class="literal">Set Metric of
        Interest</code> or <code class="literal">Set Event of Interest</code> form the 
        <code class="literal">Charts</code> menu (if you don't, and you need to, you will
		be prompted). Now you can view a chart by selecting it
        from the <code class="literal">Charts</code> menu.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ClusterAnalysis"></a>Chapter&nbsp;20.&nbsp;Cluster Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DimensionReduction">20.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#MaxClusters">20.2. Max Number of Clusters</a></span></dt><dt><span class="sect1"><a href="#PerformingClusterAnalysis">20.3. Performing Cluster Analysis</a></span></dt></dl></div><p>Cluster analysis is a valuable tool for reducing large
	parallel profiles down to representative groups for investigation.
	Currently, there are two types of clustering analysis implemented in
	PerfExplorer.  Both <span class="emphasis"><em>hierarchical</em></span> and
	<span class="emphasis"><em>k-means</em></span> analysis are used to group parallel
	profiles into common clusters, and then the clusters are summarized.
	Initially, we used similarity measures computed on a single parallel
	profile as input to the clustering algorithms, although other forms
	of input are possible.  Here, the performance data is organized into
	multi-dimensional vectors for analysis.  Each vector represents one
	parallel thread (or process) of execution in the profile.  Each
	dimension in the vector represents an event that was profiled in the
	application.  Events can be any sub-region of code, including
	libraries, functions, loops, basic blocks or even individual lines
	of code.  In simple clustering examples, each vector represents only
	one metric of measurement.  For our purposes, some dissimilarity
	value, such as <span class="emphasis"><em>Euclidean</em></span> or
	<span class="emphasis"><em>Manhattan</em></span> distance, is computed on the vectors.
	As discussed later, we have tested hierarchical and $k$-means
	cluster analysis in PerfExplorer on profiles with over 32K threads
	of execution with few difficulties.  </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DimensionReduction"></a>20.1.&nbsp;Dimension Reduction</h2></div></div></div><p>Often, many hundreds of events are instrumented when
            profile data is collected.  Clustering works best with
            dimensions less than 10, so dimension reduction is often
            necessary to get meaningful results.  Currently, there is
            only one type of dimension reduction available in
            PerfExplorer.  To reduce dimensions, the user specifies a
            minimum exclusive percentage for an event to be considered
            "significant".
			</p><p>To reduce dimensions, select the "Select Dimension
            Reduction" item under the "Analysis" main menu bar item.
			The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction1"></a><p class="title"><b>Figure&nbsp;20.1.&nbsp;Selecting a dimension reduction method</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction1.gif" align="middle" alt="Selecting a dimension reduction method"></td></tr></table></div></div><p>
			Select "Over X Percent".  The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction2"></a><p class="title"><b>Figure&nbsp;20.2.&nbsp;Entering a minimum threshold for exclusive percentage</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction2.gif" align="middle" alt="Entering a minimum threshold for exclusive percentage"></td></tr></table></div></div><p>
			Enter a value, for example "1".
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MaxClusters"></a>20.2.&nbsp;Max Number of Clusters</h2></div></div></div><p>By default, PerfExplorer will attempt k-means
			clustering with values of k from 2 to 10.  To change the
			maximum number of clusters, select the "Set Maximum Number
			of Clusters" item under the "Analysis" main menu item.
			The following dialog will appear:  
			</p><div class="figure"><a name="perfexplorer.mainwindow.maxclusters"></a><p class="title"><b>Figure&nbsp;20.3.&nbsp;Entering a maximum number of clusters</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/maxclusters.gif" align="middle" alt="Entering a maximum number of clusters"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerformingClusterAnalysis"></a>20.3.&nbsp;Performing Cluster Analysis</h2></div></div></div><p>To perform cluster analysis, you first need to select a
		metric.  To select a metric, navigate through the tree of
		applications, experiments and trials, and expand the trial of
		interest, showing the available metrics, as shown in the figure
		below:
		</p><div class="figure"><a name="perfexplorer.mainwindow.clustering"></a><p class="title"><b>Figure&nbsp;20.4.&nbsp;Selecting a
	Metric to Cluster</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusteringselection.gif" align="middle" alt="Selecting a Metric to Cluster"></td></tr></table></div></div><p>After selecting the metric of interest, select the "Do
		Clustering" item under the "Analysis" main menu bar item.
		The following dialog will appear:  </p><div class="figure"><a name="perfexplorer.confirm.clustering"></a><p class="title"><b>Figure&nbsp;20.5.&nbsp;Confirm
	Clustering Options</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/confirmclustering.gif" align="middle" alt="Confirm Clustering Options"></td></tr></table></div></div><p>After confirming the clustering, the clustering will
		begin.  When the clustering results are available, you can view
		them in the "Cluster Results" tab.
		</p><div class="figure"><a name="perfexplorer.cluster.results"></a><p class="title"><b>Figure&nbsp;20.6.&nbsp;Cluster
	Results</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusterresults.gif" align="middle" alt="Cluster Results"></td></tr></table></div></div><p>There are a number of images in the "Cluster Results"
		window.  From left to right, the windows indicate the cluster
		membership histogram, a PCA scatterplot showing the cluster
		memberships, a virtual topology of the parallel machine, the
		minimum values for each event in each cluster, the average
		values for each event in each cluster, and the maximum values
		for each event in each cluster.  Clicking on a thumbnail image
		in the main window will bring up the images, as shown below:
		</p><div class="figure"><a name="perfexplorer.cluster.histogram"></a><p class="title"><b>Figure&nbsp;20.7.&nbsp;Cluster
	Membership Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/histogram.gif" align="middle" alt="Cluster Membership Histogram"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.scatterplot"></a><p class="title"><b>Figure&nbsp;20.8.&nbsp;Cluster
	Membership Scatterplot</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/scatterplot.gif" align="middle" alt="Cluster Membership Scatterplot"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.topology"></a><p class="title"><b>Figure&nbsp;20.9.&nbsp;Cluster
	Virtual Topology</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/topology.gif" align="middle" alt="Cluster Virtual Topology"></td></tr></table></div></div><div class="figure"><a name="perfexplorer.cluster.averages"></a><p class="title"><b>Figure&nbsp;20.10.&nbsp;Cluster
	Average Behavior</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/averages.gif" align="middle" alt="Cluster Average Behavior"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="CorrelationAnalysis"></a>Chapter&nbsp;21.&nbsp;Correlation Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DimensionReduction2">21.1. Dimension Reduction</a></span></dt><dt><span class="sect1"><a href="#PerformingCorrelationAnalysis">21.2. Performing Correlation Analysis</a></span></dt></dl></div><p>Correlation analysis in PerfExplorer is used to explore relationships
	between events in a profile.  Each event is pairwise plotted with the other
	events, and a correlation coefficient is calcuated for the relationship.
	When the events are highly positively correlated (coefficient of close to
	1.0) or highly negatively correlated (coefficient close to -1.0), then the
	relationships will show up as linear groupings in the results.  Clusters
	may also be apparent.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DimensionReduction2"></a>21.1.&nbsp;Dimension Reduction</h2></div></div></div><p>Often, many hundreds of events are instrumented when
        profile data is collected.  Clustering works best with
        dimensions less than 10, so dimension reduction is often
        necessary to get meaningful results.  Currently, there is
        only one type of dimension reduction available in
        PerfExplorer.  To reduce dimensions, the user specifies a
        minimum exclusive percentage for an event to be considered
        "significant".
		</p><p>To reduce dimensions, select the "Select Dimension
        Reduction" item under the "Analysis" main menu bar item.
		The following dialog will appear:  
        </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction1b"></a><p class="title"><b>Figure&nbsp;21.1.&nbsp;Selecting a dimension reduction method</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction1.gif" align="middle" alt="Selecting a dimension reduction method"></td></tr></table></div></div><p>
			Select "Over X Percent".  The following dialog will appear:  
            </p><div class="figure"><a name="perfexplorer.mainwindow.dimensionreduction2b"></a><p class="title"><b>Figure&nbsp;21.2.&nbsp;Entering a minimum threshold for exclusive percentage</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/dimensionreduction2.gif" align="middle" alt="Entering a minimum threshold for exclusive percentage"></td></tr></table></div></div><p>
			Enter a value, for example "1".
            </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerformingCorrelationAnalysis"></a>21.2.&nbsp;Performing Correlation Analysis</h2></div></div></div><p>To perform correlation analysis, you first need to select a
		metric.  To select a metric, navigate through the tree of
		applications, experiments and trials, and expand the trial of
		interest, showing the available metrics, as shown in the figure
		below:
		</p><div class="figure"><a name="perfexplorer.mainwindow.correlation"></a><p class="title"><b>Figure&nbsp;21.3.&nbsp;Selecting a
	Metric to Cluster</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/clusteringselection.gif" align="middle" alt="Selecting a Metric to Cluster"></td></tr></table></div></div><p>After selecting the metric of interest, select the "Do
		Correlation Analysis" item under the "Analysis" main menu bar item.
		A confirmation dialog will appear, and you can either confirm
		the correlation request or cancel it.  After confirming the
		correlation, the analysis will begin.  When the analysis results
		are available, you can view them in the "Correlation Results" tab.
		</p><div class="figure"><a name="perfexplorer.correlation.results"></a><p class="title"><b>Figure&nbsp;21.4.&nbsp;Correlation
	Results</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/correlationresults.gif" align="middle" alt="Correlation Results"></td></tr></table></div></div><p>There are a number of images in the "Correlation Results"
		window.  Each thumbnail represents a pairwise correlation plot
		of two events.  Clicking on a thumbnail image
		in the main window will bring up the images, as shown below:
		</p><div class="figure"><a name="perfexplorer.correlation.example"></a><p class="title"><b>Figure&nbsp;21.5.&nbsp;Correlation
	Example</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/correlationexample.gif" align="middle" alt="Correlation Example"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Charts"></a>Chapter&nbsp;22.&nbsp;Charts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SettingChartParameters">22.1. Setting Parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GroupOfInterest">22.1.1. Group of Interest</a></span></dt><dt><span class="sect2"><a href="#MetricOfInterest">22.1.2. Metric of Interest</a></span></dt><dt><span class="sect2"><a href="#EventOfInterest">22.1.3. Event of Interest</a></span></dt><dt><span class="sect2"><a href="#TotalNumberOfTimesteps">22.1.4. Total Number of
		Timesteps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ChartTypes">22.2. Standard Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#TimestepsPerSecond">22.2.1. Timesteps Per
		Second</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiency">22.2.2. Relative
		Efficiency</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyByEvent">22.2.3. Relative Efficiency by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeEfficiencyOneEvent">22.2.4. Relative Efficiency for
		One Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedup">22.2.5. Relative
		Speedup</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupByEvent">22.2.6. Relative Speedup by
		Event</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupOneEvent">22.2.7. Relative Speedup for One
		Event</a></span></dt><dt><span class="sect2"><a href="#PercentOfTotal">22.2.8. Group % of Total
		Runtime</a></span></dt><dt><span class="sect2"><a href="#RuntimeBreakdown">22.2.9. Runtime
		Breakdown</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PhaseChartTypes">22.3. Phase Chart Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#RelativeEfficiencyPhase">22.3.1. Relative Efficiency per Phase</a></span></dt><dt><span class="sect2"><a href="#RelativeSpeedupPhase">22.3.2. Relative Speedup per Phase</a></span></dt><dt><span class="sect2"><a href="#PhaseBreakdown">22.3.3. Phase Fraction of Total
		Runtime</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SettingChartParameters"></a>22.1.&nbsp;Setting Parameters</h2></div></div></div><p>There are a few parameters which need to be set when
		doing comparisons between trials in the database.  If any
		necessary setting is not configured before requesting a
		chart, you will be prompted to set the value.  The following
		settings may be necessary for the various charts available:
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="GroupOfInterest"></a>22.1.1.&nbsp;Group of Interest</h3></div></div></div><p>TAU events are often associated with common groups,
		such as "MPI", "TRANSPOSE", etc.  This value is used for
		showing what fraction of runtime that this group of
		events contributed to the total runtime.</p><div class="figure"><a name="perfexplorer.charts.groupofinterest"></a><p class="title"><b>Figure&nbsp;22.1.&nbsp;Setting Group of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/groupofinterest.gif" align="middle" alt="Setting Group of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="MetricOfInterest"></a>22.1.2.&nbsp;Metric of Interest</h3></div></div></div><p>Profiles may contain many metrics gathered for a
		single trial.  This selects which of the available metrics
		the user is interested in.</p><div class="figure"><a name="perfexplorer.charts.metricofinterest"></a><p class="title"><b>Figure&nbsp;22.2.&nbsp;Setting Metric of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/metricofinterest.gif" align="middle" alt="Setting Metric of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="EventOfInterest"></a>22.1.3.&nbsp;Event of Interest</h3></div></div></div><p>Some charts examine events in isolation.  This setting
		configures which event to examine.</p><div class="figure"><a name="perfexplorer.charts.eventofinterest"></a><p class="title"><b>Figure&nbsp;22.3.&nbsp;Setting Event of Interest</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/eventofinterest.gif" align="middle" alt="Setting Event of Interest"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TotalNumberOfTimesteps"></a>22.1.4.&nbsp;Total Number of
		Timesteps</h3></div></div></div><p>One chart, the "Timesteps per second" chart, will
		calculate the number of timesteps completed per second.
		This setting configures that value.</p><div class="figure"><a name="perfexplorer.charts.timesteps"></a><p class="title"><b>Figure&nbsp;22.4.&nbsp;Setting Timesteps</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/timesteps.gif" align="middle" alt="Setting Timesteps"></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChartTypes"></a>22.2.&nbsp;Standard Chart Types</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="TimestepsPerSecond"></a>22.2.1.&nbsp;Timesteps Per
		Second</h3></div></div></div><p>The Timesteps Per Second chart shows how an application
		scales as it relates to time-to-solution.  If the timesteps are
		not already set, you will be prompted to enter the total number
		of timesteps in the trial (see <a href="#TotalNumberOfTimesteps" title="22.1.4.&nbsp;Total Number of&#xA;Timesteps">Section&nbsp;22.1.4, &#8220;Total Number of
		Timesteps&#8221;</a> ).  If there is more than
		one metric to choose from, you may be prompted to select the
		metric of interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.timestepspersecond"></a><p class="title"><b>Figure&nbsp;22.5.&nbsp;Timesteps per Second</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/timestepspersecond.gif" align="middle" alt="Timesteps per Second"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiency"></a>22.2.2.&nbsp;Relative
		Efficiency</h3></div></div></div><p>The Relative Efficiency chart shows how an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiency"></a><p class="title"><b>Figure&nbsp;22.6.&nbsp;Relative Efficiency</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiency.gif" align="middle" alt="Relative Efficiency"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyByEvent"></a>22.2.3.&nbsp;Relative Efficiency by
		Event</h3></div></div></div><p>The Relative Efficiency By Event chart shows how each
		event in an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencybyevent"></a><p class="title"><b>Figure&nbsp;22.7.&nbsp;Relative Efficiency by Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencybyevent.gif" align="middle" alt="Relative Efficiency by Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyOneEvent"></a>22.2.4.&nbsp;Relative Efficiency for
		One Event</h3></div></div></div><p>The Relative Efficiency for One Event chart shows how one
		event from an application
		scales with respect to relative efficiency.  That is, as the
		number of processors increases by a factor, the time to solution
		is expected to decrease by the same factor (with ideal scaling).
		The fraction between the expected scaling and the actual scaling
		is the relative efficiency.  
		If there is more than one event to choose from, and you have not
		yet selected an event of interest, you may be prompted to select
		the event of interest (see <a href="#EventOfInterest" title="22.1.3.&nbsp;Event of Interest">Section&nbsp;22.1.3, &#8220;Event of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencyoneevent"></a><p class="title"><b>Figure&nbsp;22.8.&nbsp;Relative Efficiency one Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencyoneevent.gif" align="middle" alt="Relative Efficiency one Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedup"></a>22.2.5.&nbsp;Relative
		Speedup</h3></div></div></div><p>The Relative Speedup chart shows how an application
		scales with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedup"></a><p class="title"><b>Figure&nbsp;22.9.&nbsp;Relative Speedup</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedup.gif" align="middle" alt="Relative Speedup"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupByEvent"></a>22.2.6.&nbsp;Relative Speedup by
		Event</h3></div></div></div><p>The Relative Speedup By Event chart shows how the events
		in an application
		scale with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedupbyevent"></a><p class="title"><b>Figure&nbsp;22.10.&nbsp;Relative Speedup by Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedupbyevent.gif" align="middle" alt="Relative Speedup by Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupOneEvent"></a>22.2.7.&nbsp;Relative Speedup for One
		Event</h3></div></div></div><p>The Relative Speedup for One Event chart shows how one
		event in an application
		scales with respect to relative speedup.  That is, as the
		number of processors increases by a factor, the speedup
		is expected to increase by the same factor (with ideal scaling).
		The ideal speedup is charted, along with the actual speedup for
		the application.  
		If there is more than one event to choose from, and you have not
		yet selected an event of interest, you may be prompted to select
		the event of interest (see <a href="#EventOfInterest" title="22.1.3.&nbsp;Event of Interest">Section&nbsp;22.1.3, &#8220;Event of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeeduponeevent"></a><p class="title"><b>Figure&nbsp;22.11.&nbsp;Relative Speedup one Event</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeeduponeevent.gif" align="middle" alt="Relative Speedup one Event"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="PercentOfTotal"></a>22.2.8.&nbsp;Group % of Total
		Runtime</h3></div></div></div><p>
		The Group % of Total Runtime chart shows how the fraction of the
		total runtime for one group of events changes as the number of
		processors increases.  
		If there is more than one group
		to choose from, and you have not yet selected a group of
		interest, you may be prompted to select the group of
		interest (see <a href="#GroupOfInterest" title="22.1.1.&nbsp;Group of Interest">Section&nbsp;22.1.1, &#8220;Group of Interest&#8221;</a>).
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one or more experiments or one view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.percentoftotal"></a><p class="title"><b>Figure&nbsp;22.12.&nbsp;Group % of Total Runtime</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/percentoftotal.gif" align="middle" alt="Group % of Total Runtime"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RuntimeBreakdown"></a>22.2.9.&nbsp;Runtime
		Breakdown</h3></div></div></div><p>
		The Runtime Breakdown chart shows the fraction of the total
		runtime for all events in the application, and how the fraction
		changes as the number of processors increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.runtimebreakdown"></a><p class="title"><b>Figure&nbsp;22.13.&nbsp;Runtime Breakdown</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/runtimebreakdown.gif" align="middle" alt="Runtime Breakdown"></td></tr></table></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PhaseChartTypes"></a>22.3.&nbsp;Phase Chart Types</h2></div></div></div><p>TAU now provides the ability to break down profiles with
		respect to phases of execution.  One such application would be
		to collect separate statistics for each timestep, or group of
		timesteps.  In order to visualize the variance between the
		phases of execution, a number of phase-based charts are
		available.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeEfficiencyPhase"></a>22.3.1.&nbsp;Relative Efficiency per Phase</h3></div></div></div><p>
		The Relative Efficiency Per Phase chart shows the relative
		efficiency for each phase, as the number of processors
		increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativeefficiencybyphase"></a><p class="title"><b>Figure&nbsp;22.14.&nbsp;Relative Efficiency per Phase</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativeefficiencybyphase.gif" align="middle" alt="Relative Efficiency per Phase"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="RelativeSpeedupPhase"></a>22.3.2.&nbsp;Relative Speedup per Phase</h3></div></div></div><p>
		The Relative Speedup Per Phase chart shows the relative
		speedup for each phase, as the number of processors
		increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.relativespeedupbyphase"></a><p class="title"><b>Figure&nbsp;22.15.&nbsp;Relative Speedup per Phase</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/relativespeedupbyphase.gif" align="middle" alt="Relative Speedup per Phase"></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="PhaseBreakdown"></a>22.3.3.&nbsp;Phase Fraction of Total
		Runtime</h3></div></div></div><p>
		The Phase Fraction of Total Runtime chart shows the breakdown of
		the execution by phases, and shows how that breakdown changes as
		the number of processors increases.
		If there is more than one metric
		to choose from, you may be prompted to select the metric of
		interest (see <a href="#MetricOfInterest" title="22.1.2.&nbsp;Metric of Interest">Section&nbsp;22.1.2, &#8220;Metric of Interest&#8221;</a>).
		To request this chart, select one experiment or view,
		and select this chart item under the "Charts" main menu item.
		</p><div class="figure"><a name="perfexplorer.charts.phasebreakdown"></a><p class="title"><b>Figure&nbsp;22.16.&nbsp;Phase Fraction of Total Runtime</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="360"><tr><td align="center"><img src="images/phasebreakdown.gif" align="middle" alt="Phase Fraction of Total Runtime"></td></tr></table></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="CustomCharts"></a>Chapter&nbsp;23.&nbsp;Custom Charts</h2></div></div></div><p>In addition to the default charts available in the charts menu, there
	are is a custom chart interface.  To access the interface, select the "Custom
	Charts" tab on in the results pane of the main window, as shown:</p><div class="figure"><a name="perfexplorer.customcharts.interface"></a><p class="title"><b>Figure&nbsp;23.1.&nbsp;The Custom Charts
	Interface</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/customcharts.gif" align="middle" alt="The Custom Charts Interface"></td></tr></table></div></div><p>There are a number of controls for the cusotom charts.  They are:</p><div class="itemizedlist"><ul type="disc"><li><p>Main Only - When selected, only the main event (the event with
	the highest inclusive value) will be selected.  When deselected, the
	"Events" control (see below) is activated, and one or all events can be
	selected.</p></li><li><p>Call Paths - When selected, callpath events will be available in
	the "Events" control (see below).</p></li><li><p>Log Y - When selected, the Y axis will be the log of the true
	value.</p></li><li><p>Scalability - When selected, the chart will be interpreted as a
	speedup chart.  The trial with the fewest number of threads of execution
	will be considered the baseline trial.</p></li><li><p>Efficiency - When selected, the chart will be interpreted as a
	relative efficiency chart.  The trial with the fewest number of threads of
	execution will be considered the baseline trial.</p></li><li><p>Strong Scaling - When deselected, the speedup or efficiency chart
	will be interpreted as a strong scaling study (the workload is the same for
	all trials).  When selected, the button will change to "Weak Scaling", and
	the chart will be interpreted as a weak scaling study (the workload is
	proportional to the total number of threads in each trial).</p></li><li><p>Horizontal - when selected, the chart X and Y axes will be
	swapped.</p></li><li><p>Show Y-Axis Zero - when selected, the chart will include the
	value 0.  When deselected, the chart will only show the relevant values for
	all data points.</p></li><li><p>Chart Title - value to use for the chart title</p></li><li><p>Series Name/Value - the field to be used to group the data points
	as a series.</p></li><li><p>X Axis Value - the field to use as the X axis value.</p></li><li><p>X Axis Name - the name to put in the chart for the value along
	the X axis.</p></li><li><p>Y Axis Value - the field to use as the Y axis value</p></li><li><p>Y Axis Name - the name to put in the chart for the value along
	the X axis.</p></li><li><p>Dimension Reduction - whether or not to use dimension reduction.
	This is only applicable when "Main Only" is disabled.</p></li><li><p>Cutoff - when the "Dimension Reduction" is enabled, the cutoff
	value for selecting "All Events".</p></li><li><p>Metric - The metric of interest for the Y axis.</p></li><li><p>Units - The unit to be selected for the Y axis.</p></li><li><p>Event - The event of interest, or "All Events".</p></li><li><p>XML Field - When the X or Y axis is selected to be an XML field,
	this is the field of interest.</p></li><li><p>Apply - build the chart.</p></li><li><p>Reset - restore the options back to the default
	values.</p></li></ul></div><p>When the chart is generated, it can be saved as a vector image by
	selecting "File -&gt; Save As Vector Image".  The chart can also be saved
	as a PNG by right clicking on the chart, and selecting "Save As...".</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Visualization"></a>Chapter&nbsp;24.&nbsp;Visualization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ThreeDVisualization">24.1. 3D Visualization</a></span></dt><dt><span class="sect1"><a href="#DataSummary">24.2. Data Summary</a></span></dt><dt><span class="sect1"><a href="#CreateBoxchart">24.3. Creating a Boxchart</a></span></dt><dt><span class="sect1"><a href="#CreateHistogram">24.4. Creating a Histogram</a></span></dt><dt><span class="sect1"><a href="#CreateNormalProbability">24.5. Creating a Normal Probability Chart</a></span></dt></dl></div><p>Under the "Visualization" main menu item, there are five types
	of raw data visualization. The five items are "3D Visualization",
	"Data Summary", "Create Boxchart", "Create Histogram" and 
	"Create Normal Probability Chart".  For the Boxchart, Histogram
	and Normal Probability Charts, you can either select one metric
	in the trial (which selects all events by default), or expand the metric
	and select events of interest.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ThreeDVisualization"></a>24.1.&nbsp;3D Visualization</h2></div></div></div><p>When the "3D Visualization" is requested, PerfExplorer
		examines the data to try to determine the most interesting
		events in the trial.  That is, for the selected metric in the
		selected trial, the database will calculate the weighted
		relative variance for each event across all threads of
		execution, in order to find the top four "significant" events.
		These events are selected by calculating: stddev(exclusive) /
		(max(exclusive) - min(exclusive)) * exclusive_percentage.  After
		selecting the top four events, they are graphed in an OpenGL
		window.</p><div class="figure"><a name="perfexplorer.visualization.threed"></a><p class="title"><b>Figure&nbsp;24.1.&nbsp;3D
		Visualization of multivariate data</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/3dvisualization.gif" align="middle" alt="3D Visualization of multivariate data"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DataSummary"></a>24.2.&nbsp;Data Summary</h2></div></div></div><p>In order to see a summary of the performance data in the
		database, select the "Show Data Summary" item under the
		"Visualization" main menu item.</p><div class="figure"><a name="perfexplorer.visualization.datasummary"></a><p class="title"><b>Figure&nbsp;24.2.&nbsp;Data
		Summary Window</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/datasummary.gif" align="middle" alt="Data Summary Window"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateBoxchart"></a>24.3.&nbsp;Creating a Boxchart</h2></div></div></div><p>In order to see a boxchart summary of the performance data in the
		database, select the "Create Boxchart" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.boxchart"></a><p class="title"><b>Figure&nbsp;24.3.&nbsp;Boxchart</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/boxchart.gif" align="middle" alt="Boxchart"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateHistogram"></a>24.4.&nbsp;Creating a Histogram</h2></div></div></div><p>In order to see a histogram summary of the performance data in the
		database, select the "Create Histogram" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.histogram"></a><p class="title"><b>Figure&nbsp;24.4.&nbsp;Histogram</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/histogram2.gif" align="middle" alt="Histogram"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreateNormalProbability"></a>24.5.&nbsp;Creating a Normal Probability Chart</h2></div></div></div><p>In order to see a normal probability summary of the performance data in the
		database, select the "Create NormalProbability" item under the "Visualization"
		main menu item.</p><div class="figure"><a name="perfexplorer.visualization.normalprobability"></a><p class="title"><b>Figure&nbsp;24.5.&nbsp;Normal
		Probability</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/normalprobability.gif" align="middle" alt="Normal Probability"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Views"></a>Chapter&nbsp;25.&nbsp;Views</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CreatingViews">25.1. Creating Views</a></span></dt><dt><span class="sect1"><a href="#CreatingSubviews">25.2. Creating Subviews</a></span></dt></dl></div><p>Often times, data is loaded into the database with multiple
	parametric cross-sections.  For example, the charts available in
	PerfExplorer are primarily designed for scalability analysis,
	however data might be loaded as a parametric study.  For example, in
	the following example, the data has been loaded with three problem
	sizes, MIN, HALF and FULL.</p><div class="figure"><a name="perfexplorer.views.parametricexample"></a><p class="title"><b>Figure&nbsp;25.1.&nbsp;Potential
	scalability data organized as a parametric study</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/parametricdata.gif" align="middle" alt="Potential scalability data organized as a parametric study"></td></tr></table></div></div><p>In order to examine this data in a scalability study, it is
	necessary to reorganize the data.  However, it is not necessary to
	re-load the data.  Using views in PerfExplorer, you can re-organize
	the data based on values in the database.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingViews"></a>25.1.&nbsp;Creating Views</h2></div></div></div><p>To create a view, select the "Create New View" item under
		the "Views" main menu item.  The first step is to select the
		table which will form the basis of the view.  The three possible
		values are Application, Experiment and Trial:</p><div class="figure"><a name="perfexplorer.views.viewslevel"></a><p class="title"><b>Figure&nbsp;25.2.&nbsp;Selecting a table</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewslevel.gif" align="middle" alt="Selecting a table"></td></tr></table></div></div><p>
		After selecting the table, you need to select the column on
		which to filter:
		</p><div class="figure"><a name="perfexplorer.views.viewscolumn"></a><p class="title"><b>Figure&nbsp;25.3.&nbsp;Selecting a
	column</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewscolumn.gif" align="middle" alt="Selecting a column"></td></tr></table></div></div><p>
		After selecting the column, you need to select the operator for
		comparing to that column:
		</p><div class="figure"><a name="perfexplorer.views.viewsoperator"></a><p class="title"><b>Figure&nbsp;25.4.&nbsp;Selecting an
	operator</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsoperator.gif" align="middle" alt="Selecting an operator"></td></tr></table></div></div><p>
		After selecting the operator, you need to select the value for
		comparing to the column:
		</p><div class="figure"><a name="perfexplorer.views.viewsvalue"></a><p class="title"><b>Figure&nbsp;25.5.&nbsp;Selecting a value</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsvalue.gif" align="middle" alt="Selecting a value"></td></tr></table></div></div><p>
		After selecting the value, you need to select a name for the
		view:
		</p><div class="figure"><a name="perfexplorer.views.viewsname"></a><p class="title"><b>Figure&nbsp;25.6.&nbsp;Entering a name
	for the view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/viewsname.gif" align="middle" alt="Entering a name for the view"></td></tr></table></div></div><p>
		After creating the view, you will need to exit PerfExplorer and
		re-start it to see the view.  This is a known problem with the
		application, and will be fixed in a future release.
		</p><div class="figure"><a name="perfexplorer.views.completedview"></a><p class="title"><b>Figure&nbsp;25.7.&nbsp;The completed
	view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/completedview.gif" align="middle" alt="The completed view"></td></tr></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingSubviews"></a>25.2.&nbsp;Creating Subviews</h2></div></div></div><p>In order to create sub-views, you first need to select
		the "Create New Sub-View" item from the "Views" main menu item.
		The first dialog box will prompt you to select the view (or
		sub-view) to base the new sub-view on:</p><div class="figure"><a name="perfexplorer.views.subview"></a><p class="title"><b>Figure&nbsp;25.8.&nbsp;Selecting the base
	view</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="180"><tr><td align="center"><img src="images/subview.gif" align="middle" alt="Selecting the base view"></td></tr></table></div></div><p>After selecting the base view or sub-view, the options for
		creating the new sub-view are the same as creating a new view.  
		After creating the sub-view, you will need to exit PerfExplorer and
		re-start it to see the sub-view.  This is a known problem with the
		application, and will be fixed in a future release.
		</p><div class="figure"><a name="perfexplorer.views.completedsubview"></a><p class="title"><b>Figure&nbsp;25.9.&nbsp;Completed
	sub-views</b></p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td align="center"><img src="images/completedsubview.gif" align="middle" alt="Completed sub-views"></td></tr></table></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Scripting"></a>Chapter&nbsp;26.&nbsp;Running PerfExplorer Scripts</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#AnalysisComponents">26.1. Analysis Components</a></span></dt><dt><span class="sect1"><a href="#Scripting_Interface">26.2. Scripting Interface</a></span></dt><dt><span class="sect1"><a href="#ExampleScript">26.3. Example Script</a></span></dt></dl></div><p>As of version 2.0, PerfExplorer has officially supported a
	scripting interface.  The scripting interface is useful for adding
	automation to PerfExplorer.  For example, a user can load a trial,
	perform data reduction, extract out key phases, derive metrics, 
	and plot the result.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="AnalysisComponents"></a>26.1.&nbsp;Analysis Components</h2></div></div></div><p>There are many operations available, including:</p><div class="itemizedlist"><ul type="disc"><li><p>BasicStatisticsOperation</p></li><li><p>CopyOperation</p></li><li><p>CorrelateEventsWithMetadata</p></li><li><p>CorrelationOperation</p></li><li><p>DeriveMetricOperation</p></li><li><p>DifferenceMetadataOperation</p></li><li><p>DifferenceOperation</p></li><li><p>DrawBoxChartGraph</p></li><li><p>DrawGraph</p></li><li><p>DrawMMMGraph</p></li><li><p>ExtractCallpathEventOperation</p></li><li><p>ExtractEventOperation</p></li><li><p>ExtractMetricOperation</p></li><li><p>ExtractNonCallpathEventOperation</p></li><li><p>ExtractPhasesOperation</p></li><li><p>ExtractRankOperation</p></li><li><p>KMeansOperation</p></li><li><p>LinearRegressionOperation</p></li><li><p>LogarithmicOperation</p></li><li><p>MergeTrialsOperation</p></li><li><p>MetadataClusterOperation</p></li><li><p>PCAOperation</p></li><li><p>RatioOperation</p></li><li><p>ScalabilityOperation</p></li><li><p>TopXEvents</p></li><li><p>TopXPercentEvents</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Scripting_Interface"></a>26.2.&nbsp;Scripting Interface</h2></div></div></div><p>
	The scripting interface is in Python, and scripts can be used to build
	analysis workflows.  The Python scripts control the Java classes in the
	application through the Jython interpreter (http://www.jython.org/).  There
	are two types of components which are useful in
	building analysis scripts.  The first type is the PerformanceResult interface,
	and the second is the PerformanceAnalysisComponent interface.  For
	documentation on how to use the Java classes, see the javadoc in the
	perfexplorer source distribution, and the example scripts below.
	To build the perfexplorer javadoc, type </p><pre class="screen"> %&gt;./make javadoc</pre><p>
	in the perfexplorer source directory.
	
      </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExampleScript"></a>26.3.&nbsp;Example Script</h2></div></div></div><pre class="screen">
from glue import PerformanceResult
from glue import PerformanceAnalysisOperation
from glue import ExtractEventOperation
from glue import Utilities
from glue import BasicStatisticsOperation
from glue import DeriveMetricOperation
from glue import MergeTrialsOperation
from glue import TrialResult
from glue import AbstractResult
from glue import DrawMMMGraph
from edu.uoregon.tau.perfdmf import Trial
from java.util import HashSet
from java.util import ArrayList

True = 1
False = 0

def glue():
	print "doing phase test for gtc on jaguar"
	# load the trial
	Utilities.setSession("perfdmf.demo")
	trial1 = Utilities.getTrial("gtc_bench", "Jaguar Compiler Options", "fastsse")
	result1 = TrialResult(trial1)

	print "got the data"

	# get the iteration inclusive totals

	events = ArrayList()
	for event in result1.getEvents():
		#if event.find("Iteration") &gt;= 0 and result1.getEventGroupName(event).find("TAU_PHASE") &lt; 0:
		if event.find("Iteration") &gt;= 0 and event.find("=&gt;") &lt; 0:
			events.add(event)

	extractor = ExtractEventOperation(result1, events)
	extracted = extractor.processData().get(0)

	print "extracted phases"

	# derive metrics

	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCA", "PAPI_L1_TCM", DeriveMetricOperation.SUBTRACT)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCA-PAPI_L1_TCM", "PAPI_L1_TCA", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCM", "PAPI_L2_TCM", DeriveMetricOperation.SUBTRACT)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_L1_TCM-PAPI_L2_TCM", "PAPI_L1_TCM", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_FP_INS", "P_WALL_CLOCK_TIME", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)
	derivor = DeriveMetricOperation(extracted, "PAPI_FP_INS", "PAPI_TOT_INS", DeriveMetricOperation.DIVIDE)
	derived = derivor.processData().get(0)
	merger = MergeTrialsOperation(extracted)
	merger.addInput(derived)
	extracted = merger.processData().get(0)

	print "derived metrics..."

	# get the Statistics
	dostats = BasicStatisticsOperation(extracted, False)
	stats = dostats.processData()

	print "got stats..."

	return

	for metric in stats.get(0).getMetrics():
		grapher = DrawMMMGraph(stats)
		metrics = HashSet()
		metrics.add(metric)
		grapher.set_metrics(metrics)
		grapher.setTitle("GTC Phase Breakdown: " + metric)
		grapher.setSeriesType(DrawMMMGraph.TRIALNAME);
		grapher.setCategoryType(DrawMMMGraph.EVENTNAME)
		grapher.setValueType(AbstractResult.INCLUSIVE)
		grapher.setXAxisLabel("Iteration")
		grapher.setYAxisLabel("Inclusive " + metric);
		# grapher.setLogYAxis(True)
		grapher.processData()

	# graph the significant events in the iteration

	subsetevents = ArrayList()
	subsetevents.add("CHARGEI")
	subsetevents.add("PUSHI")
	subsetevents.add("SHIFTI")

	print "got data..."

	for subsetevent in subsetevents:
		events = ArrayList()
		for event in result1.getEvents():
			if event.find("Iteration") &gt;= 0 and event.rfind(subsetevent) &gt;= 0:
				events.add(event)

		extractor = ExtractEventOperation(result1, events)
		extracted = extractor.processData().get(0)

		print "extracted phases..."

		# get the Statistics
		dostats = BasicStatisticsOperation(extracted, False)
		stats = dostats.processData()

		print "got stats..."

		for metric in stats.get(0).getMetrics():
			grapher = DrawMMMGraph(stats)
			metrics = HashSet()
			metrics.add(metric)
			grapher.set_metrics(metrics)
			grapher.setTitle(subsetevent + ", " + metric)
			grapher.setSeriesType(DrawMMMGraph.TRIALNAME);
			grapher.setCategoryType(DrawMMMGraph.EVENTNAME)
			grapher.setValueType(AbstractResult.INCLUSIVE)
			# grapher.setLogYAxis(True)
			grapher.processData()
	return

print "--------------- JPython test script start ------------"
glue()
print "---------------- JPython test script end -------------"
	</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Derived Metrics"></a>Chapter&nbsp;27.&nbsp;Derived Metrics</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CreatingExpression">27.1. CreatingExpressions</a></span></dt><dt><span class="sect1"><a href="#Applying">27.2. Selecting Expressions</a></span></dt><dt><span class="sect1"><a href="#Files">27.3. Expression Files</a></span></dt></dl></div><p>Sometimes metrics in a profile need to be combined to create a derived
	metric.  PerfExplorer allows the user to create these using the derived metric expression tab.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CreatingExpression"></a>27.1.&nbsp;CreatingExpressions</h2></div></div></div><p>The text box at the top of the tab allows the user to enter an expression.  
        Double clicking on a metric in the "Performance Data" tree will copy that metrics name into the
        box.  If a metric contains any operands, the whole metric must be surrounded by quotes. If 
        the you would like of the metric to be renamed, then you should start the expression with 
        the new name and and equals sign.
		</p><p> If this is the only metric you wish to derive, then select the trial, expression or 
		application where the metric should be derived and then click apply.  If you wish to derive 
		many metrics, then click Add to List and create more expressions.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Applying"></a>27.2.&nbsp;Selecting Expressions</h2></div></div></div><p>If you have added multiple expressions, you can select one or many of them to apply.
		They will be derived from top to bottom.  After you have select some, you can select the trial, 
		experiment or application to apply the expression to and then click apply.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Files"></a>27.3.&nbsp;Expression Files</h2></div></div></div><p>You can also derive metrics using an expression file.  An expression file has a single 
		expression per line.  To parse the file, select the trial, experiment or application to apply
		the expressions to; then select File &gt; Parse Expression File and chose the file.
		</p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUdbDoc"></a>Part&nbsp;IV.&nbsp;TAUdb</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#taudb.intro">28. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.using">29. Using TAUdb</a></span></dt><dd><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.schema">30. Database Schema</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taudb.capi">31. TAUdb C API</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.intro"></a>Chapter&nbsp;28.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.prereq">28.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#taudb.installation">28.2. Installation</a></span></dt></dl></div><p>
	TAUdb (TAU Database), formerly known as PerfDMF (Performance Data
	Management Framework) is a an API/Toolkit that sits atop a DBMS to manage
	and analyze performance data.  The API is available in its native Java form
	as well as C.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.prereq"></a>28.1.&nbsp;Prerequisites</h2></div></div></div><div class="orderedlist"><ol type="1"><li><p>A supported Database Management System (DBMS).  TAUdb
	  currently supports PostgreSQL, MySQL, Oracle, H2, and Derby. For
	  use with the C API, only PostgreSQL is supported (SQLite support is
	  currently being evaluated). Because they are Java only, H2 and Derby
	  can NO  be accessed with the C API.</p></li><li><p>Java 1.5.</p></li><li><p>If the C API is desired, a working C compiler is
	  required, along with the following libraries: libpq (PostgreSQL
	  libraries), libxml2, libz, libuuid. These libraries are all commonly
	  installed by default on *NIX systems.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.installation"></a>28.2.&nbsp;Installation</h2></div></div></div><p>The TAUdb utilities and applications are installed as part of the
    standard TAU release.  Shell scripts are installed in the TAU bin directory
    to configure and run the utilities.  It is assumed that the user has
    installed TAU and run TAU's configure and 'make install'.
    </p><div class="orderedlist"><ol type="1"><li><p>(Optionally) Create a database.  This step will depend on the user's
		chosen DBMS.
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>H2:</strong></span>
	  Because it is an embedded, file-based DBMS, H2 does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. TAUdb takes advantage of the "auto-server"
	  capabilities in H2, so multiple clients can connect to the same database
	  at the same time. Users should use the H2 DBMS if they expect to
	  maintain a small to moderate local repository of performance data, and
	  want the convenience of connecting to the database from multiple clients.
	  </p></li><li><p><span class="bold"><strong>Derby:</strong></span>
	  Because it is an embedded, file-based DBMS, Derby does
	  <span class="bold"><strong>not</strong></span> require creating the database before
	  configuring TAUdb. Be advised that the Derby DBMS does <span class="bold"><strong>not</strong></span> allow multiple clients to connect to the same
	  database. For that reason, we suggest users use the H2 DBMS if a
	  file-based database is desired. Derby support is maintained for backwards
	  compatability.
	  </p></li><li><p><span class="bold"><strong>PostgreSQL:</strong></span>
	  </p><pre class="screen">$ createdb -O taudb taudb</pre><p>
	  Or, from <span><strong class="command">psql</strong></span>
	  </p><pre class="screen">psql=# create database taudb with owner = taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>MySQL:</strong></span>  From the MySQL prompt
	  </p><pre class="screen">mysql&gt; create database taudb;</pre><p>
	  </p></li><li><p><span class="bold"><strong>Oracle:</strong></span> It is recommended that
	  you create a tablespace for taudb: 
	  </p><pre class="screen">create tablespace taudb 
datafile '/path/to/somewhere' size 500m reuse;</pre><p>

	  Then, create a user that has this tablespace as default:
	  </p><pre class="screen">create user amorris identified by db;
grant create session to amorris;
grant create table to amorris;
grant create sequence to amorris;
grant create trigger to amorris;
alter user amorris quota unlimited on taudb;
alter user amorris default tablespace taudb;</pre><p>
	  
TAUdb is set up to use the Oracle Thin Java driver.  You will have
to obtain this jar file for your DBMS.  In our case, it was
ojdbc14.jar.
	  </p></li></ul></div></li><li><p>Configure a TAUdb connection.  To configure TAUdb, run the
	<span><strong class="command">taudb_configure</strong></span> program from the TAU bin directory.</p><p>The configuration program will prompt the user for several values.  The
	default values will work for most users.  When configuration is complete,
	it will connect to the database and test the configuration.  If the
	configuration is valid and the schema is not already found in the database
	(as will be the case on initial configuration), the schema will be
	uploaded.  Be sure to specify the correct version of the schema for your
	DBMS.
	</p><p>An example session for configuring a database is below. The user
	is creating an H2 database, with default settings including no username
	and no password (recommended for file-based databases when security is not
	an issue).
	</p><pre class="screen">
$ taudb_configure
Configuration file NOT found...
a new configuration file will be created.

Welcome to the configuration program for PerfDMF.
This program will prompt you for some information necessary to 
ensure the desired behavior for the PerfDMF tools.


You will now be prompted for new values, if desired.  The current 
or default values for each prompt are shown in parenthesis.
To accept the current/default value, just press Enter/Return.

Please enter the name of this configuration.
():documentation_example
Please enter the database vendor (oracle, postgresql, mysql, db2, 
derby or h2).
(h2):
Please enter the JDBC jar file.
(/Users/khuck/src/tau2/apple/lib/h2.jar):
Please enter the JDBC Driver name.
(org.h2.Driver):
Please enter the path to the database directory.
(/Users/khuck/.ParaProf/documentation_example):
Please enter the database username.
():
Store the database password in CLEAR TEXT in your configuration 
file? (y/n):y
Please enter the database password: 
Please enter the PerfDMF schema file.
(/Users/khuck/src/tau2/etc/taudb.sql):

Writing configuration file: 
/Users/khuck/.ParaProf/perfdmf.cfg.documentation_example

Now testing your database connection.

Database created, command: 
jdbc:h2:/Users/khuck/.ParaProf/documentation_example/perfdmf;AUTO_SERVER=TRUE;create=true

Uploading Schema: /Users/khuck/src/tau2/etc/taudb.sql
Found /Users/khuck/src/tau2/etc/taudb.sql  ... Loading
Successfully uploaded schema

Database connection successful.
Configuration complete.
	</pre><p>
	</p></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.using"></a>Chapter&nbsp;29.&nbsp;Using TAUdb</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#perfdmf.createapp">29.1. perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#perfdmf.createexp">29.2. perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</a></span></dt><dt><span class="sect1"><a href="#taudb.loadtrial">29.3. taudb_loadtrial</a></span></dt><dt><span class="sect1"><a href="#taudb.views">29.4. TAUdb Views</a></span></dt></dl></div><p>The easiest way to interact with TAUdb is to use ParaProf which
    provides a GUI interface to all of the database information.  In addition,
    the following commandline utilities are provided.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createapp"></a>29.1.&nbsp;perfdmf_createapp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates applications with a given name</p><pre class="screen">$ perfdmf_createapp -n "New Application"
Created Application, ID: 24</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perfdmf.createexp"></a>29.2.&nbsp;perfdmf_createexp (deprecated - only supported for older PerfDMF databases)</h2></div></div></div><p>This utility creates experiments with a given name, under a specified application</p><pre class="screen">$ perfdmf_createexp -a 24 -n "New Experiment"
Created Experiment, ID: 38</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.loadtrial"></a>29.3.&nbsp;taudb_loadtrial</h2></div></div></div><p>This utility uploads a trial to the database with a given name, under
    a specified experiment</p><pre class="screen">
$ taudb_loadtrial -h
Usage: perfdmf_loadtrial -a &lt;appName&gt; -x &lt;expName&gt; -n &lt;name&gt; 
[options] &lt;files&gt;

Required Arguments:

  -n, --name &lt;text&gt;              Specify the name of the trial
  -a, --applicationname &lt;string&gt; Specify associated application name
                                 for this trial
  -x, --experimentname &lt;string&gt;  Specify associated experiment name
                                 for this trial
               ...or...

  -n, --name &lt;text&gt;              Specify the name of the trial
  -e, --experimentid &lt;number&gt;    Specify associated experiment ID
                                 for this trial

Optional Arguments:

  -c, --config &lt;name&gt;       Specify the name of the configuration to use
  -g, --configFile &lt;file&gt;   Specify the configuration file to use
                            (overrides -c)
  -f, --filetype &lt;filetype&gt; Specify type of performance data, options 
                            are: profiles (default), pprof, dynaprof, 
                            mpip, gprof, psrun, hpm, packed, cube, 
                            hpc, ompp, snap, perixml, gptl, paraver, 
                            ipm, google
  -t, --trialid &lt;number&gt;    Specify trial ID
  -i, --fixnames            Use the fixnames option for gprof
  -z, --usenull             Include NULL values as 0 for mean 
                            calculation
  -r, --reduce &lt;percentage&gt; Aggregate all timers less than percentage 
                            as "other"
  -m, --metadata &lt;filename&gt; XML metadata for the trial

Notes:
  For the TAU profiles type, you can specify either a specific set 
of profile files on the commandline, or you can specify a directory 
(by default the current directory).  The specified directory will be 
searched for profile.*.*.* files, or, in the case of multiple counters, 
directories named MULTI_* containing profile data.

Examples:

  perfdmf_loadtrial -e 12 -n "Batch 001"
    This will load profile.* (or multiple counters directories 
    MULTI_*) into experiment 12 and give the trial the name 
    "Batch 001"

  perfdmf_loadtrial -e 12 -n "HPM data 01" -f hpm perfhpm*
    This will load perfhpm* files of type HPMToolkit into experiment 
    12 and give the trial the name "HPM data 01"

  perfdmf_loadtrial -a "NPB2.3" -x "parametric" -n "64" par64.ppk
    This will load packed profile par64.ppk into the experiment named
    "parametric" under the application named "NPB2.3" and give the 
    trial the name "64".  The application and experiment will be 
    created if not found.
  </pre><p>TAUdb supports a large number of parallel profile formats:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>TAU Profiles (profiles)</strong></span>
	  - Output from the TAU measurement library, these files generally take the
		form of <code class="filename">profile.X.X.X</code>, one for each
		node/context/thread combination.  When multiple counters are used, each
		metric is located in a directory prefixed with "MULTI__".  To launch
		ParaProf with all the metrics, simply launch it from the root of the
		MULTI__ directories.</p></li><li><p><span class="bold"><strong>ParaProf Packed Format
	  (ppk)</strong></span> - Export format supported by PerfDMF/ParaProf.
	  Typically .ppk.  </p></li><li><p><span class="bold"><strong>TAU Merged Profiles
	  (snap)</strong></span> - Merged and snapshot profile format supported by
	  TAU.  Typically tauprofile.xml.</p></li><li><p><span class="bold"><strong>TAU pprof (pprof)</strong></span> - Dump
	  Output from TAU's <span><strong class="command">pprof -d</strong></span>.  Provided for backward
	  compatibility only.</p></li><li><p><span class="bold"><strong>DynaProf (dynaprof)</strong></span> -
	  Output From DynaProf's wallclock and papi probes.  </p></li><li><p><span class="bold"><strong>mpiP (mpip)</strong></span> - Output
	  from mpiP.  </p></li><li><p><span class="bold"><strong>gprof (gprof)</strong></span> - Output
	  from gprof, see also the --fixnames option.  </p></li><li><p><span class="bold"><strong>PerfSuite (psrun)</strong></span> -
	  Output from PerfSuite psrun files.</p></li><li><p><span class="bold"><strong>HPM Toolkit (hpm)</strong></span> -
	  Output from IBM's HPM Toolkit.  </p></li><li><p><span class="bold"><strong>Cube (cube)</strong></span> - Output
	  from Kojak Expert tool for use with Cube.  </p></li><li><p><span class="bold"><strong>Cube3 (cube3)</strong></span> - Output
	  from Kojak Expert tool for use with Cube3 and Cube4.  </p></li><li><p><span class="bold"><strong>HPCToolkit (hpc)</strong></span> - XML
	  data from hpcquick.  Typically, the user runs hpcrun, then hpcquick on
	  the resulting binary file.  </p></li><li><p><span class="bold"><strong>OpenMP Profiler (ompp)</strong></span> -
	  CSV format from the ompP OpenMP Profiler (http://www.ompp-tool.com).  The
	  user must use OMPP_OUTFORMAT=CVS.</p></li><li><p><span class="bold"><strong>PERI XML (perixml)</strong></span> -
	  Output from the PERI data exchange format.</p></li><li><p><span class="bold"><strong>General Purpose Timing Library
	  (gptl)</strong></span> - Output from the General Purpose Timing
	  Library.</p></li><li><p><span class="bold"><strong>Paraver (paraver)</strong></span> -
	  2D output from the Paraver trace analysis tool from
	  BSC.</p></li><li><p><span class="bold"><strong>IPM (ipm)</strong></span> -
	  Integrated Performance Monitoring format, from NERSC.</p></li><li><p><span class="bold"><strong>Google (google)</strong></span> -
	  Google Profiles.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.views"></a>29.4.&nbsp;TAUdb Views</h2></div></div></div><p>In order to provide flexible data management, the application /
	experiment / trial hierarchy was removed in the conversion from PerfDMF to
	TAUdb. In addition, trial metadata was promoted from an XML blob in PerfDMF
	to queryable tables. Users can now organize their data in arbitrary
	hierarchies using Views and SubViews.  Creating and using Views is outlined
	in the ParaProf User Manual, in Chapter 2.
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.schema"></a>Chapter&nbsp;30.&nbsp;Database Schema</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.schema.sql">30.1. SQL for TAUdb</a></span></dt></dl></div><p>
    The database schema in TAUdb is designed to flexibly and efficiently store
    multidimensional parallel performance data. There are 5 dimensions to the
    actual timer measurements, and 4 dimensions to the counter measurements
    </p><p>Timer dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Metric of interest (i.e. FP_OPS, TIME)</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><p>Counter dimensions</p><div class="orderedlist"><ol type="1"><li><p>Process and thread of execution</p></li><li><p>Timer source code location (i.e. foo())</p></li><li><p>Phase of execution (i.e. iteration number, timestamp)</p></li><li><p>Dynamic timer context (i.e. parameter values)</p></li></ol></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.schema.sql"></a>30.1.&nbsp;SQL for TAUdb</h2></div></div></div><p>Below is the SQL schema definition for TAUdb.</p><pre class="screen">
/****************************/
/* CREATE THE STATIC TABLES */
/****************************/

CREATE TABLE schema_version (
 version     INT NOT NULL,
 description VARCHAR NOT NULL
);
/* IF THE SCHEMA IS MODIFIED, INCREMENT THIS VALUE */
/* 0 = PERFDMF (ORIGINAL) */
/* 1 = TAUDB (APRIL, 2012) */
/*VALUES (1, 'TAUdb redesign from Spring, 2012');*/
INSERT INTO schema_version (version, description) 
  VALUES (2, 'Changes after Nov. 9, 2012 release');

/* These are our supported parsers. */
CREATE TABLE data_source (
 id          INT UNIQUE NOT NULL,
 name        VARCHAR NOT NULL,
 description VARCHAR
);

INSERT INTO data_source (name,id,description) 
  VALUES ('ppk',0,'TAU Packed profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('TAU profiles',1,'TAU profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('DynaProf',2,'PAPI DynaProf profiles (UTK)');
INSERT INTO data_source (name,id,description) 
  VALUES ('mpiP',3,'mpiP: Lightweight, Scalable MPI Profiling (Vetter, Chambreau)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPM',4,'HPM Toolkit profiles (IBM)');
INSERT INTO data_source (name,id,description) 
  VALUES ('gprof',5,'gprof profiles (GNU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('psrun',6,'PerfSuite psrun profiles (NCSA)');
INSERT INTO data_source (name,id,description) 
  VALUES ('pprof',7,'TAU pprof.dat output (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube',8,'Cube data (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('HPCToolkit',9,'HPC Toolkit profiles (Rice Univ.)');
INSERT INTO data_source (name,id,description) 
  VALUES ('SNAP',10,'TAU Snapshot profiles (TAU)');
INSERT INTO data_source (name,id,description) 
  VALUES ('OMPP',11,'OpenMP Profiler profiles (Fuerlinger)');
INSERT INTO data_source (name,id,description) 
  VALUES ('PERIXML',12,'Data Exchange Format (PERI)');
INSERT INTO data_source (name,id,description) 
  VALUES ('GPTL',13,'General Purpose Timing Library (ORNL)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Paraver',14,'Paraver profiles (BSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('IPM',15,'Integrated Performance Monitoring (NERSC)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Google',16,'Google profiles (Google)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Cube3',17,'Cube 3D profiles (FZJ)');
INSERT INTO data_source (name,id,description) 
  VALUES ('Gyro',100,'Self-timing profiles from Gyro application');
INSERT INTO data_source (name,id,description) 
  VALUES ('GAMESS',101,'Self-timing profiles from GAMESS application');
INSERT INTO data_source (name,id,description) 
  VALUES ('Other',999,'Other profiles');

/* threads make it convenient to identify timer values.
   Special values for thread_index:
   -1 mean (nulls ignored)
   -2 total
   -3 stddev (nulls ignored)
   -4 min
   -5 max
   -6 mean (nulls are 0 value)
   -7 stddev (nulls are 0 value)
*/

CREATE TABLE derived_thread_type (
 id INT NOT NULL,
 name VARCHAR NOT NULL,
 description VARCHAR NOT NULL
);

INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-1, 'MEAN', 'MEAN (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-2, 'TOTAL', 'TOTAL');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-3, 'STDDEV', 'STDDEV (nulls ignored)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-4, 'MIN', 'MIN');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-5, 'MAX', 'MAX');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-6, 'MEAN', 'MEAN (nulls are 0 value)');
INSERT INTO derived_thread_type (id, name, description) 
  VALUES (-7, 'STDDEV', 'STDDEV (nulls are 0 value)');

/**************************/
/* CREATE THE TRIAL TABLE */
/**************************/

/* trials are the top level table */

CREATE TABLE trial (
 id                  SERIAL NOT NULL PRIMARY KEY,
 name                VARCHAR,
 /* where did this data come from? */
 data_source         INT,
 /* number of processes */
 node_count          INT,
 /* legacy values - these are actually "max" values - i.e. not all nodes have
  * this many threads */
 contexts_per_node   INT,
 /* how many threads per node? */
 threads_per_context INT,
 /* total number of threads */
 total_threads       INT,
 /* reference to the data source table. */
 FOREIGN KEY(data_source) REFERENCES data_source(id) 
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/******************************/
/* CREATE THE DATA DIMENSIONS */
/******************************/

/* threads are the "location" dimension */

CREATE TABLE thread (
 id           SERIAL NOT NULL PRIMARY KEY,
 /* trial this thread belongs to */
 trial        INT NOT NULL,
 /* process rank, really */
 node_rank    INT NOT NULL,
 /* legacy value */
 context_rank INT NOT NULL,
 /* thread rank relative to the process */
 thread_rank  INT NOT NULL,
 /* thread index from 0 to N-1 */
 thread_index INT NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id) ON DELETE 
   NO ACTION ON UPDATE NO ACTION
);

/* metrics are things like num_calls, num_subroutines, TIME, PAPI
   counters, and derived metrics. */

CREATE TABLE metric (
 id      SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial   INT NOT NULL,
 /* name of the metric */
 name    VARCHAR NOT NULL,
 /* if this metric is derived by one of the tools */
 derived BOOLEAN NOT NULL DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timers are timers, capturing some interval value.  For callpath or
   phase profiles, the parent refers to the calling function or phase. */

CREATE TABLE timer (
 id                SERIAL NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial             INT NOT NULL,
 /* name of the timer */
 name              VARCHAR NOT NULL,
 /* short name of the timer - without source or parameter info */
 short_name        VARCHAR NOT NULL,
 /* filename */
 source_file       VARCHAR,
 /* line number of the start of the block of code */
 line_number       INT,
 /* line number of the end of the block of code */
 line_number_end   INT,
 /* column number of the start of the block of code */
 column_number     INT,
 /* column number of the end of the block of code */
 column_number_end INT,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer index on the trial and name columns */
CREATE INDEX timer_trial_index on timer (trial, name);

/***********************************/
/* CREATE THE TIMER RELATED TABLES */
/***********************************/

/* timer groups are the groups such as TAU_DEFAULT,
   MPI, OPENMP, TAU_PHASE, TAU_CALLPATH, TAU_PARAM, etc. 
   This mapping table allows for NxN mappings between timers
   and groups */

CREATE TABLE timer_group (
 timer INT,
 group_name  VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* index for faster queries into groups */
CREATE INDEX timer_group_index on timer_group (timer, group_name);

/* timer parameters are parameter based profile values. 
 * an example is foo (x,y) where x=4 and y=10. In that example,
 * timer would be the index of the timer with the
 * name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. This table would have two
 * entries, one for the x value and one for the y value. */

CREATE TABLE timer_parameter (
 timer     INT,
 parameter_name  VARCHAR NOT NULL,
 parameter_value VARCHAR NOT NULL,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer callpath have the information about the call graph in a trial.
 * If the profile is "flat", these will all have no parents. Otherwise,
 * the parent points to a node in the callgraph, the calling timer 
 * (function). */

CREATE TABLE timer_callpath (
 id        SERIAL NOT NULL PRIMARY KEY,
 /* what timer is this? */
 timer     INT NOT NULL,
 /* what is the parent timer? */
 parent    INT,
 FOREIGN KEY(timer) REFERENCES timer(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* By definition, profiles have no time data. However, there are a few
 * examples where time ranges make sense, such as tracking call stacks
 * or associating metadata to a particular phase. The time_range table
 * is used to give other measurements a time context. The iteration
 * start and end can be used to indicate which loop iterations or 
 * calls to a function are relevant for this time range. */

CREATE TABLE time_range (
 id SERIAL NOT NULL PRIMARY KEY,
 /* starting iteration */
 iteration_start INT NOT NULL,
 /* ending iteration. */
 iteration_end INT,
 /* starting timestamp */
 time_start BIGINT NOT NULL,
 /* ending timestamp. */
 time_end BIGINT
);

/* timer_call_data records have the dynamic information for when a node
 * in the callgraph is visited by a thread. If you are tracking dynamic
 * callstacks, you would use the time_range field. If you are storing
 * snapshot data, you would use the time_range field. */

CREATE TABLE timer_call_data (
 id          SERIAL NOT NULL PRIMARY KEY,
 /* what callgraph node is this? */
 timer_callpath       INT NOT NULL,
 /* what thread is this? */
 thread      INT NOT NULL,
 /* how many times this timer was called */
 calls       INT,
 /* how many subroutines this timer called */
 subroutines INT,
 /* what is the time_range? this is for supporting snapshots */
 time_range  INT,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* timer values have the timer of one timer
   on one thread for one metric, at one location on the callgraph. */

CREATE TABLE timer_value (
 /* what node in the callgraph and thread is this? */
 timer_call_data       INT NOT NULL,
 /* what metric is this? */
 metric                INT NOT NULL,
 /* The inclusive value for this timer */
 inclusive_value       DOUBLE PRECISION,
 /* The exclusive value for this timer */
 exclusive_value       DOUBLE PRECISION,
 /* The inclusive percent for this timer */
 inclusive_percent     DOUBLE PRECISION,
 /* The exclusive percent for this timer */
 exclusive_percent     DOUBLE PRECISION,
 /* The variance for this timer */
 sum_exclusive_squared DOUBLE PRECISION,
 FOREIGN KEY(timer_call_data) REFERENCES timer_call_data(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(metric) REFERENCES metric(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one metric, one thread, one timer */
CREATE INDEX timer_value_index on timer_value (timer_call_data, metric);

/*************************************/
/* CREATE THE COUNTER RELATED TABLES */
/*************************************/

/* counters measure some counted value. */

CREATE TABLE counter (
 id          SERIAL      NOT NULL PRIMARY KEY,
 trial       INT         NOT NULL,
 name        VARCHAR        NOT NULL,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* counter index on the trial and name columns */
CREATE INDEX counter_trial_index on counter (trial, name);

CREATE TABLE counter_value (
 /* what counter is this? */
 counter            INT NOT NULL,
 /* where in the callgraph? */
 timer_callpath     INT,
 /* what thread is this? */
 thread             INT NOT NULL,
 /* The total number of samples */
 sample_count       INT,         
 /* The maximum value seen */
 maximum_value      DOUBLE PRECISION,
 /* The minimum value seen */
 minimum_value      DOUBLE PRECISION,
 /* The mean value seen */
 mean_value         DOUBLE PRECISION,
 /* The variance for this counter */
 standard_deviation DOUBLE PRECISION,
 FOREIGN KEY(counter) REFERENCES counter(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* one thread, one counter */
CREATE INDEX counter_value_index on counter_value (counter, thread);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

CREATE TABLE primary_metadata (
 trial    INT NOT NULL,
 name     VARCHAR NOT NULL,
 value    VARCHAR,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the primary_metadata table */
CREATE INDEX primary_metadata_index on primary_metadata (trial, name);

/* secondary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

CREATE TABLE secondary_metadata (
 id       VARCHAR NOT NULL PRIMARY KEY,
 /* trial this value belongs to */
 trial    INT NOT NULL,
 /* this metadata value could be associated with a thread */
 thread   INT,
 /* this metadata value could be associated with a timer that happened */
 timer_callpath    INT,
 /* which call to the context timer was this? */
 time_range    INT,
 /* this metadata value could be a nested structure */
 parent   VARCHAR,
 /* the name of the metadata field */
 name     VARCHAR NOT NULL,
 /* the value of the metadata field */
 value    VARCHAR,
 /* this metadata value could be an array - so tokenize it */
 is_array BOOLEAN DEFAULT FALSE,
 FOREIGN KEY(trial) REFERENCES trial(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(thread) REFERENCES thread(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(timer_callpath) REFERENCES timer_callpath(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(parent) REFERENCES secondary_metadata(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION,
 FOREIGN KEY(time_range) REFERENCES time_range(id)
   ON DELETE NO ACTION ON UPDATE NO ACTION
);

/* create an index for faster queries against the secondary_metadata table */
CREATE INDEX secondary_metadata_index on secondary_metadata 
   (trial, name, thread, parent);

/**************************************/
/* CREATE THE METADATA RELATED TABLES */
/**************************************/

/* this is the view table, which organizes and filters trials */
create table taudb_view (
    id                    SERIAL            NOT NULL    PRIMARY KEY,
    /* views can be nested */
    parent                INTEGER            NULL,
    /* name of the view */
    name                VARCHAR    NOT NULL,
    /* view conjoin type for parameters */
    conjoin                VARCHAR    NOT NULL,
    FOREIGN KEY (parent) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

create table taudb_view_parameter (
    /* the view ID */
    taudb_view            INTEGER    NOT NULL,
    /* the table name for the where clause */
    table_name            VARCHAR    NOT NULL,
    /* the column name for the where clause.
       If the table_name is one of the metadata tables, this is the 
       value of the "name" column */
    column_name            VARCHAR    NOT NULL,
    /* the operator for the where clause */
    operator            VARCHAR    NOT NULL,
    /* the value for the where clause */
    value                VARCHAR    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
      ON DELETE CASCADE ON UPDATE CASCADE
);

/* simple view of all trials */
INSERT INTO taudb_view (parent, name, conjoin) 
    VALUES (NULL, 'All Trials', 'and');
/* must have a parameter or else the sub views for this view 
   do not work correctly*/
INSERT INTO taudb_view_parameter 
    (taudb_view, table_name, column_name, operator, value) 
	VALUES (1, 'trial', 'total_threads', '&gt;', '-1');

/* the application and experiment columns are not used in the 
   latest schema, but keeping them makes the code in 
   PerfExplorer simpler. */
create table analysis_settings (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    taudb_view          INTEGER         NULL,
    application         INTEGER         NULL,
    experiment          INTEGER         NULL,
    trial               INTEGER         NULL,
    metric              INTEGER         NULL,
    method              VARCHAR(255)    NOT NULL,
    dimension_reduction VARCHAR(255)    NOT NULL,
    normalization       VARCHAR(255)    NOT NULL,
    FOREIGN KEY (taudb_view) REFERENCES taudb_view(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (trial) REFERENCES trial(id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (metric) REFERENCES metric(id)
        ON DELETE CASCADE ON UPDATE CASCADE
);

create table analysis_result (
    id                  SERIAL          NOT NULL    PRIMARY KEY,
    analysis_settings   INTEGER         NOT NULL,
    description         VARCHAR(255)    NOT NULL,
    thumbnail_size      INTEGER         NULL,
    image_size          INTEGER         NULL,
    thumbnail           BYTEA           NULL,
    image               BYTEA           NULL,
    result_type         INTEGER         NOT NULL
);

 /* Performance indexes! */
create index trial_name_index on trial(name);
create index timer_name_index on timer(name);
CREATE INDEX timer_callpath_parent on timer_callpath(parent);
CREATE INDEX thread_trial on thread(trial);
CREATE INDEX timer_call_data_timer_callpath on 
    timer_call_data(timer_callpath);
CREATE INDEX counter_name_index on counter(name);
CREATE INDEX timer_call_data_thread on timer_call_data(thread);

/* SHORT TERM FIX! These views make sure that charts 
   (mostly) work... for now. */

DROP VIEW IF EXISTS interval_location_profile;
DROP VIEW IF EXISTS interval_mean_summary;
DROP VIEW IF EXISTS interval_total_summary;
DROP VIEW IF EXISTS interval_event_value;
DROP VIEW IF EXISTS interval_event;
DROP VIEW IF EXISTS atomic_location_profile;
DROP VIEW IF EXISTS atomic_mean_summary;
DROP VIEW IF EXISTS atomic_total_summary;
DROP VIEW IF EXISTS atomic_event_value;
DROP VIEW IF EXISTS atomic_event;

CREATE OR REPLACE VIEW interval_event 
(id, trial, name, group_name, source_file, line_number, line_number_end) 
AS  
SELECT tcp.id, t.trial, t.name, tg.group_name,  
t.source_file, t.line_number, t.line_number_end  
FROM timer_callpath tcp  
INNER JOIN timer t ON tcp.timer = t.id  
INNER JOIN timer_group tg ON tg.timer = t.id; 

CREATE OR REPLACE VIEW interval_event_value 
(interval_event, node, context, thread, metric, inclusive_percentage,  
inclusive, exclusive_percentage, exclusive, call, subroutines,  
inclusive_per_call, sum_exclusive_squared) 
AS SELECT tcd.timer_callpath, t.node_rank, t.context_rank,  
t.thread_rank, tv.metric, tv.inclusive_percent,  
tv.inclusive_value, tv.exclusive_percent, tv.exclusive_value, tcd.calls, 
tcd.subroutines, tv.inclusive_value / tcd.calls, tv.sum_exclusive_squared 
FROM timer_value tv 
INNER JOIN timer_call_data tcd on tv.timer_call_data = tcd.id 
INNER JOIN thread t on tcd.thread = t.id; 

CREATE OR REPLACE VIEW interval_location_profile 
AS SELECT * from interval_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW interval_total_summary 
AS SELECT * from interval_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW interval_mean_summary 
AS SELECT * from interval_event_value WHERE thread = -1; 
 
 
CREATE OR REPLACE VIEW atomic_event  
(id, trial, name, group_name, source_file, line_number) 
AS SELECT c.id, c.trial, c.name, NULL, NULL, NULL 
FROM counter c; 

CREATE OR REPLACE VIEW atomic_event_value 
(atomic_event, node, context, thread, sample_count, 
maximum_value, minimum_value, mean_value, standard_deviation) 
AS SELECT cv.counter, t.node_rank, t.context_rank, t.thread_rank, 
cv.sample_count, cv.maximum_value, cv.minimum_value, cv.mean_value, 
cv.standard_deviation FROM counter_value cv 
INNER JOIN thread t ON cv.thread = t.id;
 
CREATE OR REPLACE VIEW atomic_location_profile 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= 0; 
 
CREATE OR REPLACE VIEW atomic_total_summary 
AS SELECT * FROM atomic_event_value WHERE thread = -2; 
 
CREATE OR REPLACE VIEW atomic_mean_summary 
AS SELECT * FROM atomic_event_value WHERE thread &gt;= -1; 
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="taudb.capi"></a>Chapter&nbsp;31.&nbsp;TAUdb C API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#taudb.capi.overview">31.1. TAUdb C API Overview</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.structs">31.2. TAUdb C Structures</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.api">31.3. TAUdb C API</a></span></dt><dt><span class="sect1"><a href="#taudb.capi.examples">31.4. TAUdb C API Examples</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taudb.capi.examples.insert">31.4.1. Creating a trial and inserting into the database</a></span></dt><dt><span class="sect2"><a href="#taudb.capi.examples.query">31.4.2. Querying a trial from the database</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.overview"></a>31.1.&nbsp;TAUdb C API Overview</h2></div></div></div><p>The C API for TAUdb is currently under development, but there is a
	beta version of the API available.  The API provides the following
    capabilities: </p><div class="itemizedlist"><ul type="disc"><li><p>Loading trials from the database</p></li><li><p>Inserting trials into the database</p></li><li><p>Parsing TAU profile files</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.structs"></a>31.2.&nbsp;TAUdb C Structures</h2></div></div></div><p>The C structures are roughly organized as a tree, with a trial
        object at the root.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>taudb_trial: </strong></span>
A top-level structure which contains the collections of all the performance data
dimensions.</p></li><li><p><span class="bold"><strong>taudb_primary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial.</p></li><li><p><span class="bold"><strong>taudb_secondary_metadata: </strong></span>
Name/value pairs which describe the properties of the trial. Unlike primary_metadata
values, secondary_metadata objects can have complex value types. They are also associated
with a measurement context - a thread of execution, a timer, a timestamp, an iteration,
etc.</p></li><li><p><span class="bold"><strong>taudb_thread: </strong></span>
A structure which represents a thread of execution in the parallel
measurement.</p></li><li><p><span class="bold"><strong>taudb_time_range: </strong></span>
A structure which holds a time-range value of beginning and ending iteration
numbers or timestamps.</p></li><li><p><span class="bold"><strong>taudb_metric: </strong></span>
A structure which represents a unit of measurement, such as TIME, FP_OPS,
L1_DCM, etc.</p></li><li><p><span class="bold"><strong>taudb_timer: </strong></span>
A structure which represents a region of code. For example, a phase, a 
function, a loop, a basic block, or even a line of code.</p></li><li><p><span class="bold"><strong>taudb_timer_parameter: </strong></span>
A structure which represents parameter values, when parameter based profiling
is used.</p></li><li><p><span class="bold"><strong>taudb_timer_group: </strong></span>
A structure which represents a semantic grouping of timers, such as "I/O",
"MPI", "OpenMP", etc.</p></li><li><p><span class="bold"><strong>taudb_timer_callpath: </strong></span>
A structure which represents a node in the dynamic callpath tree. Timer_callpaths
with a null parent are either top level timers, or a timers in a flat
profile.</p></li><li><p><span class="bold"><strong>taudb_timer_call_data: </strong></span>
A structure which represents a tuple between a thread of execution and a node
on the timer callpath tree.</p></li><li><p><span class="bold"><strong>taudb_timer_value: </strong></span>
A structure which represents a tuple between a timer_call_data object and a
metric. The timer_value contains the measurement of one metric for one timer on
one thread of execution.</p></li><li><p><span class="bold"><strong>taudb_counter: </strong></span>
A structure which represents a counter in the profile. For example, 
the number of bytes transferred on an MPI_Send() timer.</p></li><li><p><span class="bold"><strong>taudb_counter_value: </strong></span>
A structure which represents a counter measurement on one thread of
execution.</p></li></ul></div><p>Below are the object definitions, from the TAUdb C header file.</p><pre class="screen">
#ifndef TAUDB_STRUCTS_H
#define TAUDB_STRUCTS_H 1

#include "time.h"
#include "uthash.h"
#include "taudb_structs.h"

#if defined __TAUDB_POSTGRESQL__
#include "libpq-fe.h"
#elif defined __TAUDB_SQLITE__
#include "sqlite3.h"
#endif

#ifndef boolean
#define TRUE  1
#define FALSE 0
typedef int boolean;
#endif

typedef struct taudb_prepared_statement {
 char* name;
 UT_hash_handle hh; /* hash index for hashing by name */
} TAUDB_PREPARED_STATEMENT;

/* forward declarations to ease objects that need to know about 
 * each other and have doubly-linked relationships */

struct taudb_timer_call_data;
struct taudb_timer_value;
struct taudb_timer_callpath;
struct taudb_timer_group;
struct taudb_timer_parameter;
struct taudb_timer;
struct taudb_counter_value;
struct taudb_counter;
struct taudb_primary_metadata;
struct taudb_secondary_metadata;
struct taudb_time_range;
struct taudb_thread;
struct taudb_metric;
struct taudb_trial;
struct perfdmf_experiment;
struct perfdmf_application;

typedef struct taudb_configuration {
  char* jdbc_db_type;    /* to identify DBMS vendor. 
                          * postgresql, mysql, h2, derby, etc. */
  char* db_hostname;     /* server host name */
  char* db_portnum;      /* server port number */
  char* db_dbname;       /* the database name at the server */
  char* db_schemaprefix; /* the schema prefix. This is appended to 
                          * all table names for some DBMSs */
  char* db_username;     /* the database username */
  char* db_password;     /* the database password for username */
  char* db_schemafile;   /* full or relative path to the schema file, 
                          * used for configuration, not used in C API */
} TAUDB_CONFIGURATION;

typedef enum taudb_database_schema_version {
  TAUDB_2005_SCHEMA,
  TAUDB_2012_SCHEMA
} TAUDB_SCHEMA_VERSION;

typedef struct taudb_data_source {
 int id;
 char* name;
 char*description;
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_DATA_SOURCE;

typedef struct taudb_connection {
  TAUDB_CONFIGURATION *configuration;
#if defined __TAUDB_POSTGRESQL__
  PGconn *connection;
  PGresult *res;
  TAUDB_PREPARED_STATEMENT *statements;
#elif defined __TAUDB_SQLITE__
  sqlite3 *connection;
  sqlite3_stmt *ppStmt;
  int rc; 
#endif
  TAUDB_SCHEMA_VERSION schema_version;
  boolean inTransaction;
  boolean inPortal;
  TAUDB_DATA_SOURCE* data_sources_by_id;
  TAUDB_DATA_SOURCE* data_sources_by_name;
} TAUDB_CONNECTION;

/* these are the derived thread indexes. */

#define TAUDB_MEAN_WITHOUT_NULLS -1
#define TAUDB_TOTAL -2
#define TAUDB_STDDEV_WITHOUT_NULLS -3
#define TAUDB_MIN -4
#define TAUDB_MAX -5
#define TAUDB_MEAN_WITH_NULLS -6
#define TAUDB_STDDEV_WITH_NULLS -7

/* trials are the top level structure */

typedef struct taudb_trial {
 /* actual data from the database */
 int id;
 char* name;
 struct taudb_data_source* data_source;
 int node_count;             /* i.e. number of processes. */
 int contexts_per_node;      /* rarely used, usually 1. */
 int threads_per_context;    /* max number of threads per process 
                              * (can be less on individual processes) */
 int total_threads;          /* total number of threads */
 /* arrays of data for this trial */
 struct taudb_metric* metrics_by_id;
 struct taudb_metric* metrics_by_name;
 struct taudb_thread* threads;
 struct taudb_time_range* time_ranges;
 struct taudb_timer* timers_by_id;
 struct taudb_timer* timers_by_name;
 struct taudb_timer_group* timer_groups;
 struct taudb_timer_callpath* timer_callpaths_by_id;
 struct taudb_timer_callpath* timer_callpaths_by_name;
 struct taudb_timer_call_data* timer_call_data_by_id;
 struct taudb_timer_call_data* timer_call_data_by_key;
 struct taudb_counter* counters_by_id;
 struct taudb_counter* counters_by_name;
 struct taudb_counter_value* counter_values;
 struct taudb_primary_metadata* primary_metadata;
 struct taudb_secondary_metadata* secondary_metadata;
 struct taudb_secondary_metadata* secondary_metadata_by_key;
} TAUDB_TRIAL;

/*********************************************/
/* data dimensions */
/*********************************************/

/* thread represents one physical &amp; logical 
 * location for a measurement. */

typedef struct taudb_thread {
 int id; /* database id, also key to hash */
 struct taudb_trial* trial;
 int node_rank;    /* which process does this thread belong to? */
 int context_rank; /* which context? USUALLY 0 */
 int thread_rank;  /* what is this thread's rank in the process */
 int index;        /* what is this threads OVERALL index? 
                    * ranges from 0 to trial.thread_count-1 */
 struct taudb_secondary_metadata* secondary_metadata;
 UT_hash_handle hh;
} TAUDB_THREAD;

/* metrics are things like TIME, PAPI counters, and derived metrics. */

typedef struct taudb_metric {
 int id; /* database value, also key to hash */
 char* name; /* key to hash hh2 */
 boolean derived;  /* was this metric measured, or created by a 
                    * post-processing tool? */
 UT_hash_handle hh1; /* hash index for hashing by id */
 UT_hash_handle hh2; /* hash index for hashing by name */
} TAUDB_METRIC;

/* Time ranges are ways to delimit the profile data within time ranges.
   They are also useful for secondary metadata which is associated with
   a specific call to a function. */

typedef struct taudb_time_range {
 int id; /* database value, also key to hash */
 int iteration_start;
 int iteration_end;
 uint64_t time_start;
 uint64_t time_end;  /* was this metric measured, 
                      * or created by a post-processing tool? */
 UT_hash_handle hh;
} TAUDB_TIME_RANGE;

/* timers are interval timers, capturing some interval value.  
 * For callpath or phase profiles, the parent refers to the calling 
 * function or phase.  Timers can also be sample locations, or 
 * phases (dynamic or static), or sample aggregations (intermediate) */

typedef struct taudb_timer {
 int id; /* database value, also key to hash */
 struct taudb_trial* trial;  /* pointer back to trial - NOTE: Necessary? */
 char* name;  /* the full timer name, can have file, line, etc. */
 char* short_name;  /* just the function name, for example */
 char* source_file;  /* what source file does this function live in? */
 int line_number;  /* what line does the timer start on? */
 int line_number_end;  /* what line does the timer end on? */
 int column_number;  /* what column number does the timer start on? */
 int column_number_end;  /* what column number does the timer end on? */
 struct taudb_timer_group* groups; /* hash of groups, 
                                    * using group hash handle hh2 */
 struct taudb_timer_parameter* parameters; /* array of parameters */
 UT_hash_handle trial_hash_by_id;  /* hash key for id lookup */
 UT_hash_handle trial_hash_by_name;  /* hash key for name lookup 
                                      * in temporary hash */
 UT_hash_handle group_hash_by_name;  /* hash key for name lookup 
                                      * in timer group */
} TAUDB_TIMER;

/*********************************************/
/* timer related structures  */
/*********************************************/

/* timer groups are the groups such as tau_default,
   mpi, openmp, tau_phase, tau_callpath, tau_param, etc. 
   this mapping table allows for nxn mappings between timers
   and groups */

typedef struct taudb_timer_group {
 char* name;
 struct taudb_timer* timers;   /* hash of timers, 
                                * using timer hash handle hh3 */
 UT_hash_handle trial_hash_by_name;  // hash handle for trial
 UT_hash_handle timer_hash_by_name;  // hash handle for timers
} TAUDB_TIMER_GROUP;

/* timer parameters are parameter based profile values. 
   an example is foo (x,y) where x=4 and y=10. in that example,
   timer would be the index of the timer with the
   name 'foo (x,y) &lt;x&gt;=&lt;4&gt; &lt;y&gt;=&lt;10&gt;'. this table would have two
   entries, one for the x value and one for the y value.
   The parameter can also be a phase / iteration index.
*/

typedef struct taudb_timer_parameter {
 char* name;
 char* value;
 UT_hash_handle hh;
} TAUDB_TIMER_PARAMETER;

/* callpath objects contain the merged dynamic callgraph tree seen
 * during execution */

typedef struct taudb_timer_callpath {
 int id; /* link back to database, and hash key */
 struct taudb_timer* timer; /* which timer is this? */
 struct taudb_timer_callpath *parent; /* callgraph parent */
 char* name; /* a string which has the aggregated callpath. */
 UT_hash_handle hh1; /* hash key for hash by id */
 UT_hash_handle hh2; /* hash key for name (a =&gt; b =&gt; c...) lookup */
} TAUDB_TIMER_CALLPATH;

/* timer_call_data objects are observations of a node of the callgraph
   for one of the threads. */

typedef struct taudb_call_data_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_TIMER_CALL_DATA_KEY;

typedef struct taudb_timer_call_data {
 int id; /* link back to database */
 TAUDB_TIMER_CALL_DATA_KEY key; /* hash table key */
 int calls;  /* number of times this timer was seen */
 int subroutines;  /* number of timers this timer calls */
 struct taudb_timer_value* timer_values;
 UT_hash_handle hh1;
 UT_hash_handle hh2;
} TAUDB_TIMER_CALL_DATA;

/* finally, timer_values are specific measurements during one of the
   observations of the node of the callgraph on a thread. */

typedef struct taudb_timer_value {
 struct taudb_metric* metric;   /* which metric is this? */
 double inclusive;              /* the inclusive value of this metric */
 double exclusive;              /* the exclusive value of this metric */
 double inclusive_percentage;   /* the inclusive percentage of 
                                 * total time of the application */
 double exclusive_percentage;   /* the exclusive percentage of 
                                 * total time of the application */
 double sum_exclusive_squared;  /* how much variance did we see 
                                 * every time we measured this timer? */
 char *key; /* hash table key - metric name */
 UT_hash_handle hh;
} TAUDB_TIMER_VALUE;

/*********************************************/
/* counter related structures  */
/*********************************************/

/* counters measure some counted value. An example would be MPI message size
 * for an MPI_Send.  */

typedef struct taudb_counter {
 int id; /* database reference */
 struct taudb_trial* trial;
 char* name;
 UT_hash_handle hh1; /* hash key for hashing by id */
 UT_hash_handle hh2; /* hash key for hashing by name */
} TAUDB_COUNTER;

/* counters are atomic counters, not just interval timers */

typedef struct taudb_counter_value_key {
 struct taudb_counter* counter; /* the counter we are measuring */
 struct taudb_thread* thread;   /* where this measurement is */
 struct taudb_timer_callpath* context; /* the calling context (can be null) */
 char* timestamp; /* timestamp in case we are in a snapshot or something */
} TAUDB_COUNTER_VALUE_KEY;

typedef struct taudb_counter_value {
 TAUDB_COUNTER_VALUE_KEY key;
 int sample_count;          /* how many times did we see take this count? */
 double maximum_value;      /* what was the max value we saw? */
 double minimum_value;      /* what was the min value we saw? */
 double mean_value;         /* what was the average value we saw? */
 double standard_deviation; /* how much variance was there? */
 UT_hash_handle hh1; /* hash key for hashing by key */
} TAUDB_COUNTER_VALUE;

/*********************************************/
/* metadata related structures  */
/*********************************************/

/* primary metadata is metadata that is not nested, does not
   contain unique data for each thread. */

typedef struct taudb_primary_metadata {
 char* name;
 char* value;
 UT_hash_handle hh; /* uses the name as the key */
} TAUDB_PRIMARY_METADATA;

/* primary metadata is metadata that could be nested, could
   contain unique data for each thread, and could be an array. */

typedef struct taudb_secondary_metadata_key {
 struct taudb_timer_callpath *timer_callpath; /* link back to database */
 struct taudb_thread *thread; /* link back to database, roundabout way */
 struct taudb_secondary_metadata* parent; /* self-referencing */
 struct taudb_time_range* time_range;
 char* name;
} TAUDB_SECONDARY_METADATA_KEY;

typedef struct taudb_secondary_metadata {
 char* id; /* link back to database */
 TAUDB_SECONDARY_METADATA_KEY key;
 int num_values; /* can have arrays of data */
 char** value;
 int child_count;
 struct taudb_secondary_metadata* children; /* self-referencing  */
 UT_hash_handle hh; /* uses the id as a compound key */
 UT_hash_handle hh2; /* uses the key as a compound key */
} TAUDB_SECONDARY_METADATA;

/* these are for supporting the older schema */

typedef struct perfdmf_experiment {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_EXPERIMENT;

typedef struct perfdmf_application {
 int id;
 char* name;
 struct taudb_primary_metadata* primary_metadata;
} PERFDMF_APPLICATION;

#endif /* TAUDB_STRUCTS_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.api"></a>31.3.&nbsp;TAUdb C API</h2></div></div></div><pre class="screen">
#ifndef TAUDB_API_H
#define TAUDB_API_H 1

#include "taudb_structs.h"

/* when a "get" function is called, this global has the number of 
   top-level objects that are returned. */
extern int taudb_numItems;

/* the database version */
extern enum taudb_database_schema_version taudb_version;

/* to connect to the database */
extern TAUDB_CONNECTION* taudb_connect_config(char* config_name);
extern TAUDB_CONNECTION* taudb_connect_config_file(char* config_file_name);

/* test the connection status */
extern int taudb_check_connection(TAUDB_CONNECTION* connection);

/* disconnect from the database */
extern int taudb_disconnect(TAUDB_CONNECTION* connection);

/************************************************/
/* query functions */
/************************************************/

/* functions to support the old database schema - avoid these if you can */
extern PERFDMF_APPLICATION* 
    perfdmf_query_applications(TAUDB_CONNECTION* connection);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiments(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application);
extern PERFDMF_APPLICATION* 
    perfdmf_query_application(TAUDB_CONNECTION* connection, char* name);
extern PERFDMF_EXPERIMENT* 
    perfdmf_query_experiment(TAUDB_CONNECTION* connection, 
	PERFDMF_APPLICATION* application, char* name);
extern TAUDB_TRIAL* perfdmf_query_trials(TAUDB_CONNECTION* connection, 
    PERFDMF_EXPERIMENT* experiment);

/* get the data sources */
extern TAUDB_DATA_SOURCE* 
    taudb_query_data_sources(TAUDB_CONNECTION* connection);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_id(TAUDB_DATA_SOURCE* data_sources, 
	const int id);
extern TAUDB_DATA_SOURCE* 
    taudb_get_data_source_by_name(TAUDB_DATA_SOURCE* data_sources, 
	const char* name);

/* using the properties set in the filter, find a set of trials */
extern TAUDB_TRIAL* 
    taudb_query_trials(TAUDB_CONNECTION* connection, boolean complete, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_query_primary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);
extern TAUDB_PRIMARY_METADATA* 
    taudb_get_primary_metadata_by_name(TAUDB_PRIMARY_METADATA* primary_metadata, 
	const char* name);
extern TAUDB_SECONDARY_METADATA* 
    taudb_query_secondary_metadata(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* filter);

/* get the threads for a trial */
extern TAUDB_THREAD* 
    taudb_query_threads(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_query_derived_threads(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_THREAD* 
    taudb_get_thread(TAUDB_THREAD* threads, int thread_index);
extern int taudb_get_total_threads(TAUDB_THREAD* threads);

/* get the metrics for a trial */
extern TAUDB_METRIC* 
    taudb_query_metrics(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_METRIC* 
    taudb_get_metric_by_name(TAUDB_METRIC* metrics, const char* name);
extern TAUDB_METRIC* 
    taudb_get_metric_by_id(TAUDB_METRIC* metrics, const int id);

/* get the time_ranges for a trial */
extern TAUDB_TIME_RANGE* 
    taudb_query_time_range(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIME_RANGE* 
    taudb_get_time_range(TAUDB_TIME_RANGE* time_ranges, const int id);

/* get the timers for a trial */
extern TAUDB_TIMER* 
    taudb_query_timers(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_TIMER* 
    taudb_get_timer_by_id(TAUDB_TIMER* timers, int id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER* 
    taudb_get_trial_timer_by_name(TAUDB_TIMER* timers, const char* id);
extern TAUDB_TIMER_GROUP* 
    taudb_query_timer_groups(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern void 
    taudb_parse_timer_group_names(TAUDB_TRIAL* trial, TAUDB_TIMER* timer, 
	char* group_names);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_trial_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_GROUP* 
    taudb_get_timer_group_from_timer_by_name(TAUDB_TIMER_GROUP* timers, 
	const char* name);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER* timer);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_id(TAUDB_TIMER_CALLPATH* timers, int id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_get_timer_callpath_by_name(TAUDB_TIMER_CALLPATH* timers, 
	const char* id);
extern TAUDB_TIMER_CALLPATH* 
    taudb_query_all_timer_callpaths(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern char* taudb_get_callpath_string(TAUDB_TIMER_CALLPATH* timer_callpath);

/* get the counters for a trial */
extern TAUDB_COUNTER* 
    taudb_query_counters(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_id(TAUDB_COUNTER* counters, int id);
extern TAUDB_COUNTER* 
    taudb_get_counter_by_name(TAUDB_COUNTER* counters, const char* id);
extern TAUDB_COUNTER_VALUE* 
    taudb_query_counter_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
TAUDB_COUNTER_VALUE* 
    taudb_get_counter_value(TAUDB_COUNTER_VALUE* counter_values, 
	TAUDB_COUNTER* counter, TAUDB_THREAD* thread, 
	TAUDB_TIMER_CALLPATH* context, char* timestamp);

/* get the timer call data for a trial */
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_query_all_timer_call_data_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_id(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	int id);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_get_timer_call_data_by_key(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_TIMER_CALLPATH* callpath, TAUDB_THREAD* thread, char* timestamp);

/* get the timer values for a trial */
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial, TAUDB_TIMER_CALLPATH* timer_callpath, 
	TAUDB_THREAD* thread, TAUDB_METRIC* metric);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_values(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_query_all_timer_stats(TAUDB_CONNECTION* connection, 
	TAUDB_TRIAL* trial);
extern TAUDB_TIMER_VALUE* 
    taudb_get_timer_value(TAUDB_TIMER_CALL_DATA* timer_call_data, 
	TAUDB_METRIC* metric);

/* find main */
extern TAUDB_TIMER* 
    taudb_query_main_timer(TAUDB_CONNECTION* connection, TAUDB_TRIAL* trial);

/* save everything */
extern void taudb_save_trial(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update, boolean cascade);
extern void taudb_save_threads(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_metrics(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timers(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_time_ranges(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_groups(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_parameters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_callpaths(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_call_data(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_timer_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counters(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_counter_values(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_primary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);
extern void taudb_save_secondary_metadata(TAUDB_CONNECTION* connection, 
    TAUDB_TRIAL* trial, boolean update);

/************************************************/
/* memory functions */
/************************************************/

extern char* taudb_strdup(const char* in_string);
extern TAUDB_TRIAL* taudb_create_trials(int count);
extern TAUDB_METRIC*             taudb_create_metrics(int count);
extern TAUDB_TIME_RANGE*         taudb_create_time_ranges(int count);
extern TAUDB_THREAD*             taudb_create_threads(int count);
extern TAUDB_SECONDARY_METADATA* taudb_create_secondary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_create_primary_metadata(int count);
extern TAUDB_PRIMARY_METADATA*   taudb_resize_primary_metadata(int count, 
    TAUDB_PRIMARY_METADATA* old_primary_metadata);
extern TAUDB_COUNTER*            taudb_create_counters(int count);
extern TAUDB_COUNTER_VALUE*      taudb_create_counter_values(int count);
extern TAUDB_TIMER*              taudb_create_timers(int count);
extern TAUDB_TIMER_PARAMETER*    taudb_create_timer_parameters(int count);
extern TAUDB_TIMER_GROUP*        taudb_create_timer_groups(int count);
extern TAUDB_TIMER_GROUP*        taudb_resize_timer_groups(int count, 
    TAUDB_TIMER_GROUP* old_groups);
extern TAUDB_TIMER_CALLPATH*     taudb_create_timer_callpaths(int count);
extern TAUDB_TIMER_CALL_DATA*    taudb_create_timer_call_data(int count);
extern TAUDB_TIMER_VALUE*        taudb_create_timer_values(int count);

extern void taudb_delete_trials(TAUDB_TRIAL* trials, int count);

/************************************************/
/* Adding objects to the hierarchy */
/************************************************/

extern void taudb_add_metric_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_METRIC* metric);
extern void taudb_add_time_range_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIME_RANGE* time_range);
extern void taudb_add_thread_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_THREAD* thread);
extern void taudb_add_secondary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_SECONDARY_METADATA* secondary_metadata);
extern void taudb_add_secondary_metadata_to_secondary_metadata
    (TAUDB_SECONDARY_METADATA* parent, TAUDB_SECONDARY_METADATA* child);
extern void taudb_add_primary_metadata_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_PRIMARY_METADATA* primary_metadata);
extern void taudb_add_counter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER* counter);
extern void taudb_add_counter_value_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_COUNTER_VALUE* counter_value);
extern void taudb_add_timer_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_parameter_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_PARAMETER* timer_parameter);
extern void taudb_add_timer_group_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_GROUP* timer_group);
extern void taudb_add_timer_to_timer_group(TAUDB_TIMER_GROUP* timer_group, 
    TAUDB_TIMER* timer);
extern void taudb_add_timer_callpath_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALLPATH* timer_callpath);
extern void taudb_add_timer_call_data_to_trial(TAUDB_TRIAL* trial, 
    TAUDB_TIMER_CALL_DATA* timer_call_data);
extern void taudb_add_timer_value_to_timer_call_data
    (TAUDB_TIMER_CALL_DATA* timer_call_data, TAUDB_TIMER_VALUE* timer_value);

/* Profile parsers */
extern TAUDB_TRIAL* taudb_parse_tau_profiles(const char* directory_name);

/* Analysis routines */
extern void taudb_compute_statistics(TAUDB_TRIAL* trial);

/* iterators */
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_name_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_DATA_SOURCE* 
    taudb_next_data_source_by_id_from_connection
	(TAUDB_DATA_SOURCE* current);
extern TAUDB_THREAD* 
    taudb_next_thread_by_index_from_trial(TAUDB_THREAD* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_name_from_trial(TAUDB_METRIC* current);
extern TAUDB_METRIC* 
    taudb_next_metric_by_id_from_trial(TAUDB_METRIC* current);
extern TAUDB_TIME_RANGE* 
    taudb_next_time_range_by_id_from_trial(TAUDB_TIME_RANGE* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_id_from_trial(TAUDB_TIMER* current);
extern TAUDB_TIMER* 
    taudb_next_timer_by_name_from_group(TAUDB_TIMER* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_trial
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_GROUP* 
    taudb_next_timer_group_by_name_from_timer
	(TAUDB_TIMER_GROUP* current);
extern TAUDB_TIMER_PARAMETER* 
    taudb_next_timer_parameter_by_name_from_timer
	(TAUDB_TIMER_PARAMETER* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_name_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALLPATH* 
    taudb_next_timer_callpath_by_id_from_trial
	(TAUDB_TIMER_CALLPATH* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_key_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_CALL_DATA* 
    taudb_next_timer_call_data_by_id_from_trial
	(TAUDB_TIMER_CALL_DATA* current);
extern TAUDB_TIMER_VALUE* 
    taudb_next_timer_value_by_metric_from_timer_call_data
	(TAUDB_TIMER_VALUE* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_name_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER* 
    taudb_next_counter_by_id_from_trial(TAUDB_COUNTER* current);
extern TAUDB_COUNTER_VALUE* 
    taudb_next_counter_value_by_key_from_trial(TAUDB_COUNTER_VALUE* current);
extern TAUDB_PRIMARY_METADATA* 
    taudb_next_primary_metadata_by_name_from_trial
	(TAUDB_PRIMARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_key_from_trial
	(TAUDB_SECONDARY_METADATA* current);
extern TAUDB_SECONDARY_METADATA* 
    taudb_next_secondary_metadata_by_id_from_trial
	(TAUDB_SECONDARY_METADATA* current);

#endif /* TAUDB_API_H */
	</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="taudb.capi.examples"></a>31.4.&nbsp;TAUdb C API Examples</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.insert"></a>31.4.1.&nbsp;Creating a trial and inserting into the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include "dump_functions.h"

int main (int argc, char** argv) {
  TAUDB_CONNECTION* connection = NULL;
  if (argc &gt;= 2) {
    connection = taudb_connect_config(argv[1]);
  } else {
    fprintf(stderr, "Please specify a TAUdb config file.\n");
    exit(1);
  }
  printf("Checking connection...\n");
  taudb_check_connection(connection);

  // create a trial
  TAUDB_TRIAL* trial = taudb_create_trials(1);
  trial-&gt;name = taudb_strdup("TEST TRIAL");
  // set the data source to "other"
  trial-&gt;data_source = taudb_get_data_source_by_id(
      taudb_query_data_sources(connection), 999);
  
  // create some metadata
  TAUDB_PRIMARY_METADATA* pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Application");
  pm-&gt;value = taudb_strdup("Test Application");
  taudb_add_primary_metadata_to_trial(trial, pm);

  pm = taudb_create_primary_metadata(1);
  pm-&gt;name = taudb_strdup("Start Time");
  pm-&gt;value = taudb_strdup("2012-11-07 12:30:00");
  taudb_add_primary_metadata_to_trial(trial, pm);

  // alternatively, you can allocate the primary metadata in blocks
  pm = taudb_create_primary_metadata(10);
  pm[0].name = taudb_strdup("ClientID");
  pm[0].value = taudb_strdup("joe_user");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[0]));
  pm[1].name = taudb_strdup("hostname");
  pm[1].value = taudb_strdup("hopper04");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[1]));
  pm[2].name = taudb_strdup("Operating System");
  pm[2].value = taudb_strdup("Linux");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[2]));
  pm[3].name = taudb_strdup("Release");
  pm[3].value = taudb_strdup("2.6.32.36-0.5-default");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[3]));
  pm[4].name = taudb_strdup("Machine");
  pm[4].value = taudb_strdup("Hopper.nersc.gov");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[4]));
  pm[5].name = taudb_strdup("CPU Cache Size");
  pm[5].value = taudb_strdup("512 KB");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[5]));
  pm[6].name = taudb_strdup("CPU Clock Frequency");
  pm[6].value = taudb_strdup("800.000 MHz");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[6]));
  pm[7].name = taudb_strdup("CPU Model");
  pm[7].value = taudb_strdup("Quad-Core AMD Opteron(tm) Processor 8378");
  taudb_add_primary_metadata_to_trial(trial, &amp;(pm[7]));

  // create a metric
  TAUDB_METRIC* metric = taudb_create_metrics(1);
  metric-&gt;name = taudb_strdup("TIME");
  taudb_add_metric_to_trial(trial, metric);

  // create a thread
  TAUDB_THREAD* thread = taudb_create_threads(1);
  thread-&gt;node_rank = 1;
  thread-&gt;context_rank = 1;
  thread-&gt;thread_rank = 1;
  thread-&gt;index = 1;
  taudb_add_thread_to_trial(trial, thread);

  // create a timer, timer_callpath, timer_call_data, timer_value
  TAUDB_TIMER_GROUP* timer_group = taudb_create_timer_groups(1);
  TAUDB_TIMER* timer = taudb_create_timers(1);
  TAUDB_TIMER_CALLPATH* timer_callpath = taudb_create_timer_callpaths(1);
  TAUDB_TIMER_CALL_DATA* timer_call_data = taudb_create_timer_call_data(1);
  TAUDB_TIMER_VALUE* timer_value = taudb_create_timer_values(1);

  timer-&gt;name = taudb_strdup(
      "int main(int, char **) [{kernel.c} {134,1}-{207,1}]");
  timer-&gt;short_name = taudb_strdup("main");
  timer-&gt;source_file = taudb_strdup("kernel.c");
  timer-&gt;line_number = 134;
  timer-&gt;column_number = 1;
  timer-&gt;line_number_end = 207;
  timer-&gt;column_number_end = 1;
  taudb_add_timer_to_trial(trial, timer);

  timer_group-&gt;name = taudb_strdup("TAU_DEFAULT");
  taudb_add_timer_group_to_trial(trial, timer_group);
  taudb_add_timer_to_timer_group(timer_group, timer);

  timer_callpath-&gt;timer = timer;
  timer_callpath-&gt;parent = NULL;
  taudb_add_timer_callpath_to_trial(trial, timer_callpath);

  timer_call_data-&gt;key.timer_callpath = timer_callpath;
  timer_call_data-&gt;key.thread = thread;
  timer_call_data-&gt;calls = 1;
  timer_call_data-&gt;subroutines = 0;
  taudb_add_timer_call_data_to_trial(trial, timer_call_data);

  timer_value-&gt;metric = metric;
  // 5 seconds, or 5 million microseconds
  timer_value-&gt;inclusive = 5000000; 
  timer_value-&gt;exclusive = 5000000;
  timer_value-&gt;inclusive_percentage = 100.0;
  timer_value-&gt;exclusive_percentage = 100.0;
  timer_value-&gt;sum_exclusive_squared = 0.0;
  taudb_add_timer_value_to_timer_call_data(timer_call_data, timer_value);

  // compute stats
  printf("Computing Stats...\n");
  taudb_compute_statistics(trial);

  // save the trial!
  printf("Testing inserts...\n");
  boolean update = FALSE;
  boolean cascade = TRUE;
  taudb_save_trial(connection, trial, update, cascade);
  
  printf("Disconnecting...\n");
  taudb_disconnect(connection);
  printf("Done.\n");
  return 0;
}
	    </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="taudb.capi.examples.query"></a>31.4.2.&nbsp;Querying a trial from the database</h3></div></div></div><pre class="screen">
#include "taudb_api.h"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void dump_metadata(TAUDB_PRIMARY_METADATA *metadata) {
   printf("%d metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_PRIMARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_primary_metadata_by_name_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;name, current-&gt;value);
   }
}

void dump_secondary_metadata(TAUDB_SECONDARY_METADATA *metadata) {
   printf("%d secondary metadata fields:\n", HASH_COUNT(metadata));
   TAUDB_SECONDARY_METADATA * current;
   for(current = metadata; current != NULL; 
       current = taudb_next_secondary_metadata_by_key_from_trial(current)) {
     printf("  %s = %s\n", current-&gt;key.name, current-&gt;value[0]);
   }
}

void dump_trial(TAUDB_CONNECTION* connection, TAUDB_TRIAL* filter, 
                boolean haveTrial) {
   TAUDB_TRIAL* trial;
   if (haveTrial) {
     trial = filter;
   } else {
     trial = taudb_query_trials(connection, FALSE, filter);
   }
   TAUDB_TIMER* timer = taudb_query_main_timer(connection, trial);
   printf("Trial name: '%s', id: %d, main: '%s'\n\n", 
          trial-&gt;name, trial-&gt;id, timer-&gt;name);
}

int main (int argc, char** argv) {
   printf("Connecting...\n");
   TAUDB_CONNECTION* connection = NULL;
   if (argc &gt;= 2) {
     connection = taudb_connect_config(argv[1]);
   } else {
     fprintf(stderr, "Please specify a TAUdb config file.\n");
     exit(1);
   }
   printf("Checking connection...\n");
   taudb_check_connection(connection);
   printf("Testing queries...\n");

   int t;

   // test the "find trials" method to populate the trial
   TAUDB_TRIAL* filter = taudb_create_trials(1);
   filter-&gt;id = atoi(argv[2]);
   TAUDB_TRIAL* trials = taudb_query_trials(connection, TRUE, filter);
   int numTrials = taudb_numItems;
   for (t = 0 ; t &lt; numTrials ; t = t+1) {
      printf("  Trial name: '%s', id: %d\n", 
	         trials[t].name, trials[t].id);
      dump_metadata(trials[t].primary_metadata);
      dump_secondary_metadata(trials[t].secondary_metadata);
      dump_trial(connection, &amp;(trials[t]), TRUE);
   }

   printf("Disconnecting...\n");
   taudb_disconnect(connection);
   printf("Done.\n");
   return 0;
}
	    </pre></div></div></div></div></div>
       </div>
       <?php include("../../footer.php") ?>
    </body></html>
