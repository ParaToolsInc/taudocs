<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "../tools/docbook-xml-4.4/docbookx.dtd"> 

<chapter id="tau.installation">

  <title>Installation</title>

<!--  <simplesect> -->
      <para> TAU (Tuning and Analysis Utilities) is a portable profiling and 
      tracing toolkit for performance analysis of parallel programs written 
      in Fortran, C++, C, Java and Python.  The model that TAU uses to profile 
      parallel, multi-threaded programs maintains performance data for each 
      thread, context, and node in use by an application. The profiling 
      instrumentation needed to implement the model captures data for 
      functions, methods, basic blocks, and statement execution at these 
      levels. All C++ language features are supported in the TAU profiling 
      instrumentation including templates and namespaces, which is available 
      through an API at the library or application level. The API also 
      provides selection of profiling groups for organizing and controlling 
      instrumentation. The instrumentation can be inserted in the source code 
      using an automatic instrumentor tool based on the Program Database 
      Toolkit (PDT), dynamically using DyninstAPI, at runtime in the Java 
      virtual machine, or manually using the instrumentation API.  TAU's 
      profile visualization tool, paraprof, provides graphical displays of 
      all the performance analysis results, in aggregate and single 
      node/context/thread forms.  The user can quickly identify sources of 
      performance bottlenecks in the application using the graphical 
      interface. In addition, TAU can generate event traces that can be 
      displayed with the Vampir or Paraver trace visualization tools.  
      This chapter discusses installation of the TAU portable profiling 
      package.</para>
      
      <para>
      Some tau options allow external resources to be automatically downloaded 
      and built when TAU is configured. To obtain these resources in a single
      package download  http://tau.uoregon.edu/ext.tgz and unpack it in TAU's
      root directory. When you configure TAU with:
      
      <itemizedlist>
		<listitem>
			<para>
				<literal>
				-bfd=download
				</literal>
			</para>
		</listitem>
		<listitem>
			<para>
				<literal>
				-unwind=download
				</literal>
			</para>
		</listitem>
		<listitem>
			<para>
				<literal>
				-ompt=download
				</literal>
			</para>
		</listitem>
	</itemizedlist>
      these packages will be provided by the ext.tgz package and no additional
      network activity will be required.
      </para>
<!--  </simplesect> -->

  <sect1 id="installing.tau">
    
    <title>Installing TAU</title>

		<sect2><title>Know what options you will need</title>

			<para>Each TAU configuration results in a single
			<literal>Makefile</literal>. These <literal>Makefiles</literal> denote
			the configuration that produced it and is used by the user to select
			the TAU libraries/scripts associated with its configuration. (These
			makefiles are named after the configuration options, ie. TAU configured with
			MPI, PDT, PGI compilers and the '-nocomm' option is named:
			<literal>Makefile.tau-nocomm-mpi-pdt-pgi</literal>). On most machines
			several configuration of TAU will need to be built in order to take full
			advantage of the many features of TAU. This section should help you
			decide on the smallest set of configuration you will need to build.</para>
			<para>
			The options used to configure TAU can be grouped into two
			categories:
			<itemizedlist>
				<listitem>
					<para>
					External packages: TAU will use these when instrumenting or measuring an
					application. <emphasis>Configuring with these options does
					not force the user to
					use these packages</emphasis>, ie: configuring with PDT does not force the user
					to use source code based instrumentation (they can use
					compiler based instrumentation instead). Similarly configuring with
					PAPI does not forces the user to select any PAPI counters when
					profiling.
					<note>
						<para>
						The only exception is configuring with the epilog (scalasca) tracing
						package. This will replace the TAU tracer with the epliog one, a single
						configuration cannot use both tracers.
						</para>
					</note>
					</para>
					<para>
					For this reason it is recommend that you <emphasis>configure with every external
					packages that the user might be interested in using</emphasis>, letting them choose
					which packages to enable when they go to instrument or measure their
					application.</para>
				</listitem>
				<listitem>
					<para>
					Compiler and MPI options: these control the behavior of TAU when it compiles the
					instrumented application. TAU provides compiler wrapper scripts,
					these options control which compiler TAU will wrap, <emphasis>These
					options are determinative: select only options that are
				  compatible.</emphasis> For example, when configuring with MPI use a
					version of MPI compatible with the compiler you select.</para>

					<para>Since multiple compiler/MPI libraries cannot be specified for a
					single configuration, <emphasis>each set of compiler/MPI libraries that you want
					to use with TAU need to be configured separately.</emphasis></para>

					<note>
						<para>
						Configurations with different compilers are given separate
						<literal>Makefiles</literal> automatically, however configurations with different
						MPI implementations are not. Use the <literal>-tag=</literal> option
						to distinguish between different MPIs, ie:
						<literal>-tag=mvapich</literal> or
						<literal>-tag=openmpi</literal>.
						</para>
					</note>
				</listitem>
		</itemizedlist>
		</para>

    <para>The <literal>configure</literal> shell script attempts to guess 
    correct values for various system-dependent variables used during 
    compilation (compilers and system architecture), other options need to be
		specified on the command line.</para>
    <para>The following are the most important command-line options are available to configure:</para>
		</sect2>

		<sect2>
			<title>Common configuration options</title>

			<sect3><title>Select compiler</title>
			
			<para>TAU defaults to using any compilers found in the environment. To
			use a specific compiler use these options:</para>
      <itemizedlist>
      <listitem>

	<para><literal>-c++=&lt;C++ compiler&gt;</literal></para>

        <para>Specifies the name of the C++ compiler. Supported C++ 
        compilers include KCC (from KAI/Intel), CC (SGI, Sun), g++ 
        (from GNU), FCC (from Fujitsu), xlC (from IBM), guidec++ 
        (from KAI/Intel), cxx (Tru64) and aCC (from HP), c++ (from Apple), 
        icpc and ecpc (from Intel) and pgCC (from PGI).</para>

      </listitem>

      <listitem>
	<para><literal>-cc=&lt;C Compiler&gt;</literal></para>

        <para> Specifies the name of the C compiler. Supported C 
        compilers include cc, gcc (from GNU), pgcc (from PGI), 
        fcc (from Fujitsu), xlc (from IBM), and KCC (from KAI/ Intel), 
        icc and ecc (from Intel).</para>

      </listitem>
      <listitem>

	<para><literal>-fortran=&lt;Fortran Compiler&gt;</literal></para>

        <para>Specifies the name of the Fortran90 compiler. Valid options are: 
        gnu, sgi, ibm, ibm64, intel, cray, pgi, absoft, fujitsu, sun, kai, nec, 
        hitachi, compaq, nagware, g95 and hp.</para>

      </listitem>
			</itemizedlist>
			
			</sect3>

			<sect3><title>Using MPI</title>

				<para>To profile a program that use MPI configure TAU with these
				options:</para>
			<itemizedlist>

      <listitem>
	<para><literal>-mpi</literal></para>

	<para>With this option, TAU will try to guess the location of the MPI
	libraries if the mpirun command is in your path. This does not always work in
	which case use these more detailed options:</para>
	
			</listitem>
			<listitem>
	<para><literal>-mpiinc=&lt;dir&gt;</literal></para>

        <para>Specifies the directory where MPI header files reside (such as 
        mpi.h and mpif.h).  This option also generates the TAU MPI wrapper 
        library that instruments MPI routines using the MPI Profiling 
        Interface. See the examples/NPB2.3/config/make.def file for its 
        usage with Fortran and MPI programs. <ulink
		  url="http://www-unix.mcs.anl.gov/mpi/">MPI</ulink></para>

    </listitem>

    <listitem>

      <para><literal>-mpilib=&lt;dir&gt;</literal></para>

      <para>Specifies the directory where MPI library files reside. This option
      should be used in conjunction with the -mpiinc=&lt;dir&gt; option to
      generate the TAU MPI wrapper library. </para>

    </listitem>

    <listitem>

      <para><literal>-mpilibrary=&lt;lib&gt;</literal></para>

      <para>Specifies the use of a different MPI library. By default, TAU uses
      -lmpi or -lmpich as the MPI library. This option allows the user to 
      specify another library. e.g., -mpilibrary=-lmpi_r for specifying a 
      thread-safe MPI library.</para>

    </listitem>
			</itemizedlist>


			</sect3>

			<sect3><title>OpenMP</title>
			<para>To profile programs using openmp use -openm and either 
			OPARI option:</para>

			<itemizedlist>

      <listitem>
	<para><literal>-openmp</literal></para>

        <para>Specifies OpenMP as the threads package to be used.
        <ulink url="http://www.open-mpi.org/">Open MPI</ulink></para>

      </listitem>

      <listitem>

	<para><literal>-opari</literal></para>

        <para>The use of Opari2 source-to-source instrumentor in conjunction 
        with TAU exposes OpenMP events for instrumentation. See 
        examples/opari directory. <ulink
		  url="ihttp://www.vi-hps.org/projects/score-p/">OPARI</ulink> </para>

      </listitem>
      <listitem>

	<para><literal>-opari1</literal></para>

        <para>Use this option for the use of the original Opari.
        Only use this option if -opari fails. <ulink
		  url="http://www.fz-juelich.de/zam/kojak/opari/">OPARI</ulink> </para>

      </listitem>
			</itemizedlist>
		</sect3>
		</sect2>

		<sect2><title>Configuring with external packages</title>

			<itemizedlist>
      <listitem>

	<para><literal>-pdt=&lt;directory&gt;</literal></para>

        <para>Specifies the location of the installed PDT (Program Database 
        Toolkit) root directory. PDT is used to build tau_instrumentor, 
        a C++, C and F90 instrumentation program that automatically inserts 
        TAU annotations in the source code <ulink
		  url="http://www.cs.uoregon.edu/research/pdt">PDT</ulink>.  If PDT is configured 
        with a subdirectory option (-compdir=&lt;opt&gt;) then TAU can be 
        configured with the same option.</para>

      </listitem>
      
			<listitem>

	<para><literal>-pdt_c++=&lt;C++ Compiler&gt;</literal></para>

        <para>Specifies a different C++ compiler for PDT (tau_instrumentor). 
        This is typically used when the library is compiled with a C++ 
        compiler (specified with -c++) and the tau_instrumentor is compiled 
        with a different &lt;pdt_c++&gt; compiler. For e.g., </para>


	<screen>-arch=craycnl -pdt=/usr/pdtoolkit-3.17 -pdt_c++=g++ ...</screen>

        <para>uses g++ to compile the tau_instrumentor, for example on CRAY XT5
				systems use this option to build TAU any of the backend compilers.</para>

        <screen>-arch=bgp -pdt=/usr/pdtoolkit-3.17 -pdt_c++=xlC -mpi</screen>

        <para>uses PDT, MPI for IBM BG/P and specifies the use of the front-end
        xlC compiler for building tau_instrumentor.</para>

      </listitem>


      <listitem>

	<para><literal>-papi=&lt;directory&gt;</literal></para>

        <para>Specifies the location of the installed PAPI (Performance 
        Data Standard and API) root directory. PCL provides a common 
        interface to access hardware performance counters and timers on 
        modern microprocessors. Most modern CPUs provide on-chip hardware 
        performance counters that can record several events such as the 
        number of instructions issued, floating point operations performed, 
        the number of primary and secondary data and instruction cache misses.
        To measure floating point instructions, set the environment 
        variable TAU_METRICS to PAPI_FP_INS (for example). This option (by 
        default) specifies the use of hardware performance counters for 
        profiling (instead of time).
		  
		  <ulink url="http://icl.cs.utk.edu/papi/">PAPI</ulink>
				</para>
      </listitem>

    <listitem>
      
      <para><literal>-epilog=&lt;dir&gt;</literal></para>

      <para>Specifies the directory where the EPILOG tracing package 
      <ulink url="http://www.fz-juelich.de/zam/kojak/epilog/">EPILOG</ulink> is installed.This option should be used in conjunction with 
      the -TRACE option to generate binary EPILOG traces (instead of 
      binary TAU traces). EPILOG traces can then be used with other tools 
      such as EXPERT. EPILOG comes with its own implementation of the 
      MPI wrapper library and the POMP library used with Opari. Using option 
      overrides TAU's libraries for MPI, and OpenMP.</para>

    </listitem>
      <listitem>
	<para><literal>-otf=&lt;directory&gt;</literal></para>
          <para>
	    Specifies the location of the OTF trace libraries generation package. TAU's
	    binary traces can be converted to the OTF format using tau2otf, a
	    tool that links with the OTF library. 
        </para>
      </listitem>      
      <listitem>
	<para><literal>-vtf=&lt;directory&gt;</literal></para>
          <para>
	    Specifies the location of the VTF3 trace generation package. TAU's
	    binary traces can be converted to the VTF3 format using tau2vtf, a
	    tool that links with the VTF3 library. The VTF3 format is read by
	    Intel trace analyzer, formerly known as vampir, a commercial trace
	    visualization tool developed by TU. Dresden, Germany.
        </para>
      </listitem>    
		</itemizedlist>
		</sect2>
    <sect2>
      <title>More configuration options</title>
      
      <itemizedlist>

    <listitem>
      <para><literal>-PROFILEPHASE</literal></para>
      <para>This option generates phase based profiles. It requires special
      instrumentation to mark phases in an application (I/O, computation,
      etc.). Phases can be static or dynamic (different phases for each loop
      iteration, for instance).  See examples/phase/README for further
      information.
      </para>
    </listitem>
      <listitem>

	<para><literal>-prefix=&lt;directory&gt;</literal></para>

        <para>Specifies the destination directory where the header, library and 
        binary files are copied. By default, these are copied to subdirectories 
        &lt;arch&gt;/bin and &lt;arch&gt;/lib in the TAU root directory.</para>

      </listitem>

      <listitem>
	<para><literal>-arch=&lt;architecture&gt;</literal></para>

        <para>Specifies the architecture. If the user does not 
        specify this option, configure determines the architecture. 
        For IBM BGL, the user should specify bgl as the architecture. 
        For SGI, the user can specify either of sgi32, sgin32 or 
        sgi64 for 32, n32 or 64 bit compilation modes respectively. 
        The files are installed in the &lt;architecture&gt;/bin and 
        &lt;architecture&gt;/lib directories. Cray options are xt3, craycnl or
				crayxmt.</para>

      </listitem>


      
      <listitem>

	<para><literal>-tag=&lt;Unique Name&gt;</literal></para>

        <para>Specifies a tag in the name of the stub Makefile and TAU makefiles to uniquely identify the installation. This is useful when more than one MPI library may be used with different versions of compilers. e.g.,</para>
	
	<screen> 
% configure -c++=icpc -cc=icc -tag=intel71-vmi   \ 
            -mpiinc=/vmi2/mpich/include
	</screen>

      </listitem>
    
		<listitem>
      
      <para><literal>-scalasca=&lt;dir&gt;</literal></para>

      <para>Specifies the directory where the <ulink url="http://www.sclasca.org">SCALASCA</ulink> package 
       is installed.</para>

    </listitem>
      
      <listitem>
	<para><literal>-pthread</literal></para>

        <para>Specifies pthread as the thread package to be used. In the 
        default mode, no thread package is used.</para>

      </listitem>

<!-- No longer preferred option to using charm++, see charm++ 6.1.2 or later for
TAU integration. <listitem>
	<para><literal>-charm=&lt;directory&gt;</literal></para>

        <para>Specifies charm++ (converse) threads as the thread package to be used.</para>

      </listitem> -->
      
      <!-- No longer an option listitem>
	<para><literal>-tulipthread=&lt;directory&gt; -smarts</literal></para>

        <para>Specifies SMARTS (Shared Memory Asynchronous Runtime System) 
        as the threads package to be used. &lt;directory&gt; gives the 
        location of the SMARTS root directory. <ulink
		  url="http://www.cs.uoregon.edu/research/tau/users/smarts.php">Smarts</ulink></para>

      </listitem-->


      <listitem>

	<para><literal>-opari_region</literal></para>

        <para>Report performance data for only OpenMP regions and not 
        constructs.  By default, both regions and constructs are profiled 
        with Opari.</para>

      </listitem>

      <listitem>

	<para><literal>-opari_construct</literal></para>

        <para>Report performance data for only OpenMP constructs and not 
        Regions.  By default, both regions and constructs are profiled with 
        Opari.</para>

      </listitem>


      <listitem>
        <para><literal>-pdtarch=&lt;architecture&gt;</literal></para>

        <para>Specifies the architecture used to build pdt, default the tau architecture.</para>
      </listitem>

<!-- I do not think we support PCL anymore      <listitem>
	<para><literal>-pcl=&lt;directory&gt;</literal></para>

        <para>Specifies the location of the installed PCL (Performance 
        Counter Library) root directory. PCL provides a common interface 
        to access hardware performance counters on modern microprocessors. 
        The library supports Sun UltraSparc I/II, PowerPC 604e under AIX, 
        MIPS R10000/12000 under IRIX, Compaq Alpha 21164, 21264 under 
        Tru64Unix and Cray Unicos (T3E) and the Intel Pentium family of 
        microprocessors under Linux. This option specifies the use of 
        hardware performance counters for profiling (instead of time). 
        To measure floating point instructions, set the environment 
        variable PCL_EVENT to PCL_FP_INSTR (for example). See the section 
        "Using Hardware Performance Counters" in Chapter 4 for details 
        regarding its usage.</para> 
		          
				<para>NOTE: If you want to profile multiple PCL counters set the
				"-MULTIPLECOUNTERS" options as well. And instead of using the PCL
				environment variable use COUNTER1, COUNTER2, ... COUNTER25 environment
				variables to specify the type of counter to profile..
		  
		  <ulink
		  url="http://www.fz-juelich.de/zam/PCL/">PCL</ulink></para>

      </listitem> -->


    <listitem>
      <para><literal>-papithreads</literal> </para>
      <para>Same as papi, except uses threads to
      highlight how hardware performance counters may be used in a
      multi-threaded application. When it is used with PAPI, TAU should be
      configured with -papi=&lt;dir&gt; -pthread autoinstrument Shows the use
      of Program Database Toolkit (PDT) for automating the insertion of TAU
      macros in the source code. It requires configuring TAU with the
      -pdt=&lt;dir&gt; option. The Makefile is modified to illustrate the use
      of a source to source translator (tau_instrumentor). </para>
    </listitem>


        
<!-- Set automatically <para><literal>-PAPIWALLCLOCK</literal></para>

        <para>When used in conjunction with the -papi=&lt;dir&gt; option, 
        this option allows TAU to use high resolution, low overhead CPU 
        timers for wallclock time based measurements. This can reduce 
        the TAU overhead for accessing wallclock time for profile and 
        trace measurements. (See NOTE below.)</para>

      </listitem> 

      <listitem>

	<para><literal>-PAPIVIRTUAL</literal></para>

        <para>When used in conjunction with the -papi=&lt;dir&gt; option, 
        this option allows TAU to use the process virtual time (time spent 
        in the "user" mode) for profile measurements, instead of the 
        default wallclock time. (See NOTE below.)</para>

      </listitem>

      <listitem>

	<para><literal>-CPUTIME</literal></para>

        <para>Specifies the use of user+ system time (collectively CPU time) 
        for profile measurements, instead of the default wallclock time. This 
        may be used with multi-threaded programs only under the LINUX 
        operating system which provides bound threads.  On other platforms, 
        this option may be used for profiling single-threaded programs 
        only.</para>

      </listitem>

      <listitem>

	<para><literal>-MULTIPLECOUNTERS</literal></para>

        <para>Allows TAU to track more than one quantity (multiple hardware
        counters, CPU- time, wallclock time, etc.) Configure with other options
        such as -papi=&lt;dir&gt;, -pcl=&lt;dir&gt;, -LINUXTIMERS, -SGITIMERS,
        -CPUTIME, -PAPIVIRTUAL, etc.  See Section "Using Multiple Hardware
        Counters" in Chapter 4 for detailed instructions on setting the
        environment variables COUNTER&lt;1-25&gt; for this option. If
        -MULTIPLECOUNTERS is used with the -TRACE option, tracing employs the
        COUNTER1 environment variable for wallclock time.</para>

        <para>NOTE: The default measurement option in TAU is to use the 
        wallclock time, which is the total time a program takes to execute, 
        including the time when it is waiting for resources. It is the time 
        measured from a real-time clock. The process virtual time 
        (-PAPIVIRTUAL) is the time spent when the process is actually running. 
        It does not include the time spent when the process is swapped out 
        waiting for CPU or other resources and it does not include the time 
        spent on behalf of the operating system (for executing a system call, 
        for instance). It is the time spent in the "user" mode. The CPUTIME 
        on the other hand, includes both the time the process is running 
        (process virtual time) and the time the system is providing services 
        for it (such as executing a system call). It is the sum of the 
        process virtual (user) time and the system time (See man 
        getrusage()).</para>

				<para>NOTE: If "-TRACE" and "-MULTIPLECOUNTERS" options are both set the
				environment variable "COUNTER1" must be set to "GET_TIME_OF_DAY".</para>

      </listitem> -->

      <listitem>

	<para><literal>-jdk=&lt;directory&gt;</literal></para>

        <para>Specifies the location of the installed Java root directory. 
        TAU can profile or trace Java 
        applications without any modifications to the source code, byte-code 
        or the Java virtual machine. See README.JAVA on instructions on 
        using TAU with Java 2 applications. Also the refence guide has more information 
        on the new tau_java tool.  This option should only be used 
        for configuring TAU to use JVMTI for profiling and tracing of Java 
        applications. It should not be used for configuring paraprof, 
        which uses Java from the user's path.</para>
	
      </listitem>

      <listitem>

	<para><literal>-dyninst=&lt;dir&gt;</literal></para>

        <para>Specifies the directory where the DynInst dynamic 
        instrumentation package is installed. Using DynInst, a user can 
        invoke tau_run to instrument an executable program at runtime or 
        prior to execution by rewriting it. 
        <ulink url="http://www.dyninst.org/">DyninstAPI</ulink><ulink
		  url="http://www.paradyn.org/">PARA-DYN</ulink>.</para>

      </listitem>
      
      <listitem>
	<para><literal>-vampirtrace=&lt;directory&gt;</literal></para>
          <para>
	    Specifies the location of the Vampir Trace package. 
      With this option TAU will generate traces in Open Trace Format (OTF). 
      For more information, see <ulink url="
      http://www.tu-dresden.de/zih/vampirtrace">Technische Universitat
      Dresden</ulink>
        </para>
      </listitem>   
      
            <listitem>
	<para><literal>-scorep=&lt;directory&gt;</literal></para>
          <para>
	    Specify location of Score-P package.  Set the enviroment varible SCOREP_PROFILING_FORMAT 
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles. 
        </para>
      </listitem>   
      
      
      
      <!-- no longer and option listitem>
	<para><literal>-slog2=&lt;directory&gt;</literal></para>
          <para>
	    Specifies the location of the SLOG2 SDK trace generation
	    package. TAU's binary traces can be converted to the SLOG2 format
	    using tau2slog2, a tool that uses the SLOG2 SDK. The SLOG2 format
	    is read by the Jumpshot4 trace visualization software, a freely
	    available trace visualizer from Argonne National Laboratories.
	    [Ref:
	    http://www-unix.mcs.anl.gov/perfvis/download/index.htm#slog2sdk]
        </para>
      </listitem>       
      
      
      <listitem>
	<para><literal>-slog2</literal></para>
          <para>
	    Specifies the use of the SLOG2 trace generation package and the
	    Jumpshot trace visualizer that is bundled with TAU. Jumpshot v4 and
	    SLOG2 v1.2.5delta are included in the TAU distribution. When the
	    -slog2 flag is specified, tau2slog2 and jumpshot tools are copied
	    to the &lt;tau&gt;/&lt;arch&gt;/&lt;bin&gt; directory.  It is
	    important to have a working javac and Java (preferably v1.4+) in
	    your path. On Linux systems, where /usr/bin/java may be a place
	    holder, you'll need to modify your path accordingly.
        </para>
      </listitem-->           
      
      
    <!--listitem> Already covered

      <para><literal>-mpilibrary=&lt;lib&gt;</literal></para>

      <para>Specifies the use of a different MPI library. By default, TAU uses
      -lmpi or -lmpich as the MPI library. This option allows the user to 
      specify another library. e.g., -mpilibrary=-lmpi_r for specifying a 
      thread-safe MPI library.</para>

    </listitem-->

    
    <listitem>
      <para><literal>-shmeminc=&lt;dir&gt;</literal></para>
      <para>Specifies the directory where shmem.h resides and specifies the use of
      the TAU SHMEM interface.</para>
    </listitem>
    
    <listitem>
      <para><literal>-shmemlib=&lt;dir&gt;</literal></para>
      <para>Specifies the directory where libsma.a resides and specifies the use
      of the TAU SHMEM interface.</para>
    </listitem>    
    
    <listitem>
      <para><literal>-shmemlibrary=&lt;lib&gt;</literal></para>
      <para>By default, TAU uses -lsma as the shmem/pshmem library. This option
      allows the user to specify a different shmem library.</para>
    </listitem>      
    
    <listitem>

      <para><literal>-nocomm</literal></para>

      <para>Allows the user to turn off tracking of messages 
      (synchronous/asynchronous) in TAU's MPI wrapper interposition 
      library. Entry and exit events for MPI routines are still tracked. 
      Affects both profiling and tracing.</para>

    </listitem>
    
     <listitem>

      <para><literal>-cuda=&lt;dir&gt;</literal></para>

      <para>Specifies the location of the top level CUDA SDK</para>

    </listitem>

     <listitem>
     
      <para><literal>-gpi=&lt;dir&gt;</literal></para>

      <para>Specify use of TAU's GPI wrapper library. </para>
<para> It works well with PDT and compiler based instrumentation of the source code and there is  a wrapper interposition library that is linked in to track the communication of GPI.  It is important to specify all TAU runtime options in the tau.conf file that must reside in the current working directory where the executable is stored and launched from. This is important because the worker tasks are spawned by the GPI daemon on remote nodes and do not inherit the user's working directory or the environment. 
So, options such as TAU_TRACE=1, and sampling must be specified in the tau.conf file. </para>
   
    <figure> 
      <mediaobject>
        <imageobject><imagedata fileref="onesidecomm.png" scalefit="0"
                       width="6in" align="center"/></imageobject>
      </mediaobject>
<caption>
Context events using GPI as shown in ParaProf.
</caption>
    </figure>
 
     </listitem>
     <listitem>

      <para><literal>-opencl=&lt;dir&gt;</literal></para>

      <para>Specifies the location of the OpenCL package</para>

    </listitem>
    
       <listitem>

      <para><literal>-armci=&lt;dir&gt;</literal></para>

      <para>Specifies the location of the ARMCI directory</para>

    </listitem>


    <listitem>
      <para><literal>-epiloglib=&lt;dir&gt;</literal></para>
      <para>Specifies the directory of where the Epilog library is to be
        found. Ex: if directory structure is:
        <literal>/usr/local/epilog/fe/lib/</literal> let the install options be:
        <literal>-epilog=/usr/local/epilog -epiloglib=/usr/local/epilog/fe/lib.</literal>
      </para>
    </listitem>
    <listitem>
      <para><literal>-epilogbin=&lt;dir&gt;</literal></para>
      <para>Specifies the directory of where the Epilog binaries are to be
      found.
      </para>
    </listitem>
    <listitem>
      <para><literal>-epiloginc=&lt;dir&gt;</literal></para>
      <para>Specifies the directory of where the epilog's included sources headers are to be
      found.
      </para>
    </listitem>
    <listitem>
      <para><literal>-MPITRACE</literal></para>
      <para>Specifies the tracing option and generates event traces for MPI
      calls and routines that are ancestors of MPI calls in the callstack. This
      option is useful for generating traces that are converted to the EPILOG
      trace format.  KOJAK's Expert automatic diagnosis tool needs traces with
      events that call MPI routines. Do not use this option with the -TRACE
      option. </para>
    </listitem>
    
    
    <listitem>

      <para><literal>-pythoninc=&lt;dir&gt;</literal></para>

      <para>Specifies the location of the Python include directory. This is 
      the directory   where Python.h header file is located. This option 
      enables python bindings to be generated. The user should set the 
      environment variable PYTHONPATH to 
      &lt;TAUROOT&gt;/&lt;ARCH&gt;/lib/bindings-&lt;options&gt; to use a 
      specific version of the TAU Python bindings. By importing package pytau, 
      a user can manually instrument the source code and use the TAU API. On 
      the other hand, by importing tau and using tau.run(`&lt;func&gt;'), 
      TAU can automatically generate instrumentation. See examples/python 
      directory for further information.</para>

    </listitem>

    <listitem>

      <para><literal>-pythonlib=&lt;dir&gt;</literal></para>

      <para>Specifies the location of the Python lib directory. This is the 
      directory where *.py and *.pyc files (and config directory) are located. 
      This option is mandatory for IBM when Python bindings are used. For other
      systems, this option may not be specified (but -pythoninc=&lt;dir&gt; 
      needs to be specified).</para>

    </listitem>

<!-- No longer set at configure time    <listitem>

      <para><literal>-PROFILE</literal></para>

      <para>This is the default option; it specifies summary profile files to 
      be generated at the end of execution. Profiling generates aggregate 
      statistics (such as the total time spent in routines and statements), 
      and can be used in conjunction with the profile browser racy to analyze 
      the performance. Wallclock time is used for profiling program 
      entities.</para>

    </listitem>

    <listitem>

      <para id="PROFILECALLPATH"><literal>-PROFILECALLPATH</literal></para>

      <para>This option generates call path profiles which shows the time 
      spent in a routine when it is called by another routine in the calling 
      path. "a =&gt; b" stands for the time spent in routine "b" when it is 
      invoked by routine "a". This option is an extension of -PROFILE, the 
      default profiling option.  Specifying TAU_CALLPATH_DEPTH environment 
      variable, the user can vary the depth of the callpath. See 
      examples/calltree for further information.</para>

    </listitem> -->


    
    <!--listitem>

      <para><literal>-PROFILESTATS</literal></para>

      <para>Specifies the calculation of additional statistics, such as the 
      standard deviation of the exclusive time/counts spent in each profiled 
      block. This option is an extension of -PROFILE, the default profiling 
      option.</para>

    </listitem-->

<!-- no longer set at runtime 
    <listitem>
      <para><literal>-DEPTHLIMIT</literal></para>
      <para>Allows users to enable instrumentation at runtime based on the
      depth of a calling routine on a callstack. The depth is specified using
      the environment variable TAU_DEPTH_LIMIT. When its value is 1,
      instrumentation in the top-level routine such as main (in C/C++) or
      program (in F90) is activated. When it is 2, only routine invoked
      directly by main and main are recorded. When a routine appears at a depth
      of 2 and at 10 and we set the limit at 5, then the routine is recorded
      when its depth is 2, and ignored when its depth is 10 on the calling
      stack. This can be used with -PROFILECALLPATH to generate a tree of
      height &lt;h&gt; from the main routine by setting TAU_CALLPATH_DEPTH and
      TAU_DEPTH_LIMIT variables to &lt;h&gt;.
      </para>
    </listitem> -->


   
    <listitem>
      <para><literal>-PROFILEMEMORY</literal></para>
      <para>
	Specifies tracking heap memory utilization for each instrumented
	function.  When any function entry takes place, a sample of the heap
	memory used is taken. This data is stored as user-defined event data in
	profiles/traces.
      </para>
    </listitem>   
    
        <listitem>
      <para><literal>-PROFILECOMMUNICATORS</literal></para>
      <para>
	This option generates MPI information partitioned by communicators. TAU
   lists upto 8 ranks in each communicator in the listing. 
      </para>
    </listitem>   
    
    
    
    <listitem>
      <para><literal>-PROFILEHEADROOM</literal></para>
      <para>
	Specifies tracking memory available in the heap (as opposed to memory
	utilization tracking in -PROFILEMEMORY). When any function entry takes
	place, a sample of the memory available (headroom to grow) is
	taken. This data is stored as user-defined event data in
	profiles/traces. Please refer to the examples/headroom/README file for
	a full explanation of these headroom options and the C++/C/F90 API for
	evaluating the headroom.
      </para>
    </listitem>    
    
    
    <listitem>
      <para><literal>-COMPENSATE</literal></para>
      <para>
	Specifies online compensation of performance perturbation. When this
	option is used, TAU computes its overhead and subtracts it from the
	profiles. It can be only used when profiling is chosen. This option
	works with MULTIPLECOUNTERS as well, but while it is relevant for
	removing perturbation with wallclock time, it cannot accurately account
	for perturbation with hardware performance counts (e.g., L1 Data cache
	misses).  See TAU Publication [Europar04] for further information on
	this option.
      </para>
    </listitem>       
    
    <listitem>
    
      <para><literal>-PROFILECOUNTERS</literal></para>

      <para>Specifies use of hardware performance counters for profiling 
      under IRIX using the SGI R10000 perfex counter access interface. The 
      use of this option is deprecated in favor of the -pcl=&lt;dir&gt; 
      and -papi=&lt;dir&gt; options described above. </para>

    </listitem>


<!-- set automatically  
    <listitem>
      <para><literal>-SGITIMERS</literal></para>
      <para>Specifies use of the free running nanosecond resolution on-chip 
      timer on the R10000+. This timer has a lower overhead than the default 
      timer on SGI, and is recommended for SGIs (similar to the 
      -papi=&lt;dir&gt; -PAPIWALLCLOCK options).</para>
    </listitem>

    <listitem>
      <para><literal>-CRAYTIMERS</literal></para>
      <para>Specifies use of the free running nanosecond resolution on-chip 
      timer on the CRAY X1 cpu (accessed by the rtc() syscall). This timer 
      has a significantly lower overhead than the default timer on the X1, 
      and is recommended for profiling. Since this timer is not synchronized 
      across different cpus, this option should not be used with the -TRACE 
      option for tracing a multi-cpu application, where a globally 
      synchronized realtime clock is required.</para>
    </listitem>
    
    <listitem>
      <para><literal>-LINUXTIMERS</literal></para>
      <para>Specifies the use of the free running nanosecond resolution time 
      stamp counter (TSC) on Pentium III+ and Itanium family of processors 
      under Linux. This timer has a lower overhead than the default time and 
      is recommended. When generating trace data with these timers it is
      recommended that the user set the environment variable
      <literal>TAU_SYNCHRONIZE_CLOCKS</literal> to true so that TAU can synchronize the timers.
      </para>
    </listitem> -->

<!-- no longer set at runtime    <listitem>
      <para><literal>-TRACE</literal></para>
      <para>Generates event-trace logs, rather than summary profiles. Traces 
      show when and where an event occurred, in terms of the location in the 
      source code and the process that executed it. Traces can be merged and 
      converted using tau_merge and tau_convert utilities respectively, and 
      visualized using Vampir, a commercial trace visualization tool. 
      <ulink url="http://www.vampir-ng.de/">VAMPIR</ulink></para>
    </listitem> -->

    <!-- not suported listitem>

      <para><literal>-muse</literal></para>
      <para>Specifies the use of MAGNET/MUSE to extract low-level information 
      from the kernel. To use this configuration, Linux kernel has to be 
      patched with MAGNET and MUSE has to be install on the executing machine.  
      Also, magnetd has to be running with the appropriate handlers and filters
      installed. User can specify pack- age by setting the environment 
      variable TAU_MUSE_PACKAGE.  <ulink url="http://public.lanl.gov/radiant/">MUSE</ulink></para>

    </listitem-->

    <listitem>

      <para><literal>-noex</literal></para>

      <para>Specifies that no exceptions be used while compiling the library. 
      This is relevant for C++. </para>

    </listitem>

    <listitem>

      <para><literal>-useropt=&lt;options-list&gt;</literal></para>

      <para>Specifies additional user options such as -g or -I. For multiple 
      options, the options list should be enclosed in a single quote. For 
      example </para>

      <screen>
%./configure -useropt='-g -I/usr/local/stl'
      </screen>

    </listitem>

    <listitem>

      <para><literal>-mrnet=&lt;mrnet source root&gt;</literal></para>

      <para>Base location of the MRnet package.</para>

    </listitem>
    
    <listitem>

      <para><literal>-mrnetlib=&lt;mrnet libraries&gt;</literal></para>

      <para>Path to the MRnet libraries. <note>On some cluster systems the MRnet libraries need to
			available to the runtime system (ie. on the lustre filesystem.)</note></para>

    </listitem>

    <listitem>

      <para><literal>-scorep=&lt;scorep subsystem&gt;</literal></para>

      <para>Path to the Score-P measurement system. Set the enviroment varible SCOREP_PROFILING_FORMAT
            to TAU_SNAPHOT so that Score-P will output Tau Snapsot profiles.
      </para>

    </listitem>

		<listitem>

      <para><literal>-help</literal></para>

      <para>Lists all the available configure options and quits.</para>

    </listitem>

  </itemizedlist>

  </sect2>

  <sect2>

    <title>tau_setup</title>
    <para>tau_setup is a GUI interface to the configure and installtau tools.</para>

  </sect2>

  <sect2>
    <title>installtau script</title>

    <para>To install multiple (typical) configurations of TAU at a site, you 
    may use the script `installtau'. It takes options similar to those 
    described above. It invokes ./configure &lt;opts&gt;; make clean install;  
    to create multiple libraries that may be requested by the users at a 
    site. The installtau script accepts the following options: </para>

    <screen>
% installtau -help

TAU Configuration Utility 
***************************************************
Usage: installtau [OPTIONS]
  where [OPTIONS] are:
-arch=&lt;arch&gt;  
-fortran=&lt;compiler&gt;  
-cc=&lt;compiler&gt;   
-c++=&lt;compiler&gt;   
-useropt=&lt;options&gt;  
-pdt=&lt;pdtdir&gt;  
-pdtcompdir=&lt;compdir&gt;  
-pdt_c++=&lt;C++ Compiler&gt;  
-papi=&lt;papidir&gt;  
-vtf=&lt;vtfdir&gt;  
-otf=&lt;otfdir&gt;  
-dyninst=&lt;dyninstdir&gt; 
-mpi
-mpiinc=&lt;mpiincdir&gt;  
-mpilib=&lt;mpilibdir&gt;  
-mpilibrary=&lt;mpilibrary&gt;  
-perfinc=&lt;dir&gt; 
-perflib=&lt;dir&gt; 
-perflibrary=&lt;library&gt; 
-mpi
-tag=&lt;unique name&gt; 
-opari=&lt;oparidir&gt;  
-epilog=&lt;epilogdir&gt;  
-epiloginc=&lt;absolute path to epilog include dir&gt; (&lt;epilog&gt;/include default) 
-epilogbin=&lt;absolute path to epilog bin dir&gt; (&lt;epilog&gt;/bin default)  
-epiloglib=&lt;absolute path to epilog lib dir&gt; (&lt;epilog&gt;/lib default)  
-prefix=&lt;dir&gt;  
-exec-prefix=&lt;dir&gt; 
-j=&lt;num processes for parallel make&gt;  (just -j for full parallel) 

******************************************************************
</screen>

    <para>These options are similar to the options used by the configure script.</para>

  </sect2>
<!--
  <sect2>

    <title>Examples: </title>
 adding more current examples     

    <itemizedlist>
      <listitem>
        <para>a) Profiling a Multithreaded C++ program (compiled on 64-bit Linux) 
        </para>
          
        <screen>
 % configure -pthread
     % make clean; make install
     % set path=($path &lt;TAU DIRECTORY&gt;/x86_64/bin)
     % cd examples/threads
     % make;
     % hello
</screen>

      <para> It has two threads: the profiling data should show functions executing on
       each thread</para>
      <screen>
% pprof
</screen>
      <para>This is the text based profile browser.</para>
      <screen>
% paraprof
</screen>  

    </listitem>

    <listitem>

      <para>b) TAU with Java</para>

      <screen>
%./configure -c++=g++ -jdk=/usr/local/packages/jdk1.4
% make install
% set path=($path &lt;taudir&gt;/&lt;tauarch&gt;/bin)
% setenv LD_LIBRARY_PATH \ 
  $LD_LIBRARY_PATH:&lt;taudir&gt;/&lt;tauarch&gt;/lib
% cd examples/java/pi
% java -XrunTAU Pi 200000
% paraprof
</screen>

    </listitem>

    <listitem>

      <para>c) Profiling an MPI program using the TAU MPI wrapper library</para>

      <screen>
% configure -mpi
% make clean; make install
% cd examples/pi
% make
% poe cpi -procs 4 -rmpool 2
% pprof or paraprof</screen>

      <para>Note: Using the MPI Profiling Interface TAU can generate profile data for
       all MPI routines as well.</para>

    </listitem>

    <listitem>

      <para>d)  Profiling an application written in C++ (compiled with icpc) using automatic
     source code instrumentation and using CPU time instead of (the default)
     wall-clock time.
     Download PDT (Program Database Toolkit) from http://www.cs.uoregon.edu/research/pdtoolkit ]</para>

      <screen>
% cd pdtoolkit-&lt;x&gt;
% configure  -XLC -prefix=/usr/local/pdt
% make clean install
</screen>

      <para>Next configure TAU to use PDT for automatic source code instrumentation.
      </para>

      <screen>
% cd tau-2.x
% configure -c++=icpc -cc=icc -pdt=&lt;pdtoolkit root directory&gt; -CPUTIME
% make clean; make install
% cd examples/taucompiler/c++
% make
</screen>

      <para>This takes klargest.cpp, an uninstrumented file, parses it (PDT), and
       invokes tau_instrumentor, which takes the PDT output and generates an
       instrumented C++ file, which when linked with the TAU library, generates
       performance date when executed.</para>

      <screen>
% klargest
% pprof
% paraprof
</screen>
    </listitem>

    <listitem>

      <para>e) Use CPUTIME measurements for a multi-threaded application 
      using pthreads under LINUX.</para>

      <screen>
% configure -pthread -CPUTIME
</screen>

    </listitem>

    <listitem>

      <para>f) Use multiple hardware performance counters</para>

      <screen>
% configure -MULTIPLECOUNTERS -papi=/usr/local/papi \
  -PAPIWALLCLOCK -PAPIVIRTUAL -LINUXTIMERS \
  -mpiinc=/usr/local/mpich/include \
  -mpilib=/usr/local/mpich/ lib/ \
  -pdt=/usr/local/pdtoolkit -useropt=-O2
% setenv COUNTER1 LINUX_TIMERS
% setenv COUNTER2 PAPI_FP_INS
% setenv COUNTER3 PAPI_L1_DCM ...
</screen>

    </listitem>

    <listitem>
      <para>g) Use TAU with PDT and MPI on IBM BG/L </para>

<screen>
% cd pdtoolkit-3.x
% configure -XLC -exec-prefix=bgl; make clean install
% cd tau-2.x
% configure -mpi -arch=bgl -pdt=/usr/local/pdtoolkit-3.x -pdt_c++=xlC
</screen>

    </listitem>

    <listitem>
      <para>h) Tracing an MPI program (compiled with xlC) and displaying the traces in
     Vampir or VNG using Open Trace Format (OTF)</para>
  
      <screen>
% configure -c++=xlC -cc=xlc -fortran=ibm -mpi -otf=/usr/local/otf-1.2.6 -TRACE
% make clean; make install
% cd examples/taucompiler/f90
% make
% poe ./ring -procs 128  
% tau_treemerge.pl
% tau2otf tau.trc tau.edf app.otf -z -n 8
</screen>
    
    <para>creates a compressed OTF trace (-z) with 8 parallel streams (-n 8).
    The main OTF file is called app.otf.</para>
    <screen>
% vampir app.otf
</screen>
    <para>In the Menu, choose Preferences -> Color Styles -> Activities and
    choose a distinct color for each activity.</para>

    </listitem>

    <listitem>
      <para>h) Profiling an OpenMP F90 program using IBM</para>
      <screen>
% configure -c++=xlC -cc=xlc -fortran=ibm -mpi -opari=&lt;dir&gt; -pdt=&lt;dir&gt; -opari=&lt;dir&gt;
% cd examples/taucompiler/opari_f90
% make
% setenv OMP_NUM_THREADS 2
% mandel
% pprof
</screen>
    </listitem>

  </itemizedlist>

    <para>NOTE: Also see Section "<link linkend="RunningApplication">Running the Application</link>" in Chapter 2 
    (Compiling) for an explanation of simple examples that are included 
    with the TAU distribution.</para>

    </sect2>
			-->

  <sect2>

    <title>upgradetau</title>
    <para>This script is provided to rebuild all TAU configurations
                previously built in a different TAU source directory. Give this
                command the location of a previous version of tau followed by
                any additional configurations and it will rebuild tau
                with these same options.</para>

  </sect2>

  <sect2>

    <title>tau_validate</title>
      <para>This script will attempt to validate a tau installation. Its only
      argument is TAU's architecture directory. These are some options: 
      <itemizedlist>
        <listitem><para>-v Verbose output</para></listitem>
        <listitem><para>--html       Output results in HTML</para></listitem>
        <listitem><para>--build      Only build</para></listitem>
        <listitem><para>--run        Only run</para></listitem>
      </itemizedlist>  
    </para> 
    <para> Here is a simple example: 
    <screen>

bash : ./tau_validate --html x86_64 &amp;&gt; results.html
tcsh : ./tau_validate --html x86_64 &gt;&amp; results.html
</screen>
    </para>
  </sect2>
  
  </sect1>

  <sect1 id="platforms.supported">

    <title>Platforms Supported</title>

    <para>TAU has been tested on the following platforms:</para>

    <itemizedlist>

      <listitem>
        <para>LINUX Clusters</para>

        <para>On Linux based Intel x86 (32 and 64 bit) PC clusters, KAI/Intel's KCC, g++, egcs
        (GNU), <ulink url="http://www.pgroup.com">pgCC (PGI)</ulink>, <ulink
        url="http://www.fujitsu.com">FCC (Fujitsu)</ulink> and icpc/ecpc <ulink
        url="http://www.intel.com">Intel</ulink> compilers have been
        tested. TAU also runs under IA-64, Opteron, ARM, PowerPC, Alpha, Apple
        PowerMac, Sparc and other processors running Linux. </para>

      </listitem>

      <listitem>

        <para>Cray Compute Node Linux (XT5, XT6, XE6), X1, T3E, SV-1, XT3, and RedStorm</para>

        <para>When using Cray CNL you need to configure tau with the option 
				<literal>-arch=craycnl</literal>On Cray T3E systems, KAI KCC and Cray CC compilers have been 
        tested with TAU. On Cray SV-1 and X1 systems, Cray CC compilers 
        have been tested with TAU. On Cray XT3, and RedStorm systems, PGI and
        GNU compilers have been tested with TAU. </para>

      </listitem>
      <listitem>

        <para>IBM</para>

        <para>On IBM BlueGene (L/P/Q) SP2 and AIX systems.  On IBM BG: IBM xlC, blrts_xlC,
        blrts_xlf90, blrts_xlc, and gnu compilers work with TAU. SP2 and AIX: vKAI KCC, KAP/Pro, IBM xlC, xlc, 
        xlf90 and g++ compilers work with TAU. On IBM pSeries
        Linux, xlC, xlc, xlf90 and gnu compilers work with TAU. </para>

      </listitem>

      <listitem>
        <para>Sun Solaris</para>

        <para>Sun compilers (CC, F90), KAI KCC, KAP/Pro and GNU g++ work with 
        TAU.</para>

      </listitem>

      <listitem>

        <para>Apple OS X</para>

        <para>On Apple OS X machines, c++ or g++ may be used to compile TAU. 
        Also, IBM's xlf90, xlf and Absoft Fortran 90 compilers for G4/G5 may 
        be used with TAU.</para>

      </listitem>
      <listitem>
        <para>SGI</para>

        <para>On IRIX 6.x based systems, including Indy, Power Challenge, Onyx,
        Onyx2 and Origin 200, 2000, 3000 Series, CC 7.2+, <ulink
        url="http://www.kai.com">KAI</ulink> KCC and <ulink
        url="http://www.gnu.org">g++</ulink> compilers are supported. On SGI
        Altix systems, Intel, and GNU compilers are supported.</para>

      </listitem>

			<listitem>
				<para>Accelerators</para>

				<para>TAU performance data can be retrived from ATI, Nvidia or Intel GPUs
				(through OpenCL, or CUDA). Intel Many Intergrated Cores (MIC) is
				supported in native execution.</para>

			</listitem>

			<listitem>
				<para>Intel</para>

      </listitem>
      <listitem>
        <para>HP HP-UX</para>

        <para>On HP PA-RISC systems, aCC and g++ can be used.</para>

      </listitem>

      <listitem>

        <para>HP Alpha Tru64</para>

        <para>On HP Alpha Tru64 machines, cxx and g++, and Guide compilers 
        may be used with TAU.</para>

      </listitem>

      <listitem>

        <para>NEC SX series vector machines</para>

    <para>On NEC SX-5 systems, NEC c++ may be used with TAU.</para>

      </listitem>


      <listitem>
        <para>On Hitachi machines, Hitachi KCC, g++ and Hitachi cc compilers 
        may be used with TAU</para>

      </listitem>


      <listitem>
        <para>Fujitsu PRIMEPOWER</para>

        <para>On Fujitsu Power machines, Sun and Fujitsu compilers may be used
        with TAU. </para>
      </listitem>

      <listitem>

        <para>Microsoft Window</para>

        <para>On Windows, Microsoft Visual C++ 6.0 or higher and JDK 1.2+ 
        compilers have been tested with TAU</para>

      </listitem>

    </itemizedlist> 

    <para>NOTE: TAU has been tested with JDK 1.2, 1.3, 1.4.x under Solaris, SGI, IBM, 
    Linux, and MacOS X.</para>

  </sect1>

  <sect1 id="software.requirements">
    <title>Software Requirements</title>

    <itemizedlist>
      <listitem>
        <para>1. Java v 1.5</para>

        <para>TAU's GUI ParaProf and PerfExplorer require Java v1.4 or better 
        in your path. If Java 1.4 is the only version avaible, older version of 
        ParaProf and PerfExplorer can be installed.  To do so, simple run either program 
        with Java 1.4 in your path.  You will guided through the installation process.
        ParaProf does not 
        require -jdk=&lt;dir&gt; option to be specified during configuration. (This option 
        is used for configuring TAU for analyzing Java applications.)</para>

      </listitem>

    </itemizedlist>

  </sect1>
</chapter>
