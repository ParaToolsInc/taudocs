<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;TAU Tutorial</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
       <?php include("../../header.php") ?>
       <div id="content">
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1"></a>Chapter&nbsp;1.&nbsp;TAU Tutorial</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#GetInformation">1.1. Gather information</a></span></dt><dt><span class="sect1"><a href="#FirstInstallPDT">1.2. Installing PDT</a></span></dt><dt><span class="sect1"><a href="#installtau">1.3. Installing TAU</a></span></dt><dt><span class="sect1"><a href="#automatic">1.4. Automatic instrumentation using TAU Compiler</a></span></dt><dt><span class="sect1"><a href="#tau_throttle">1.5. TAU throttle</a></span></dt><dt><span class="sect1"><a href="#paraprof">1.6. ParaProf</a></span></dt></dl></div><span class="author"><span class="firstname"></span> <span class="surname"></span></span><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GetInformation"></a>1.1.&nbsp;Gather information</h2></div></div></div><p>
        Before we began installing PDT and TAU you will find it helpful to
        gather information about your computing environment. TAU and PDT require
        both a C and C++ compiler. Furthermore this tutorial uses MPICH, if you
        use a different implementation just find its lib and include directories. Find
        out the following information about your computing environment before we began: 
    </p><div class="itemizedlist"><ul type="disc"><li><p>The path to your MPI lib directory</p></li><li><p>The path to your MPI include directory</p></li><li><p>The path of your C compiler (same as the used to compile
        MPI)</p></li><li><p>The path of your C++ compiler  (same as the used to compile
        MPI)</p></li></ul></div><p>For the remaining of this tutorial we will assume that your C compiler
    is xlc, your C++ compiler is xlC. 
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="FirstInstallPDT"></a>1.2.&nbsp;Installing PDT</h2></div></div></div><p>
        To take advantage of TAU's automatic instrumentation features, you will
        need to install the Program Database Toolkit (PDT). Download the latest
        version from the PDT pages and put the tar.gz package in the location
        that you want to install PDT. For this installation, we will assume that
        you are using IBM's Fortran and C/C++ compilers, with an mpich
        installation. 
	</p><p>
		  Start by uncompressing the PDT package and moving into the PDT directory.
		</p><pre class="screen">
%&gt; tar -xvzf pdtoolkit-x.x.tar.gz
%&gt; cd pdtoolkit
</pre><p>
		  You can get a sense for what options you can configure PDT with by
        entering:
		  </p><pre class="screen">
%&gt; ./configure
Program Database Toolkit (PDT) Configuration
--------------------------------------------
Looks like a Linux machine ...
Looking for C++ compilers .... done
Usage: ./configure [-GNU|-CC|-c++|-cxx|-xlC|-pgCC|-icpc|-ecpc]
                   [-arch=ibm64|ibm64linux|IRIXO32|IRIXN32|IRIX64] [-help]
                   [-compdir=&lt;compdir&gt;&gt;]
                   [-enable-old-headers]
                   [-useropt=&lt;options&gt;&gt;]
                   [-prefix=&lt;dir&gt;]
                   [-exec-prefix=&lt;dir&gt;&gt;]
</pre><p>
        We will configure PDT for use the the Fortran xlF, xlc, and xlC
        compilers. To configure PDT, type
</p><pre class="screen">
%&gt; ./configure -xlC

Program Database Toolkit (PDT) Configuration
--------------------------------------------
Looks like a Linux machine ...
Looking for C++ compilers .... done
==&gt; Using /opt/ibmcmp/vacpp/6.0/bin/xlC
Unpacking ppc64/bin ...
==&gt; ARCH is PPCLINUX
==&gt; PLATFORM is ppc64
==&gt; Default compiler options are -O2
==&gt; Makefiles were configured
==&gt; cparse was configured
==&gt; cxxparse was configured
==&gt; f90parse was configured
==&gt; f95parse was configured

Configuration is complete!

Run "make" and "make install"
Add "/home/users/hoge/pdtoolkit-3.4/ppc64//bin" to your path
</pre><p>
        Add the specified directory to your path. In bash, for example you could
        enter
        </p><pre class="screen">
%&gt; export PATH=$PATH:/home/users/hoge/pdtoolkit/ppc64/bin
</pre><p>
        Now, build and install PDT. Unless you specify a different location to
        install PDT, it will be placed in the current working directory.
        </p><pre class="screen">
%&gt; make
...
%&gt; make install
</pre><p>
        Now you're ready to proceed with the TAU installation.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installtau"></a>1.3.&nbsp;Installing TAU</h2></div></div></div><p>Download the latest version of TAU from the TAU home. Place the
    distribution In the directory that you want to install TAU. Type
    </p><pre class="screen">
%&gt; tar -xvzf tau_latest.tar.gz
%&gt; cd tau2
</pre><p>
    We will be installing TAU once again assuming that we are using the IBM
    compilers (xlf, xlc and xlC), and an MPICH installation. Note where your
	 MPICH installation resides, and configure TAU by entering
    (replacing the MPICH specifics with those in your local system.
    </p><pre class="screen">
%&gt; ./configure -c++=xlC -cc=xlc -fortran=ibm \
  -mpiinc=/opt/osshpc/mpich-1.2.5/32/ch_shmem/include \
  -mpilib=/opt/osshpc/mpich-1.2.5/32/ch_shmem/lib \
  -pdt=/home/users/hoge/pdtoolkit
</pre><p>
    Add the TAU directory to your path and install.
    </p><pre class="screen">
%&gt; export PATH=$PATH:/home/users/hoge/tau2/ppc64/bin
%&gt; make install
</pre><p>
    TAU is installed, and you're ready to start profiling your code.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="automatic"></a>1.4.&nbsp;Automatic instrumentation using TAU Compiler</h2></div></div></div><p>For this section of the tutorial we will be using the files found in
    the <code class="literal">examples/taututorial</code> directory of the tau distribution. To start, there
    are two files of note: computePi.cpp and Makefile. computePi.cpp is a C++
    program that uses an MPI client-server model to estimate the value of Pi.
    The server accepts requests for random numbers from the clients, and returns
    an array of random numbers to the clients. The clients use these values to
    estimate Pi using a dart-throwing method. When the clients have converged to
    a satisfactory tolerance, they signal their completion to the server and the
    program exits. 
    </p><p>
			Build computePi.cpp as you would any c++ mpi application.
    </p><pre class="screen">
%&gt; mpicxx -c computePi.cpp -o computePi.o
%&gt; mpicxx computePi.o -o computePi
    </pre><p>
      Test the program
      in your MPI environment. For mpich, the command might be
	</p><pre class="screen">
%&gt; mpirun -np 5 ./computePi
Pi is 3.14226
</pre><p>
        to run the program on 5 nodes. Note that this program requires at least
        two nodes to be running! Once you've confirmed that the program ran
        successfully, try timing it to get a sense of how long it takes to run.
   </p><pre class="screen">
%&gt; time mpirun -np 5 ./computePi
Pi is 3.14226

real    0m2.012s
user    0m1.570s
sys     0m0.330s
</pre><p>Now let us rebuild computePi to be instrumented with tau. First we
      need to tell TAU which instrumentation library to use by setting the
		  environment variable TAU_MAKEFILE to the location of the tau makefile, for example:
		  </p><pre class="screen">
%&gt; export TAU_MAKEFILE=/home/users/hoge/tau2/ia64/lib/Makefile.tau-mpi-pdt
%&gt; tau_cxx.sh -c computePi.cpp -o computePi.o
%&gt; tau_cxx.sh computePi.o -o computePi
</pre><p>
		  Assuming that all goes well, the computePi program will have been
        automatically built with TAU instrumentation. Run the program as you
        would any MPI program, i.e.
        </p><pre class="screen">
%&gt; mpirun -np 5 ./computePi
Pi is 3.14226
</pre><p>
        TAU generates a profile file for every node the program is run on.
        You can see these files by doing a directory listing.
        </p><pre class="screen">
%&gt; ls profile*
profile.0.0.0  profile.1.0.0  profile.2.0.0  
profile.3.0.0  profile.4.0.0
</pre><p>
    </p><p>
        Now you're ready to view the output of TAU. If you've added the TAU
        binary directory to your path you can launch the TAU profile viewer,
        Paraprof.
        </p><pre class="screen">
%&gt; paraprof
</pre><p>
        Enjoy exploring the performance data displayed by Paraprof. A complete
        description of how to use Paraprof is outside the scope of this
        document. Please see the 
		 <a href="http://www.cs.uoregon.edu/research/tau/docs/paraprof/index.html" target="_top">
		  Paraprof Manual</a> for more information.
    </p><p>
        When you ran the instrumented version of computePi you might have
        noticed that it took significantly longer to run than the
        non-instrumented version. Let's verify this behavior.
        </p><pre class="screen">
%&gt; time mpirun -np 5 ./computePi
real    0m37.750s
user    0m37.370s
sys     0m0.320s
</pre><p>
        On my system, this is an order of magnitude overhead. For
        multi-processor MPI programs, this is an unacceptable amount of
        overhead. However, TAU offers a method for dealing with this added
        overhead, which we'll explore that in the next section.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tau_throttle"></a>1.5.&nbsp;TAU throttle</h2></div></div></div><p>
		Tau_THROTTLE is designed to reduce the computational overhead associated
		with instrumenting a program with TAU. This usually takes the form of
		selectively instrumented some functions but not others. This can be done
		manually, but TAU_THROTTLE with do this automatically by helping you
		develop a criterion to decide which function to instrument.
	</p><p>
	
		Looking  at the #call column we see that the function computeRandom() is
		called about 20,000,000 times. It is functions like these that
		contribute greatly to the overhead associated with instrumenting a
		program. You see, when a function is entered and exited a small amount of
		tauinstrument code is executed. When a function is called millions of
		times even that small amount of code can cause a slow down in execute time.
	</p><p>
		Let us tell tau not to instrument functions like computeRandom(),
		this will remove the computational overhead of instrumenting a function
		that is called 20 millions times. To do this, set these environment
		variables:
		</p><pre class="screen">
%&gt; export TAU_THROTTLE=1
%&gt; export TAU_THROTTLE_NUMCALLS=400000
%&gt; export TAU_THROTTLE_PERCALL=3000
</pre><p>
		This will tell tau not to profile any functions which are called
		more than 400000 times and their inclusive time per call is less than 3
		seconds.
	</p><p>
		Let us now see how much time it takes to run computePi, 
		</p><pre class="screen">
%&gt; time mpirun -np 5 ./computePi
Pi is 3.14226

real    0m2.123s
user    0m1.760s
sys     0m0.270s
</pre><p>
		On my machine computePi runs at about 10% overhead much better than the
		overhead before using TAU_THROTTLE. Not only does TAU_THROTTLE help reduce
		the overall runtime overhead of instrumenting a program, it also, as we
		will see in the next section, increases the accuracy of the resulting
		profile data.
	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paraprof"></a>1.6.&nbsp;ParaProf</h2></div></div></div><p>
        Paraprof is a tool that shows you a graphical representation of the
        profiles generated by tau_compiler. Documentation on setting up and
		  using paraprof is outside the scope of this tutorial, see the <a href="http://www.cs.uoregon.edu/research/tau/docs/paraprof/index.html" target="_top">
		  ParaProf Manual</a>
    </p><p>
        Here is the results of using TAU_THROTTLE are displayed in paraprof.
        Notice that before TAU_THROTTLE that the number of calls made to
		  functions other than computeRandom() is obscured. But after TAU_THROTTLE
		  they can be seen clearly.
    </p><div class="figure"><a name="d0e133"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;A graph of the number of calls by function before
        TAU_THROTTLE</b></p><div><img src="images/before.png" alt="A graph of the number of calls by function before TAU_THROTTLE"></div></div><div class="figure"><a name="d0e137"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;A graph of the number of calls by function after
        TAU_THROTTLE</b></p><div><img src="images/after.png" alt="A graph of the number of calls by function after TAU_THROTTLE"></div></div><p>
		Congratulations, you have successfully instrumented a C++ program with
		tau compiler. Furthermore the you know the basics of TAU_THROTTLE and how
		it can help reduce the overhead of instrumenting a program. For more
		information on tau features see the <a href="http://www.cs.uoregon.edu/research/tau/docs.php" target="_top">Tau
		Documentation.</a>

	</p></div></div>
       </div>
       <?php include("../../footer.php") ?>
    </body></html>
