<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Tau API</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
       <?php include("../../header.php") ?>
       <div id="content">
    <div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TAUAPIS"></a>Tau API</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="reference"><a href="#d0e4">I. TAU Instrumentation API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_START">TAU_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STOP">TAU_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE">TAU_PROFILE</a></span><span class="refpurpose"> - Profile a C++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PROFILE">TAU_DYNAMIC_PROFILE</a></span><span class="refpurpose"> - dynamic_profile a c++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_DYNAMIC">TAU_PROFILE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Creates a dynamic timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_DYNAMIC_AUTO">TAU_CREATE_DYNAMIC_AUTO</a></span><span class="refpurpose"> - Creates a dynamic timer for C/C++</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DYNAMIC_ITER">TAU_PROFILE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic timer in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_DYNAMIC_ITER">TAU_PHASE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic phase in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER">TAU_PROFILE_TIMER</a></span><span class="refpurpose"> - Defines a static timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_START">TAU_PROFILE_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STOP">TAU_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_START">TAU_STATIC_TIMER_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_STOP">TAU_STATIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_START">TAU_DYNAMIC_TIMER_START</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_STOP">TAU_DYNAMIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_DYNAMIC">TAU_PROFILE_TIMER_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DECLARE_TIMER">TAU_PROFILE_DECLARE_TIMER</a></span><span class="refpurpose"> - Declares a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_TIMER">TAU_PROFILE_CREATE_TIMER</a></span><span class="refpurpose"> - Creates a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER">TAU_GLOBAL_TIMER</a></span><span class="refpurpose"> - Declares a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_EXTERNAL">TAU_GLOBAL_TIMER_EXTERNAL</a></span><span class="refpurpose"> - Declares a global timer from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_START">TAU_GLOBAL_TIMER_START</a></span><span class="refpurpose"> - Starts a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_STOP">TAU_GLOBAL_TIMER_STOP</a></span><span class="refpurpose"> - Stops a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE">TAU_PHASE</a></span><span class="refpurpose"> - Profile a C++ function as a phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE">TAU_DYNAMIC_PHASE</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_DYNAMIC">TAU_PHASE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_STATIC">TAU_PHASE_CREATE_STATIC</a></span><span class="refpurpose"> - Defines a static phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_START">TAU_PHASE_START</a></span><span class="refpurpose"> - Enters a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_STOP">TAU_PHASE_STOP</a></span><span class="refpurpose"> - Exits a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_START">TAU_DYNAMIC_PHASE_START</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_STOP">TAU_DYNAMIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_START">TAU_STATIC_PHASE_START</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_STOP">TAU_STATIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE">TAU_GLOBAL_PHASE</a></span><span class="refpurpose"> - Declares a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_EXTERNAL">TAU_GLOBAL_PHASE_EXTERNAL</a></span><span class="refpurpose"> - Declares a global phase from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_START">TAU_GLOBAL_PHASE_START</a></span><span class="refpurpose"> - Starts a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_STOP">TAU_GLOBAL_PHASE_STOP</a></span><span class="refpurpose"> - Stops a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_EXIT">TAU_PROFILE_EXIT</a></span><span class="refpurpose"> - Alerts the profiling system to an exit call</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_THREAD">TAU_REGISTER_THREAD</a></span><span class="refpurpose"> - Register a thread with the profiling system</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_NODE">TAU_PROFILE_GET_NODE</a></span><span class="refpurpose"> - Returns the measurement system's node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_CONTEXT">TAU_PROFILE_GET_CONTEXT</a></span><span class="refpurpose"> - Gives the measurement system's context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_THREAD">TAU_PROFILE_SET_THREAD</a></span><span class="refpurpose"> - Informs the measurement system of the THREAD id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_THREAD">TAU_PROFILE_GET_THREAD</a></span><span class="refpurpose"> - Gives the measurement system's thread id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_NODE">TAU_PROFILE_SET_NODE</a></span><span class="refpurpose"> - Informs the measurement system of the node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_CONTEXT">TAU_PROFILE_SET_CONTEXT</a></span><span class="refpurpose"> - Informs the measurement system of the context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_FORK">TAU_REGISTER_FORK</a></span><span class="refpurpose"> - Informs the measurement system that a fork has taken place</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_EVENT">TAU_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_REGISTER_EVENT">TAU_PROFILER_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_THREAD">TAU_EVENT_THREAD</a></span><span class="refpurpose"> - Triggers a user event on a given thread</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_CONTEXT_EVENT">TAU_REGISTER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Registers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_CONTEXT_EVENT">TAU_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT">TAU_TRIGGER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a context user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_CONTEXT_EVENT">TAU_ENABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Enable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_CONTEXT_EVENT">TAU_DISABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Disable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_SET_NAME">TAU_EVENT_SET_NAME</a></span><span class="refpurpose"> - Sets the name of an event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MAX">TAU_EVENT_DISABLE_MAX</a></span><span class="refpurpose"> - Disables tracking of maximum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MEAN">TAU_EVENT_DISABLE_MEAN</a></span><span class="refpurpose"> - Disables tracking of mean statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MIN">TAU_EVENT_DISABLE_MIN</a></span><span class="refpurpose"> - Disables tracking of minimum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_STDDEV">TAU_EVENT_DISABLE_STDDEV</a></span><span class="refpurpose"> - Disables tracking of standard deviation statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_STATISTICS">TAU_REPORT_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_THREAD_STATISTICS">TAU_REPORT_THREAD_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics, plus thread statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_INSTRUMENTATION">TAU_ENABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Enables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_INSTRUMENTATION">TAU_DISABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Disables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP">TAU_ENABLE_GROUP</a></span><span class="refpurpose"> - Enables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP">TAU_DISABLE_GROUP</a></span><span class="refpurpose"> - Disables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP">TAU_PROFILE_TIMER_SET_GROUP</a></span><span class="refpurpose"> - Change the group of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME">TAU_PROFILE_TIMER_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name for a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_NAME">TAU_PROFILE_TIMER_SET_NAME</a></span><span class="refpurpose"> - Changes the name of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_TYPE">TAU_PROFILE_TIMER_SET_TYPE</a></span><span class="refpurpose"> - Changes the type of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_GROUP_NAME">TAU_PROFILE_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name of a profiled section</span></dt><dt><span class="refentrytitle"><a href="#TAU_INIT">TAU_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_INIT">TAU_PROFILE_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_PROFILE_GROUP">TAU_GET_PROFILE_GROUP</a></span><span class="refpurpose"> - Creates groups based on names</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP_NAME">TAU_ENABLE_GROUP_NAME</a></span><span class="refpurpose"> - Enables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP_NAME">TAU_DISABLE_GROUP_NAME</a></span><span class="refpurpose"> - Disables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_ALL_GROUPS">TAU_ENABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Enables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_ALL_GROUPS">TAU_DISABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Disables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_NAMES">TAU_GET_EVENT_NAMES</a></span><span class="refpurpose"> - Gets the registered user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_VALS">TAU_GET_EVENT_VALS</a></span><span class="refpurpose"> - Gets user event data for given user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_COUNTER_NAMES">TAU_GET_COUNTER_NAMES</a></span><span class="refpurpose"> - Gets the counter names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_NAMES">TAU_GET_FUNC_NAMES</a></span><span class="refpurpose"> - Gets the function names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_VALS">TAU_GET_FUNC_VALS</a></span><span class="refpurpose"> - Gets detailed performance data for given functions</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY">TAU_ENABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Enables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY">TAU_DISABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Disables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER">TAU_TRACK_POWER</a></span><span class="refpurpose"> - Initializes POWER tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER_HERE">TAU_TRACK_POWER_HERE</a></span><span class="refpurpose"> - Triggers power tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_POWER">TAU_ENABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Enables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_POWER">TAU_DISABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Disables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY">TAU_TRACK_MEMORY</a></span><span class="refpurpose"> - Initializes memory tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HERE">TAU_TRACK_MEMORY_HERE</a></span><span class="refpurpose"> - Triggers memory tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT">TAU_TRACK_MEMORY_FOOTPRINT</a></span><span class="refpurpose"> - Initializes memory footprint tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE">TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span><span class="refpurpose"> - Triggers memory footprint tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Enables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Disables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM">TAU_TRACK_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM_HERE">TAU_TRACK_MEMORY_HEADROOM_HERE</a></span><span class="refpurpose"> - Takes a sample of the amount of memory available at a given point.</span></dt><dt><span class="refentrytitle"><a href="#TAU_SET_INTERRUPT_INTERVAL">TAU_SET_INTERRUPT_INTERVAL</a></span><span class="refpurpose"> - Change the inter-interrupt interval for tracking memory and headroom</span></dt><dt><span class="refentrytitle"><a href="#CT">CT</a></span><span class="refpurpose"> - Returns the type information for a variable</span></dt><dt><span class="refentrytitle"><a href="#TAU_TYPE_STRING">TAU_TYPE_STRING</a></span><span class="refpurpose"> - Creates a type string</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP">TAU_DB_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_MERGED_DUMP">TAU_DB_MERGED_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_INCR">TAU_DB_DUMP_INCR</a></span><span class="refpurpose"> - Dumps profile database into timestamped profiles on disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX">TAU_DB_DUMP_PREFIX</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given prefix</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX_TASK">TAU_DB_DUMP_PREFIX_TASK</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given task</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_PURGE">TAU_DB_PURGE</a></span><span class="refpurpose"> - Purges the performance data.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_NAMES">TAU_DUMP_FUNC_NAMES</a></span><span class="refpurpose"> - Dumps function names to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS">TAU_DUMP_FUNC_VALS</a></span><span class="refpurpose"> - Dumps performance data for given functions to disk.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS_INCR">TAU_DUMP_FUNC_VALS_INCR</a></span><span class="refpurpose"> - Dumps function values with a timestamp</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STMT">TAU_PROFILE_STMT</a></span><span class="refpurpose"> - Executes a statement only when TAU is used.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CALLSTACK">TAU_PROFILE_CALLSTACK</a></span><span class="refpurpose"> - Generates a callstack trace at a given location.</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_RECVMSG">TAU_TRACE_RECVMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_SENDMSG">TAU_TRACE_SENDMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_PARAM1L">TAU_PROFILE_PARAM1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT">TAU_PROFILE_SNAPSHOT</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT_1L">TAU_PROFILE_SNAPSHOT_1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_CREATE">TAU_PROFILER_CREATE</a></span><span class="refpurpose"> - Creates a profiler object referenced as a standard pointer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_TASK">TAU_CREATE_TASK</a></span><span class="refpurpose"> - Creates a task id.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START">TAU_PROFILER_START</a></span><span class="refpurpose"> - starts a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START_TASK">TAU_PROFILER_START_TASK</a></span><span class="refpurpose"> - Starts a profiler object created by  on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP">TAU_PROFILER_STOP</a></span><span class="refpurpose"> - stops a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP_TASK">TAU_PROFILER_STOP_TASK</a></span><span class="refpurpose"> - Stops a profiler object on a task</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS">TAU_PROFILER_GET_CALLS</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS_TASK">TAU_PROFILER_GET_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS">TAU_PROFILER_GET_CHILD_CALLS</a></span><span class="refpurpose"> - Gets the number of calls made while this timer was running</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK">TAU_PROFILER_GET_CHILD_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of child call for this timer, created by , is started on a task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES">TAU_PROFILER_GET_INCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES">TAU_PROFILER_GET_EXCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO">TAU_PROFILER_GET_COUNTER_INFO</a></span><span class="refpurpose"> - Returns information about all the timers created.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK">TAU_PROFILER_GET_COUNTER_INFO_TASK</a></span><span class="refpurpose"> - Returns information about all the timers created on a task. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_DECLARE_EVENT">TAU_QUERY_DECLARE_EVENT</a></span><span class="refpurpose"> - Returns a event handle.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_CURRENT_EVENT">TAU_QUERY_GET_CURRENT_EVENT</a></span><span class="refpurpose"> - set event to be the current TAU event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_EVENT_NAME">TAU_QUERY_GET_EVENT_NAME</a></span><span class="refpurpose"> - Gets the name of a given event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_PARENT_EVENT">TAU_QUERY_GET_PARENT_EVENT</a></span><span class="refpurpose"> - gets the parent of the current event. 
	</span></dt></dl></dd><dt><span class="reference"><a href="#d0e8745">II. TAU Mapping API</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#TAU_MAPPING">TAU_MAPPING</a></span><span class="refpurpose"> - Encapsulates a C++ statement for profiling</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_CREATE">TAU_MAPPING_CREATE</a></span><span class="refpurpose"> - Creates a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_LINK">TAU_MAPPING_LINK</a></span><span class="refpurpose"> - Creates a mapping link</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_OBJECT">TAU_MAPPING_OBJECT</a></span><span class="refpurpose"> - Declares a mapping object</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE">TAU_MAPPING_PROFILE</a></span><span class="refpurpose"> - Profiles a block based on a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_START">TAU_MAPPING_PROFILE_START</a></span><span class="refpurpose"> - Starts a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_STOP">TAU_MAPPING_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_TIMER">TAU_MAPPING_PROFILE_TIMER</a></span><span class="refpurpose"> - Declares a mapping timer</span></dt></dl></dd></dl></div><div class="reference" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e4"></a>TAU Instrumentation API</h1></div></div><hr></div><div class="partintro" lang="en"><div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8"></a>Introduction</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>C++</strong></span></p><p>The C++ API is a set of macros that can be inserted in the C++
	source code. An extension of the same API is available to instrument C
	and Fortran sources.</p><p>At the beginning of each instrumented source file, include the
	following header</p><pre class="screen">
#include &lt;TAU.h&gt;
	</pre></li><li><p><span class="bold"><strong>C</strong></span></p><p>The API for instrumenting C source code is similar to the C++
        API. The primary difference is that the <code class="literal">TAU_PROFILE()</code> macro
	is not available for identifying an entire block of code or function.
	Instead, routine transitions are explicitly specified using
	<code class="literal">TAU_PROFILE_TIMER()</code> macro with
	<code class="literal">TAU_PROFILE_START()</code> and
	<code class="literal">TAU_PROFILE_STOP()</code> macros to indicate the entry and
	exit from a routine. Note that, <code class="literal">TAU_TYPE_STRING()</code> and
	CT() macros are not applicable for C. It is important to declare the
	<code class="literal">TAU_PROFILE_TIMER()</code> macro after all the variables
	have been declared in the function and before the execution of the first
        C statement. 
      </p><p>Example:</p><pre class="screen">

#include &lt;TAU.h&gt;

int main (int argc, char **argv) {
  int ret;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  pthread_attr_init(&amp;attr);
  printf("Started Main...\n");
  // other statements
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
      </pre></li><li><p><span class="bold"><strong>Fortran 77/90/95</strong></span></p><p>The Fortran90 TAU API allows source code written in Fortran to
       be instrumented for TAU. This API is comprised of Fortran routines. As
       explained in Chapter 2, the instrumentation can be disabled in the
       program by using the TAU stub makefile variable
       <code class="literal">TAU_DISABLE</code> on the link command line. This points to
       a library that contains empty TAU instrumentation routines.</p></li></ul></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e61"></a>Timers</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Static timers</strong></span></p><p>These are commonly used in most profilers where all invocations of a
		routine are recorded. The name and group registration takes place when the
		timer is created (typically the first time a routine is entered). A given
		timer is started and stopped at routine entry and exit points. A user
		defined timer can also measure the time spent in a group of statements.
		Timers may be nested but they may not overlap. The performance data
		generated can typically answer questions such as: <span class="emphasis"><em>what is the 
		total time spent in MPI_Send() across all invocations?</em></span></p></li><li><p><span class="bold"><strong>Dynamic timers</strong></span></p><p>To record the execution of each invocation of a routine, TAU
		provides dynamic timers where a unique name may be constructed for a
		dynamic timer for each iteration by embedding the iteration count in it.
		It uses the start/stop calls around the code to be examined, similar to
		static timers. The performance data generated can typically answer
		questions such as:<span class="emphasis"><em>what is the time spent in the routine foo() in
		iterations 24, 25, and 40?</em></span></p></li><li><p><span class="bold"><strong>Static phases</strong></span></p><p>An application typically goes through several phases in its
	    execution. To track the performance of the application based on
	    phases, TAU provides static and dynamic phase profiling. A profile
	    based on phases highlights the context in which a routine is
	    called. An application has a default phase within which other
	    routines and phases are invoked. A phase based profile shows the
	    time spent in a routine when it was in a given phase. So, if a set
	    of instrumented routines are called directly or indirectly by a
	    phase, we'd see the time spent in each of those routines under the
	    given phase. Since phases may be nested, a routine may belong to
	    only one phase. When more than one phase is active for a given
	    routine, the closest ancestor phase of a routine along its
	    callstack is its phase for that invocation. The performance data
	    generated can answer questions such as: <span class="emphasis"><em>what is the total
	    time spent in MPI_Send() when it was invoked in all invocations of
	    the IO (IO =&gt; MPI_Send()) phase?  </em></span></p></li><li><p><span class="bold"><strong>Dynamic phases</strong></span></p><p>Dynamic phases borrow from dynamic timers and static phases to
		create performance data for all routines that are invoked in a given
		invocation of a phase. If we instrument a routine as a dynamic phase,
		creating a unique name for each of its invocations (by embedding the
		invocation count in the name), we can examine the time spent in all
		routines and child phases invoked directly or indirectly from the given
		phase. The performance data generated can typically answer questions such
		as: 
		<span class="emphasis"><em>what is the total time spent in MPI_Send() when it was invoked
		directly or indirectly in iteration 24?</em></span> 
		Dynamic phases are useful for
		tracking per-iteration profiles for an adaptive computation where
		iterations may differ in their execution times.</p></li><li><p><span class="bold"><strong>Callpaths</strong></span></p><p>In phase-based profiles, we see the relationship between routines
		and parent phases. Phase profiles do not show the calling structure
		between different routines as is represented in a callgraph. To do so, TAU
		provides callpath profiling capabilities where the time spent in a routine
		along an edge of a callgraph is captured. Callpath profiles present the
		full flat profiles of routines (or nodes in the callgraph), as well as
		routines along a callpath. A callpath is represented syntactically as a
		list of routines separated by a delimiter. The maximum depth of a callpath
		is controlled by an environment variable.</p></li><li><p><span class="bold"><strong>User-defined Events</strong></span></p><p>Besides timers and phases that measure the time spent between a pair
		of start and stop calls in the code, TAU also provides support for
		user-defined atomic events. After an event is registered with a name, it
		may be triggered with a value at a given point in the source code. At the
		application level, we can use user-defined events to track the progress of
		the simulation by keeping track of application specific parameters that
		explain program dynamics, for example, the number of iterations required
		for convergence of a solver at each time step, or the number of cells in
		each iteration of an adaptive mesh refinement application.</p></li></ul></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#TAU_START">TAU_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STOP">TAU_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE">TAU_PROFILE</a></span><span class="refpurpose"> - Profile a C++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PROFILE">TAU_DYNAMIC_PROFILE</a></span><span class="refpurpose"> - dynamic_profile a c++ function</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_DYNAMIC">TAU_PROFILE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Creates a dynamic timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_DYNAMIC_AUTO">TAU_CREATE_DYNAMIC_AUTO</a></span><span class="refpurpose"> - Creates a dynamic timer for C/C++</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DYNAMIC_ITER">TAU_PROFILE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic timer in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_DYNAMIC_ITER">TAU_PHASE_DYNAMIC_ITER</a></span><span class="refpurpose"> - Creates a dynamic phase in Fortran.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER">TAU_PROFILE_TIMER</a></span><span class="refpurpose"> - Defines a static timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_START">TAU_PROFILE_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STOP">TAU_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_START">TAU_STATIC_TIMER_START</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_TIMER_STOP">TAU_STATIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_START">TAU_DYNAMIC_TIMER_START</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_TIMER_STOP">TAU_DYNAMIC_TIMER_STOP</a></span><span class="refpurpose"> - Starts a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_DYNAMIC">TAU_PROFILE_TIMER_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic timer.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_DECLARE_TIMER">TAU_PROFILE_DECLARE_TIMER</a></span><span class="refpurpose"> - Declares a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CREATE_TIMER">TAU_PROFILE_CREATE_TIMER</a></span><span class="refpurpose"> - Creates a timer for C</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER">TAU_GLOBAL_TIMER</a></span><span class="refpurpose"> - Declares a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_EXTERNAL">TAU_GLOBAL_TIMER_EXTERNAL</a></span><span class="refpurpose"> - Declares a global timer from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_START">TAU_GLOBAL_TIMER_START</a></span><span class="refpurpose"> - Starts a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_TIMER_STOP">TAU_GLOBAL_TIMER_STOP</a></span><span class="refpurpose"> - Stops a global timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE">TAU_PHASE</a></span><span class="refpurpose"> - Profile a C++ function as a phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE">TAU_DYNAMIC_PHASE</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_DYNAMIC">TAU_PHASE_CREATE_DYNAMIC</a></span><span class="refpurpose"> - Defines a dynamic phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_CREATE_STATIC">TAU_PHASE_CREATE_STATIC</a></span><span class="refpurpose"> - Defines a static phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_START">TAU_PHASE_START</a></span><span class="refpurpose"> - Enters a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PHASE_STOP">TAU_PHASE_STOP</a></span><span class="refpurpose"> - Exits a phase.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_START">TAU_DYNAMIC_PHASE_START</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DYNAMIC_PHASE_STOP">TAU_DYNAMIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a DYNAMIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_START">TAU_STATIC_PHASE_START</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_STATIC_PHASE_STOP">TAU_STATIC_PHASE_STOP</a></span><span class="refpurpose"> - Enters a STATIC_PHASE.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE">TAU_GLOBAL_PHASE</a></span><span class="refpurpose"> - Declares a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_EXTERNAL">TAU_GLOBAL_PHASE_EXTERNAL</a></span><span class="refpurpose"> - Declares a global phase from an external compilation unit</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_START">TAU_GLOBAL_PHASE_START</a></span><span class="refpurpose"> - Starts a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_GLOBAL_PHASE_STOP">TAU_GLOBAL_PHASE_STOP</a></span><span class="refpurpose"> - Stops a global phase</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_EXIT">TAU_PROFILE_EXIT</a></span><span class="refpurpose"> - Alerts the profiling system to an exit call</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_THREAD">TAU_REGISTER_THREAD</a></span><span class="refpurpose"> - Register a thread with the profiling system</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_NODE">TAU_PROFILE_GET_NODE</a></span><span class="refpurpose"> - Returns the measurement system's node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_CONTEXT">TAU_PROFILE_GET_CONTEXT</a></span><span class="refpurpose"> - Gives the measurement system's context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_THREAD">TAU_PROFILE_SET_THREAD</a></span><span class="refpurpose"> - Informs the measurement system of the THREAD id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_GET_THREAD">TAU_PROFILE_GET_THREAD</a></span><span class="refpurpose"> - Gives the measurement system's thread id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_NODE">TAU_PROFILE_SET_NODE</a></span><span class="refpurpose"> - Informs the measurement system of the node id</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_CONTEXT">TAU_PROFILE_SET_CONTEXT</a></span><span class="refpurpose"> - Informs the measurement system of the context id</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_FORK">TAU_REGISTER_FORK</a></span><span class="refpurpose"> - Informs the measurement system that a fork has taken place</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_EVENT">TAU_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_REGISTER_EVENT">TAU_PROFILER_REGISTER_EVENT</a></span><span class="refpurpose"> - Registers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_THREAD">TAU_EVENT_THREAD</a></span><span class="refpurpose"> - Triggers a user event on a given thread</span></dt><dt><span class="refentrytitle"><a href="#TAU_REGISTER_CONTEXT_EVENT">TAU_REGISTER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Registers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_CONTEXT_EVENT">TAU_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT">TAU_TRIGGER_CONTEXT_EVENT</a></span><span class="refpurpose"> - Triggers a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRIGGER_CONTEXT_EVENT_THREAD">TAU_EVENT</a></span><span class="refpurpose"> - Triggers a context user event</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_CONTEXT_EVENT">TAU_ENABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Enable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_CONTEXT_EVENT">TAU_DISABLE_CONTEXT_EVENT</a></span><span class="refpurpose"> - Disable a context event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_SET_NAME">TAU_EVENT_SET_NAME</a></span><span class="refpurpose"> - Sets the name of an event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MAX">TAU_EVENT_DISABLE_MAX</a></span><span class="refpurpose"> - Disables tracking of maximum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MEAN">TAU_EVENT_DISABLE_MEAN</a></span><span class="refpurpose"> - Disables tracking of mean statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_MIN">TAU_EVENT_DISABLE_MIN</a></span><span class="refpurpose"> - Disables tracking of minimum statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_EVENT_DISABLE_STDDEV">TAU_EVENT_DISABLE_STDDEV</a></span><span class="refpurpose"> - Disables tracking of standard deviation statistic for a given event</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_STATISTICS">TAU_REPORT_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_REPORT_THREAD_STATISTICS">TAU_REPORT_THREAD_STATISTICS</a></span><span class="refpurpose"> - Outputs statistics, plus thread statistics</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_INSTRUMENTATION">TAU_ENABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Enables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_INSTRUMENTATION">TAU_DISABLE_INSTRUMENTATION</a></span><span class="refpurpose"> - Disables instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP">TAU_ENABLE_GROUP</a></span><span class="refpurpose"> - Enables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP">TAU_DISABLE_GROUP</a></span><span class="refpurpose"> - Disables tracking of a given group</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP">TAU_PROFILE_TIMER_SET_GROUP</a></span><span class="refpurpose"> - Change the group of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME">TAU_PROFILE_TIMER_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name for a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_NAME">TAU_PROFILE_TIMER_SET_NAME</a></span><span class="refpurpose"> - Changes the name of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_TIMER_SET_TYPE">TAU_PROFILE_TIMER_SET_TYPE</a></span><span class="refpurpose"> - Changes the type of a timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SET_GROUP_NAME">TAU_PROFILE_SET_GROUP_NAME</a></span><span class="refpurpose"> - Changes the group name of a profiled section</span></dt><dt><span class="refentrytitle"><a href="#TAU_INIT">TAU_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_INIT">TAU_PROFILE_INIT</a></span><span class="refpurpose"> - Processes command-line arguments for selective instrumentation</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_PROFILE_GROUP">TAU_GET_PROFILE_GROUP</a></span><span class="refpurpose"> - Creates groups based on names</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_GROUP_NAME">TAU_ENABLE_GROUP_NAME</a></span><span class="refpurpose"> - Enables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_GROUP_NAME">TAU_DISABLE_GROUP_NAME</a></span><span class="refpurpose"> - Disables a group based on name</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_ALL_GROUPS">TAU_ENABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Enables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_ALL_GROUPS">TAU_DISABLE_ALL_GROUPS</a></span><span class="refpurpose"> - Disables instrumentation in all groups</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_NAMES">TAU_GET_EVENT_NAMES</a></span><span class="refpurpose"> - Gets the registered user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_EVENT_VALS">TAU_GET_EVENT_VALS</a></span><span class="refpurpose"> - Gets user event data for given user events.</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_COUNTER_NAMES">TAU_GET_COUNTER_NAMES</a></span><span class="refpurpose"> - Gets the counter names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_NAMES">TAU_GET_FUNC_NAMES</a></span><span class="refpurpose"> - Gets the function names</span></dt><dt><span class="refentrytitle"><a href="#TAU_GET_FUNC_VALS">TAU_GET_FUNC_VALS</a></span><span class="refpurpose"> - Gets detailed performance data for given functions</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY">TAU_ENABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Enables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY">TAU_DISABLE_TRACKING_MEMORY</a></span><span class="refpurpose"> - Disables memory tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER">TAU_TRACK_POWER</a></span><span class="refpurpose"> - Initializes POWER tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_POWER_HERE">TAU_TRACK_POWER_HERE</a></span><span class="refpurpose"> - Triggers power tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_POWER">TAU_ENABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Enables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_POWER">TAU_DISABLE_TRACKING_POWER</a></span><span class="refpurpose"> - Disables power headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY">TAU_TRACK_MEMORY</a></span><span class="refpurpose"> - Initializes memory tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HERE">TAU_TRACK_MEMORY_HERE</a></span><span class="refpurpose"> - Triggers memory tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT">TAU_TRACK_MEMORY_FOOTPRINT</a></span><span class="refpurpose"> - Initializes memory footprint tracking system</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE">TAU_TRACK_MEMORY_FOOTPRINT_HERE</a></span><span class="refpurpose"> - Triggers memory footprint tracking at a given execution point</span></dt><dt><span class="refentrytitle"><a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Enables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Disables memory headroom tracking</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM">TAU_TRACK_MEMORY_HEADROOM</a></span><span class="refpurpose"> - Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACK_MEMORY_HEADROOM_HERE">TAU_TRACK_MEMORY_HEADROOM_HERE</a></span><span class="refpurpose"> - Takes a sample of the amount of memory available at a given point.</span></dt><dt><span class="refentrytitle"><a href="#TAU_SET_INTERRUPT_INTERVAL">TAU_SET_INTERRUPT_INTERVAL</a></span><span class="refpurpose"> - Change the inter-interrupt interval for tracking memory and headroom</span></dt><dt><span class="refentrytitle"><a href="#CT">CT</a></span><span class="refpurpose"> - Returns the type information for a variable</span></dt><dt><span class="refentrytitle"><a href="#TAU_TYPE_STRING">TAU_TYPE_STRING</a></span><span class="refpurpose"> - Creates a type string</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP">TAU_DB_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_MERGED_DUMP">TAU_DB_MERGED_DUMP</a></span><span class="refpurpose"> - Dumps the profile database to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_INCR">TAU_DB_DUMP_INCR</a></span><span class="refpurpose"> - Dumps profile database into timestamped profiles on disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX">TAU_DB_DUMP_PREFIX</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given prefix</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_DUMP_PREFIX_TASK">TAU_DB_DUMP_PREFIX_TASK</a></span><span class="refpurpose"> - Dumps the profile database into profile files with a given task</span></dt><dt><span class="refentrytitle"><a href="#TAU_DB_PURGE">TAU_DB_PURGE</a></span><span class="refpurpose"> - Purges the performance data.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_NAMES">TAU_DUMP_FUNC_NAMES</a></span><span class="refpurpose"> - Dumps function names to disk</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS">TAU_DUMP_FUNC_VALS</a></span><span class="refpurpose"> - Dumps performance data for given functions to disk.</span></dt><dt><span class="refentrytitle"><a href="#TAU_DUMP_FUNC_VALS_INCR">TAU_DUMP_FUNC_VALS_INCR</a></span><span class="refpurpose"> - Dumps function values with a timestamp</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_STMT">TAU_PROFILE_STMT</a></span><span class="refpurpose"> - Executes a statement only when TAU is used.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_CALLSTACK">TAU_PROFILE_CALLSTACK</a></span><span class="refpurpose"> - Generates a callstack trace at a given location.</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_RECVMSG">TAU_TRACE_RECVMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_TRACE_SENDMSG">TAU_TRACE_SENDMSG</a></span><span class="refpurpose"> - Traces a receive operation</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_PARAM1L">TAU_PROFILE_PARAM1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT">TAU_PROFILE_SNAPSHOT</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILE_SNAPSHOT_1L">TAU_PROFILE_SNAPSHOT_1L</a></span><span class="refpurpose"> - Creates a snapshot of the current apllication profile</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_CREATE">TAU_PROFILER_CREATE</a></span><span class="refpurpose"> - Creates a profiler object referenced as a standard pointer</span></dt><dt><span class="refentrytitle"><a href="#TAU_CREATE_TASK">TAU_CREATE_TASK</a></span><span class="refpurpose"> - Creates a task id.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START">TAU_PROFILER_START</a></span><span class="refpurpose"> - starts a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_START_TASK">TAU_PROFILER_START_TASK</a></span><span class="refpurpose"> - Starts a profiler object created by  on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP">TAU_PROFILER_STOP</a></span><span class="refpurpose"> - stops a profiler object created by </span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_STOP_TASK">TAU_PROFILER_STOP_TASK</a></span><span class="refpurpose"> - Stops a profiler object on a task</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS">TAU_PROFILER_GET_CALLS</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CALLS_TASK">TAU_PROFILER_GET_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of times this timer, created by , is started on a given task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS">TAU_PROFILER_GET_CHILD_CALLS</a></span><span class="refpurpose"> - Gets the number of calls made while this timer was running</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK">TAU_PROFILER_GET_CHILD_CALLS_TASK</a></span><span class="refpurpose"> - Gets the number of child call for this timer, created by , is started on a task.</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES">TAU_PROFILER_GET_INCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES">TAU_PROFILER_GET_EXCLUSIVE_VALUES</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</a></span><span class="refpurpose"> - Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO">TAU_PROFILER_GET_COUNTER_INFO</a></span><span class="refpurpose"> - Returns information about all the timers created.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK">TAU_PROFILER_GET_COUNTER_INFO_TASK</a></span><span class="refpurpose"> - Returns information about all the timers created on a task. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_DECLARE_EVENT">TAU_QUERY_DECLARE_EVENT</a></span><span class="refpurpose"> - Returns a event handle.
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_CURRENT_EVENT">TAU_QUERY_GET_CURRENT_EVENT</a></span><span class="refpurpose"> - set event to be the current TAU event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_EVENT_NAME">TAU_QUERY_GET_EVENT_NAME</a></span><span class="refpurpose"> - Gets the name of a given event. 
	</span></dt><dt><span class="refentrytitle"><a href="#TAU_QUERY_GET_PARENT_EVENT">TAU_QUERY_GET_PARENT_EVENT</a></span><span class="refpurpose"> - gets the parent of the current event. 
	</span></dt></dl></div></div><div class="refentry" lang="en"><a name="TAU_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>character <var class="pdparam">name</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e145"></a><h2>Description</h2><p>Starts the timer given by <em class="parameter"><code>name</code></em></p></div><div class="refsect1" lang="en"><a name="d0e152"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  
	call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e165"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STOP" title="TAU_STOP"><span class="refentrytitle">TAU_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STOP &#8212; Stops a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>character <var class="pdparam">name</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e209"></a><h2>Description</h2><p>Stops the timer given by <em class="parameter"><code>timer</code></em>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</p></div><div class="refsect1" lang="en"><a name="d0e217"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e230"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_START" title="TAU_START"><span class="refentrytitle">TAU_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE &#8212; Profile a C++ function</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e266"></a><h2>Description</h2><p><code class="function">TAU_PROFILE</code> profiles a function.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e273"></a><h2>Example</h2><pre class="screen">
int foo(char *str) {
  TAU_PROFILE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e278"></a><h2>See Also</h2><p><a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PROFILE &#8212; dynamic_profile a c++ function</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PROFILE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e310"></a><h2>description</h2><p><code class="function">TAU_DYNAMIC_PROFILE</code> profiles a function dynamically
    creating a separate profile for each time the function is called.  this macro
    defines the function and takes care of the timer start and stop as well.
    the timer will stop when the macro goes out of scope (as in c++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e317"></a><h2>example</h2><pre class="screen">
int foo(char *str) {
  tau_dynamic_profile("foo","int (char *)",tau_default);
  ...
}
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CREATE_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CREATE_DYNAMIC &#8212; Creates a dynamic timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e377"></a><h2>description</h2><p><code class="function">TAU_PROFILE_CREATE_DYNAMIC</code> creates a dynamic
    timer the name of the timer should be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e384"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
</pre><p>&gt;<span class="bold"><strong>Fortran:</strong></span></p><pre class="screen">
 subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
</pre></div><div class="refsect1" lang="en"><a name="d0e399"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CREATE_DYNAMIC_AUTO"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CREATE_DYNAMIC_AUTO &#8212; Creates a dynamic timer for C/C++</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CREATE_DYNAMIC_AUTO</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e437"></a><h2>description</h2><p><code class="function">TAU_CREATE_DYNAMIC_AUTO</code> creates a dynamic
    timer automatically incrementing the name each time the timer is executed.</p></div><div class="refsect1" lang="en"><a name="d0e444"></a><h2>example</h2><pre class="screen">
int tau_ret_val;
TAU_PROFILE_CREATE_DYNAMIC_AUTO(tautimer, "int foo1(int) C [{foo.c} {22,1}-{29,1}]", " ",TAU_USER);
TAU_PROFILE_START(tautimer);
{
printf("inside foo1: calling bar: x = %d\n", x);
printf("before calling bar in foo1\n");
bar(x-1); /* 26 */
printf("after calling bar in foo1\n");
{ tau_ret_val =  x; TAU_PROFILE_STOP(tautimer); return (tau_ret_val); }</pre></div><div class="refsect1" lang="en"><a name="d0e449"></a><h2>see also</h2><p><a href="#TAU_PROFILE_CREATE_DYNAMIC" title="TAU_PROFILE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_CREATE_DYNAMIC</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_DYNAMIC_ITER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_DYNAMIC_ITER &#8212; Creates a dynamic timer in Fortran.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_DYNAMIC_ITER</b>(</code></td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iterator</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e487"></a><h2>description</h2><p><code class="function">TAU_PROFILE_DYNAMIC_ITER</code> creates a dynamic
    timer the name of the timer is appended by the iterator.</p></div><div class="refsect1" lang="en"><a name="d0e494"></a><h2>example</h2><pre class="screen">
  integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PROFILE_DYNAMIC_ITER(tau_iter, profiler, '               &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PROFILE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</pre></div><div class="refsect1" lang="en"><a name="d0e499"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_DYNAMIC_ITER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_DYNAMIC_ITER &#8212; Creates a dynamic phase in Fortran.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_DYNAMIC_ITER</b>(</code></td><td><var class="pdparam">iterator</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iterator</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">timer</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e535"></a><h2>description</h2><p><code class="function">TAU_PHASE_DYNAMIC_ITER</code> creates a dynamic
    phase the name of which is appended by the iterator.</p></div><div class="refsect1" lang="en"><a name="d0e542"></a><h2>example</h2><pre class="screen">
          integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PHASE_DYNAMIC_ITER(tau_iter, profiler, '                 &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PHASE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</pre></div><div class="refsect1" lang="en"><a name="d0e547"></a><h2>see also</h2><p><a href="#TAU_DYNAMIC_TIMER_START" title="TAU_DYNAMIC_TIMER_START"><span class="refentrytitle">TAU_DYNAMIC_TIMER_START</span></a></p><p><a href="#TAU_DYNAMIC_TIMER_STOP" title="TAU_DYNAMIC_TIMER_STOP"><span class="refentrytitle">TAU_DYNAMIC_TIMER_STOP</span></a></p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER &#8212; Defines a static timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">profiler</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e606"></a><h2>Description</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><p>With <code class="literal">TAU_PROFILE_TIMER</code>, a group of one or more
    statements is profiled. This macro has a timer variable as its first
    argument, and then strings for name and type, as described earlier. It
    associates the timer to the profile group specified in the last
    parameter. </p><p><span class="bold"><strong>Fortran :</strong></span></p><p>To profile a block of Fortran code, such as a function, subroutine,
    loop etc., the user must first declare a profiler, which is an integer array
    of two elements (pointer) with the save attribute, and pass it as the first
    parameter to the <code class="literal">TAU_PROFILE_TIMER</code> subroutine. The second
    parameter must contain the name of the routine, which is enclosed in a single
    quote. <code class="literal">TAU_PROFILE_TIMER</code> declares the profiler that must
    be used to profile a block of code. The profiler is used to profile the
    statements using <code class="literal">TAU_PROFILE_START</code> and
    <code class="literal">TAU_PROFILE_STOP</code> as explained later.
    </p></div><div class="refsect1" lang="en"><a name="d0e634"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt; class T, unsigned Dim &gt;
void BareField&lt;T,Dim&gt;::fillGuardCells(bool reallyFill)
{y
 // profiling macros
 TAU_TYPE_STRING(taustr, CT(*this) + " void (bool)" );
 TAU_PROFILE("BareField::fillGuardCells()", taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(sendtimer, "fillGuardCells-send", 
                   taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(localstimer, "fillGuardCells-locals",
                   taustr, TAU_FIELD);
 ...
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine bcast_inputs
implicit none
integer profiler(2)
save profiler
					
include 'mpinpb.h'
include 'applu.incl'
					
interger IERR
					
call TAU_PROFILE_TIMER(profiler, 'bcast_inputs')
  </pre></div><div class="refsect1" lang="en"><a name="d0e647"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER_DYNAMIC" title="TAU_PROFILE_TIMER_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_TIMER_DYNAMIC</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>, 
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_START</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e693"></a><h2>Description</h2><p>Starts the timer given by <em class="parameter"><code>timer</code></em></p></div><div class="refsect1" lang="en"><a name="d0e700"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e713"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_STOP &#8212; Stops a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STOP</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e757"></a><h2>Description</h2><p>Stops the timer given by <em class="parameter"><code>timer</code></em>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</p></div><div class="refsect1" lang="en"><a name="d0e765"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e778"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_TIMER_START &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_START</b>(</code></td><td><var class="pdparam">profiler</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e822"></a><h2>Description</h2><p>Starts a static timer defined by <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e829"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </pre></div><div class="refsect1" lang="en"><a name="d0e842"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STATIC_PHASE_START" title="TAU_STATIC_PHASE_START"><span class="refentrytitle">TAU_STATIC_PHASE_START</span></a>,
      <a href="#TAU_STATIC_PHASE_STOP" title="TAU_STATIC_PHASE_STOP"><span class="refentrytitle">TAU_STATIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_TIMER_STOP &#8212; Starts a timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_TIMER_STOP</b>(</code><var class="pdparam">profiler</var><code>)</code>;<br>integer <var class="pdparam">profiler</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e888"></a><h2>Description</h2><p>Starts a static timer defined by <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e895"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </pre></div><div class="refsect1" lang="en"><a name="d0e908"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_STATIC_PHASE_START" title="TAU_STATIC_PHASE_START"><span class="refentrytitle">TAU_STATIC_PHASE_START</span></a>,
      <a href="#TAU_STATIC_PHASE_STOP" title="TAU_STATIC_PHASE_STOP"><span class="refentrytitle">TAU_STATIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_TIMER_START &#8212; Starts a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>String <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_START</b>(</code></td><td><var class="pdparam">iteration</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iteration</var>;</td></tr><tr><td>char &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e958"></a><h2>Description</h2><p>Starts a new dynamic timer concating the iterator to the end of the
    name.</p></div><div class="refsect1" lang="en"><a name="d0e963"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e976"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_TIMER_STOP &#8212; Starts a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>String <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_TIMER_STOP</b>(</code></td><td><var class="pdparam">iteration</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">iteration</var>;</td></tr><tr><td>char &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1024"></a><h2>Description</h2><p>Stops a new dynamic timer concating the iterator to the end of the
    name.<em class="parameter"><code>timer</code></em></p></div><div class="refsect1" lang="en"><a name="d0e1031"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e1044"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_DYNAMIC &#8212; Defines a dynamic timer.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_DYNAMIC</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_DYNAMIC</b>(</code></td><td><var class="pdparam">profiler</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">profiler</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1105"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_TIMER_DYNAMIC</code> operates similar to
  <code class="literal">TAU_PROFILE_TIMER</code> except that the timer is created each
  time the statement is invoked.  This way, the name of the timer can be
  different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e1115"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_TIMER_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_TIMER_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e1128"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_DECLARE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_DECLARE_TIMER &#8212; Declares a timer for C</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_DECLARE_TIMER</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e1162"></a><h2>Description</h2><p>Because C89 does not allow mixed code and declarations,
    <code class="literal">TAU_PROFILE_TIMER</code> can only be used once in a function.  To
    declare two timers in a C function, use
    <code class="literal">TAU_PROFILE_DECLARE_TIMER</code> and
    <code class="literal">TAU_PROFILE_CREATE_TIMER</code>.</p></div><div class="refsect1" lang="en"><a name="d0e1176"></a><h2>Example</h2><p><span class="bold"><strong>C :</strong></span></p><pre class="screen">int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1184"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_CREATE_TIMER" title="TAU_PROFILE_CREATE_TIMER"><span class="refentrytitle">TAU_PROFILE_CREATE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CREATE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CREATE_TIMER &#8212; Creates a timer for C</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CREATE_TIMER</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e1212"></a><h2>Description</h2><p>Because C89 does not allow mixed code and declarations,
  <code class="literal">TAU_PROFILE_TIMER</code> can only be used once in a function.  To
  declare two timers in a C function, use
  <code class="literal">TAU_PROFILE_DECLARE_TIMER</code> and
  <code class="literal">TAU_PROFILE_CREATE_TIMER</code>.</p></div><div class="refsect1" lang="en"><a name="d0e1226"></a><h2>Example</h2><p><span class="bold"><strong>C :</strong></span></p><pre class="screen">int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}</pre></div><div class="refsect1" lang="en"><a name="d0e1234"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_DECLARE_TIMER" title="TAU_PROFILE_DECLARE_TIMER"><span class="refentrytitle">TAU_PROFILE_DECLARE_TIMER</span></a>,
      <a href="#TAU_PROFILE_START" title="TAU_PROFILE_START"><span class="refentrytitle">TAU_PROFILE_START</span></a>,
      <a href="#TAU_PROFILE_STOP" title="TAU_PROFILE_STOP"><span class="refentrytitle">TAU_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER &#8212; Declares a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1280"></a><h2>Description</h2><p>As <code class="literal">TAU_PROFILE_TIMER</code> is used within the scope of a
    block (typically a routine), <code class="literal">TAU_GLOBAL_TIMER</code> can be used
    across different routines. </p></div><div class="refsect1" lang="en"><a name="d0e1291"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1299"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_EXTERNAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_EXTERNAL &#8212; Declares a global timer from an external compilation unit</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_EXTERNAL</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e1331"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_EXTERNAL</code> allows you to access a
    timer defined in another compilation unit.</p></div><div class="refsect1" lang="en"><a name="d0e1338"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1346"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_START &#8212; Starts a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e1380"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_START</code> starts a global timer.</p></div><div class="refsect1" lang="en"><a name="d0e1387"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1395"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_STOP" title="TAU_GLOBAL_TIMER_STOP"><span class="refentrytitle">TAU_GLOBAL_TIMER_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_TIMER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_TIMER_STOP &#8212; Stops a global timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_TIMER_STOP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e1426"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_TIMER_STOP</code> stops a global timer.</p></div><div class="refsect1" lang="en"><a name="d0e1433"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1441"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_TIMER" title="TAU_GLOBAL_TIMER"><span class="refentrytitle">TAU_GLOBAL_TIMER</span></a>,
      <a href="#TAU_GLOBAL_TIMER_EXTERNAL" title="TAU_GLOBAL_TIMER_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_TIMER_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_TIMER_START" title="TAU_GLOBAL_TIMER_START"><span class="refentrytitle">TAU_GLOBAL_TIMER_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE &#8212; Profile a C++ function as a phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE</b>(</code></td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1481"></a><h2>Description</h2><p><code class="function">TAU_PHASE</code> profiles a function as a phase.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</p></div><div class="refsect1" lang="en"><a name="d0e1488"></a><h2>Example</h2><pre class="screen">
int foo(char *str) {
  TAU_PHASE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e1493"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE &#8212; Defines a dynamic phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1554"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE</code> creates a dynamic phase.
  The name of the timer can be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e1561"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_DYNAMIC_PHASE(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_DYNAMIC_PHASE(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e1574"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_DYNAMIC_PHASE_START" title="TAU_DYNAMIC_PHASE_START"><span class="refentrytitle">TAU_DYNAMIC_PHASE_START</span></a>,
      <a href="#TAU_DYNAMIC_PHASE_STOP" title="TAU_DYNAMIC_PHASE_STOP"><span class="refentrytitle">TAU_DYNAMIC_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_CREATE_DYNAMIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_CREATE_DYNAMIC &#8212; Defines a dynamic phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_DYNAMIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1637"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_CREATE_DYNAMIC</code> creates a dynamic phase.
  The name of the timer can be different for each execution.</p></div><div class="refsect1" lang="en"><a name="d0e1644"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PHASE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PHASE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </pre></div><div class="refsect1" lang="en"><a name="d0e1657"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_CREATE_STATIC"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_CREATE_STATIC &#8212; Defines a static phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_STATIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PHASE_CREATE_STATIC</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">phase</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e1720"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_CREATE_STATIC</code> creates a static phase.
  Static phases (and timers) are more efficient than dynamic ones because the
  function registration only takes place once.</p></div><div class="refsect1" lang="en"><a name="d0e1727"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.phase("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e1746"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_START &#8212; Enters a phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>integer <var class="pdparam">phase</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e1792"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_START</code> enters a phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e1799"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre></div><div class="refsect1" lang="en"><a name="d0e1812"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PHASE_STOP &#8212; Exits a phase.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>integer <var class="pdparam">phase</var>(2);</p></div></div><div class="refsect1" lang="en"><a name="d0e1858"></a><h2>Description</h2><p><code class="literal">TAU_PHASE_STOP</code> exits a phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e1865"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</pre></div><div class="refsect1" lang="en"><a name="d0e1878"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_START" title="TAU_PHASE_START"><span class="refentrytitle">TAU_PHASE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE_START &#8212; Enters a DYNAMIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e1924"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE_START</code> enters a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e1931"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e1944"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DYNAMIC_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DYNAMIC_PHASE_STOP &#8212; Enters a DYNAMIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DYNAMIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e1990"></a><h2>Description</h2><p><code class="literal">TAU_DYNAMIC_PHASE_STOP</code> leaves a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e1997"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e2010"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_PHASE_START &#8212; Enters a STATIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_START</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e2056"></a><h2>Description</h2><p><code class="literal">TAU_STATIC_PHASE_START</code> enters a static phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e2063"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e2076"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_STATIC_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_STATIC_PHASE_STOP &#8212; Enters a STATIC_PHASE.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>string <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_STATIC_PHASE_STOP</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char <var class="pdparam">name</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e2122"></a><h2>Description</h2><p><code class="literal">TAU_STATIC_PHASE_STOP</code> leaves a static phase.  Phases can be
  nested, but not overlapped.</p></div><div class="refsect1" lang="en"><a name="d0e2129"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </pre></div><div class="refsect1" lang="en"><a name="d0e2142"></a><h2>See Also</h2><p>
      <a href="#TAU_PHASE_CREATE_STATIC" title="TAU_PHASE_CREATE_STATIC"><span class="refentrytitle">TAU_PHASE_CREATE_STATIC</span></a>,
      <a href="#TAU_PHASE_CREATE_DYNAMIC" title="TAU_PHASE_CREATE_DYNAMIC"><span class="refentrytitle">TAU_PHASE_CREATE_DYNAMIC</span></a>,
      <a href="#TAU_PHASE_STOP" title="TAU_PHASE_STOP"><span class="refentrytitle">TAU_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE &#8212; Declares a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE</b>(</code></td><td><var class="pdparam">phase</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Phase &nbsp;</td><td><var class="pdparam">phase</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e2188"></a><h2>Description</h2><p>Declares a global phase to be used in multiple compilation units.</p></div><div class="refsect1" lang="en"><a name="d0e2193"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e2201"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_EXTERNAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_EXTERNAL &#8212; Declares a global phase from an external compilation unit</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_EXTERNAL</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Profiler <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2235"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_EXTERNAL</code> allows you to access a
    phase defined in another compilation unit.</p></div><div class="refsect1" lang="en"><a name="d0e2242"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e2250"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_START &#8212; Starts a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_START</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2284"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_START</code> starts a global phase.</p></div><div class="refsect1" lang="en"><a name="d0e2291"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e2299"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_STOP" title="TAU_GLOBAL_PHASE_STOP"><span class="refentrytitle">TAU_GLOBAL_PHASE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GLOBAL_PHASE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GLOBAL_PHASE_STOP &#8212; Stops a global phase</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GLOBAL_PHASE_STOP</b>(</code><var class="pdparam">phase</var><code>)</code>;<br>Phase <var class="pdparam">phase</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2333"></a><h2>Description</h2><p><code class="literal">TAU_GLOBAL_PHASE_STOP</code> stops a global phase.</p></div><div class="refsect1" lang="en"><a name="d0e2340"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_STOP(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e2348"></a><h2>See Also</h2><p>
      <a href="#TAU_GLOBAL_PHASE" title="TAU_GLOBAL_PHASE"><span class="refentrytitle">TAU_GLOBAL_PHASE</span></a>,
      <a href="#TAU_GLOBAL_PHASE_EXTERNAL" title="TAU_GLOBAL_PHASE_EXTERNAL"><span class="refentrytitle">TAU_GLOBAL_PHASE_EXTERNAL</span></a>,
      <a href="#TAU_GLOBAL_PHASE_START" title="TAU_GLOBAL_PHASE_START"><span class="refentrytitle">TAU_GLOBAL_PHASE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_EXIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_EXIT &#8212; Alerts the profiling system to an exit call</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_EXIT</b>(</code><var class="pdparam">message</var><code>)</code>;<br>const char * <var class="pdparam">message</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_EXIT</b>(</code><var class="pdparam">message</var><code>)</code>;<br>character <var class="pdparam">message</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e2395"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_EXIT</code> should be called prior to an
    error exit from the program so that any profiles or event traces can be
    dumped to disk before quitting.</p></div><div class="refsect1" lang="en"><a name="d0e2403"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if ((ret = open(...)) &lt; 0) {
  TAU_PROFILE_EXIT("ERROR in opening a file");
  perror("open() failed");
  exit(1);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_PROFILE_EXIT('abort called')
    </pre></div><div class="refsect1" lang="en"><a name="d0e2416"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_THREAD &#8212; Register a thread with the profiling system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REGISTER_THREAD</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REGISTER_THREAD</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2451"></a><h2>Description</h2><p>To register a thread with the profiling system, invoke the
    <code class="literal">TAU_REGISTER_THREAD</code> macro in the run method of the
    thread prior to executing any other TAU macro. This sets up thread
    identifiers that are later used by the instrumentation system.</p></div><div class="refsect1" lang="en"><a name="d0e2459"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void * threaded_func(void *data) {
  TAU_REGISTER_THREAD();
  { /**** NOTE WE START ANOTHER BLOCK IN THREAD */
    TAU_PROFILE_TIMER(tautimer, "threaded_func()", "int ()", 
                      TAU_DEFAULT);
    TAU_PROFILE_START(tautimer);
    work(); /* work done by this thread */
    TAU_PROFILE_STOP(tautimer);
  }
  return NULL;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REGISTER_THREAD()
    </pre></div><div class="refsect1" lang="en"><a name="d0e2472"></a><h2>Caveat</h2><p>PDT based tau_instrumentor does not insert <code class="literal">TAU_REGISTER_THREAD</code> calls,
    they must be inserted manually</p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_NODE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_NODE &#8212; Returns the measurement system's node id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>int <var class="pdparam">node</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>integer <var class="pdparam">node</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2514"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_NODE</code> gives the node id for the
		processes in which it is called. When using MPI node id is the same as MPI
		rank.</p></div><div class="refsect1" lang="en"><a name="d0e2521"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
	int nodeid;
  TAU_PROFILE_GET_NODE(nodeid);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: N
      call TAU_PROFILE_GET_NODE(N)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setNode(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e2539"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_GET_CONTEXT" title="TAU_PROFILE_GET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_GET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_CONTEXT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_CONTEXT &#8212; Gives the measurement system's context id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>int <var class="pdparam">context</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>integer <var class="pdparam">context</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2580"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_CONTEXT</code> gives the context id for the
		processes in which it is called.
		</p></div><div class="refsect1" lang="en"><a name="d0e2587"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_CONTEXT(i);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: C 
        call TAU_PROFILE_GET_CONTEXT(C)
      END PROGRAM SUM_OF_CUBES
    </pre></div><div class="refsect1" lang="en"><a name="d0e2600"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_THREAD &#8212; Informs the measurement system of the THREAD id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>int <var class="pdparam">THREAD</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>integer <var class="pdparam">THREAD</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2641"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_THREAD</code> macro sets the thread
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;THREAD&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_THREAD</code> when you
		configued with a threading package (including OpenMP).</p></div><div class="refsect1" lang="en"><a name="d0e2652"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_THREAD(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_THREAD(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setThread(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e2670"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_NODE" title="TAU_PROFILE_SET_NODE"><span class="refentrytitle">TAU_PROFILE_SET_NODE</span></a>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_GET_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_GET_THREAD &#8212; Gives the measurement system's thread id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_THREAD</b>(</code><var class="pdparam">thread</var><code>)</code>;<br>int <var class="pdparam">thread</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_GET_THREAD</b>(</code><var class="pdparam">THREAD</var><code>)</code>;<br>integer <var class="pdparam">THREAD</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2713"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_GET_THREAD</code> gives the thread id for the
		processes in which it is called.
		</p></div><div class="refsect1" lang="en"><a name="d0e2720"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_THREAD(i);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
      INTEGER :: T
        call TAU_PROFILE_GET_THREAD(T)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
pytau.getThread(i)
		</pre></div><div class="refsect1" lang="en"><a name="d0e2738"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_GET_NODE" title="TAU_PROFILE_GET_NODE"><span class="refentrytitle">TAU_PROFILE_GET_NODE</span></a>
      <a href="#TAU_PROFILE_GET_CONTEXT" title="TAU_PROFILE_GET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_GET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_NODE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_NODE &#8212; Informs the measurement system of the node id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>int <var class="pdparam">node</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_NODE</b>(</code><var class="pdparam">node</var><code>)</code>;<br>integer <var class="pdparam">node</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2781"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_NODE</code> macro sets the node
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_NODE</code> when using the
    TAU MPI wrapper library.</p></div><div class="refsect1" lang="en"><a name="d0e2792"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.setNode(0)
		</pre></div><div class="refsect1" lang="en"><a name="d0e2810"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_CONTEXT" title="TAU_PROFILE_SET_CONTEXT"><span class="refentrytitle">TAU_PROFILE_SET_CONTEXT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_CONTEXT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_CONTEXT &#8212; Informs the measurement system of the context id</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>int <var class="pdparam">context</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_CONTEXT</b>(</code><var class="pdparam">context</var><code>)</code>;<br>integer <var class="pdparam">context</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e2851"></a><h2>Description</h2><p>The <code class="literal">TAU_PROFILE_SET_CONTEXT</code> macro sets the context
    identifier of the executing task for profiling and tracing. Tasks are
    identified using context, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;context&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <code class="literal">TAU_PROFILE_SET_CONTEXT</code> when using the
    TAU MPI wrapper library.</p></div><div class="refsect1" lang="en"><a name="d0e2862"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_SET_CONTEXT(1);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
        call TAU_PROFILE_SET_CONTEXT(1)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </pre></div><div class="refsect1" lang="en"><a name="d0e2875"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SET_NODE" title="TAU_PROFILE_SET_NODE"><span class="refentrytitle">TAU_PROFILE_SET_NODE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_FORK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_FORK &#8212; Informs the measurement system that a fork has taken place</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_FORK</b>(</code></td><td><var class="pdparam">pid</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">option</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">pid</var>;</td></tr><tr><td>enum TauFork_t &nbsp;</td><td><var class="pdparam">option</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e2909"></a><h2>Description</h2><p>To register a child process obtained from the fork()
    syscall, invoke the  <code class="literal">TAU_REGISTER_FORK</code>  macro. It takes 
    two parameters, the first is the node id of the child process (typically
    the process id returned by the fork call or any 0..N-1 range integer).
    The second parameter specifies whether the performance data for the
    child process should be derived from the parent at the time of fork
    ( <code class="literal">TAU_INCLUDE_PARENT_DATA</code> ) or should be independent of
    its parent at the time of fork
    ( <code class="literal">TAU_EXCLUDE_PARENT_DATA</code> ). If the process id is used as
    the node id, before any analysis is done, all profile files should be
    converted to contiguous node numbers (from 0..N-1). It is highly
    recommended to use flat contiguous node numbers in this call for
    profiling and tracing. </p></div><div class="refsect1" lang="en"><a name="d0e2923"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
pID = fork();
if (pID == 0) {
  printf("Parent : pid returned %d\n", pID)
}  else { 
  // If we'd used the TAU_INCLUDE_PARENT_DATA, we get
  // the performance data from the parent in this process
  // as well.
  TAU_REGISTER_FORK(pID, TAU_EXCLUDE_PARENT_DATA);        
  printf("Child : pid = %d", pID);
}
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_EVENT &#8212; Registers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e2975"></a><h2>Description</h2><p>TAU can profile user-defined events using
    <code class="literal">TAU_REGISTER_EVENT</code>. The meaning of the event is
    determined by the user. The first argument to
    <code class="literal">TAU_REGISTER_EVENT</code> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e2986"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e2999"></a><h2>See Also</h2><p>
      <a href="#TAU_EVENT" title="TAU_EVENT"><span class="refentrytitle">TAU_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_REGISTER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_REGISTER_EVENT &#8212; Registers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>void *&nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_REGISTER_EVENT</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3064"></a><h2>Description</h2><p>TAU can profile user-defined events using
    <code class="literal">TAU_PROFILER_REGISTER_EVENT</code>. The meaning of the event is
    determined by the user. The first argument to
    <code class="literal">TAU_PROFILER_REGISTER_EVENT</code> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e3075"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  void *ue1;
	TAU_PROFILER_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_PROFILER_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e3088"></a><h2>See Also</h2><p>
      <a href="#TAU_EVENT" title="TAU_EVENT"><span class="refentrytitle">TAU_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_EVENT &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3149"></a><h2>Description</h2><p>Triggers an named event with the given value</p></div><div class="refsect1" lang="en"><a name="d0e3154"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_EVENT(count, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_EVENT_THREAD &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT_THREAD</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_EVENT_THREAD</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3220"></a><h2>Description</h2><p>Triggers an named event with the given value on a given thead or task.</p></div><div class="refsect1" lang="en"><a name="d0e3225"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count, workTask);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_EVENT(count, workTask, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT &#8212; Triggers a user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT</b>(</code><var class="pdparam">variable</var>, <var class="pdparam">value</var><code>)</code>;<br>integer <var class="pdparam">variable</var>(2);<br>real <var class="pdparam">value</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e3281"></a><h2>Description</h2><p>Triggers an event that was registered with
    <code class="literal">TAU_REGISTER_EVENT</code>.</p></div><div class="refsect1" lang="en"><a name="d0e3289"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </pre></div><div class="refsect1" lang="en"><a name="d0e3302"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_THREAD &#8212; Triggers a user event on a given thread</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_THREAD</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread id</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEVENT_THREAD &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread id</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_THREAD</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread id</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">thread id</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3360"></a><h2>Description</h2><p>Triggers an event that was registered with
    <code class="literal">TAU_REGISTER_EVENT</code> on a given thread.</p></div><div class="refsect1" lang="en"><a name="d0e3368"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT_THREAD(ue1, count * count, threadid);
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT_THREAD(eventid, count, threadid)
    </pre></div><div class="refsect1" lang="en"><a name="d0e3381"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REGISTER_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REGISTER_CONTEXT_EVENT &#8212; Registers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">event_name</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_REGISTER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3432"></a><h2>Description</h2><p>Creates a context event with name. A context event appends the 
     names of routines executing on the callstack to the name specified by
     the user. Whenver a context event is triggered, the callstack is 
     examined to determine the context of execution. Starting from the parent
     function where the event is triggered, TAU walks up the callstack to a 
     depth specified by the user in the environment variable 
     <code class="literal">TAU_CALLPATH_DEPTH </code>. If this environment variable is 
     not specified, TAU uses 2 as the default depth. For e.g., if the user 
     registers a context event with the name "memory used" and specifies 3 as 
     the callpath depth, and if the event is triggered in two locations 
     (in routine a, when it was called by b, when it was called by c, and in 
     routine h, when it was called by g, when it was called by i), then, we'd 
     see the user defined event information for 
     "memory used: c() =&gt; b() =&gt; a()" and "memory used: i() =&gt; g() =&gt; h()".
 
      </p></div><div class="refsect1" lang="en"><a name="d0e3440"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
subroutine foo(id)
  integer id
       
  integer profiler(2) / 0, 0 /
  integer maev(2) / 0, 0 /
  integer mdev(2) / 0, 0 /
  save profiler, maev, mdev

  integer :: ierr
  integer :: h, t, u
  INTEGER, ALLOCATABLE :: STORAGEARY(:)
  DOUBLEPRECISION   edata

  call TAU_PROFILE_TIMER(profiler, 'FOO')
  call TAU_PROFILE_START(profiler)
  call TAU_PROFILE_SET_NODE(0)

  call TAU_REGISTER_CONTEXT_EVENT(maev, "STORAGEARY Alloc [cubes.f:20]")
  call TAU_REGISTER_CONTEXT_EVENT(mdev, "STORAGEARY Dealloc [cubes.f:37]")

  allocate(STORAGEARY(1:999), STAT=IERR)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(maev, edata)
  ...
  deallocate(STORAGEARY)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(mdev, edata)
  call TAU_PROFILE_STOP(profiler)
  end subroutine foo
     </pre></div><div class="refsect1" lang="en"><a name="d0e3453"></a><h2>See Also</h2><p>
      <a href="#TAU_CONTEXT_EVENT" title="TAU_CONTEXT_EVENT"><span class="refentrytitle">TAU_CONTEXT_EVENT</span></a>,
      <a href="#TAU_ENABLE_CONTEXT_EVENT" title="TAU_ENABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_ENABLE_CONTEXT_EVENT</span></a>,
      <a href="#TAU_DISABLE_CONTEXT_EVENT" title="TAU_DISABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_DISABLE_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CONTEXT_EVENT &#8212; Triggers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">variable</var>(2);</td></tr><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3517"></a><h2>Description</h2><p>Triggers a context event. A context event associates the name with 
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e3525"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer memevent(2) / 0, 0 /
save memevent
call TAU_REGISTER_CONTEXT_EVENT(memevent, "STORAGEARY mem allocated')
call TAU_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER))
    </pre></div><div class="refsect1" lang="en"><a name="d0e3538"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_CONTEXT_EVENT &#8212; Triggers a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>real &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3588"></a><h2>Description</h2><p>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e3596"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_TRIGGER_CONTEXT_EVENT("Iteration count", 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
integer memevent(2) / 0, 0 /
save memevent
call TAU_TRIGGER_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER), "STORAGEARY mem allocated")
    </pre></div><div class="refsect1" lang="en"><a name="d0e3609"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRIGGER_CONTEXT_EVENT_THREAD"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRIGGER_CONTEXT_EVENT_THREAD &#8212; Triggers a context user event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT_THREAD</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">value</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">thread</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>double &nbsp;</td><td><var class="pdparam">value</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">thread</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRIGGER_CONTEXT_EVENT_THREAD</b>(</code></td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">integer </var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">event_name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">integer </var>(2);</td></tr><tr><td>character &nbsp;</td><td><var class="pdparam">event_name</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3669"></a><h2>Description</h2><p>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <code class="literal"> TAU_CALLPATH_DEPTH</code>. If this variable is not 
          specified, TAU uses a default depth of 2. </p></div><div class="refsect1" lang="en"><a name="d0e3677"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int user_square(int count) {
  TAU_TRIGGER_CONTEXT_EVENT_THREAD("Error in Iteration", count * count, workTask);
  return 0;
}
		</pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRIGGER_CONTEXT_EVENT_THREAD(count, workTask, 'Error in Iteration')
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_CONTEXT_EVENT &#8212; Enable a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_ENABLE_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3713"></a><h2>Description</h2><p>Enables a context event.</p></div><div class="refsect1" lang="en"><a name="d0e3718"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e3726"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_DISABLE_CONTEXT_EVENT" title="TAU_DISABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_DISABLE_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_CONTEXT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_CONTEXT_EVENT &#8212; Disable a context event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DISABLE_CONTEXT_EVENT</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3758"></a><h2>Description</h2><p>Disables a context event.</p></div><div class="refsect1" lang="en"><a name="d0e3763"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e3771"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_ENABLE_CONTEXT_EVENT" title="TAU_ENABLE_CONTEXT_EVENT"><span class="refentrytitle">TAU_ENABLE_CONTEXT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_SET_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_SET_NAME &#8212; Sets the name of an event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_SET_NAME</b>(</code></td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">name</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>const char *&nbsp;</td><td><var class="pdparam">name</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3807"></a><h2>Description</h2><p>Changes the name of an event.</p></div><div class="refsect1" lang="en"><a name="d0e3812"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_SET_NAME(event, "new name");
    </pre></div><div class="refsect1" lang="en"><a name="d0e3820"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MAX"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MAX &#8212; Disables tracking of maximum statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MAX</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e3850"></a><h2>Description</h2><p>Disables tracking of maximum statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e3855"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MAX(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e3863"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MEAN"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MEAN &#8212; Disables tracking of mean statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MEAN</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e3893"></a><h2>Description</h2><p>Disables tracking of mean statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e3898"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MEAN(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e3906"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_MIN"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_MIN &#8212; Disables tracking of minimum statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_MIN</b>(</code><var class="pdparam">event</var><code>)</code>;<br>TauUserEvent <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e3936"></a><h2>Description</h2><p>Disables tracking of minimum statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e3941"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_MIN(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e3949"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_EVENT_DISABLE_STDDEV"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_EVENT_DISABLE_STDDEV &#8212; Disables tracking of standard deviation statistic for a given event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_EVENT_DISABLE_STDDEV</b>(</code></td><td><var class="pdparam">event</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>TauUserEvent &nbsp;</td><td><var class="pdparam">event</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e3979"></a><h2>Description</h2><p>Disables tracking of standard deviation statistic for a given event</p></div><div class="refsect1" lang="en"><a name="d0e3984"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_EVENT_DISABLE_STDDEV(event);
    </pre></div><div class="refsect1" lang="en"><a name="d0e3992"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REPORT_STATISTICS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REPORT_STATISTICS &#8212; Outputs statistics</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_STATISTICS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_STATISTICS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4027"></a><h2>Description</h2><p> <code class="literal">TAU_REPORT_STATISTICS</code>  prints the aggregate
    statistics of user events across all threads in each node. Typically,
    this should be called just before the main thread exits. </p></div><div class="refsect1" lang="en"><a name="d0e4035"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_REPORT_STATISTICS();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REPORT_STATISTICS()
    </pre></div><div class="refsect1" lang="en"><a name="d0e4048"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_THREAD_STATISTICS" title="TAU_REPORT_THREAD_STATISTICS"><span class="refentrytitle">TAU_REPORT_THREAD_STATISTICS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_REPORT_THREAD_STATISTICS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_REPORT_THREAD_STATISTICS &#8212; Outputs statistics, plus thread statistics</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_THREAD_STATISTICS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_REPORT_THREAD_STATISTICS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4087"></a><h2>Description</h2><p><code class="literal">TAU_REPORT_THREAD_STATISTICS</code> prints the
    aggregate, as well as per thread user event statistics.  Typically, this
    should be called just before the main thread exits. </p></div><div class="refsect1" lang="en"><a name="d0e4094"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_REPORT_THREAD_STATISTICS();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_REPORT_THREAD_STATISTICS()
    </pre></div><div class="refsect1" lang="en"><a name="d0e4107"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_REPORT_STATISTICS" title="TAU_REPORT_STATISTICS"><span class="refentrytitle">TAU_REPORT_STATISTICS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_INSTRUMENTATION"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_INSTRUMENTATION &#8212; Enables instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4146"></a><h2>Description</h2><p> <code class="literal">TAU_ENABLE_INSTRUMENTATION</code>  macro re-enables
    all TAU instrumentation. All instances of functions and statements that
    occur between the disable/enable section are ignored by TAU. This allows
    a user to limit the trace size, if the macros are used to disable
    recording of a set of iterations that have the same characteristics as,
    for example, the first recorded instance.</p></div><div class="refsect1" lang="en"><a name="d0e4154"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_ENABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_ENABLE_INSTRUMENTATION()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</pre></div><div class="refsect1" lang="en"><a name="d0e4172"></a><h2>See Also</h2><p>
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_INSTRUMENTATION"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_INSTRUMENTATION &#8212; Disables instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_INSTRUMENTATION</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4215"></a><h2>Description</h2><p> <code class="literal">TAU_DISABLE_INSTRUMENTATION</code>  macro disables
    all entry/exit instrumentation within all threads of a context. This
    allows the user to selectively enable and disable instrumentation in
    parts of his/her code. It is important to re-enable the instrumentation
    within the same basic block and scope. </p></div><div class="refsect1" lang="en"><a name="d0e4223"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_DISABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_DISABLE_INSTRUMENTATION()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</pre></div><div class="refsect1" lang="en"><a name="d0e4241"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_GROUP &#8212; Enables tracking of a given group</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>TauGroup_t <var class="pdparam">group</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>integer <var class="pdparam">group</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4290"></a><h2>Description</h2><p>Enables the instrumentation for a given group.  By default, it is already on.</p></div><div class="refsect1" lang="en"><a name="d0e4295"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_ENABLE_GROUP(TAU_USER);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  include 'Profile/TauFAPI.h'
  call TAU_ENABLE_GROUP(TAU_USER)
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableGroup(TAU_USER)
		</pre></div><div class="refsect1" lang="en"><a name="d0e4313"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_GROUP" title="TAU_DISABLE_GROUP"><span class="refentrytitle">TAU_DISABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_GROUP &#8212; Disables tracking of a given group</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>TauGroup_t <var class="pdparam">group</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP</b>(</code><var class="pdparam">group</var><code>)</code>;<br>integer <var class="pdparam">group</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4362"></a><h2>Description</h2><p>Disables the instrumentation for a given group.  By default, it is on.</p></div><div class="refsect1" lang="en"><a name="d0e4367"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_DISABLE_GROUP(TAU_USER);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
  include 'Profile/TauFAPI.h'
  call TAU_DISABLE_GROUP(TAU_USER)
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableGroup(TAU_USER)
		</pre></div><div class="refsect1" lang="en"><a name="d0e4385"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_INSTRUMENTATION" title="TAU_ENABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_ENABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_DISABLE_INSTRUMENTATION" title="TAU_DISABLE_INSTRUMENTATION"><span class="refentrytitle">TAU_DISABLE_INSTRUMENTATION</span></a>,
      <a href="#TAU_ENABLE_GROUP" title="TAU_ENABLE_GROUP"><span class="refentrytitle">TAU_ENABLE_GROUP</span></a>,
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>,
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_GROUP &#8212; Change the group of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_GROUP</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4427"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP</code> changes the group
    associated with a timer.</p></div><div class="refsect1" lang="en"><a name="d0e4435"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(t, "foo loop timer", " ", TAU_USER1);
  ...
  TAU_PROFILE_TIMER_SET_GROUP(t, TAU_USER3);
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e4443"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_TIMER_SET_GROUP_NAME" title="TAU_PROFILE_TIMER_SET_GROUP_NAME"><span class="refentrytitle">TAU_PROFILE_TIMER_SET_GROUP_NAME</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_GROUP_NAME &#8212; Changes the group name for a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_GROUP_NAME</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4479"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP_NAME</code> changes the
    group name associated with a given timer.</p></div><div class="refsect1" lang="en"><a name="d0e4487"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(looptimer, "foo: loop1", " ", TAU_USER);
  TAU_PROFILE_START(looptimer);
  for (int i = 0; i &lt; N; i++) { /* do something */ }
  TAU_PROFILE_STOP(looptimer);
  TAU_PROFILE_TIMER_SET_GROUP_NAME("Field");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e4495"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_PROFILE_TIMER_SET_GROUP" title="TAU_PROFILE_TIMER_SET_GROUP"><span class="refentrytitle">TAU_PROFILE_TIMER_SET_GROUP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_NAME &#8212; Changes the name of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_NAME</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">newname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>string &nbsp;</td><td><var class="pdparam">newname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4531"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_NAME</code> macro changes the name
    associated with a timer to the newname argument. </p></div><div class="refsect1" lang="en"><a name="d0e4539"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo:loop1", " ", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_NAME(timer1, "foo:lines 21-34");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e4547"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_TIMER_SET_TYPE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_TIMER_SET_TYPE &#8212; Changes the type of a timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_TIMER_SET_TYPE</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">newname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>string &nbsp;</td><td><var class="pdparam">newname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4581"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_TIMER_SET_TYPE</code> macro changes the type
    associated with a timer to the newname argument. </p></div><div class="refsect1" lang="en"><a name="d0e4589"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo", "int", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_TYPE(timer1, "long");
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e4597"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SET_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SET_GROUP_NAME &#8212; Changes the group name of a profiled section</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SET_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4627"></a><h2>Description</h2><p> <code class="literal">TAU_PROFILE_SET_GROUP_NAME</code>  macro allows
    the user to change the group name associated with the instrumented
    routine. This macro must be called within the instrumented routine. 
    </p></div><div class="refsect1" lang="en"><a name="d0e4635"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_PROFILE("foo()", "void ()", TAU_USER);
  TAU_PROFILE_SET_GROUP_NAME("Particle"); 
  /* gives a more meaningful group name */
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e4643"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_INIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_INIT &#8212; Processes command-line arguments for selective instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_INIT</b>(</code><var class="pdparam">argc</var>, <var class="pdparam">argv</var><code>)</code>;<br>int *<var class="pdparam">argc</var>;<br>char ***<var class="pdparam">argv</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4677"></a><h2>Description</h2><p><code class="literal">TAU_INIT</code> parses and removes the command-line
    arguments for the names of profile groups that are to be selectively
    enabled for instrumentation. By default, if this macro is not used,
    functions belonging to all profile groups are
    enabled. <code class="literal">TAU_INIT</code> differs from
    <code class="literal">TAU_PROFILE_INIT</code> only in the argument types.</p></div><div class="refsect1" lang="en"><a name="d0e4690"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_GROUP_12);
  TAU_INIT(&amp;argc, &amp;argv);
  ...
}

% ./a.out --profile 12+14
    </pre></div><div class="refsect1" lang="en"><a name="d0e4698"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_INIT" title="TAU_PROFILE_INIT"><span class="refentrytitle">TAU_PROFILE_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_INIT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_INIT &#8212; Processes command-line arguments for selective instrumentation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_INIT</b>(</code><var class="pdparam">argc</var>, <var class="pdparam">argv</var><code>)</code>;<br>int <var class="pdparam">argc</var>;<br>char **<var class="pdparam">argv</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_INIT</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4740"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_INIT</code> parses the
    command-line arguments for the names of profile groups that are to be
    selectively enabled for instrumentation. By default, if this macro is not
    used, functions belonging to all profile groups are
    enabled. <code class="literal">TAU_INIT</code> differs from
    <code class="literal">TAU_PROFILE_INIT</code> only in the argument types.</p></div><div class="refsect1" lang="en"><a name="d0e4753"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  TAU_PROFILE_INIT(argc, argv);
  ...
}

% ./a.out --profile 12+14
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
PROGRAM SUM_OF_CUBES
  integer profiler(2)
  save profiler
      
  call TAU_PROFILE_INIT()
  ...
    </pre></div><div class="refsect1" lang="en"><a name="d0e4766"></a><h2>See Also</h2><p>
      <a href="#TAU_INIT" title="TAU_INIT"><span class="refentrytitle">TAU_INIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_PROFILE_GROUP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_PROFILE_GROUP &#8212; Creates groups based on names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_GET_PROFILE_GROUP</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e4796"></a><h2>Description</h2><p> <code class="literal">TAU_GET_PROFILE_GROUP</code>  allows the user to
    dynamically create groups based on strings, rather than use predefined,
    statically assigned groups such as  <code class="literal">TAU_USER1, TAU_USER2</code> 
    etc. This allows names to be associated in creating unique groups that
    are more meaningful, using names of files or directories for instance.
    </p></div><div class="refsect1" lang="en"><a name="d0e4807"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
#define PARTICLES TAU_GET_PROFILE_GROUP("PARTICLES")

void foo() {
  TAU_PROFILE("foo()", " ", PARTICLES);
}

void bar() {
  TAU_PROFILE("bar()", " ", PARTICLES);
}
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.getProfileGroup("PARTICLES")
		</pre></div><div class="refsect1" lang="en"><a name="d0e4820"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_GROUP_NAME &#8212; Enables a group based on name</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP_NAME</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_ENABLE_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">groupname</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4868"></a><h2>Description</h2><p> <code class="literal">TAU_ENABLE_GROUP_NAME</code> macro can turn on the
    instrumentation associated with routines based on a dynamic group assigned
    to them. It is important to note that this and the
    <code class="literal">TAU_DISABLE_GROUP_NAME</code> macros apply to groups created
    dynamically using <code class="literal">TAU_GET_PROFILE_GROUP.</code> </p></div><div class="refsect1" lang="en"><a name="d0e4882"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE&gt;DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableGroupName("DTM")
		</pre></div><div class="refsect1" lang="en"><a name="d0e4900"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_GROUP_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_GROUP_NAME &#8212; Disables a group based on name</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP_NAME</b>(</code><var class="pdparam">groupname</var><code>)</code>;<br>char *<var class="pdparam">groupname</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DISABLE_GROUP_NAME</b>(</code></td><td><var class="pdparam">groupname</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">groupname</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e4948"></a><h2>Description</h2><p>Similar to <code class="literal">TAU_ENABLE_GROUP_NAME</code> , this macro
    turns off the instrumentation in all routines associated with the dynamic
    group created using the tau_instrumentor -g &lt;group_name&gt; argument. 
    </p></div><div class="refsect1" lang="en"><a name="d0e4956"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE&gt;DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableGroupName("DTM")
		</pre></div><div class="refsect1" lang="en"><a name="d0e4974"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_ALL_GROUPS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_ALL_GROUPS &#8212; Enables instrumentation in all groups</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5015"></a><h2>Description</h2><p>This macro turns on instrumentation in all groups</p></div><div class="refsect1" lang="en"><a name="d0e5020"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_ENABLE_ALL_GROUPS();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_ALL_GROUPS();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableAllGroups()
     </pre></div><div class="refsect1" lang="en"><a name="d0e5038"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_ALL_GROUPS" title="TAU_DISABLE_ALL_GROUPS"><span class="refentrytitle">TAU_DISABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_ALL_GROUPS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_ALL_GROUPS &#8212; Disables instrumentation in all groups</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_ALL_GROUPS</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5079"></a><h2>Description</h2><p>This macro turns off instrumentation in all groups.</p></div><div class="refsect1" lang="en"><a name="d0e5084"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
void foo() {
  TAU_DISABLE_ALL_GROUPS();
  TAU_ENABLE_GROUP_NAME("PARTICLES");
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_ALL_GROUPS();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableAllGroups()
		</pre></div><div class="refsect1" lang="en"><a name="d0e5102"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_PROFILE_GROUP" title="TAU_GET_PROFILE_GROUP"><span class="refentrytitle">TAU_GET_PROFILE_GROUP</span></a>,
      <a href="#TAU_ENABLE_GROUP_NAME" title="TAU_ENABLE_GROUP_NAME"><span class="refentrytitle">TAU_ENABLE_GROUP_NAME</span></a>,
      <a href="#TAU_DISABLE_GROUP_NAME" title="TAU_DISABLE_GROUP_NAME"><span class="refentrytitle">TAU_DISABLE_GROUP_NAME</span></a>,
      <a href="#TAU_ENABLE_ALL_GROUPS" title="TAU_ENABLE_ALL_GROUPS"><span class="refentrytitle">TAU_ENABLE_ALL_GROUPS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_EVENT_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_EVENT_NAMES &#8212; Gets the registered user events.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_EVENT_NAMES</b>(</code></td><td><var class="pdparam">eventList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numEvents</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char ***&nbsp;</td><td><var class="pdparam">eventList</var>;</td></tr><tr><td>int *&nbsp;</td><td><var class="pdparam">numEvents</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e5142"></a><h2>Description</h2><p>Retrieves user event names for all user-defined events</p></div><div class="refsect1" lang="en"><a name="d0e5147"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **eventList;
int numEvents;

TAU_GET_EVENT_NAMES(eventList, numEvents);

cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

    </pre></div><div class="refsect1" lang="en"><a name="d0e5155"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_GET_EVENT_VALS" title="TAU_GET_EVENT_VALS"><span class="refentrytitle">TAU_GET_EVENT_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_EVENT_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_EVENT_VALS &#8212; Gets user event data for given user events.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_EVENT_VALS</b>(</code></td><td><var class="pdparam">inUserEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numUserEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numEvents</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">max</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">min</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mean</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">sumSqe</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char **&nbsp;</td><td><var class="pdparam">inUserEvents</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numUserEvents</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numEvents</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">max</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">min</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">mean</var>;</td></tr><tr><td>double **&nbsp;</td><td><var class="pdparam">sumSqe</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e5213"></a><h2>Description</h2><p>Retrieves user defined event data for the specified user defined events. The list of events are specified by the first parameter (eventList) and the user specifies the number of events in the second parameter (numUserEvents). TAU returns the number of times the event was invoked in the numUserEvents. The max, min, mean values are returned in the following parameters. TAU computes the sum of squares of the given event and returns this value in the next argument (sumSqe). </p></div><div class="refsect1" lang="en"><a name="d0e5218"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
  const char **eventList;
  int numEvents;

  TAU_GET_EVENT_NAMES(eventList, numEvents);

  cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

  if (numEvents &gt; 0) {
    int *numSamples;
    double *max;
    double *min;
    double *mean;
    double *sumSqr;

    TAU_GET_EVENT_VALS(eventList, numEvents, numSamples, 
      max, min, mean, sumSqr);
    for (int i=0; i&lt;numEvents; i++) {
      cout &lt;&lt; "-------------------\n";
      cout &lt;&lt; "User Event:        " &lt;&lt; eventList[i] &lt;&lt; endl;
      cout &lt;&lt; "Number of Samples: " &lt;&lt; numSamples[i] &lt;&lt; endl;
      cout &lt;&lt; "Maximum Value:     " &lt;&lt; max[i] &lt;&lt; endl;
      cout &lt;&lt; "Minimum Value:     " &lt;&lt; min[i] &lt;&lt; endl;
      cout &lt;&lt; "Mean Value:        " &lt;&lt; mean[i] &lt;&lt; endl;
      cout &lt;&lt; "Sum Squared:       " &lt;&lt; sumSqr[i] &lt;&lt; endl;
    }
  }
}

    </pre></div><div class="refsect1" lang="en"><a name="d0e5226"></a><h2>See Also</h2><p>
      <a href="#TAU_REGISTER_EVENT" title="TAU_REGISTER_EVENT"><span class="refentrytitle">TAU_REGISTER_EVENT</span></a>,
      <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>,
      <a href="#TAU_GET_EVENT_NAMES" title="TAU_GET_EVENT_NAMES"><span class="refentrytitle">TAU_GET_EVENT_NAMES</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_COUNTER_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_COUNTER_NAMES &#8212; Gets the counter names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_COUNTER_NAMES</b>(</code></td><td><var class="pdparam">counterList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numCounters</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">counterList</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numCounters</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e5264"></a><h2>Description</h2><p> <code class="literal">TAU_GET_COUNTER_NAMES</code> returns the list of counter
    names and the number of counters used for measurement. When wallclock time
    is used, the counter name of "default" is returned.</p></div><div class="refsect1" lang="en"><a name="d0e5272"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int numOfCounters;
const char ** counterList;

TAU_GET_COUNTER_NAMES(counterList, numOfCounters);

for(int j=0;j&lt;numOfCounters;j++){ 
  cout &lt;&lt; "The counter names so far are: " &lt;&lt; counterList[j] &lt;&lt; endl;
}
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.getCounterNames(counterList, numOfCounters);
		</pre></div><div class="refsect1" lang="en"><a name="d0e5285"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_FUNC_NAMES" title="TAU_GET_FUNC_NAMES"><span class="refentrytitle">TAU_GET_FUNC_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_VALS" title="TAU_GET_FUNC_VALS"><span class="refentrytitle">TAU_GET_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_FUNC_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_FUNC_NAMES &#8212; Gets the function names</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_FUNC_NAMES</b>(</code></td><td><var class="pdparam">functionList</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">functionList</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e5321"></a><h2>Description</h2><p>This macro fills the funcList argument with the list of
    timer and routine names. It also records the number of routines active
    in the numFuncs argument. </p></div><div class="refsect1" lang="en"><a name="d0e5326"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
  const char ** functionList;
  int numOfFunctions;

  TAU_GET_FUNC_NAMES(functionList, numOfFunctions);

  for(int i=0;i&lt;numOfFunctions;i++){
    cout &lt;&lt; "This function names so far are: " &lt;&lt; functionList[i] &lt;&lt; endl;
  }

    </pre><p><span class="role">Python:</span></p><pre class="screen">
import pytau

pytau.getFuncNames(functionList, numOfFunctions)
		</pre></div><div class="refsect1" lang="en"><a name="d0e5339"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_COUNTER_NAMES" title="TAU_GET_COUNTER_NAMES"><span class="refentrytitle">TAU_GET_COUNTER_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_VALS" title="TAU_GET_FUNC_VALS"><span class="refentrytitle">TAU_GET_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_GET_FUNC_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_GET_FUNC_VALS &#8212; Gets detailed performance data for given functions</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_GET_FUNC_VALS</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterExclusiveValues</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterInclusiveValues</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfCalls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfSubRoutines</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">counterNames</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numOfCounters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numOfFuncs</var>;</td></tr><tr><td>double ***&nbsp;</td><td><var class="pdparam">counterExclusiveValues</var>;</td></tr><tr><td>double ***&nbsp;</td><td><var class="pdparam">counterInclusiveValues</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numOfCalls</var>;</td></tr><tr><td>int **&nbsp;</td><td><var class="pdparam">numOfSubRoutines</var>;</td></tr><tr><td>const char ***&nbsp;</td><td><var class="pdparam">counterNames</var>;</td></tr><tr><td>int *&nbsp;</td><td><var class="pdparam">numOfCounters</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e5407"></a><h2>Description</h2><p>It gets detailed performance data for the list of
    routines. The user specifies inFuncs and the number of routines; TAU
    then returns the other arguments with the performance data.
    counterExclusiveValues and counterInclusiveValues are two dimensional
    arrays: the first dimension is the routine id and the second is counter
    id. The value is indexed by these two dimensions. numCalls and numSubrs
    (or child routines) are one dimensional arrays. </p></div><div class="refsect1" lang="en"><a name="d0e5412"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **inFuncs;
/* The first dimension is functions, and the 
second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;
      
TAU_GET_FUNC_NAMES(functionList, numOfFunctions);
      
/* We are only interested in the first two routines 
that are executing in this context. So, we allocate 
space for two routine names and get the performance 
data for these two routines at runtime. */
if (numOfFunctions &gt;=2 ) {
  inFuncs = (const char **) malloc(sizeof(const char *) * 2);
      
  inFuncs[0] = functionList[0];
  inFuncs[1] = functionList[1];
      
  //Just to show consistency.
  TAU_DB_DUMP();
      
  TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);
      
  TAU_DUMP_FUNC_VALS_INCR(inFuncs, 2);
      
      
  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
  cout &lt;&lt; "The number of counters is: " &lt;&lt; numOfCouns &lt;&lt; endl;
  cout &lt;&lt; "The first counter is: " &lt;&lt; counterNames[0] &lt;&lt; endl;
      
  cout &lt;&lt; "The Exclusive value of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; counterExclusiveValues[0][0] &lt;&lt; endl;
  cout &lt;&lt; "The numOfSubRoutines of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; numOfSubRoutines[0]
  &lt;&lt; endl;
      
      
  cout &lt;&lt; "The Inclusive value of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; counterInclusiveValues[1][0]
  &lt;&lt; endl;
  cout &lt;&lt; "The numOfCalls of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; numOfCalls[1]
  &lt;&lt; endl;

  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
}
      
TAU_DB_DUMP_INCR();
    </pre><p>Python:</p><pre class="screen">
import pytau

pytau.dumpFuncVals("foo", "bar", "bar2")
		</pre></div><div class="refsect1" lang="en"><a name="d0e5424"></a><h2>See Also</h2><p>
      <a href="#TAU_GET_COUNTER_NAMES" title="TAU_GET_COUNTER_NAMES"><span class="refentrytitle">TAU_GET_COUNTER_NAMES</span></a>,
      <a href="#TAU_GET_FUNC_NAMES" title="TAU_GET_FUNC_NAMES"><span class="refentrytitle">TAU_GET_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_MEMORY &#8212; Enables memory tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5465"></a><h2>Description</h2><p>Enables tracking of the heap memory utilization in the program. TAU takes a sample of the heap memory utilized (as reported by the mallinfo system call) and associates it with a single global user defined event. An interrupt is generated every 10 seconds and the value of the heap memory used is recorded in the user defined event. The inter-interrupt interval (default of 10 seconds) may be set by the user using the call <code class="literal">TAU_SET_INTERRUPT_INTERVAL</code>.</p></div><div class="refsect1" lang="en"><a name="d0e5473"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_ENABLE_TRACKING_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingMemory()
		</pre></div><div class="refsect1" lang="en"><a name="d0e5491"></a><h2>See Also</h2><p>
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_MEMORY &#8212; Disables memory tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5532"></a><h2>Description</h2><p>Disables tracking of heap memory utilization. This call may be used in sections of code where TAU should not interrupt the execution to periodically track the heap memory utilization.</p></div><div class="refsect1" lang="en"><a name="d0e5537"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingMemory()

		</pre></div><div class="refsect1" lang="en"><a name="d0e5555"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_POWER &#8212; Initializes POWER tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5596"></a><h2>Description</h2><p>For power profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_POWER_HERE() calls in the source code and the
    power event is triggered at those locations, and 2) the user enables
    tracking POWER by calling TAU_TRACK_POWER() and an interrupt is generated
    every 10 seconds and the POWER event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of power events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_POWER() or TAU_DISABLE_TRACKING_()
    respectively.</p></div><div class="refsect1" lang="en"><a name="d0e5601"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_POWER();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_POWER()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackPower()
    </pre></div><div class="refsect1" lang="en"><a name="d0e5619"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_POWER" title="TAU_ENABLE_TRACKING_POWER"><span class="refentrytitle">TAU_ENABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_DISABLE_TRACKING_POWER" title="TAU_DISABLE_TRACKING_POWER"><span class="refentrytitle">TAU_DISABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_POWER_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_POWER_HERE &#8212; Triggers power tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_POWER_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5662"></a><h2>Description</h2><p>Triggers power tracking at a given execution point</p></div><div class="refsect1" lang="en"><a name="d0e5667"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_POWER_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_POWER_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap POWER 
! utilization at this point, invoke the following call:
call TAU_TRACK_POWER_HERE()

    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackPowerHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e5685"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_POWER &#8212; Enables power headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5720"></a><h2>Description</h2><p>
      <code class="literal">TAU_ENABLE_TRACKING_POWER()</code> enables power 
      tracking after a
      <code class="literal">TAU_DISABLE_TRACKING_POWER()</code>.
    </p></div><div class="refsect1" lang="en"><a name="d0e5731"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_POWER();
/* do some work */
...
/* re-enable tracking POWER */
TAU_ENABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingPowerHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e5749"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>,
      <a href="#TAU_DISABLE_TRACKING_POWER" title="TAU_DISABLE_TRACKING_POWER"><span class="refentrytitle">TAU_DISABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_POWER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_POWER &#8212; Disables power headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_POWER</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5790"></a><h2>Description</h2><p>
      <code class="literal">TAU_DISABLE_TRACKING_POWER()</code> disables
      power tracking.
    </p></div><div class="refsect1" lang="en"><a name="d0e5798"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_POWER();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_POWER()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingPowerHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e5816"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_POWER" title="TAU_TRACK_POWER"><span class="refentrytitle">TAU_TRACK_POWER</span></a>,
      <a href="#TAU_ENABLE_TRACKING_POWER" title="TAU_ENABLE_TRACKING_POWER"><span class="refentrytitle">TAU_ENABLE_TRACKING_POWER</span></a>,
      <a href="#TAU_TRACK_POWER_HERE" title="TAU_TRACK_POWER_HERE"><span class="refentrytitle">TAU_TRACK_POWER_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY &#8212; Initializes memory tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5857"></a><h2>Description</h2><p>For memory profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_MEMORY_HERE() calls in the source code and the
    memory event is triggered at those locations, and 2) the user enables
    tracking memory by calling TAU_TRACK_MEMORY() and an interrupt is generated
    every 10 seconds and the memory event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of memory events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_MEMORY() or TAU_DISABLE_TRACKING_MEMORY()
    respectively.</p></div><div class="refsect1" lang="en"><a name="d0e5862"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemory()
    </pre></div><div class="refsect1" lang="en"><a name="d0e5880"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HERE &#8212; Triggers memory tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5923"></a><h2>Description</h2><p>Triggers memory tracking at a given execution point</p></div><div class="refsect1" lang="en"><a name="d0e5928"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap memory 
! utilization at this point, invoke the following call:
call TAU_TRACK_MEMORY_HERE()

    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e5946"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_FOOTPRINT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_FOOTPRINT &#8212; Initializes memory footprint tracking system</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e5981"></a><h2>Description</h2><p>Similar to TAU_TRACK_MEMORY but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="refsect1" lang="en"><a name="d0e5986"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY_FOOTPRINT();      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY_FOOTPRINT()
    </pre></div><div class="refsect1" lang="en"><a name="d0e5999"></a><h2>See Also</h2><p>
      <a href="#TAU_ENABLE_TRACKING_MEMORY" title="TAU_ENABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY" title="TAU_DISABLE_TRACKING_MEMORY"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_TRACK_MEMORY_HERE" title="TAU_TRACK_MEMORY_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_FOOTPRINT_HERE" title="TAU_TRACK_MEMORY_FOOTPRINT_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_FOOTPRINT_HERE</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_FOOTPRINT_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_FOOTPRINT_HERE &#8212; Triggers memory footprint tracking at a given execution point</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_FOOTPRINT_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6046"></a><h2>Description</h2><p>Similar to TAU_TRACK_MEMORY_HERE but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</p></div><div class="refsect1" lang="en"><a name="d0e6051"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_FOOTPRINT_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_FOOTPRINT_HERE();
  return 0;
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)


call TAU_TRACK_MEMORY_FOOTPRINT_HERE()

    </pre></div><div class="refsect1" lang="en"><a name="d0e6064"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_FOOTPRINT" title="TAU_TRACK_MEMORY_FOOTPRINT"><span class="refentrytitle">TAU_TRACK_MEMORY_FOOTPRINT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_ENABLE_TRACKING_MEMORY_HEADROOM &#8212; Enables memory headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6099"></a><h2>Description</h2><p>
      <code class="literal">TAU_ENABLE_TRACKING_MEMORY_HEADROOM()</code> enables memory
      headroom tracking after a
      <code class="literal">TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</code>.
    </p></div><div class="refsect1" lang="en"><a name="d0e6110"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
/* do some work */
...
/* re-enable tracking memory headroom */
TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
import pytau

pytau.enableTrackingMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6128"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM" title="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DISABLE_TRACKING_MEMORY_HEADROOM &#8212; Disables memory headroom tracking</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6169"></a><h2>Description</h2><p>
      <code class="literal">TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</code> disables memory
      headroom tracking.
    </p></div><div class="refsect1" lang="en"><a name="d0e6177"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DISABLE_TRACKING_MEMORY_HEADROOM()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.disableTrackingMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6195"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM" title="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HEADROOM"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HEADROOM &#8212; Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6236"></a><h2>Description</h2><p>Tracks the amount of memory available for the process before it runs
    out of free memory on the heap. This call sets up a signal handler that is
    invoked every 10 seconds by an interrupt (this interval may be altered by
    using the <code class="literal">TAU_SET_INTERRUPT_INTERVAL</code> call). Inside the
    interrupt handler, TAU evaluates how much memory it can allocate and
    associates it with the callstack using the TAU context events (See <a href="#TAU_REGISTER_CONTEXT_EVENT" title="TAU_REGISTER_CONTEXT_EVENT"><span class="refentrytitle">TAU_REGISTER_CONTEXT_EVENT</span></a>). The user can vary the size of the
    callstack by setting the environment variable
    <code class="literal">TAU_CALLPATH_DEPTH</code> (default is 2). This call is useful
    on machines like IBM BG/L where no virtual memory (or paging using the swap
    space) is present. The amount of heap memory available to the program is
    limited by the amount of available physical memory. TAU executes a series
    of malloc calls with a granularity of 1MB and determines the amount of
    memory available for the program to grow.</p></div><div class="refsect1" lang="en"><a name="d0e6249"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_TRACK_MEMORY_HEADROOM();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACK_MEMORY_HEADROOM()
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHeadroom()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6267"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_SET_INTERRUPT_INTERVAL" title="TAU_SET_INTERRUPT_INTERVAL"><span class="refentrytitle">TAU_SET_INTERRUPT_INTERVAL</span></a>,
      <a href="#TAU_ENABLE_TRACKING_MEMORY_HEADROOM" title="TAU_ENABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_ENABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_DISABLE_TRACKING_MEMORY_HEADROOM" title="TAU_DISABLE_TRACKING_MEMORY_HEADROOM"><span class="refentrytitle">TAU_DISABLE_TRACKING_MEMORY_HEADROOM</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM_HERE" title="TAU_TRACK_MEMORY_HEADROOM_HERE"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM_HERE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACK_MEMORY_HEADROOM_HERE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACK_MEMORY_HEADROOM_HERE &#8212; Takes a sample of the amount of memory available at a given point.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM_HERE</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_TRACK_MEMORY_HEADROOM_HERE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6310"></a><h2>Description</h2><p>Instead of relying on a periodic interrupt to track the amount of memory available to grow, this call may be used to take a sample at a given location in the source code. Context events are used to track the amount of memory headroom.</p></div><div class="refsect1" lang="en"><a name="d0e6315"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
ary = new double [1024*1024*50];
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.trackMemoryHeadroomHere()
		</pre></div><div class="refsect1" lang="en"><a name="d0e6333"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_SET_INTERRUPT_INTERVAL"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_SET_INTERRUPT_INTERVAL &#8212; Change the inter-interrupt interval for tracking memory and headroom</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_SET_INTERRUPT_INTERVAL</b>(</code><var class="pdparam">value</var><code>)</code>;<br>int <var class="pdparam">value</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_SET_INTERRUPT_INTERVAL</b>(</code><var class="pdparam">value</var><code>)</code>;<br>integer <var class="pdparam">value</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6374"></a><h2>Description</h2><p>Set the interrupt interval for tracking memory and headroom (See <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a> and <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>). By default an inter-interrupt interval of 10 seconds is used in TAU. This call allows the user to set it to a different value specified by the argument value.</p></div><div class="refsect1" lang="en"><a name="d0e6383"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_SET_INTERRUPT_INTERVAL(2)
/* invokes the interrupt handler for memory every 2s */
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_SET_INTERRUPT_INTERVAL(2)
    </pre><p><span class="bold"><strong>Python: </strong></span></p><pre class="screen">
import pytau

pytau.setInterruptTnterval(2)
		</pre></div><div class="refsect1" lang="en"><a name="d0e6401"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACK_MEMORY" title="TAU_TRACK_MEMORY"><span class="refentrytitle">TAU_TRACK_MEMORY</span></a>,
      <a href="#TAU_TRACK_MEMORY_HEADROOM" title="TAU_TRACK_MEMORY_HEADROOM"><span class="refentrytitle">TAU_TRACK_MEMORY_HEADROOM</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="CT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>CT &#8212; Returns the type information for a variable</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">CT</b>(</code><var class="pdparam">variable</var><code>)</code>;<br>&lt;type&gt; <var class="pdparam">variable</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6434"></a><h2>Description</h2><p>The <code class="literal">CT</code> macro returns the runtime type
    information string of a variable. This is useful in constructing the
    type parameter of the  <code class="literal">TAU_PROFILE</code>  macro. For templates,
    the type information can be constructed using the type of the return and
    the type of each of the arguments (parameters) of the template. The
    example in the following macro will clarify this.</p></div><div class="refsect1" lang="en"><a name="d0e6445"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE("foo::memberfunc()", CT(*this), TAU_DEFAULT);
    </pre></div><div class="refsect1" lang="en"><a name="d0e6453"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
      <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>,
      <a href="#TAU_TYPE_STRING" title="TAU_TYPE_STRING"><span class="refentrytitle">TAU_TYPE_STRING</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TYPE_STRING"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TYPE_STRING &#8212; Creates a type string</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TYPE_STRING</b>(</code></td><td><var class="pdparam">variable</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type_string</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>string &amp;&nbsp;</td><td><var class="pdparam">variable</var>;</td></tr><tr><td>string &amp;&nbsp;</td><td><var class="pdparam">type_string</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e6491"></a><h2>Description</h2><p>This macro assigns the string constructed in type_string to
    the variable. The + operator and the CT macro can be used to construct
    the type string of an object. This is useful in identifying templates
    uniquely, as shown below.</p></div><div class="refsect1" lang="en"><a name="d0e6496"></a><h2>Example</h2><p><span class="bold"><strong>C++ :</strong></span></p><pre class="screen">
template&lt;class PLayout&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const ParticleBase&lt;PLayout&gt;&amp; P) {
  TAU_TYPE_STRING(taustr, "ostream (ostream, " + CT(P) + " )");
  TAU_PROFILE("operator&lt;&lt;()"taustr, TAU_PARTICLE | TAU_IO);
  ... 
}
    </pre><p>When PLayout is instantiated with
    " <code class="literal">UniformCartesian&lt;3U, double&gt;</code> ",this generates the
    unique template name: </p><pre class="screen">
operator&lt;&lt;() ostream const 
ParticleBase&lt;UniformCartesian&lt;3U, double&gt; &gt; )
    </pre><p>The following example illustrates the usage of the CT macro
    to extract the name of the class associated with the given object using
    CT(*this);</p><pre class="screen">
template&lt;class PLayout&gt;
unsigned ParticleBase&lt;PLayout7&gt;::GetMessage(Message&amp; msg, int node) {
  TAU_TYPE_STRING(taustr, CT(*this) + "unsigned (Message, int)");
  TAU_PROFILE("ParticleBase::GetMessage()", taustr, TAU_PARTICLE);
  ...
}
    </pre><p>When PLayout is instantiated with " <code class="literal">UniformCartesian&lt;3U,
    double&gt;</code> ",this generates the unique template name:</p><pre class="screen">
ParticleBase::GetMessage() ParticleBase&lt;UniformCartesian&lt;3U, 
double&gt; &gt; unsigned (Message, int)
    </pre></div><div class="refsect1" lang="en"><a name="d0e6522"></a><h2>See Also</h2><p>
    <a href="#CT" title="CT"><span class="refentrytitle">CT</span></a>,
    <a href="#TAU_PROFILE" title="TAU_PROFILE"><span class="refentrytitle">TAU_PROFILE</span></a>,
    <a href="#TAU_PROFILE_TIMER" title="TAU_PROFILE_TIMER"><span class="refentrytitle">TAU_PROFILE_TIMER</span></a>
  </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP &#8212; Dumps the profile database to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6561"></a><h2>Description</h2><p>Dumps the profile database to disk.  The format of the files is the
    same as regular profiles, they are simply prefixed with "dump" instead of
    "profile".</p></div><div class="refsect1" lang="en"><a name="d0e6566"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6579"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DB_DUMP_INCR" title="TAU_DB_DUMP_INCR"><span class="refentrytitle">TAU_DB_DUMP_INCR</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_MERGED_DUMP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_MERGED_DUMP &#8212; Dumps the profile database to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_MERGED_DUMP</b>(</code><code>)</code>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_MERGED_DUMP</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6626"></a><h2>Description</h2><p>Dumps the profile database to disk.  The format of the files is the
    same as merged profiles: tauprofile.xml </p></div><div class="refsect1" lang="en"><a name="d0e6631"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_MERGED_DUMP();
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_MERGED_DUMP()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6644"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DB_DUMP_INCR" title="TAU_DB_DUMP_INCR"><span class="refentrytitle">TAU_DB_DUMP_INCR</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_INCR"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_INCR &#8212; Dumps profile database into timestamped profiles on disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_INCR</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6683"></a><h2>Description</h2><p>This is similar to the TAU_DB_DUMP macro but it produces
    dump files that have a timestamp in their names. This allows the user to
    record timestamped incremental dumps as the application executes.
    </p></div><div class="refsect1" lang="en"><a name="d0e6688"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_INCR();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dbDumpIncr("prefix")
    </pre></div><div class="refsect1" lang="en"><a name="d0e6701"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>,
      <a href="#TAU_DB_PURGE" title="TAU_DB_PURGE"><span class="refentrytitle">TAU_DB_PURGE</span></a>,
      <a href="#TAU_PROFILE_EXIT" title="TAU_PROFILE_EXIT"><span class="refentrytitle">TAU_PROFILE_EXIT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_PREFIX"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_PREFIX &#8212; Dumps the profile database into profile files with a given prefix</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX</b>(</code><var class="pdparam">prefix</var><code>)</code>;<br>char *<var class="pdparam">prefix</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX</b>(</code><var class="pdparam">prefix</var><code>)</code>;<br>character <var class="pdparam">prefix</var>(size);</p></div></div><div class="refsect1" lang="en"><a name="d0e6755"></a><h2>Description</h2><p>The <code class="literal">TAU_DB_DUMP_PREFIX</code> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</p></div><div class="refsect1" lang="en"><a name="d0e6763"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_PREFIX("prefix");      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP_PREFIX("prefix")
    </pre><p><span class="bold"><strong>Python :</strong></span></p><pre class="screen">
import pytau

pytau.dbDump("prefix")
    </pre></div><div class="refsect1" lang="en"><a name="d0e6781"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_DUMP_PREFIX_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_DUMP_PREFIX_TASK &#8212; Dumps the profile database into profile files with a given task</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX_TASK</b>(</code><var class="pdparam">PREFIX_TASK</var><code>)</code>;<br>char *<var class="pdparam">PREFIX_TASK</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DB_DUMP_PREFIX_TASK</b>(</code></td><td><var class="pdparam">prefix</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">task</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>character &nbsp;</td><td><var class="pdparam">prefix</var>(size);</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">task</var>(size);</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e6828"></a><h2>Description</h2><p>The <code class="literal">TAU_DB_DUMP_PREFIX_TASK</code> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics on a
		particular task at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</p></div><div class="refsect1" lang="en"><a name="d0e6836"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid);      
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid)
    </pre><p><span class="bold"><strong>Python :</strong></span></p><pre class="screen">
import pytau

pytau.dbDump("PREFIX", taskid)
    </pre></div><div class="refsect1" lang="en"><a name="d0e6854"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP_PREFIX" title="TAU_DB_DUMP_PREFIX"><span class="refentrytitle">TAU_DB_DUMP_PREFIX</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DB_PURGE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DB_PURGE &#8212; Purges the performance data.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DB_PURGE</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6881"></a><h2>Description</h2><p>Purges the performance data collected so far.</p></div><div class="refsect1" lang="en"><a name="d0e6886"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DB_PURGE();
    </pre></div><div class="refsect1" lang="en"><a name="d0e6894"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_NAMES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_NAMES &#8212; Dumps function names to disk</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_NAMES</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e6921"></a><h2>Description</h2><p>This macro writes the names of active functions to a file named dump_functionnames_&lt;node&gt;.&lt;context&gt;.</p></div><div class="refsect1" lang="en"><a name="d0e6926"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_DUMP_FUNC_NAMES();
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dumpFuncNames()
    </pre></div><div class="refsect1" lang="en"><a name="d0e6939"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_VALS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_VALS &#8212; Dumps performance data for given functions to disk.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_VALS</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e6977"></a><h2>Description</h2><p> <code class="literal">TAU_DUMP_FUNC_VALS</code>  writes the data
    associated with the routines listed in inFuncs to disk. The number of
    routines is specified by the user in numFuncs.</p></div><div class="refsect1" lang="en"><a name="d0e6985"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">

    </pre></div><div class="refsect1" lang="en"><a name="d0e6993"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS_INCR" title="TAU_DUMP_FUNC_VALS_INCR"><span class="refentrytitle">TAU_DUMP_FUNC_VALS_INCR</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_DUMP_FUNC_VALS_INCR"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_DUMP_FUNC_VALS_INCR &#8212; Dumps function values with a timestamp</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_DUMP_FUNC_VALS_INCR</b>(</code></td><td><var class="pdparam">inFuncs</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">numFuncs</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char **&nbsp;</td><td><var class="pdparam">inFuncs</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">numFuncs</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7031"></a><h2>Description</h2><p>Similar to <code class="literal">TAU_DUMP_FUNC_VALS</code>. This macro
    creates an incremental selective dump and dumps the results with a date
    stamp to the filename such as
    sel_dump__Thu-Mar-28-16:30:48-2002__.0.0.0. In this manner the previous
    <code class="literal">TAU_DUMP_FUNC_VALS_INCR(...)</code> are not overwritten
    (unless they occur within a second).</p></div><div class="refsect1" lang="en"><a name="d0e7042"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
const char **inFuncs;
/* The first dimension is functions, and the second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;

TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);

TAU_DUMP_FUNC_VALS(inFuncs, 2);
    </pre><p><span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau

pytau.dumpFuncValsIncr("foo", "bar", "bar2")
		</pre></div><div class="refsect1" lang="en"><a name="d0e7055"></a><h2>See Also</h2><p>
      <a href="#TAU_DB_DUMP" title="TAU_DB_DUMP"><span class="refentrytitle">TAU_DB_DUMP</span></a>,
      <a href="#TAU_DUMP_FUNC_NAMES" title="TAU_DUMP_FUNC_NAMES"><span class="refentrytitle">TAU_DUMP_FUNC_NAMES</span></a>,
      <a href="#TAU_DUMP_FUNC_VALS" title="TAU_DUMP_FUNC_VALS"><span class="refentrytitle">TAU_DUMP_FUNC_VALS</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_STMT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_STMT &#8212; Executes a statement only when TAU is used.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_STMT</b>(</code><var class="pdparam">statement</var><code>)</code>;<br>statement <var class="pdparam">statement</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7089"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_STMT</code> executes a statement, or declares
    a variable that is used only during profiling or for execution of a
    statement that takes place only when the instrumentation is active.  When
    instrumentation is inactive (i.e., when profiling and tracing are turned
    off as described in Chapter 2), all macros are defined as null. </p></div><div class="refsect1" lang="en"><a name="d0e7096"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE_STMT(T obj;); // T is a template parameter)
TAU_TYPE_STRING(str, "void () " + CT(obj) );
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_CALLSTACK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_CALLSTACK &#8212; Generates a callstack trace at a given location.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_CALLSTACK</b>(</code><code>)</code>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7124"></a><h2>Description</h2><p>When TAU is configured with <code class="literal">-PROFILECALLSTACK</code>
    configuration option, and this call is invoked, a callpath trace is
    generated. A GUI for viewing this trace is included in TAU's utils/csUI
    directory. This option is deprecated.</p></div><div class="refsect1" lang="en"><a name="d0e7132"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
TAU_PROFILE_CALLSTACK();
    </pre></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACE_RECVMSG"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACE_RECVMSG &#8212; Traces a receive operation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_RECVMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_RECVMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7190"></a><h2>Description</h2><p> <code class="literal">TAU_TRACE_RECVMSG</code>  traces a receive operation where tag represents the type of the message received from the source process.</p><p><span class="emphasis"><em>NOTE:</em></span> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <code class="literal">TAU_TRACE_RECVMSG</code>  and
    <code class="literal">TAU_TRACE_SENDMSG</code>  macros are not required. The wrapper
    interposition library in </p><pre class="screen">$(TAU_MPI_LIBS)</pre><p> uses these
    macros internally for logging messages. </p></div><div class="refsect1" lang="en"><a name="d0e7211"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </pre></div><div class="refsect1" lang="en"><a name="d0e7224"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACE_SENDMSG" title="TAU_TRACE_SENDMSG"><span class="refentrytitle">TAU_TRACE_SENDMSG</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_TRACE_SENDMSG"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_TRACE_SENDMSG &#8212; Traces a receive operation</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_SENDMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>int &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_TRACE_SENDMSG</b>(</code></td><td><var class="pdparam">tag</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">source</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>integer &nbsp;</td><td><var class="pdparam">tag</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">source</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7281"></a><h2>Description</h2><p><code class="literal">TAU_TRACE_SENDMSG</code> traces an inter-process message communication when a tagged message is sent to a destination process. </p><p><span class="emphasis"><em>NOTE:</em></span> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <code class="literal">TAU_TRACE_SENDMSG</code>  and
    <code class="literal">TAU_TRACE_SENDMSG</code>  macros are not required. The wrapper
    interposition library in </p><pre class="screen">$(TAU_MPI_LIBS)</pre><p> uses these
    macros internally for logging messages. </p></div><div class="refsect1" lang="en"><a name="d0e7301"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </pre><p><span class="bold"><strong>Fortran :</strong></span></p><pre class="screen">
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </pre></div><div class="refsect1" lang="en"><a name="d0e7314"></a><h2>See Also</h2><p>
      <a href="#TAU_TRACE_RECVMSG" title="TAU_TRACE_RECVMSG"><span class="refentrytitle">TAU_TRACE_RECVMSG</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_PARAM1L"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_PARAM1L &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_PARAM1L</b>(</code><var class="pdparam">number</var>, <var class="pdparam">name</var><code>)</code>;<br>long <var class="pdparam">number</var>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_PARAM1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">number</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7367"></a><h2>Description</h2><p>Track the a given numerial parameter to a function and records each
		value as a seperate event. <code class="literal">number</code> is the parameter to be
		tracked. <code class="literal">name</code> is the name of this event.</p></div><div class="refsect1" lang="en"><a name="d0e7378"></a><h2>Example</h2><p><span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
int f1(int x)
{
  TAU_PROFILE("f1()", "", TAU_USER);
  TAU_PROFILE_PARAM1L((long) x, "x");
	...
</pre><p><span class="bold"><strong>Fortran:</strong></span></p><pre class="screen">
 subroutine ITERATION(val)
  integer val
  integer profiler(2) / 0, 0 /
  save profiler

  call TAU_PROFILE_TIMER(profiler, 'INTERATION')
  call TAU_PROFILE_START(profiler)

 	call TAU_PROFILE_PARAM1L('value', val, 4) 

	....

	call TAU_PROFILE_STOP(profiler)
  return
end
</pre></div><div class="refsect1" lang="en"><a name="d0e7391"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_TIMER_DYNAMIC" title="TAU_PROFILE_TIMER_DYNAMIC"><span class="refentrytitle">TAU_PROFILE_TIMER_DYNAMIC</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SNAPSHOT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SNAPSHOT &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT</b>(</code><var class="pdparam">name</var><code>)</code>;<br>char* <var class="pdparam">name</var>;</p></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7436"></a><h2>Description</h2><p><code class="literal">TAU_PROFILE_SNAPSHOT</code> writes a snapshot profile
    representing the program's execution up to this point. These file are
    written the system as snapshot.[node].[context].[thread] format. They can be
    merged by appending one to another. Uploading a snapshot to a PerfDMF
    database or packing them into a PPK file will condense them to a single
    profile (the last one).
    </p></div><div class="refsect1" lang="en"><a name="d0e7443"></a><h2>Examples</h2><p>C/C++:</p><pre class="screen">
TAU_PROFILE_SNAPSHOT(name);
</pre><p>Fortran:</p><pre class="screen">
TAU_PROFILE_SNAPSHOT(name, length);
</pre><p>Python:</p><pre class="screen">
import pytau;

pytau.snapshot("name")
</pre></div><div class="refsect1" lang="en"><a name="d0e7458"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SNAPSHOT_1L" title="TAU_PROFILE_SNAPSHOT_1L"><span class="refentrytitle">TAU_PROFILE_SNAPSHOT_1L</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILE_SNAPSHOT_1L"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILE_SNAPSHOT_1L &#8212; Creates a snapshot of the current apllication profile</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT_1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">number</var>;</td></tr></table></div><div class="funcsynopsis"><pre class="funcsynopsisinfo">Fortran:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILE_SNAPSHOT_1L</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">number</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">length</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char* &nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">number</var>;</td></tr><tr><td>integer &nbsp;</td><td><var class="pdparam">length</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7511"></a><h2>Description</h2><p>Calls <code class="literal">TAU_PROFILE_SNAPSHOT</code> giving it the as a name
    the name with a number appended.</p></div><div class="refsect1" lang="en"><a name="d0e7519"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILE_SNAPSHOT" title="TAU_PROFILE_SNAPSHOT"><span class="refentrytitle">TAU_PROFILE_SNAPSHOT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_CREATE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_CREATE &#8212; Creates a profiler object referenced as a standard pointer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_CREATE</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">function_name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">group</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">function_name</var>;</td></tr><tr><td>char* or string&amp; &nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>taugroup_t &nbsp;</td><td><var class="pdparam">group</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7559"></a><h2>description</h2><p><code class="function">TAU_PROFILER_CREATE</code> creates a
    timer the that can be controlled by the Timer pointer object.</p><p>The TAU_PROFILER_* API is intended for applications to easily layer
		their legacy timing measurements APIs on top of TAU, Unlike other TAU API
		calls (TAU_PROFILE_TIMER) that are statically expanded in the source code,
		these calls allocate TAU entities on the heap. So the pointer to the TAU
		timer may be used as a handle to access the TAU performance data.</p></div><div class="refsect1" lang="en"><a name="d0e7568"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e7583"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_CREATE_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_CREATE_TASK &#8212; Creates a task id.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_CREATE_TASK</b>(</code><var class="pdparam">taskid</var><code>)</code>;<br>Integer <var class="pdparam">taskid</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7623"></a><h2>description</h2><p><code class="function">TAU_CREATE_TASK</code> creates a task with id 'taskid'
	this task is an independent event stream for which Profiler objects can be
	started and stop on. TAU will increment the taskids as needed an write out
	profiles and traces from the task as if they were thread.
	</p></div><div class="refsect1" lang="en"><a name="d0e7630"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e7639"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_START &#8212; starts a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a></p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_START</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7680"></a><h2>description</h2><p><code class="function">TAU_PROFILER_START</code>starts a profiler
    timer by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e7689"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e7704"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_START_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_START_TASK &#8212; Starts a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> on a given task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_START_TASK</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7746"></a><h2>description</h2><p><code class="function">TAU_PROFILER_START_TASK</code>starts a profiler timer on
		a task by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> and a task created by <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a> on a given task.</p></div><div class="refsect1" lang="en"><a name="d0e7757"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e7766"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_STOP &#8212; stops a profiler object created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a></p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_STOP</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7807"></a><h2>description</h2><p><code class="function">TAU_PROFILER_STOP</code>stops a profiler
    timer by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e7816"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</pre><p>&gt;<span class="bold"><strong>Python:</strong></span></p><pre class="screen">
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</pre></div><div class="refsect1" lang="en"><a name="d0e7831"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_STOP_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_STOP_TASK &#8212; Stops a profiler object on a task</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_PROFILER_STOP_TASK</b>(</code><var class="pdparam">timer</var><code>)</code>;<br>Timer <var class="pdparam">timer</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e7871"></a><h2>description</h2><p><code class="function">TAU_PROFILER_STOP_TASK</code>STOPs a profiler timer on a
		task by passing the pointer created by the <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a> and a task created by <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>.</p></div><div class="refsect1" lang="en"><a name="d0e7882"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e7891"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CALLS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CALLS &#8212; Gets the number of times this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CALLS</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e7937"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CALLS</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</p></div><div class="refsect1" lang="en"><a name="d0e7944"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS(ptr, &amp;calls); 
</pre></div><div class="refsect1" lang="en"><a name="d0e7953"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CALLS_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CALLS_TASK &#8212; Gets the number of times this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started on a given task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CALLS_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8003"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CALLS_TASK</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed) on a given task.</p></div><div class="refsect1" lang="en"><a name="d0e8010"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS_TASK(ptr, &amp;calls, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8019"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CHILD_CALLS"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CHILD_CALLS &#8212; Gets the number of calls made while this timer was running</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CHILD_CALLS</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">calls</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">calls</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8063"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CHILD_CALLS</code>
    Gets the number of timers started while <code class="literal">timer</code> was
		running. This is non-recursive, only timers started directly count.</p></div><div class="refsect1" lang="en"><a name="d0e8073"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

long calls;
TAU_PROFILER_GET_CHILD_CALLS(ptr, &amp;calls); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8082"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_CHILD_CALLS_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_CHILD_CALLS_TASK &#8212; Gets the number of child call for this timer, created by <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>, is started on a task.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_CHILD_CALLS_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">child_calls</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>long&amp; &nbsp;</td><td><var class="pdparam">child_calls</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8132"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_CHILD_CALLS_TASK</code> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</p></div><div class="refsect1" lang="en"><a name="d0e8139"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long child_calls;
TAU_PROFILER_GET_CHILD_CALLS_TASK(ptr, &amp;child_calls, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8148"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_INCLUSIVE_VALUES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_INCLUSIVE_VALUES &#8212; Returns the inclusive amount of a metric spend by this timer.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_INCLUSIVE_VALUES</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">incl</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">incl</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8192"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_INCLUSIVE_VALUES</code>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer.)
		</p></div><div class="refsect1" lang="en"><a name="d0e8199"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES(ptr, &amp;incl); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8208"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK &#8212; Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">incl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">incl</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8256"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</code>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer) on a given
	task.
		</p></div><div class="refsect1" lang="en"><a name="d0e8263"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK(ptr, &amp;incl, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8272"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO_TASK" title="TAU_PROFILER_GET_COUNTER_INFO_TASK"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_EXCLUSIVE_VALUES"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_EXCLUSIVE_VALUES &#8212; Returns the exclusive amount of a metric spend by this timer.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_EXCLUSIVE_VALUES</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">excl</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">excl</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8316"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_EXCLUSIVE_VALUES</code>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running.)
		</p></div><div class="refsect1" lang="en"><a name="d0e8323"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES(ptr, &amp;excl); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8332"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK &#8212; Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">excl</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Timer &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>double&amp; &nbsp;</td><td><var class="pdparam">excl</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8380"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</code>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running) on a given
	task.
		</p></div><div class="refsect1" lang="en"><a name="d0e8387"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK(ptr, &amp;excl, taskid); 
</pre></div><div class="refsect1" lang="en"><a name="d0e8396"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_COUNTER_INFO" title="TAU_PROFILER_GET_COUNTER_INFO"><span class="refentrytitle">TAU_PROFILER_GET_COUNTER_INFO</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_COUNTER_INFO"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_COUNTER_INFO &#8212; Returns information about all the timers created.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_COUNTER_INFO</b>(</code></td><td><var class="pdparam">counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">num_counters</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">counters</var>;</td></tr><tr><td>int &amp;&nbsp;</td><td><var class="pdparam">num_counters</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8440"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_COUNTER_INFO</code>
		  Gets the number of counters created and an array of the counters
			containing information about the counters.
		</p></div><div class="refsect1" lang="en"><a name="d0e8447"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO(&amp;counters, &amp;numcounters);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf("&gt;&gt;&gt;");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</pre></div><div class="refsect1" lang="en"><a name="d0e8456"></a><h2>See Also</h2><p>
      <a href="#TAU_PROFILER_CREATE" title="TAU_PROFILER_CREATE"><span class="refentrytitle">TAU_PROFILER_CREATE</span></a>
      <a href="#TAU_PROFILER_START" title="TAU_PROFILER_START"><span class="refentrytitle">TAU_PROFILER_START</span></a>
      <a href="#TAU_PROFILER_STOP" title="TAU_PROFILER_STOP"><span class="refentrytitle">TAU_PROFILER_STOP</span></a>
      <a href="#TAU_PROFILER_GET_CALLS" title="TAU_PROFILER_GET_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS" title="TAU_PROFILER_GET_CHILD_CALLS"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES" title="TAU_PROFILER_GET_INCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_PROFILER_GET_COUNTER_INFO_TASK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_PROFILER_GET_COUNTER_INFO_TASK &#8212; Returns information about all the timers created on a task. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_PROFILER_GET_COUNTER_INFO_TASK</b>(</code></td><td><var class="pdparam">counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">num_counters</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">taskid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>const char * &nbsp;</td><td><var class="pdparam">counters</var>;</td></tr><tr><td>int &amp;&nbsp;</td><td><var class="pdparam">num_counters</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">taskid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8504"></a><h2>description</h2><p><code class="function">TAU_PROFILER_GET_COUNTER_INFO_TASK</code>
		  Gets the number of counters created and an array of the counters
			containing information about the counters on a given task.
		</p></div><div class="refsect1" lang="en"><a name="d0e8511"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr, taskid);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO_TASK(&amp;counters, &amp;numcounters, taskid);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf("&gt;&gt;&gt;");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</pre></div><div class="refsect1" lang="en"><a name="d0e8520"></a><h2>See Also</h2><p>
      <a href="#TAU_CREATE_TASK" title="TAU_CREATE_TASK"><span class="refentrytitle">TAU_CREATE_TASK</span></a>
      <a href="#TAU_PROFILER_START_TASK" title="TAU_PROFILER_START_TASK"><span class="refentrytitle">TAU_PROFILER_START_TASK</span></a>
      <a href="#TAU_PROFILER_STOP_TASK" title="TAU_PROFILER_STOP_TASK"><span class="refentrytitle">TAU_PROFILER_STOP_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CALLS_TASK" title="TAU_PROFILER_GET_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_CHILD_CALLS_TASK" title="TAU_PROFILER_GET_CHILD_CALLS_TASK"><span class="refentrytitle">TAU_PROFILER_GET_CHILD_CALLS_TASK</span></a>
      <a href="#TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</span></a>
      <a href="#TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" title="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK"><span class="refentrytitle">TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_DECLARE_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_DECLARE_EVENT &#8212; Returns a event handle.
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_DECLARE_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e8560"></a><h2>description</h2><p><code class="function">TAU_QUERY_DECLARE_EVENT</code>
			Creates a event handle for querying TAU events.
		</p></div><div class="refsect1" lang="en"><a name="d0e8567"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e8576"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_CURRENT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_CURRENT_EVENT &#8212; set event to be the current TAU event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_CURRENT_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e8610"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_CURRENT_EVENT</code>
			Set event to be the current TAU event in the context in which this call is
			made.
		</p></div><div class="refsect1" lang="en"><a name="d0e8617"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e8626"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_EVENT_NAME"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_EVENT_NAME &#8212; Gets the name of a given event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_EVENT_NAME</b>(</code></td><td><var class="pdparam">event</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">str</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>void * &nbsp;</td><td><var class="pdparam">event</var>;</td></tr><tr><td>char * &nbsp;</td><td><var class="pdparam">str</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8664"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_EVENT_NAME</code>
			Set str to be the event name to the given event name.
		</p></div><div class="refsect1" lang="en"><a name="d0e8671"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e8680"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_QUERY_GET_PARENT_EVENT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_QUERY_GET_PARENT_EVENT &#8212; gets the parent of the current event. 
	</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_QUERY_GET_PARENT_EVENT</b>(</code><var class="pdparam">event</var><code>)</code>;<br>void * <var class="pdparam">event</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e8714"></a><h2>description</h2><p><code class="function">TAU_QUERY_GET_PARENT_EVENT</code>
			Set event to be the parent  event to the current event.
		</p></div><div class="refsect1" lang="en"><a name="d0e8721"></a><h2>example</h2><p>&gt;<span class="bold"><strong>C/C++:</strong></span></p><pre class="screen">
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_PARENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("parent event is: %d.\n", str);

</pre></div><div class="refsect1" lang="en"><a name="d0e8730"></a><h2>See Also</h2><p>
<a href="#TAU_QUERY_DECLARE_EVENT" title="TAU_QUERY_DECLARE_EVENT"><span class="refentrytitle">TAU_QUERY_DECLARE_EVENT</span></a>
<a href="#TAU_QUERY_GET_CURRENT_EVENT" title="TAU_QUERY_GET_CURRENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_CURRENT_EVENT</span></a>
<a href="#TAU_QUERY_GET_EVENT_NAME" title="TAU_QUERY_GET_EVENT_NAME"><span class="refentrytitle">TAU_QUERY_GET_EVENT_NAME</span></a>
<a href="#TAU_QUERY_GET_PARENT_EVENT" title="TAU_QUERY_GET_PARENT_EVENT"><span class="refentrytitle">TAU_QUERY_GET_PARENT_EVENT</span></a>
    </p></div></div></div><div class="reference" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e8745"></a>TAU Mapping API</h1></div></div><hr></div><div class="partintro" lang="en"><div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8749"></a>Introduction</h2></div></div></div><p>TAU allows the user to map performance data of entities from one
      layer to another in multi-layered software. Mapping is used in profiling
      (and tracing) both synchronous and asynchronous models of
      computation.</p><p>For mapping, the following macros are used.  First locate and
      identify the higher-level statement using the <a href="#TAU_MAPPING" title="TAU_MAPPING"><span class="refentrytitle">TAU_MAPPING</span></a> macro. Then, associate a function identifier with it using the <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>.  Associate the high level statement to a
      FunctionInfo object that will be visible to lower level code, using <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>, and then profile entire blocks using <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>. Independent sets of statements can be
      profiled using <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>, <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>, and <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a> macros using the FunctionInfo
      object.</p><p>The TAU <code class="filename">examples/mapping</code> directory has two
      examples (embedded and external) that illustrate the use of this mapping
      API for generating object-oriented profiles.</p></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#TAU_MAPPING">TAU_MAPPING</a></span><span class="refpurpose"> - Encapsulates a C++ statement for profiling</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_CREATE">TAU_MAPPING_CREATE</a></span><span class="refpurpose"> - Creates a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_LINK">TAU_MAPPING_LINK</a></span><span class="refpurpose"> - Creates a mapping link</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_OBJECT">TAU_MAPPING_OBJECT</a></span><span class="refpurpose"> - Declares a mapping object</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE">TAU_MAPPING_PROFILE</a></span><span class="refpurpose"> - Profiles a block based on a mapping</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_START">TAU_MAPPING_PROFILE_START</a></span><span class="refpurpose"> - Starts a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_STOP">TAU_MAPPING_PROFILE_STOP</a></span><span class="refpurpose"> - Stops a mapping timer</span></dt><dt><span class="refentrytitle"><a href="#TAU_MAPPING_PROFILE_TIMER">TAU_MAPPING_PROFILE_TIMER</a></span><span class="refpurpose"> - Declares a mapping timer</span></dt></dl></div></div><div class="refentry" lang="en"><a name="TAU_MAPPING"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING &#8212; Encapsulates a C++ statement for profiling</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING</b>(</code></td><td><var class="pdparam">statement</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>statement &nbsp;</td><td><var class="pdparam">statement</var>;</td></tr><tr><td>TauGroup_t &nbsp;</td><td><var class="pdparam">key</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8802"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING</code> is used to encapsulate a C++ statement
    as a timer.  A timer will be made, named by the statment, and will profile
    the statement.  The key given can be used with <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a> to retrieve the timer.</p></div><div class="refsect1" lang="en"><a name="d0e8811"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
int main(int argc, char **argv) {
  Array &lt;2&gt; A(N, N), B(N, N), C(N,N), D(N, N);
  // Original statement:
  // A = B + C + D;
  //Instrumented statement:
  TAU_MAPPING(A = B + C + D; , TAU_USER);
  ... 
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e8819"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_CREATE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_CREATE &#8212; Creates a mapping</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_CREATE</b>(</code></td><td><var class="pdparam">name</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">groupname</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">key</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>char *&nbsp;</td><td><var class="pdparam">name</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">type</var>;</td></tr><tr><td>char *&nbsp;</td><td><var class="pdparam">groupname</var>;</td></tr><tr><td>unsigned long &nbsp;</td><td><var class="pdparam">key</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8867"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_CREATE</code> creates a mapping and
    associates it with the key that is specified.  Later, this key may be used
    to retrieve the FunctionInfo object associated with this key for timing
    purposes. The thread identifier is specified in the <code class="literal">tid</code>
    parameter.</p></div><div class="refsect1" lang="en"><a name="d0e8877"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
class MyClass {
  public:
    MyClass() {
      TAU_MAPPING_LINK(runtimer, TAU_USER); 
    } 
    ~MyClass() {}

    void Run(void) {
      TAU_MAPPING_PROFILE(runtimer); // For one object
      TAU_PROFILE("MyClass::Run()", " void (void)", TAU_USER1);
	
      cout &lt;&lt;"Sleeping for 2 secs..."&lt;&lt;endl;
      sleep(2);
    }
  private:
    TAU_MAPPING_OBJECT(runtimer)  // EMBEDDED ASSOCIATION
};

int main(int argc, char **argv) {
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  MyClass x, y, z;
  TAU_MAPPING_CREATE("MyClass::Run() for object a", " " , TAU_USER, 
                     "TAU_USER", 0);
  MyClass a;
  TAU_PROFILE_SET_NODE(0);
  cout &lt;&lt;"Inside main"&lt;&lt;endl;

  a.Run();
  x.Run();
  y.Run();
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e8885"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_LINK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_LINK &#8212; Creates a mapping link</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_LINK</b>(</code></td><td><var class="pdparam">FuncIdVar</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">Key</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>FunctionInfo &nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr><tr><td>unsigned long &nbsp;</td><td><var class="pdparam">Key</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e8923"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_LINK </code>creates a link between
    the object defined in <code class="literal">TAU_MAPPING_OBJECT</code> (that
    identifies a statement) and the actual higher-level statement that is
    mapped with <code class="literal">TAU_MAPPING</code>. The Key argument represents a
    profile group to which the statement belongs, as specified in the
    <code class="literal">TAU_MAPPING</code> macro argument. For the example of array
    statements, this link should be created in the constructor of the class
    that represents the expression. <code class="literal">TAU_MAPPING_LINK</code>
    should be executed before any measurement takes place. It assigns the
    identifier of the statement to the object to which FuncIdVar refers. For
    example</p></div><div class="refsect1" lang="en"><a name="d0e8942"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
class MyClass {
  public:
    MyClass() { }
    ~MyClass() { }

    void Run(void) {
      TAU_MAPPING_OBJECT(runtimer)
      TAU_MAPPING_LINK(runtimer, (unsigned long) this);
      TAU_MAPPING_PROFILE(runtimer); // For one object
      TAU_PROFILE("MyClass::Run()", " void (void)", TAU_USER1);
      
      /* ... */
    }
};

int main(int argc, char **argv) {
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  MyClass x, y, z;
  MyClass a;
  TAU_MAPPING_CREATE("MyClass::Run() for object a", " " , 
                     (TauGroup_t) &amp;a, "TAU_USER", 0);
  TAU_MAPPING_CREATE("MyClass::Run() for object x", " " , 
                     (TauGroup_t) &amp;x, "TAU_USER", 0);
  TAU_PROFILE_SET_NODE(0);
  cout &lt;&lt;"Inside main"&lt;&lt;endl;

  a.Run();
  x.Run();
  y.Run();


    </pre></div><div class="refsect1" lang="en"><a name="d0e8950"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_OBJECT"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_OBJECT &#8212; Declares a mapping object</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><p><code class="funcdef"><b class="fsfunc">TAU_MAPPING_OBJECT</b>(</code><var class="pdparam">FuncIdVar</var><code>)</code>;<br>FunctionInfo <var class="pdparam">FuncIdVar</var>;</p></div></div><div class="refsect1" lang="en"><a name="d0e8984"></a><h2>Description</h2><p>To create storage for an identifier associated with a higher
    level statement that is mapped using <code class="literal">TAU_MAPPING</code>, we
    use the <code class="literal">TAU_MAPPING_OBJECT</code> macro. For example, in the
    <code class="literal">TAU_MAPPING</code> example, the array expressions are
    created into objects of a class ExpressionKernel, and each statement is
    an object that is an instance of this class. To embed the identity of
    the statement we store the mapping object in a data field in this class.
    This is shown below:</p></div><div class="refsect1" lang="en"><a name="d0e8998"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
class ExpressionKernel : public Pooma::Iterate_t {
  public:
      
    typedef ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt; This_t;
    //
    // Construct from an Expr.
    // Build the kernel that will evaluate the expression on the 
    // given domain.
    // Acquire locks on the data referred to by the expression.
    //
    ExpressionKernel(const LHS&amp;,const Op&amp;,const RHS&amp;,
    Pooma::Scheduler_t&amp;);
      
      
    virtual ~ExpressionKernel();
    
    // Do the loop.
    virtual void run();
    
  private:
      
    // The expression we will evaluate.
    LHS lhs_m;
    Op  op_m;
    RHS rhs_m;
    TAU_MAPPING_OBJECT(TauMapFI)
};
    </pre></div><div class="refsect1" lang="en"><a name="d0e9006"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_PROFILE" title="TAU_MAPPING_PROFILE"><span class="refentrytitle">TAU_MAPPING_PROFILE</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE &#8212; Profiles a block based on a mapping</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE</b>(</code></td><td><var class="pdparam">FuncIdVar</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>FunctionInfo *&nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e9040"></a><h2>Description</h2><p>The <code class="literal">TAU_MAPPING_PROFILE</code> macro measures the
    time and attributes it to the statement mapped in
    <code class="literal">TAU_MAPPING</code> macro. It takes as its argument the
    identifier of the higher level statement that is stored using
    <code class="literal">TAU_MAPPING_OBJECT</code> and linked to the statement using
    <code class="literal">TAU_MAPPING_LINK</code> macros. 
    <code class="literal">TAU_MAPPING_PROFILE</code> measures the time spent in the
    entire block in which it is invoked. For example, if the time spent in
    the run method of the class does work that must be associated with the
    higher-level array expression, then, we can instrument it as
    follows:</p></div><div class="refsect1" lang="en"><a name="d0e9060"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
// Evaluate the kernel
// Just tell an InlineEvaluator to do it.
      
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE(TauMapFI)
      
  // Just evaluate the expression.
  KernelEvaluator&lt;EvalTag&gt;().evalate(lhs_m,op_m,rhs_m);
  // we could release the locks here or in dtor 
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e9068"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_CREATE" title="TAU_MAPPING_CREATE"><span class="refentrytitle">TAU_MAPPING_CREATE</span></a>,
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_START"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_START &#8212; Starts a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_START</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e9106"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_START</code> starts the
    timer that is created using
    <code class="literal">TAU_MAPPING_PROFILE_TIMER</code>. This will measure the
    elapsed time in groups of statements, instead of the entire block. A
    corresponding stop statement stops the timer as described next. The
    thread identifier is specified in the tid parameter.</p></div><div class="refsect1" lang="en"><a name="d0e9116"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e9124"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>,
      <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_STOP"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_STOP &#8212; Stops a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_STOP</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">tid</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>int &nbsp;</td><td><var class="pdparam">tid</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e9160"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_STOP</code> stops the
    timer that is created using
    <code class="literal">TAU_MAPPING_PROFILE_TIMER</code>. This will measure the
    elapsed time in groups of statements, instead of the entire block. A
    corresponding stop statement stops the timer as described next. The
    thread identifier is specified in the tid parameter.</p></div><div class="refsect1" lang="en"><a name="d0e9170"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e9178"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_PROFILE_TIMER" title="TAU_MAPPING_PROFILE_TIMER"><span class="refentrytitle">TAU_MAPPING_PROFILE_TIMER</span></a>,
      <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>
    </p></div></div><div class="refentry" lang="en"><div class="refentry.separator"><hr></div><a name="TAU_MAPPING_PROFILE_TIMER"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>TAU_MAPPING_PROFILE_TIMER &#8212; Declares a mapping timer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">C/C++:</pre><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef"><b class="fsfunc">TAU_MAPPING_PROFILE_TIMER</b>(</code></td><td><var class="pdparam">timer</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">FuncIdVar</var><code>)</code>;</td><td>&nbsp;</td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td>Profiler &nbsp;</td><td><var class="pdparam">timer</var>;</td></tr><tr><td>FunctionInfo *&nbsp;</td><td><var class="pdparam">FuncIdVar</var>;</td></tr></table></div></div><div class="refsect1" lang="en"><a name="d0e9214"></a><h2>Description</h2><p><code class="literal">TAU_MAPPING_PROFILE_TIMER</code> enables timing
    of individual statements, instead of complete blocks. It will attribute
    the time to a higher-level statement. The second argument is the
    identifier of the statement that is obtained after
    <code class="literal">TAU_MAPPING_OBJECT</code> and
    <code class="literal">TAU_MAPPING_LINK</code> have executed. The timer argument in
    this macro is any variable that is used subsequently to start and stop
    the timer.</p></div><div class="refsect1" lang="en"><a name="d0e9227"></a><h2>Example</h2><p><span class="bold"><strong>C/C++ :</strong></span></p><pre class="screen">
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run() {
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
  KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
    </pre></div><div class="refsect1" lang="en"><a name="d0e9235"></a><h2>See Also</h2><p>
      <a href="#TAU_MAPPING_LINK" title="TAU_MAPPING_LINK"><span class="refentrytitle">TAU_MAPPING_LINK</span></a>,
      <a href="#TAU_MAPPING_OBJECT" title="TAU_MAPPING_OBJECT"><span class="refentrytitle">TAU_MAPPING_OBJECT</span></a>,
      <a href="#TAU_MAPPING_PROFILE_START" title="TAU_MAPPING_PROFILE_START"><span class="refentrytitle">TAU_MAPPING_PROFILE_START</span></a>,
      <a href="#TAU_MAPPING_PROFILE_STOP" title="TAU_MAPPING_PROFILE_STOP"><span class="refentrytitle">TAU_MAPPING_PROFILE_STOP</span></a>
    </p></div></div></div></div>
       </div>
       <?php include("../../footer.php") ?>
    </body></html>
