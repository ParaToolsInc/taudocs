<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The New TAU Users Guide</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
       <?php include("../../header.php") ?>
       <div id="content">
    <div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="TauDoc"></a>The New TAU Users Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">University of</span> <span class="surname">Oregon</span></h3></div></div></div><div><p class="copyright">Copyright &copy; 2005 University of Oregon Performance Research Lab</p></div><div><p class="pubdate">(TBA)</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tau.installation">1. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e47">1.1.1. Available configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e333">1.1.2. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e342">1.1.3. Examples: </a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tau.compiling">2. Compiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TAUMakefile.tau">2.1. TAU Stub Makefile</a></span></dt><dt><span class="sect1"><a href="#EnablingDisablingInstrumentation">2.2. Enabling and Disabling the Instrumentation</a></span></dt><dt><span class="sect1"><a href="#UsingWithMPI">2.3. Using TAU with MPI</a></span></dt><dt><span class="sect1"><a href="#EnvironmentVariables">2.4. Environment Variables</a></span></dt><dt><span class="sect1"><a href="#ApplicationScenarios">2.5. Application Scenarios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tau.instrumentation">3. Instrumentation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Automatic Instrumentation">3.1. Automatic Instrumentation of C++, C and F90 source code</a></span></dt><dt><span class="sect1"><a href="#UsingTAU_PDT_MPI">3.2. Using TAU with PDT and MPI</a></span></dt><dt><span class="sect1"><a href="#Using TAU_PDT_F90">3.3. Using TAU with PDT for an F90 MPI application</a></span></dt><dt><span class="sect1"><a href="#TAU_PDT_Opari">3.4. Using TAU with PDT and Opari</a></span></dt><dt><span class="sect1"><a href="#Selctive Instrumentation">3.5. Selective Instrumentation</a></span></dt><dt><span class="sect1"><a href="#TAU_REDUCE">3.6. TAU_REDUCE: A tool for reducing instrumentation overhead</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e976">3.6.1. OPTIONS</a></span></dt><dt><span class="sect2"><a href="#d0e997">3.6.2. RULES:</a></span></dt><dt><span class="sect2"><a href="#d0e1080">3.6.3. Examples:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#C++MeasurementAPI">3.7. C++ Measurement API</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1098">3.7.1. TAU_PROFILE(function_name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1127">3.7.2. string&amp; CT(variable);</a></span></dt><dt><span class="sect2"><a href="#d0e1140">3.7.3. TAU_TYPE_STRING(variable, type_string);</a></span></dt><dt><span class="sect2"><a href="#d0e1169">3.7.4. TAU_PROFILE_TIMER(timer, name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1181">3.7.5. TAU_PROFILE_START(timer); </a></span></dt><dt><span class="sect2"><a href="#d0e1191">3.7.6. TAU_PROFILE_STOP(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1207">3.7.7. TAU_GLOBAL_TIMER(timer, name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1220">3.7.8. TAU_GLOBAL_TIMER_START(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1230">3.7.9. TAU_GLOBAL_TIMER_STOP(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1244">3.7.10. TAU_PROFILE_SET_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1256">3.7.11. TAU_PROFILE_TIMER_SET_GROUP_NAME(timer, groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1270">3.7.12. TAU_PROFILE_STMT(statement); </a></span></dt><dt><span class="sect2"><a href="#d0e1284">3.7.13. TAU_PROFILE_INIT(argc, argv);</a></span></dt><dt><span class="sect2"><a href="#d0e1298">3.7.14. TAU_PROFILE_SET_NODE(myNode); </a></span></dt><dt><span class="sect2"><a href="#d0e1308">3.7.15. TAU_PROFILE_SET_CONTEXT(myContext);</a></span></dt><dt><span class="sect2"><a href="#d0e1321">3.7.16. TAU_REGISTER_THREAD();</a></span></dt><dt><span class="sect2"><a href="#d0e1329">3.7.17. TAU_REGISTER_FORK(nodeid, option);</a></span></dt><dt><span class="sect2"><a href="#d0e1349">3.7.18. TAU_PROFILE_EXIT(message);</a></span></dt><dt><span class="sect2"><a href="#d0e1363">3.7.19. TAU_PROFILE_TIMER_SET_NAME(t, newname)</a></span></dt><dt><span class="sect2"><a href="#d0e1377">3.7.20. TAU_PROFILE_TIMER_SET_TYPE(t, newtype)</a></span></dt><dt><span class="sect2"><a href="#d0e1387">3.7.21. TAU_PROFILE_TIMER_SET_GROUP(t, group)</a></span></dt><dt><span class="sect2"><a href="#d0e1401">3.7.22. TAU_DISABLE_INSTRUMENTATION();</a></span></dt><dt><span class="sect2"><a href="#d0e1409">3.7.23. TAU_ENABLE_INSTRUMENTATION();</a></span></dt><dt><span class="sect2"><a href="#d0e1421">3.7.24. TAU_ENABLE_GROUP(group);</a></span></dt><dt><span class="sect2"><a href="#d0e1435">3.7.25. TAU_DISABLE_GROUP(group);</a></span></dt><dt><span class="sect2"><a href="#d0e1449">3.7.26. TAU_GET_PROFILE_GROUP(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1466">3.7.27. TAU_ENABLE_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1482">3.7.28. TAU_DISABLE_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1499">3.7.29. TAU_ENABLE_ALL_GROUPS();</a></span></dt><dt><span class="sect2"><a href="#d0e1504">3.7.30. TAU_DISABLE_ALL_GROUPS();</a></span></dt><dt><span class="sect2"><a href="#d0e1513">3.7.31. TAU_REGISTER_EVENT(variable, event_name);</a></span></dt><dt><span class="sect2"><a href="#d0e1523">3.7.32. TAU_EVENT(variable, value);</a></span></dt><dt><span class="sect2"><a href="#d0e1537">3.7.33. TAU_REPORT_STATISTICS(); </a></span></dt><dt><span class="sect2"><a href="#d0e1545">3.7.34. TAU_REPORT_THREAD_STATISTICS();</a></span></dt><dt><span class="sect2"><a href="#d0e1553">3.7.35. TAU_TRACE_SENDMSG(tag, destination, length); </a></span></dt><dt><span class="sect2"><a href="#d0e1563">3.7.36. TAU_TRACE_RECVMSG(tag, source, length); </a></span></dt><dt><span class="sect2"><a href="#d0e1590">3.7.37. TAU_DB_DUMP_PREFIX(prefix);</a></span></dt><dt><span class="sect2"><a href="#d0e1600">3.7.38. TAU_DB_DUMP_INCR();</a></span></dt><dt><span class="sect2"><a href="#d0e1605">3.7.39. TAU_GET_FUNC_NAMES(functionList, numFuncs); </a></span></dt><dt><span class="sect2"><a href="#d0e1612">3.7.40. TAU_DUMP_FUNC_NAMES(); </a></span></dt><dt><span class="sect2"><a href="#d0e1617">3.7.41. TAU_GET_COUNTER_NAMES(counterList, numCounters);</a></span></dt><dt><span class="sect2"><a href="#d0e1627">3.7.42. TAU_GET_FUNC_VALS(inFuncs, numRoutines, counterExclusiveValues, counterInclusiveValues, numCalls, numSubrs, counterNames, numOfCounters);</a></span></dt><dt><span class="sect2"><a href="#d0e1636">3.7.43. TAU_DUMP_FUNC_VALS(inFuncs, numFuncs);</a></span></dt><dt><span class="sect2"><a href="#d0e1646">3.7.44. TAU_DUMP_FUNC_VALS_INCR(inFuncs, numFuncs); </a></span></dt><dt><span class="sect2"><a href="#d0e1659">3.7.45. TAU Mapping API</a></span></dt><dt><span class="sect2"><a href="#d0e1685">3.7.46. TAU_MAPPING(statement, key);</a></span></dt><dt><span class="sect2"><a href="#d0e1696">3.7.47. TAU_MAPPING_CREATE(name, type, key, groupname, tid);</a></span></dt><dt><span class="sect2"><a href="#d0e1715">3.7.48. TAU_MAPPING_OBJECT(FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1733">3.7.49. TAU_MAPPING_LINK(FuncIdVar, Key);</a></span></dt><dt><span class="sect2"><a href="#d0e1756">3.7.50. TAU_MAPPING_PROFILE (FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1780">3.7.51. TAU_MAPPING_PROFILE_TIMER(timer, FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1795">3.7.52. TAU_MAPPING_PROFILE_START(timer, tid);</a></span></dt><dt><span class="sect2"><a href="#d0e1807">3.7.53. TAU_MAPPING_PROFILE_STOP(tid);</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1814">3.8. C Measurement API</a></span></dt><dt><span class="sect1"><a href="#d0e1841">3.9. Fortran90 Measurement API</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1849">3.9.1. TAU_PROFILE_INIT()</a></span></dt><dt><span class="sect2"><a href="#d0e1860">3.9.2. TAU_PROFILE_TIMER(profiler, name)</a></span></dt><dt><span class="sect2"><a href="#d0e1881">3.9.3. TAU_PROFILE_START(profiler)</a></span></dt><dt><span class="sect2"><a href="#d0e1896">3.9.4. TAU_PROFILE_STOP(profiler)</a></span></dt><dt><span class="sect2"><a href="#d0e1915">3.9.5. TAU_PROFILE_SET_NODE(myNode)</a></span></dt><dt><span class="sect2"><a href="#d0e1927">3.9.6. TAU_PROFILE_SET_CONTEXT(myContext)</a></span></dt><dt><span class="sect2"><a href="#d0e1939">3.9.7. TAU_PROFILE_REGISTER_THREAD()</a></span></dt><dt><span class="sect2"><a href="#d0e1947">3.9.8. TAU_DISABLE_INSTRUMENTATION()</a></span></dt><dt><span class="sect2"><a href="#d0e1954">3.9.9. TAU_ENABLE_INSTRUMENTATION()</a></span></dt><dt><span class="sect2"><a href="#d0e1965">3.9.10.  TAU_PROFILE_EXIT(message) </a></span></dt><dt><span class="sect2"><a href="#d0e1978">3.9.11. TAU_REGISTER_EVENT(variable, event_name)</a></span></dt><dt><span class="sect2"><a href="#d0e1995">3.9.12. TAU_EVENT(variable, value)</a></span></dt><dt><span class="sect2"><a href="#d0e2008">3.9.13. TAU_REPORT_STATISTICS()</a></span></dt><dt><span class="sect2"><a href="#d0e2015">3.9.14. TAU_REPORT_THREAD_STATISTICS()</a></span></dt><dt><span class="sect2"><a href="#d0e2020">3.9.15. TAU_TRACE_SENDMSG(tag, destination, length)</a></span></dt><dt><span class="sect2"><a href="#d0e2027">3.9.16. TAU_TRACE_RECVMSG(tag, source, length)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SectionSummary">3.10. Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Profiling">4. Profiling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RunningApplication">4.1. Running the application</a></span></dt><dt><span class="sect1"><a href="#RunningDynInstAIP">4.2. Running an application using DynInstAPI</a></span></dt><dt><span class="sect1"><a href="#PerformanceCounters">4.3. Using Hardware Performance Counters</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">4.4. Using Multiple Hardware Counters for Measurement</a></span></dt><dt><span class="sect1"><a href="#RunningJAVA">4.5. Running a JAVA application with TAU</a></span></dt><dt><span class="sect1"><a href="#RunningPython">4.6. Running a Python application with TAU</a></span></dt><dt><span class="sect1"><a href="#pprof">4.7. pprof</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Tracing">5. Tracing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">5.1. Generating Event Traces</a></span></dt><dt><span class="sect1"><a href="#Vampir">5.2. Vampir: Visualizing TAU traces</a></span></dt></dl></dd><dt><span class="chapter"><a href="#PerformanceDatabase">6. Performance Database</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Prerequisites">6.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#Installation">6.2. Installation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3338">6.2.1. Create a database</a></span></dt><dt><span class="sect2"><a href="#d0e3354">6.2.2. Build PerfDB</a></span></dt><dt><span class="sect2"><a href="#d0e3361">6.2.3. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e3370">6.2.4. Loading database schema</a></span></dt><dt><span class="sect2"><a href="#d0e3377">6.2.5. Loading application data</a></span></dt><dt><span class="sect2"><a href="#d0e3388">6.2.6. Loading experiment data</a></span></dt><dt><span class="sect2"><a href="#d0e3406">6.2.7. Translating TAU profiles</a></span></dt><dt><span class="sect2"><a href="#d0e3423">6.2.8. Loading translated trial data</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ChapterSummery">7. Summary</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SoftwareAvalible">7.1. Software Availability</a></span></dt><dt><span class="sect1"><a href="#Credits">7.2. Acknowledgments</a></span></dt></dl></dd><dt><span class="appendix"><a href="#References">A. References</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>5.1. <a href="#d0e3190">Performance Data IO Chart</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>3.1. <a href="#d0e1008">TABLE 1. Fields used in specifying rules in tau_reduce</a></dt><dt>4.1. <a href="#d0e2173">TABLE 2. Events measured by setting the enviroment variable PCL_EVENT in TAU</a></dt><dt>4.2. <a href="#d0e2498">TABLE 3.  Events measured by setting the environment variable PAPI_EVENT in TAU</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tau.installation"></a>Chapter&nbsp;1.&nbsp;Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#installing.tau">1.1. Installing TAU</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e47">1.1.1. Available configuration options</a></span></dt><dt><span class="sect2"><a href="#d0e333">1.1.2. installtau script</a></span></dt><dt><span class="sect2"><a href="#d0e342">1.1.3. Examples: </a></span></dt></dl></dd><dt><span class="sect1"><a href="#platforms.supported">1.2. Platforms Supported</a></span></dt><dt><span class="sect1"><a href="#software.requirements">1.3. Software Requirements</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p> TAU (Tuning and Analysis Utilities) is a portable profiling and 
      tracing toolkit for performance analysis of parallel programs written 
      in Java, C++, C, and Fortran.  The model that TAU uses to profile 
      parallel, multi-threaded programs maintains performance data for each 
      thread, context, and node in use by an application. The profiling 
      instrumentation needed to implement the model captures data for 
      functions, methods, basic blocks, and statement execution at these 
      levels. All C++ language features are supported in the TAU profiling 
      instrumentation including templates and namespaces, which is available 
      through an API at the library or application level. The API also 
      provides selection of profiling groups for organizing and controlling 
      instrumentation. The instrumentation can be inserted in the source code 
      using an automatic instrumentor tool based on the Program Database 
      Toolkit (PDT), dynamically using DyninstAPI, at runtime in the Java 
      virtual machine, or manually using the instrumentation API.  TAU's 
      profile visualization tool, paraprof, provides graphical displays of 
      all the performance analysis results, in aggregate and single 
      node/context/thread forms.  The user can quickly identify sources of 
      performance bottlenecks in the application using the graphical 
      interface. In addition, TAU can generate event traces that can be 
      displayed with the Vampir or Paraver trace visualization tools.  
      This chapter discusses installation of the TAU portable profiling 
      package.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installing.tau"></a>1.1.&nbsp;Installing TAU</h2></div></div></div><p> After uncompressing and untarring TAU, the user needs to configure, 
    compile and install the package. This is done by invoking: </p><pre class="screen">
% ./configure
% make install
</pre><p>TAU is configured by running the configure script with appropriate 
    options that select the profiling and tracing components that are used to 
    build the TAU library.  The `configure' shell script attempts to guess 
    correct values for various system-dependent variables used during 
    compilation, and creates the Makefile(s) (one in each subdirectory of the 
    source directory).</p><p>The following command-line options are available to configure:</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e47"></a>1.1.1.&nbsp;Available configuration options</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><code class="literal">-prefix=&lt;directory&gt;</code><p>Specifies the destination directory where the header, library and 
        binary files are copied. By default, these are copied to subdirectories 
        &lt;arch&gt;/bin and &lt;arch&gt;/lib in the TAU root directory.</p></li><li><code class="literal">-arch=&lt;architecture&gt;</code><p>Specifies the architecture. If the user does not 
        specify this option, configure determines the architecture. 
        For SGI, the user can specify either of sgi32, sgin32 or 
        sgi64 for 32, n32 or 64 bit compilation modes respectively. 
        The files are installed in the &lt;architecture&gt;/bin and 
        &lt;architecture&gt;/lib directories.</p></li><li><code class="literal">-c++=&lt;C++ compiler&gt;</code><p>Specifies the name of the C++ compiler. Supported C++ 
        compilers include KCC (from KAI/Intel), CC (SGI, Sun), g++ 
        (from GNU), FCC (from Fujitsu), xlC (from IBM), guidec++ 
        (from KAI/Intel), cxx (Tru64) and aCC (from HP), c++ (from Apple), 
        icpc and ecpc (from Intel) and pgCC (from PGI).</p></li><li><code class="literal">-cc=&lt;C Compiler&gt;</code><p> Specifies the name of the C compiler. Supported C 
        compilers include cc, gcc (from GNU), pgcc (from PGI), 
        fcc (from Fujitsu), xlc (from IBM), and KCC (from KAI/ Intel), 
        icc and ecc (from Intel).</p></li><li><code class="literal">-pdt_c++=&lt;C++ Compiler&gt;</code><p>Specifies a different C++ compiler for PDT (tau_instrumentor). 
        This is typically used when the library is compiled with a C++ 
        compiler (specified with -c++) and the tau_instrumentor is compiled 
        with a different &lt;pdt_c++&gt; compiler. For e.g., </p><pre class="screen">
-c++=pgCC -cc=pgcc -pdt_c++=KCC -openmp ...
</pre><p>uses PGI's OpenMP compilers for TAU's library and KCC for 
        tau_instrumentor.</p></li><li><code class="literal">-fortran=&lt;Fortran Compiler&gt;</code><p>Specifies the name of the Fortran90 compiler. Valid options are: 
        gnu, sgi, ibm, ibm64, hp, cray, pgi, absoft, fujitsu, sun, kai, nec, 
        hitachi, compaq, and intel.</p></li><li><code class="literal">-tag=&lt;Unique Name&gt;</code><p>Specifies a tag in the name of the stub Makefile and TAU makefiles to uniquely identify the installation. This is useful when more than one MPI library may be used with different versions of compilers. e.g.,</p><pre class="screen"> 
	% configure -c++=icpc -cc=icc -tag=intel71-vmi -mpiinc=/vmi2/mpich/include
	</pre></li><li><code class="literal">-pthread</code><p>Specifies pthread as the thread package to be used. In the 
        default mode, no thread package is used.</p></li><li><code class="literal">-charm=&lt;directory&gt;</code><p>Specifies charm++ (converse) threads as the thread package to be used.</p></li><li><code class="literal">-tulipthread=&lt;directory&gt; -smarts</code><p>Specifies SMARTS (Shared Memory Asynchronous Runtime System) 
        as the threads package to be used. &lt;directory&gt; gives the 
        location of the SMARTS root directory. [SMARTS-URL]</p></li><li><code class="literal">-openmp</code><p>Specifies OpenMP as the threads package to be used.
        [OPENMP-URL]</p></li><li><code class="literal">-opari=&lt;dir&gt;</code><p>Specifies the location of the Opari OpenMP directive rewriting 
        tool.  The use of Opari source-to-source instrumentor in conjunction 
        with TAU exposes OpenMP events for instrumentation. See 
        examples/opari directory.  [OPARI-URL]   Note: There are two versions 
        of Opari: standalone - (opari-pomp-1.1.tar.gz) and the newer KOJAK - 
        kojak-&lt;ver&gt;.tar.gz opari/ directory. Please upgrade to the 
        KOJAK version (especially if you're using IBM xlf90) and specify 
        -opari=&lt;kojak-dir&gt;/opari while configuring TAU.</p></li><li><code class="literal">-opari_region</code><p>Report performance data for only OpenMP regions and not 
        constructs.  By default, both regions and constructs are profiled 
        with Opari.</p></li><li><code class="literal">-opari_construct</code><p>Report performance data for only OpenMP constructs and not 
        Regions.  By default, both regions and constructs are profiled with 
        Opari.</p></li><li><code class="literal">-pdt=&lt;directory&gt;</code><p>Specifies the location of the installed PDT (Program Database 
        Toolkit) root direc- tory. PDT is used to build tau_instrumentor, 
        a C++, C and F90 instrumentation program that automatically inserts 
        TAU annotations in the source code [PDT-URL].  If PDT is configured 
        with a subdirectory option (-compdir=&lt;opt&gt;) then TAU can be 
        configured with the same option by specifying </p><pre class="screen">
-pdt=&lt;dir&gt; -pdtcompdir=&lt;opt&gt;. 
</pre></li><li><code class="literal">-pcl=&lt;directory&gt;</code><p>Specifies the location of the installed PCL (Performance 
        Counter Library) root directory. PCL provides a common interface 
        to access hardware performance counters on modern microprocessors. 
        The library supports Sun UltraSparc I/II, PowerPC 604e under AIX, 
        MIPS R10000/12000 under IRIX, Compaq Alpha 21164, 21264 under 
        Tru64Unix and Cray Unicos (T3E) and the Intel Pentium family of 
        microprocessors under Linux. This option specifies the use of 
        hardware performance counters for profiling (instead of time). 
        To measure floating point instructions, set the environment 
        variable PCL_EVENT to PCL_FP_INSTR (for example). See the section 
        "Using Hardware Performance Counters" in Chapter 4 for details 
        regarding its usage. [PCL-URL]</p></li><li><code class="literal">-papi=&lt;directory&gt;</code><p>Specifies the location of the installed PAPI (Performance 
        Data Standard and API) root directory. PCL provides a common 
        interface to access hardware performance counters and timers on 
        modern microprocessors. Most modern CPUs provide on-chip hardware 
        performance counters that can record several events such as the 
        number of instructions issued, floating point operations performed, 
        the number of primary and secondary data and instruction cache misses, 
        etc. To measure floating point instructions, set the environment 
        variable PAPI_EVENT to PAPI_FP_INS (for example). This option (by 
        default) specifies the use of hardware performance counters for 
        profiling (instead of time). When used in conjunction with 
        -PAPIWALLCLOCK or -PAPIVIRTUAL, it specifies the use of wallclock 
        or virtual process timers respectively. See the section "Using 
        Hardware Performance Counters" in Chapter 4 for details regarding 
        its usage. [PAPI-URL]</p></li><li><code class="literal">-PAPIWALLCLOCK</code><p>When used in conjunction with the -papi=&lt;dir&gt; option, 
        this option allows TAU to use high resolution, low overhead CPU 
        timers for wallclock time based measure- ments. This can reduce 
        the TAU overhead for accessing wallclock time for profile and 
        trace measurements. (See NOTE below.)</p></li><li><code class="literal">-PAPIVIRTUAL</code><p>When used in conjunction with the -papi=&lt;dir&gt; option, 
        this option allows TAU to use the process virtual time (time spent 
        in the "user" mode) for profile measure- ments, instead of the 
        default wallclock time. (See NOTE below.)</p></li><li><code class="literal">-CPUTIME</code><p>Specifies the use of user+ system time (collectively CPU time) 
        for profile measurements, instead of the default wallclock time. This 
        may be used with multi-threaded programs only under the LINUX 
        operating system which provides bound threads.  On other platforms, 
        this option may be used for profiling single-threaded programs 
        only.</p></li><li><code class="literal">-MULTIPLECOUNTERS</code><p>Allows TAU to track more than one quantity (multiple hardware 
        counters, CPU- time, wallclock time, etc.) Configure with other 
        options such as -papi=&lt;dir&gt;,   - pcl=&lt;dir&gt;, -LINUXTIMERS, 
        -SGITIMERS, -CPUTIME, -PAPIVIRTUAL, etc.  See Section "Using Multiple 
        Hardware Counters" in Chapter 4 for detailed instruc- tions on setting 
        the environment variables COUNTER&lt;1-25&gt; for this option. If - 
        MULTIPLECOUNTERS is used with the -TRACE option, tracing employs 
        the COUNTER1 environment variable for wallclock time.</p><p>NOTE: The default measurement option in TAU is to use the 
        wallclock time, which is the total time a program takes to execute, 
        including the time when it is waiting for resources. It is the time 
        measured from a real-time clock. The process virtual time 
        (-PAPIVIRTUAL) is the time spent when the process is actually running. 
        It does not include the time spent when the process is swapped out 
        waiting for CPU or other resources and it does not include the time 
        spent on behalf of the operating system (for executing a system call, 
        for instance). It is the time spent in the "user" mode. The CPUTIME 
        on the other hand, includes both the time the process is running 
        (process virtual time) and the time the system is providing services 
        for it (such as executing a system call). It is the sum of the 
        process virtual (user) time and the system time (See man 
        getrusage()).</p></li><li><code class="literal">-jdk=&lt;directory&gt;</code><p>Specifies the location of the installed Java 2 Development 
        Kit (JDK1.2+) root directory. TAU can profile or trace Java 
        applications without any modifications to the source code, byte-code 
        or the Java virtual machine. See README.JAVA on instructions on 
        using TAU with Java 2 applications. This option should only be used 
        for configuring TAU to use JVMPI for profiling and tracing of Java 
        applica- tions. It should not be used for configuring paraprof, 
        which uses java from the user's path.</p></li><li><code class="literal">-dyninst=&lt;dir&gt;</code><p>Specifies the directory where the DynInst dynamic 
        instrumentation package is installed. Using DynInst, a user can 
        invoke tau_run to instrument an executable program at runtime or 
        prior to execution by rewriting it. 
        [DYNINST-URL][PARA- DYN-URL].</p></li><li><code class="literal">-vtf=&lt;directory&gt;</code><p>
   Specifies the location of the VTF3 trace generation package. TAU's binary
   traces can be converted to the VTF3 format using tau2vtf, a tool that links
   with the VTF3 library. The VTF3 format is read by Intel trace analyzer, 
   formerly known as vampir, a commercial trace visualization tool developed
   by TU. Dresden, Germany.
        </p></li><li><code class="literal">-slog2=&lt;directory&gt;</code><p>
   Specifies the location of the SLOG2 SDK trace generation package. TAU's
   binary traces can be converted to the SLOG2 format using tau2slog2, a tool
   that uses the SLOG2 SDK. The SLOG2 format is read by the Jumpshot4 trace
   visualization software, a freely available trace visualizer from Argonne National Laboratories.
   [Ref: http://www-unix.mcs.anl.gov/perfvis/download/index.htm#slog2sdk]
        </p></li><li><code class="literal">-slog2</code><p>
   Specifies the use of the SLOG2 trace generation package and the Jumpshot 
   trace visualizer that is bundled with TAU. Jumpshot v4 and SLOG2 v1.2.5delta
   are included in the TAU distribution. When the -slog2 flag is specified,
   tau2slog2 and jumpshot tools are copied to the &lt;tau&gt;/&lt;arch&gt;/&lt;bin&gt; directory.
   It is important to have a working javac and java (preferably v1.4+) in your
   path. On linux systems, where /usr/bin/java may be a place holder, you'll
   need to modify your path accordingly.
        </p></li><li><code class="literal">-mpiinc=&lt;dir&gt;</code><p>Specifies the directory where MPI header files reside (such as 
        mpi.h and mpif.h).  This option also generates the TAU MPI wrapper 
        library that instruments MPI rou- tines using the MPI Profiling 
        Interface. See the examples/NPB2.3/config/make.def file for its 
        usage with Fortran and MPI programs. [MPI-URL]</p></li><li><code class="literal">-mpilib=&lt;dir&gt;</code><p>Specifies the directory where MPI library files reside. This 
      option should be used in conjunction with the -mpiinc=&lt;dir&gt; 
      option to generate the TAU MPI wrapper library. </p></li><li><code class="literal">-mpilibrary=&lt;lib&gt;</code><p>Specifies the use of a different MPI library. By default, TAU uses
      -lmpi or -lmpich as the MPI library. This option allows the user to 
      specify another library. e.g., - mpilibrary=-lmpi_r for specifying a 
      thread-safe MPI library.</p></li><li><code class="literal">-shmeminc=&lt;dir&gt;</code><p>Specifies the directory where shmem.h resides. Specifies the use of the TAU SHMEM interface.</p></li><li><code class="literal">-shmemlib=&lt;dir&gt;</code><p>Specifies the directory where libsma.a resides. Specifies the use of the TAU SHMEM interface.</p></li><li><code class="literal">-shmemlibrary=&lt;lib&gt;</code><p>By default, TAU uses -lsma as the shmem/pshmem library. This option allows the user to specify a different shmem library.</p></li><li><code class="literal">-nocomm</code><p>Allows the user to turn off tracking of messages 
      (synchronous/asynchronous) in TAU's MPI wrapper interposition 
      library. Entry and exit events for MPI routines are still tracked. 
      Affects both profiling and tracing.</p></li><li><code class="literal">-epilog=&lt;dir&gt;</code><p>Specifies the directory where the EPILOG tracing package 
      [EPILOG-URL] is installed.This option should be used in conjunction with 
      the -TRACE option to gen- erate binary EPILOG traces (instead of 
      binary TAU traces). EPILOG traces can then be used with other tools 
      such as EXPERT. EPILOG comes with its own imple- mentation of the 
      MPI wrapper library and the POMP library used with Opari. Using option 
      overrides TAU's libraries for MPI, and OpenMP.</p></li><li><code class="literal">-MPITRACE</code><p>Specifies the tracing option and generates event traces for MPI calls and routines that are ancestors of MPI calls in the callstack. This option is useful for generating traces that are converted to the EPILOG trace format.  KOJAK's Expert automatic diagnosis tool needs traces with events that call MPI routines. Do not use this option with the -TRACE option. </p></li><li><code class="literal">-pythoninc=&lt;dir&gt;</code><p>Specifies the location of the Python include directory. This is 
      the directory   where Python.h header file is located. This option 
      enables python bindings to be gener- ated. The user should set the 
      environment variable PYTHONPATH to 
      &lt;TAUROOT&gt;/&lt;ARCH&gt;/lib/bindings-&lt;options&gt; to use a 
      specific version of the TAU Python bindings. By importing package pytau, 
      a user can manually instrument the source code and use the TAU API. On 
      the other hand, by importing tau and using tau.run(`&lt;func&gt;'), 
      TAU can automatically generate instrumentation. See examples/python 
      directory for further information.</p></li><li><code class="literal">-pythonlib=&lt;dir&gt;</code><p>Specifies the location of the Python lib directory. This is the 
      directory where *.py and *.pyc files (and config directory) are located. 
      This option is mandatory for IBM when Python bindings are used. For other
      systems, this option may not be specified (but -pythoninc=&lt;dir&gt; 
      needs to be specified).</p></li><li><code class="literal">-PROFILE</code><p>This is the default option; it specifies summary profile files to 
      be generated at the end of execution. Profiling generates aggregate 
      statistics (such as the total time spent in routines and statements), 
      and can be used in conjunction with the profile browser racy to analyze 
      the performance. Wallclock time is used for profiling program 
      entities.</p></li><li><code class="literal">-PROFILECALLPATH</code><p>This option generates call path profiles which shows the time 
      spent in a routine when it is called by another routine in the calling 
      path. "a =&gt; b" stands for the time spent in routine "b" when it is 
      invoked by routine "a". This option is an extension of -PROFILE, the 
      default profiling option.  Specifying TAU_CALLPATH_DEPTH environment 
      variable, the user can vary the depth of the callpath. See 
      examples/calltree for further information.</p></li><li><code class="literal">-PROFILEPHASE</code><p>This option generates phase based profiles. It requires special instrumentation
   to mark phases in an application (I/O, computation, etc.). Phases can be 
   static or dynamic (different phases for each loop iteration, for instance).
   See examples/phase/README for further information. 
      </p></li><li><code class="literal">-PROFILESTATS</code><p>Specifies the calculation of additional statistics, such as the 
      standard deviation of the exclusive time/counts spent in each profiled 
      block. This option is an extension of -PROFILE, the default profiling 
      option.</p></li><li><code class="literal">-DEPTHLIMIT</code><p>Allows users to enable instrumentation at runtime based on the depth of a 
   calling routine on a callstack. The depth is specified using the environment 
   variable TAU_DEPTH_LIMIT. When its value is 1, instrumentation in the top-level
   routine such as main (in C/C++) or program (in F90) is activated. When it is 2,
   only routine invoked directly by main and main are recorded. When a routine appears
   at a depth of 2 and at 10 and we set the limit at 5, then the routine is recorded
   when its depth is 2, and ignored when its depth is 10 on the calling stack. This can
   be used with -PROFILECALLPATH to generate a tree of height &lt;h&gt; from the main routine
   by setting TAU_CALLPATH_DEPTH and TAU_DEPTH_LIMIT variables to &lt;h&gt;. 
      </p></li><li><code class="literal">-PROFILEMEMORY</code><p>
Specifies tracking heap memory utilitization for each instrumented function.
   When any function entry takes place, a sample of the heap memory used is 
   taken. This data is stored as user-defined event data in profiles/traces.
      </p></li><li><code class="literal">-PROFILEHEADROOM</code><p>
Specifies tracking memory available in the heap (as opposed to memory 
   utilization tracking in -PROFILEMEMORY). When any function entry takes place,
   a sample of the memory available (headroom to grow) is taken. This data is 
   stored as user-defined event data in profiles/traces. Please refer to the
   examples/headroom/README file for a full explanation of these headroom
   options and the C++/C/F90 API for evaluating the headroom. 
      </p></li><li><code class="literal">-COMPENSATE</code><p>
Specifies online compensation of performance perturbation. When this 
   option is used, TAU computes its overhead and subtracts it from the 
   profiles. It can be only used when profiling is chosen. This option works
   with MULTIPLECOUNTERS as well, but while it is relevant for removing 
   perturbation with wallclock time, it cannot accurately account for 
   perturbation with hardware performance counts (e.g., L1 Data cache misses).
   See TAU Publication [Europar04] for further information on this option. 
      </p></li><li><code class="literal">-PROFILECOUNTERS</code><p>Specifies use of hardware performance counters for profiling 
      under IRIX using the SGI R10000 perfex counter access interface. The 
      use of this option is deprecated in favor of the -pcl=&lt;dir&gt; 
      and -papi=&lt;dir&gt; options described above. </p></li><li><code class="literal">-SGITIMERS</code><p>Specifies use of the free running nanosecond resolution on-chip 
      timer on the R10000+. This timer has a lower overhead than the default 
      timer on SGI, and is rec- ommended for SGIs (similar to the 
      -papi=&lt;dir&gt; -PAPIWALLCLOCK options).</p></li><li><code class="literal">-CRAYTIMERS</code><p>Specifies use of the free running nanosecond resolution on-chip 
      timer on the CRAY X1 cpu (accessed by the rtc() syscall). This timer 
      has a significantly lower overhead than the default timer on the X1, 
      and is recommended for profiling. Since this timer is not synchronized 
      across different cpus, this option should not be used with the - TRACE 
      option for tracing a multi-cpu application, where a globally 
      synchronized realtime clock is required.</p></li><li><code class="literal">-LINUXTIMERS</code><p>Specifies the use of the free running nanosecond resolution time 
      stamp counter (TSC) on Pentium III+ and Itanium family of processors 
      under Linux. This timer has a lower overhead than the default time and 
      is recommended.</p></li><li><code class="literal">-TRACE</code><p>Generates event-trace logs, rather than summary profiles. Traces 
      show when and where an event occurred, in terms of the location in the 
      source code and the process that executed it. Traces can be merged and 
      converted using tau_merge and tau_convert utilities respectively, and 
      visualized using Vampir, a commercial trace visualization tool. 
      [VAMPIR-URL]</p></li><li><code class="literal">-muse</code><p>Specifies the use of MAGNET/MUSE to extract low-level information 
      from the kernel. To use this configuration, Linux kernel has to be 
      patched with MAGNET and MUSE has to be install on the executing machine.  
      Also, magnetd has to be running with the appropriate handlers and filters
      installed. User can specify pack- age by setting the environment 
      variable TAU_MUSE_PACKAGE.  [MUSE-URL]</p></li><li><code class="literal">-noex</code><p>Specifies that no exceptions be used while compiling the library. 
      This is relevant for C++. </p></li><li><code class="literal">-useropt=&lt;options-list&gt;</code><p>Specifies additional user options such as -g or -I. For multiple 
      options, the options list should be enclosed in a single quote. For 
      example </p><pre class="screen">
%./configure -useropt='-g -I/usr/local/stl'
</pre></li><li><code class="literal">-help</code><p>Lists all the available configure options and quits.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e333"></a>1.1.2.&nbsp;installtau script</h3></div></div></div><p>To install multiple (typical) configurations of TAU at a site, you 
    may use the script `installtau'. It takes options similar to those 
    described above. It invokes ./configure &lt;opts&gt;; make clean install;  
    to create multiple libraries that may be requested by the users at a 
    site. The installtau script accepts the following options: </p><pre class="screen">
% installtau -help

TAU Configuration Utility 
***************************************************
Usage: installtau [OPTIONS]
  where [OPTIONS] are:
-arch=&lt;arch&gt;  
-fortran=&lt;compiler&gt;  
-cc=&lt;compiler&gt;
-c++=&lt;compiler&gt;
-useropt=&lt;options&gt;  
-pdt=&lt;pdtdir&gt;
-papi=&lt;papidir&gt;  
-mpiinc=&lt;mpiincdir&gt;  
-mpilib=&lt;mpilibdir&gt;
-mpilibrary=&lt;mpilibrary&gt;
-opari=&lt;oparidir&gt;   
******************************************************************
</pre><p>These options are similar to the options used by the configure script.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e342"></a>1.1.3.&nbsp;Examples: </h3></div></div></div><p>(See Appendix for POOMA and Windows installation instructions)</p><div class="itemizedlist"><ul type="disc"><li><p>a) Install TAU using KCC on SGI, with trace and profile 
        options:</p><pre class="screen">
%./configure -c++=KCC -SGITIMERS -arch=sgi64 -TRACE \
  -PROFILE -prefix=/usr/local/packages/tau
</pre></li><li><p>b) Installing TAU with Java</p><pre class="screen">
%./configure -c++=g++ -jdk=/usr/local/packages/jdk1.4
% make install
% set path=($path &lt;taudir&gt;/&lt;tauarch&gt;/bin)
% setenv LD_LIBRARY_PATH \ 
  $LD_LIBRARY_PATH:&lt;taudir&gt;/&lt;tauarch&gt;/lib
% cd examples/java/pi
% java -XrunTAU Pi 200000
% racy
</pre></li><li><p>c) Use TAU with KCC, and cc on 64 bit SGI systems and use MPI 
      wrapper libraries with SGI's low cost timers and use PDT for automated 
      source code instrumenta- tion. Enable both profiling and tracing.</p><pre class="screen">
% ./configure -c++=KCC -cc=cc -arch=sgi64 \
  -mpiinc=/local/apps/mpich/include \
  -mpilib=/local/apps/mpich/ lib/IRIX64/ch_p4 \
  -SGITIMERS -pdt=/local/apps/pdt
</pre></li><li><p>d) Use OpenMP+MPI using KAI's Guide compiler suite, Opari for 
      OpenMP instrumentation and use PAPI for accessing hardware performance 
      counters for profile based measurements.</p><pre class="screen">
% ./configure -c++=guidec++ -cc=guidec \
  -papi=/usr/ local/packages/papi -openmp \
  -mpiinc=/usr/pack- ages/mpich/include \
  -mpilib=/usr/packages/mpich/lib \
  -opari=/usr/local/opari
</pre></li><li><p>e) Use CPUTIME measurements for a multi-threaded application 
      using pthreads under LINUX.</p><pre class="screen">
% configure -pthread -CPUTIME
</pre></li><li><p>f) Use multiple hardware performance counters</p><pre class="screen">
% configure -MULTIPLECOUNTERS -papi=/usr/local/papi \
  -PAPIWALLCLOCK -PAPIVIRTUAL -LINUXTIMERS \
  -mpiinc=/usr/local/mpich/include \
  -mpilib=/usr/local/mpich/ lib/ \
  -pdt=/usr/local/pdtoolkit -useropt=-O2
% setenv COUNTER1 LINUX_TIMERS
% setenv COUNTER2 PAPI_FP_INS
% setenv COUNTER3 PAPI_L1_DCM ...
</pre></li></ul></div><p>NOTE: Also see Section "Application Scenarios" in Chapter 2 
    (Compiling) for an explanation of simple examples that are included 
    with the TAU distribution.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="platforms.supported"></a>1.2.&nbsp;Platforms Supported</h2></div></div></div><p>TAU has been tested on the following platforms:</p><div class="itemizedlist"><ul type="disc"><li><p>1. SGI</p><p>On IRIX 6.x based systems, including Indy, Power Challenge, 
        Onyx, Onyx2 and Origin 200, 2000, 3000 Series, CC 7.2+, KAI 
        [KAI-URL] KCC and g++/egcs [GNU-URL] compilers are supported.</p></li><li><p>2. LINUX Clusters</p><p>On Linux based Intel x86 PC clusters, KAI/Intel's KCC, g++, 
        egcs (GNU), pgCC (PGI) [PGI-URL], FCC (Fujitsu) [FUJITSU-URL] 
        and icpc/ecpc Intel compilers have been tested. TAU also runs 
        under IA-64, Opteron, PowerPC, Alpha, Apple PowerMac, Sparc and 
        other processors running Linux. </p></li><li><p>3. Sun Solaris</p><p>Sun Workshop Pro 5.0 compilers (CC, F90), KAI KCC, KAP/Pro 
        and GNU g++ work with TAU.</p></li><li><p>4. IBM AIX</p><p>On IBM SP2 and AIX systems, KAI KCC, KAP/Pro, IBM xlC, xlc, 
        xlf90 and g++ compilers work with TAU.</p></li><li><p>5. HP HP-UX</p><p>On HP PA-RISC systems, aCC and g++ can be used.</p></li><li><p>6.  HP Alpha Tru64</p><p>On HP Alpha Tru64 machines, cxx and g++, and Guide compilers 
        may be used with TAU.</p></li><li><p>7.  NEC SX series vector machines</p><p>On NEC SX-5 systems, NEC c++ may be used with TAU.</p></li><li><p>8.  Cray X1, T3E, SV-</p><p>On Cray T3E systems, KAI KCC and Cray CC compilers have been 
        tested with TAU. On Cray SV-1 and X1 systems, Cray CC compilers 
        have been tested with TAU.</p></li><li><p>9.  Hitachi SR8000 vector machine</p><p>On Hitachi machines, Hitachi KCC, g++ and Hitachi cc compilers 
        may be used with TAU</p></li><li><p>10.  Apple OS X</p><p>On Apple OS X machines, c++ or g++ may be used to compile TAU. 
        Also, IBM's xlf90, xlf compilers for G4/G5 may be used with TAU.</p></li><li><p>11.  Microsoft Window</p><p>On Windows, Microsoft Visual C++ 6.0 or higher and JDK 1.2+ 
        compilers have been tested with TAU</p></li></ul></div><p>NOTE: TAU has been tested with JDK 1.2, 1.3, 1.4.x under Solaris, SGI, IBM, 
    Linux, and MacOS X.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="software.requirements"></a>1.3.&nbsp;Software Requirements</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>1. Java v 1.3</p><p>TAU's GUI paraprof requires Java v1.3 or better in your path. 
        We recommend Java version 1.4x from Sun. An older Tcl/Tk based browser 
        racy is also included with TAU for compatibility. It requires the 
        executable wish to be in your path. racy is also available in this 
        distribution but support for racy will be gradually phased out.  
        Users are encouraged to use paraprof instead. Paraprof does *not* 
        require - jdk=&lt;dir&gt; option to be specified (which is used 
        for configuring TAU for analyzing Java applications). The java 
        program should be in the user's path.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tau.compiling"></a>Chapter&nbsp;2.&nbsp;Compiling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TAUMakefile.tau">2.1. TAU Stub Makefile</a></span></dt><dt><span class="sect1"><a href="#EnablingDisablingInstrumentation">2.2. Enabling and Disabling the Instrumentation</a></span></dt><dt><span class="sect1"><a href="#UsingWithMPI">2.3. Using TAU with MPI</a></span></dt><dt><span class="sect1"><a href="#EnvironmentVariables">2.4. Environment Variables</a></span></dt><dt><span class="sect1"><a href="#ApplicationScenarios">2.5. Application Scenarios</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p> Source-based instrumentation with TAU measurement code requires compilation. At compile time, the TAU system provides several options and configuration alternatives. This chapter explains compilation options to enable profiling or tracing. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TAUMakefile.tau"></a>2.1.&nbsp;TAU Stub Makefile</h2></div></div></div><p>TAU configuration generates a Makefile stub as well as a library. The Makefile name has the form</p><pre class="screen">
Makefile.tau-&lt;options&gt;.
</pre><p>the library name the form</p><pre class="screen">
libtau-&lt;options&gt;.a.
</pre><p>For example,</p><pre class="screen">
%./configure -TRACE -c++=KCC -arc=sgin32
</pre><p>generates</p><pre class="screen">
Makefile.tau-trace-kcc libtau-trace-kcc.a
in tau-2.x/sgin32/lib
</pre><div class="itemizedlist"><p>Using different configuration options, several modular libraries can be built and   co-exist even in the same architecture. To choose a particular version of the library, the corresponding Makefile stub must be included in the application Makefile. The stub Makefile defines the following variables: </p><ul type="disc"><li><code class="literal">TAU_CXX</code> 
    for the C++ compiler
    </li><li><code class="literal">TAU_CC</code> 
    for the C compiler
    </li><li><code class="literal">TAU_F90</code> 
    for the F90 compiler
    </li><li><code class="literal">TAU_LINKER</code> 
    for the Linker
    </li><li><code class="literal">TAU_INCLUDE</code> 
    for the include directories 
    </li><li><code class="literal">TAU_DEFS</code> 
    for the defines on the command-line 
    </li><li><code class="literal">TAU_LIBS</code> 
     for the TAU static library 
    </li><li><code class="literal">TAU_SHLIBS</code> 
    for the TAU shared object (dynamic library) 
    </li><li><code class="literal">TAU_MPI_INCLUDE</code> 
    for the directory where MPI header files reside 
    </li><li><code class="literal">TAU_MPI_LIBS</code> 
    for the TAU MPI library with the MPI libraries for C/C++ 
    </li><li><code class="literal">TAU_MPI_FLIBS</code> 
     for the TAU MPI library with MPI libraries for Fortran
    </li><li><code class="literal">TAU_FORTRANLIBS</code> 
      for additional fortran libraries for linking with C++
    </li><li><code class="literal">TAU_CXXLIBS</code> 
      for linking with C++ libraries when native f90 linker is used
    </li><li><code class="literal">TAU_TRACE_INPUT_LIB</code> 
     for linking with the TAU trace reader library to process binary TAU traces (typically used for making a trace converter) 
    </li><li><code class="literal">TAU_DISABLE</code> 
     for the default TAU stub library for Fortran
    </li><li><code class="literal">TAU_USER_OPT</code> 
    for any user defined options specified during configuration 
    </li></ul></div><p>In addition to these options, the stub makefile also contains information about other packages configured with TAU. The stub makefile defines the following variables:</p><div class="itemizedlist"><ul type="disc"><li><code class="literal">PDTDIR</code> 
      for the location of the PDT root directory
      </li><li><code class="literal">OPARIDIR</code> 
      for the location of the Opari root directory
      </li><li><code class="literal">TULIPDIR</code> 
      for the location of the Tulip root directory
      </li><li><code class="literal">PCLDIR</code> 
      for the location of the PCL root directory
      </li><li><code class="literal">PAPIDIR</code> 
      for the location of the PAPI root directory
      </li><li><code class="literal">EPILOGER</code> 
      for the location of the EPILOG root directory
      </li><li><code class="literal">JDKDIR</code> 
      for the location of the JDK root directory
      </li><li><code class="literal">DYNINSTDIR</code> 
      for the location of the DyninstAPI root directory
      </li></ul></div><p>It should be noted that the TAU library is written in C++. It may be linked with a Fortran or a C object file in two ways. Either the TAU_LINKER (typically C++ compiler) may be used or the native linker (C, F90 compiler) may be used. For Fortran programs that use the C++ linker, the TAU_FORTRANLIBS macro contains additional Fortran libraries that need to be linked in to create the executable. If the F90 linker is used, TAU_CXXLIBS should be added to the link line which links in the necessary C++ libraries.</p><p>A typical makefile that uses these Makefile variables is shown below:</p><code class="literal">TAUROOTDIR</code>  = /usr/local/packages/tau-2.x

    <pre class="screen">
include $(TAUROOTDIR)/sgin32/lib/Makefile.tau-trace-kcc
CXX             = $(TAU_CXX)
CC              = $(TAU_CC)
CFLAGS          = $(TAU_INCLUDE) $(TAU_DEFS)
LIBS            = $(TAU_LIBS) -lm
LDFLAGS         = $(USER_OPT)

RM              = /bin/rm -f
TARGET          = matrix
##############################################
all:            $(TARGET)
install:        $(TARGET)				     
$(TARGET):      $(TARGET).o
      $(CXX) $(LDFLAGS) $(TARGET).o -o $@ $(LIBS)
$(TARGET).o : $(TARGET).cpp
      $(CXX) $(CFLAGS) -c $(TARGET).cpp
clean:
        $(RM) $(TARGET).o $(TARGET)
##############################################
</pre><p>To use a different configuration, simply change the included makefile to some other. For example, for</p><pre class="screen">
% ./configure -pthread -arch=sgi64 
</pre><p>subsitute</p><pre class="screen">
include $(TAUROOTDIR)/sgi64/lib/Makefile.tau-pthread
</pre><p>in the makefile above. Also,</p><pre class="screen">
$(TAUROOTDIR)/include/Makefile
</pre><p>points to the most recently configured version of the library.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="EnablingDisablingInstrumentation"></a>2.2.&nbsp;Enabling and Disabling the Instrumentation</h2></div></div></div><p>Using the TAU stub makefile variable  <code class="literal">TAU_DEFS</code> 
while compiling C++ and C source code enables profiling (or tracing)
instrumentation and generates the performance data files. To disable the
instrumentation,  <code class="literal">TAU_DEFS</code>  should not be used. In its absence, all the
TAU profiling macros defined in the source code for instrumentation
purposes are automatically defined to null (the default behavior). Thus,
the instrumentation can be retained in the source code, since it has no
overhead when it is disabled.  For Fortran however, the instrumentation
can be disabled in the program by using the TAU stub makefile variable
 <code class="literal">TAU_DISABLE</code>  on the link command line. This points to a library that
contains empty TAU instrumentation routines.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UsingWithMPI"></a>2.3.&nbsp;Using TAU with MPI</h2></div></div></div><p>TAU MPI wrapper library (libTauMpi.a) uses the MPI Profiling Interface for instrumentation. To use the library,</p><div class="orderedlist"><ol type="1"><li>Configure TAU with -mpiinc=&lt;dir&gt; and -mpilib=&lt;dir&gt;
        command-line options that specify the location of MPI header files and 
        the directory where MPI libraries reside. Example:

        <pre class="screen">
% ./configure -mpiinc=/usr/local/packages/mpich/include \
     -mpilib=/usr/local/packages/mpich/lib/LINUX/ch_p4 \
     -c++=KCC -cc=cc 
</pre></li><li>Include the TAU stub Makefile generated in the
        application makefile.
        <pre class="screen">
TAUROOTDIR=/usr/local/packages/tau2
include $(TAUROOTDIR)/i386_linux/Makefile.tau-kcc 
</pre></li><li>Use the Makefile variables <pre class="screen">$(TAU_MPI_LIBS)</pre> for C/C++
        applications and <pre class="screen">$(TAU_MPI_FLIBS)</pre> for Fortran 90 applications, to 
        specify the TAU MPI libraries before the <pre class="screen">$(TAU_LIBS)</pre> in the link command
        line. Also, use <pre class="screen">$(TAU_MPI_INCLUDE)</pre> in the compiler command line to
        specifies the MPI include directory to be used.  Example:

        <pre class="screen">
CXX     = $(TAU_CXX)
CFLAGS  = $(TAU_INCLUDE) $(TAU_DEFS) $(TAU_MPI_INCLUDE)
LIBS    = $(TAU_MPI_LIBS) $(TAU_LIBS)
</pre></li><li>Compile and run the MPI application as usual to generate the performance data.</li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="EnvironmentVariables"></a>2.4.&nbsp;Environment Variables</h2></div></div></div><p>When the program has been compiled, it can be executed as it
    normally would be (for example, using mpirun for an MPI task). TAU
    generates profile data files or trace files in the current working
    directory. One file for each context and thread is generated. To better 
    manage different experiments, set the environment variables</p><div class="itemizedlist"><ul type="disc"><li><code class="literal">PROFILEDIR</code>  to name the directory that should contain the
      profile data files and</li><li><code class="literal">TRACEDIR</code>  the directory where event traces should be stored.
      </li><li><code class="literal">LD_LIBRARY_PATH</code>  (or LIBPATH for IBM)
      should include the &lt;tauroot&gt;/&lt;tauarch&gt;/lib directory if TAU is used with
      JAVA 2 (using the -jdk=&lt;dir&gt; configuration option) or dyninstAPI (using
      the -dyninst=&lt;dir&gt; configuration option).</li></ul></div><p>Example:</p><pre class="screen">
% make 
% setenv TRACEDIR /users/foo/tracedata/experiment1
% mpirun -np 4 matrix
</pre><p><span class="emphasis"><em>Note:</em></span> TAU also uses the environment
      variable  <code class="literal">PCL_EVENT</code>  and  <code class="literal">PAPI_EVENT</code>  to specify the hardware performance
      counter to be used when -pcl=&lt;dir&gt; or -papi=&lt;dir&gt; configuration options
      are used, respectively. See section <a href="#">Using Hardware Performance Counters"</a> in Chapter 4 for further details.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ApplicationScenarios"></a>2.5.&nbsp;Application Scenarios</h2></div></div></div><p>TAU  <code class="literal">examples</code>  directory contains programs that
    illustrate the use of TAU instrumentation and measurement options.
    </p><div class="itemizedlist"><ul type="none"><li style="list-style-type: none">
      instrument

      <p>This contains a simple C++ example that shows how TAU API
      can be used for manually instrumenting a C++ program.</p></li><li style="list-style-type: none"> 
     threads

      <p>A simple multi-threaded program that shows how the main
      function of a thread is instrumented. Performance data is generated for
      each thread of execution. Uses pthread library and TAU must be 
      configured with the  <code class="literal">-pthread</code>  option.</p></li><li style="list-style-type: none">
      cthreads
  
    <p>Same as threads above, but for a C program. An instrumented C
    program may be compiled with a C compiler, but needs to be linked with a
    C++ linker.</p></li><li style="list-style-type: none">
      sproc

      <p>SGI sproc threads example. TAU should be configured with the
       <code class="literal">-sproc</code>  option to use this. </p></li><li style="list-style-type: none">
      pi

      <p>An MPI program that calculates the value of pi and e. It
      highlights the use of TAU's MPI wrapper library. TAU needs to be
      configured with -mpiinc=&lt;dir&gt; and -mpilib=&lt;dir&gt; to use this.
      </p></li><li style="list-style-type: none">
      mpishlib

      <p>Demonstrates the use of MPI wrapper library in instrumenting
      a shared object. The MPI application is instrumented is instrumented as
      well. TAU needs to be configured with -mpiinc=&lt;dir&gt; and
      mpilib=&lt;dir&gt; flags.</p></li><li style="list-style-type: none">
      python
      <p>Instrumentation of a python application can be done
      automatically or manually using the TAU Python bindings. Two examples,
       <code class="literal">auto.py</code>  and  <code class="literal">manual.py</code>  demonstrate this respectively. TAU needs to be
      con-figured with-pythoninc=&lt;dir that contains Python.h&gt; option and the
      user needs to set  <code class="literal">PYTHONPATH</code>  to &lt;taudir&gt;/&lt;arch&gt;/lib to use this feature.
      </p></li><li style="list-style-type: none">
      traceinput
      
      <p>To build a trace converter/trace reader application, we provide the 
      TAU trace input library. This directory contains two examples (in c 
      and c++ subdirectories) that illustrate how an application can use 
      the trace input API to read online or post-mortem TAU binary 
      traces. It shows how the user can register routines with the callback 
      interface and how TAU invokes these routines when events take 
      place. </p></li><li style="list-style-type: none">
      papi
      
      <p>A matrix multiply example that shows how to use TAU
      statement level timers for comparing the performance of two algorithms
      for matrix multiplication. When used with PAPI or PCL, this can
      highlight the cache behaviors of these algorithms. TAU should be 
      configured with -papi=&lt;dir&gt; or -pcl=&lt;dir&gt; and the user should set
       <code class="literal">PAPI_EVENT</code>  or  <code class="literal">PCL_EVENT</code> 
      respective environment variables, to use this.</p></li><li style="list-style-type: none">
      papithreads
      <p>Same as papi, except uses threads to highlight how hardware
      performance counters may be used in a multi-threaded application. When
      it is used with PAPI, TAU should be configured with -papi=&lt;dir&gt;
      -pthread autoinstrument Shows the use of Program Database Toolkit (PDT)
      for automating the insertion of TAU macros in the source code. It
      requires configuring TAU with the -pdt=&lt;dir&gt; option. The Makefile
      is modified to illustrate the use of a source to source translator
      (tau_instrumentor). </p></li><li style="list-style-type: none">
      reduce
    
      <p>Shows the use of tau_reduce, a utility that can read
      profiles and a set of rules and determine which routines should not be 
      instrumented (for frequently called light-weight routines). See
       <code class="literal">&lt;tau&gt;/utils/TAU_REDUCE.README</code>  file for further details.
      It requires configuring TAU with -pdt=&lt;dir&gt; option.</p></li><li style="list-style-type: none">
      cinstrument

      <p> Shows the use of PDT for C. Requires configuring TAU with
      -pdt=&lt;dir&gt; option.</p></li><li style="list-style-type: none">
      mixedmode

      <p>This example illustrates the use of PDT,
      hand-instrumentation (for threads), MPI library instrumentation and TAU
      system call wrapper library instrumentation. Requires configuring TAU
      with -mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt; -pdt=&lt;dir&gt; -pthread
      options.</p></li><li style="list-style-type: none">
        pdt_mpi

        <p>This directory contains C, C++ and F90 examples that
        illustrate how TAU/PDT can be used with MPI.  Requires configuring TAU
        with -pdt=&lt;dir&gt; -mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt; options.
        You may also try this with the  <code class="literal">-TRACE -epilog=&lt;dir&gt;</code> 
        options to use the EPI-LOG tracing package (from FZJ).</p></li><li style="list-style-type: none">
        callpath
      
        <p>Shows the use of callpath profiling. Requires configuring
        TAU with the  <code class="literal">-PROFILECALLPATH</code>  option. Setting the
        environment variable  <code class="literal">TAU_CALLPATH_DEPTH</code>  changes the
        depth of the callpath recorded by TAU. The default value of this
        variable is 2.</p></li><li style="list-style-type: none">
      selective

      <p>This example illustrates the use of PDT, and selective
      profiling using profile groups in the tau_instrumentor. Requires
      configuring TAU with -pdt=&lt;dir&gt; -fortran=&lt;...&gt;
      options.</p></li><li style="list-style-type: none">
      NPB2.3

      <p>The NAS Parallel Benchmark 2.3 [NPB-URL]. It shows how to
      use TAU's MPI wrapper with a manually instrumented Fortran program. LU
      and SP are the two benchmarks. LU is instrumented completely, while only
      parts of the SP program are instrumented to contrast the coverage of
      routines. In both cases MPI level instrumentation is complete. TAU needs
      to be configured with -mpi-inc=&lt;dir&gt; and -mpilib=&lt;dir&gt; to use
      this.</p></li><li style="list-style-type: none">
      dyninst

      <p>An example that shows the use of DyninstAPI [DYNINST-URL] to
      insert TAU instrumentation. Using Dyninst, no modifications are needed
      and tau_run, a runtime instrumentor, inserts TAU calls at routine
      transitions in the program. [This represents work in progress].</p></li><li style="list-style-type: none">
      dyninstthreads
      <p>The above example with threads.</p></li><li style="list-style-type: none">
      java/pi

      <p>Shows a java program for calculating the value of pi. It
      illustrates the use of the TAU JVMPI layer for instrumenting a Java
      program without any modifications to its source code, byte-code or the
      JVM. It requires a Java 2 compliant JVM and TAU needs to be configured
      with the -jdk=&lt;dir&gt; option to use this.</p></li><li style="list-style-type: none">
      java/api

      <p>The same Pi program as above that illustrates the use of the
      TAU API. There are subdirectories for C, C++ and F90 to show the
      differences in instrumentation and Makefiles. TAU needs to be configured
      with the -openmp option to use this.</p></li><li style="list-style-type: none">
      openmp

      <p>Shows how to manually instrument an OpenMP program using the
      TAU API. There are subdirectories for C, C++ and F90 to show the
      differences in instrumentation and Makefiles. TAU needs to be configured
      with the -openmp option to use this. </p></li><li style="list-style-type: none">
      opari

      <p>Opari is an OpenMP directive rewriting tool that works with
      TAU. Configure TAU with -opari=&lt;dir&gt; option to use this. This provides
      detailed instrumentation of OpenMP constructs. There are subdirectories
      for C++, pdt_f90, and OpenMPI to demonstrate the use of this tool. The
      pdt_f90 directory contains an example that shows the use of PDT with
      Opari for a Fortran 90 program. </p></li><li style="list-style-type: none">
      openmpi

      <p>Illustrates TAU's support for hybrid execution models in the
      form of MPI for message passing and OpenMP threads. TAU needs to be
      configured with -mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt; -openmp options to use this.
      fork Illustrates how to register a forked process with TAU. TAU provides
      two options:  <code class="literal">TAU_INCLUDE_PARENT_DATA</code>  and
       <code class="literal">TAU_EXCLUDE_PARENT_DATA</code>  which allows the child
      process to inherit or clear the performance data when the fork
      takes place. </p></li><li style="list-style-type: none">
      mapping

      <p>Illustrates two examples in the embedded and external
      subdirectories. These correspond to profiling at the object level, where
      the time spent in a method is displayed for a specific object. There are
      two ways to achieve this using an embedded association. The first method
      requires an extension of the class definition with a TAU pointer and the
      second scheme uses external hash-table lookup that relies on looking at
      the object address at each method invocation. Both of these examples
      illustrate the use of the TAU Mapping API.</p></li><li style="list-style-type: none">
      multicounters

      <p>Illustrates the use of multiple measurement options
      configured simultaneously in TAU. See README file for instructions on
      setting the env. variables  <code class="literal">COUNTERS&lt;1-25&gt;</code>  for specifying measurements.
      Requires configuring TAU with  <code class="literal">-MULTIPLECOUNTERS.</code> </p></li><li style="list-style-type: none">
      selectiveAccess

      <p>Illustrates the use of TAU API for runtime access of TAU
      performance data. A program can get information about routines executing
      in its context. This can be used in conjunction with multiple
      counters.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tau.instrumentation"></a>Chapter&nbsp;3.&nbsp;Instrumentation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Automatic Instrumentation">3.1. Automatic Instrumentation of C++, C and F90 source code</a></span></dt><dt><span class="sect1"><a href="#UsingTAU_PDT_MPI">3.2. Using TAU with PDT and MPI</a></span></dt><dt><span class="sect1"><a href="#Using TAU_PDT_F90">3.3. Using TAU with PDT for an F90 MPI application</a></span></dt><dt><span class="sect1"><a href="#TAU_PDT_Opari">3.4. Using TAU with PDT and Opari</a></span></dt><dt><span class="sect1"><a href="#Selctive Instrumentation">3.5. Selective Instrumentation</a></span></dt><dt><span class="sect1"><a href="#TAU_REDUCE">3.6. TAU_REDUCE: A tool for reducing instrumentation overhead</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e976">3.6.1. OPTIONS</a></span></dt><dt><span class="sect2"><a href="#d0e997">3.6.2. RULES:</a></span></dt><dt><span class="sect2"><a href="#d0e1080">3.6.3. Examples:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#C++MeasurementAPI">3.7. C++ Measurement API</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1098">3.7.1. TAU_PROFILE(function_name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1127">3.7.2. string&amp; CT(variable);</a></span></dt><dt><span class="sect2"><a href="#d0e1140">3.7.3. TAU_TYPE_STRING(variable, type_string);</a></span></dt><dt><span class="sect2"><a href="#d0e1169">3.7.4. TAU_PROFILE_TIMER(timer, name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1181">3.7.5. TAU_PROFILE_START(timer); </a></span></dt><dt><span class="sect2"><a href="#d0e1191">3.7.6. TAU_PROFILE_STOP(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1207">3.7.7. TAU_GLOBAL_TIMER(timer, name, type, group);</a></span></dt><dt><span class="sect2"><a href="#d0e1220">3.7.8. TAU_GLOBAL_TIMER_START(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1230">3.7.9. TAU_GLOBAL_TIMER_STOP(timer);</a></span></dt><dt><span class="sect2"><a href="#d0e1244">3.7.10. TAU_PROFILE_SET_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1256">3.7.11. TAU_PROFILE_TIMER_SET_GROUP_NAME(timer, groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1270">3.7.12. TAU_PROFILE_STMT(statement); </a></span></dt><dt><span class="sect2"><a href="#d0e1284">3.7.13. TAU_PROFILE_INIT(argc, argv);</a></span></dt><dt><span class="sect2"><a href="#d0e1298">3.7.14. TAU_PROFILE_SET_NODE(myNode); </a></span></dt><dt><span class="sect2"><a href="#d0e1308">3.7.15. TAU_PROFILE_SET_CONTEXT(myContext);</a></span></dt><dt><span class="sect2"><a href="#d0e1321">3.7.16. TAU_REGISTER_THREAD();</a></span></dt><dt><span class="sect2"><a href="#d0e1329">3.7.17. TAU_REGISTER_FORK(nodeid, option);</a></span></dt><dt><span class="sect2"><a href="#d0e1349">3.7.18. TAU_PROFILE_EXIT(message);</a></span></dt><dt><span class="sect2"><a href="#d0e1363">3.7.19. TAU_PROFILE_TIMER_SET_NAME(t, newname)</a></span></dt><dt><span class="sect2"><a href="#d0e1377">3.7.20. TAU_PROFILE_TIMER_SET_TYPE(t, newtype)</a></span></dt><dt><span class="sect2"><a href="#d0e1387">3.7.21. TAU_PROFILE_TIMER_SET_GROUP(t, group)</a></span></dt><dt><span class="sect2"><a href="#d0e1401">3.7.22. TAU_DISABLE_INSTRUMENTATION();</a></span></dt><dt><span class="sect2"><a href="#d0e1409">3.7.23. TAU_ENABLE_INSTRUMENTATION();</a></span></dt><dt><span class="sect2"><a href="#d0e1421">3.7.24. TAU_ENABLE_GROUP(group);</a></span></dt><dt><span class="sect2"><a href="#d0e1435">3.7.25. TAU_DISABLE_GROUP(group);</a></span></dt><dt><span class="sect2"><a href="#d0e1449">3.7.26. TAU_GET_PROFILE_GROUP(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1466">3.7.27. TAU_ENABLE_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1482">3.7.28. TAU_DISABLE_GROUP_NAME(groupname);</a></span></dt><dt><span class="sect2"><a href="#d0e1499">3.7.29. TAU_ENABLE_ALL_GROUPS();</a></span></dt><dt><span class="sect2"><a href="#d0e1504">3.7.30. TAU_DISABLE_ALL_GROUPS();</a></span></dt><dt><span class="sect2"><a href="#d0e1513">3.7.31. TAU_REGISTER_EVENT(variable, event_name);</a></span></dt><dt><span class="sect2"><a href="#d0e1523">3.7.32. TAU_EVENT(variable, value);</a></span></dt><dt><span class="sect2"><a href="#d0e1537">3.7.33. TAU_REPORT_STATISTICS(); </a></span></dt><dt><span class="sect2"><a href="#d0e1545">3.7.34. TAU_REPORT_THREAD_STATISTICS();</a></span></dt><dt><span class="sect2"><a href="#d0e1553">3.7.35. TAU_TRACE_SENDMSG(tag, destination, length); </a></span></dt><dt><span class="sect2"><a href="#d0e1563">3.7.36. TAU_TRACE_RECVMSG(tag, source, length); </a></span></dt><dt><span class="sect2"><a href="#d0e1590">3.7.37. TAU_DB_DUMP_PREFIX(prefix);</a></span></dt><dt><span class="sect2"><a href="#d0e1600">3.7.38. TAU_DB_DUMP_INCR();</a></span></dt><dt><span class="sect2"><a href="#d0e1605">3.7.39. TAU_GET_FUNC_NAMES(functionList, numFuncs); </a></span></dt><dt><span class="sect2"><a href="#d0e1612">3.7.40. TAU_DUMP_FUNC_NAMES(); </a></span></dt><dt><span class="sect2"><a href="#d0e1617">3.7.41. TAU_GET_COUNTER_NAMES(counterList, numCounters);</a></span></dt><dt><span class="sect2"><a href="#d0e1627">3.7.42. TAU_GET_FUNC_VALS(inFuncs, numRoutines, counterExclusiveValues, counterInclusiveValues, numCalls, numSubrs, counterNames, numOfCounters);</a></span></dt><dt><span class="sect2"><a href="#d0e1636">3.7.43. TAU_DUMP_FUNC_VALS(inFuncs, numFuncs);</a></span></dt><dt><span class="sect2"><a href="#d0e1646">3.7.44. TAU_DUMP_FUNC_VALS_INCR(inFuncs, numFuncs); </a></span></dt><dt><span class="sect2"><a href="#d0e1659">3.7.45. TAU Mapping API</a></span></dt><dt><span class="sect2"><a href="#d0e1685">3.7.46. TAU_MAPPING(statement, key);</a></span></dt><dt><span class="sect2"><a href="#d0e1696">3.7.47. TAU_MAPPING_CREATE(name, type, key, groupname, tid);</a></span></dt><dt><span class="sect2"><a href="#d0e1715">3.7.48. TAU_MAPPING_OBJECT(FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1733">3.7.49. TAU_MAPPING_LINK(FuncIdVar, Key);</a></span></dt><dt><span class="sect2"><a href="#d0e1756">3.7.50. TAU_MAPPING_PROFILE (FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1780">3.7.51. TAU_MAPPING_PROFILE_TIMER(timer, FuncIdVar);</a></span></dt><dt><span class="sect2"><a href="#d0e1795">3.7.52. TAU_MAPPING_PROFILE_START(timer, tid);</a></span></dt><dt><span class="sect2"><a href="#d0e1807">3.7.53. TAU_MAPPING_PROFILE_STOP(tid);</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e1814">3.8. C Measurement API</a></span></dt><dt><span class="sect1"><a href="#d0e1841">3.9. Fortran90 Measurement API</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1849">3.9.1. TAU_PROFILE_INIT()</a></span></dt><dt><span class="sect2"><a href="#d0e1860">3.9.2. TAU_PROFILE_TIMER(profiler, name)</a></span></dt><dt><span class="sect2"><a href="#d0e1881">3.9.3. TAU_PROFILE_START(profiler)</a></span></dt><dt><span class="sect2"><a href="#d0e1896">3.9.4. TAU_PROFILE_STOP(profiler)</a></span></dt><dt><span class="sect2"><a href="#d0e1915">3.9.5. TAU_PROFILE_SET_NODE(myNode)</a></span></dt><dt><span class="sect2"><a href="#d0e1927">3.9.6. TAU_PROFILE_SET_CONTEXT(myContext)</a></span></dt><dt><span class="sect2"><a href="#d0e1939">3.9.7. TAU_PROFILE_REGISTER_THREAD()</a></span></dt><dt><span class="sect2"><a href="#d0e1947">3.9.8. TAU_DISABLE_INSTRUMENTATION()</a></span></dt><dt><span class="sect2"><a href="#d0e1954">3.9.9. TAU_ENABLE_INSTRUMENTATION()</a></span></dt><dt><span class="sect2"><a href="#d0e1965">3.9.10.  TAU_PROFILE_EXIT(message) </a></span></dt><dt><span class="sect2"><a href="#d0e1978">3.9.11. TAU_REGISTER_EVENT(variable, event_name)</a></span></dt><dt><span class="sect2"><a href="#d0e1995">3.9.12. TAU_EVENT(variable, value)</a></span></dt><dt><span class="sect2"><a href="#d0e2008">3.9.13. TAU_REPORT_STATISTICS()</a></span></dt><dt><span class="sect2"><a href="#d0e2015">3.9.14. TAU_REPORT_THREAD_STATISTICS()</a></span></dt><dt><span class="sect2"><a href="#d0e2020">3.9.15. TAU_TRACE_SENDMSG(tag, destination, length)</a></span></dt><dt><span class="sect2"><a href="#d0e2027">3.9.16. TAU_TRACE_RECVMSG(tag, source, length)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SectionSummary">3.10. Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p> For TAU instrumentation, macros must be added to the source
    code to identify routine transitions. It can be done automatically using
    the C++ instrumentor -  <code class="literal">tau_instrumentor</code> , based on the Program Database
    Toolkit, manually using the instrumentation API (Application Programmers
    Interface) or using the  <code class="literal">tau_run</code> , a runtime instrumentor, based on the
    DynInstAPI dynamic instrumentation package. Python applications can be
    instrumented automatically by using the tau python package. Java
    applications can be instrumented automatically by using the JVMPI TAU
    library. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Automatic Instrumentation"></a>3.1.&nbsp;Automatic Instrumentation of C++, C and F90 source code</h2></div></div></div><p>tau_instrumentor inserts TAU instrumentation in C++ source
    code using PDT [PDT-URL]. </p><div class="orderedlist"><ol type="1"><li><p>Install pdtoolkit. Refer to the README file in the PDT directory</p>.

        <pre class="screen">
% ./configure -arch=IRIX64 -KCC
</pre></li><li><p>Install TAU using the -pdt configuration option.</p><pre class="screen">
% ./configure -pdt=/usr/local/packages/pdtoolkit-1.0 
-c++=KCC -arch=sgi64 -SGITIMERS
% make install
</pre></li><li><p>Modify the makefile to invoke cxxparse from PDT which generates a program database file (.pdb) that contains program entities (such as routine locations) and tau_instrumentor which uses the .pdb file and the C++ source code to generate an instrumented version of the source code. </p></li><li><p>tau_instrumentor takes the following commandline options:</p><pre class="screen">Usage: /apps/tau-2.x/sgi64/bin/tau_instrumentor
&lt;pdbfile&gt; &lt;sourcefile&gt; [-o &lt;outputfile&gt;] [-noinline] [-noinit][-g
groupname] [-i headerfile] [-c|-c++|-fortran] [-f &lt;instr_req_file&gt; ]
[-rn &lt;return_keyword&gt;] [-rv &lt;return_void_keyword&gt;]
</pre><p>The -noinline option prevents the instrumentation of
          inlined routines. All routines in the source file can be logically
          grouped into a TAU group using the -g "groupname" option. An alternate
          header file can be used (instead of the default Profiler.h using the -i
          headerfile option. For a C/C++ program, TAU inserts the TAU_INIT call to
          parse the commandline parameters in main. To prevent this default
          behavior, specify -noinit on the commandline. The instrumentor can
          automatically deduce the language of the source file by examining the
          pdb file. The user can override this behavior using the -c, -c++ or
          -fortran option by specifying the language associated with the source
          file. This affects the placement of instrumentation in the source file.
          To specify a selective instrumentation file, use the -f file option. A 
          selective instrumentation file can contain a list of routines to exclude
          from instrumentation (one per line bracketed by  <code class="literal">BEGIN_EXCLUDE_LIST</code>  and
           <code class="literal">END_EXCLUDE_LIST</code> ). Alternately, you can specify a list of routines that
          should be included for instrumentation (no other routines are
          instrumented besides the ones in this list). Such a list is bracketed by
           <code class="literal">BEGIN_INCLUDE_LIST</code>  and  <code class="literal">END_INCLUDE_LIST</code>  as shown in the
          &lt;taudir&gt;/examples/autoinstrument/select file. The final -rn and -rv
          &lt;keywords&gt; options to tau_instrumentor allows the user to specify a
          macro that calls return in a routine with a non-void and a void return
          type respectively. TAU timers need to be stopped before a return
          statement. When the source code contains a macro that calls return, it
          is important to stop the timers before the macro is invoked in the
          instrumented source code. These -rn and -rv options help the
          tau_instrumentor identify the location of subroutine exits.</p></li><li><p> See  <code class="literal">examples/autoinstrument/Makefile</code> For example, the original makefile</p><pre class="screen">
CXX             = CC
CFLAGS          =
LIBS 		           = -lm
TARGET          = klargest
##############################################
# Original Rules
##############################################
all:           $(TARGET)
$(TARGET):     $(TARGET).o
       $(CXX) $(LDFLAGS) $(TARGET).o -o $@ $(LIBS)
$(TARGET).o : $(TARGET).cpp
       $(CXX) $(CFLAGS) -c $(TARGET).cpp
clean:
       $(RM) $(TARGET).o $(TARGET)
##############################################
is modified as follows. Some changes are shown in bold font.
TAUROOTDIR      = /usr/local/packages/tau2/
include $(TAUROOTDIR)/sgi64/Makefile.tau
CXX             = $(TAU_CXX)
CFLAGS		          = $(TAU_INCLUDES) $(TAU_DEFS)
LIBS	            = -lm $(TAU_LIBS)
PDTPARSE =$(PDTDIR)/$(CONFIG_ARCH)/bin/cxxparse
TAUINSTR =$(TAUDIR)/$(CONFIG_ARCH)/bin/tau_instrumentor
##############################################
# Modified Rules
##############################################

all:    $(TARGET) $(PDTPARSE) $(TAUINSTR)

$(TARGET): $(TARGET).o
      $(CXX) $(LDFLAGS) $(TARGET).o -o $@ $(LIBS)

# Use the instrumented source code to generate the object code
$(TARGET).o : $(TARGET).inst.cpp
       $(CXX) -c $(CFLAGS) $(TARGET).inst.cpp  -o $(TARGET).o

# Generate the instrumented source from the original source and 
# the pdb file
$(TARGET).inst.cpp : $(TARGET).pdb $(TARGET).cpp $(TAUINSTR)
    	   $(TAUINSTR) $(TARGET).pdb $(TARGET).cpp \
           -o $(TARGET).inst.cpp

# Parse the source file to generate the pdb file
$(TARGET).pdb : $(PDTPARSE) $(TARGET).cpp
        $(PDTPARSE) $(TARGET).cpp $(CFLAGS)

clean:
        $(RM) $(TARGET).o $(TARGET).inst.cpp $(TARGET) \
        $(TARGET).pdb
##############################################
$(PDTPARSE):
  @echo "****************************************"
  @echo "Download and Install Program Database Toolkit"
  @echo "ERROR: Cannot find $(PDTPARSE)"
  @echo "*************************************"

$(TAUINSTR):
  @echo "*************************************"
  @echo "Configure TAU with -pdt=&lt;dir&gt; option to use"

  @echo "C++ instrumentation with PDT"
  @echo "ERROR: Cannot find $(TAUINSTR)"
  @echo "*************************************"
</pre></li><li><p>Compile and execute the application.</p></li></ol></div><p>The user may also opt to manually insert TAU macros in the
      source code using the C++ instrumentation API. The following section
      describes this API in detail.  </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UsingTAU_PDT_MPI"></a>3.2.&nbsp;Using TAU with PDT and MPI</h2></div></div></div><p>To use PDT for source code instrumentation and TAU's MPI
      wrapper interposition library, modify the default compilation rule as
      shown in the example below:</p><pre class="screen">
TAUROOTDIR = /usr/local/packages/tau-2.x
include $(TAUROOTDIR)/include/Makefile
USE_TAU = 1
# Comment above line to disable TAU

CXX             = $(TAU_CXX)
PDTCXXPARSE     = $(PDTDIR)/$(PDTARCHDIR)/bin/cxxparse
TAUINSTR = $(TAUROOTDIR)/$(CONFIG_ARCH)/bin/ tau_instrumentor

CFLAGS   = $(TAU_INCLUDE) $(TAU_DEFS) $(TAU_MPI_INCLUDE)
LIBS  = $(TAU_MPI_LIBS) $(TAU_LIBS) $(LEXTRA1) 
$(EXTRALIBS) -lm

LDFLAGS  = $(USER_OPT)  $(TAU_LDFLAGS)

##############################################
ifdef USE_TAU
COMP_RULE = $(PDTCXXPARSE) $&lt; $(CFLAGS); \
       $(TAUINSTR) $*.pdb $&lt;o -o $*.inst.cpp -g RING;\ 
       $(CXX) $(CFLAGS) -c $*.inst.cpp -o $@ ; \        rm -f $*.pdb ;
else
# DISABLE TAU INSTRUMENTATION
TAU_DEFS =
# Don't use TAU MPI wrapper library
TAU_MPI_LIBS = -L/usr/local/lib -lmpich
TAU_LIBS =
TAU_WRAPPER_LIB =
TAU_INCLUDE =
COMP_RULE = $(CXX) $(CFLAGS) -c $&lt; -o $@ ;
endif
########################
TARGET = ring
all:            $(TARGET)
OBJS = $(TARGET).o 
$(TARGET):      $(OBJS)
        $(CXX) $(LDFLAGS) $(OBJS) -o $@ $(LIBS)
# Compilation rule
.cpp.o:
        $(COMP_RULE)
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Using TAU_PDT_F90"></a>3.3.&nbsp;Using TAU with PDT for an F90 MPI application</h2></div></div></div><p>A typical Fortran90 MPI program uses a Makefile that builds
      object files from a set of Fortran90 source files and links libraries
      with the objects to build an executable. The original Makefile might
      look like this:</p><pre class="screen">
LIBS=&lt;libraries&gt;
OBJS=&lt;list of object files&gt;
app: $(OBJS)  
	$(F90) $(LDFLAGS) $(OBJS) -o app
.f90.o: 
	$(F90) $(FFLAGS) -c $&lt; -o $@
First the user inserts the TAU stub Makefile and defines 
the Makefile variables. For e.g.
include /usr/local/packages/tau-2.13/rs6000/lib/ \
Makefile.tau-papiwallclock-multiplecounters-papivirtual-mpi-papi-pdt

F90		= $(TAU_F90)
PDTF90PARSE 	= $(PDTDIR)/$(PDTARCHDIR)/bin/f95parse
TAUINSTR	= $(TAUROOTDIR)/$(CONFIG_ARCH)/bin/tau_instrumentor
FFLAGS		= $(TAU_F90_SUFFIX) $(TAU_MPI_INCLUDE)
LIBS		= $(TAU_MPI_FLIBS) $(TAU_LIBS) $(TAU_FORTRANLIBS)
LINKER		= $(TAU_LINKER)
</pre><p>Next, the compilation rule is changed to first parse the
      original file using PDT's parser, then instrument the source code and
      compile the instrumented source code. The PDT script f95parser invokes
      the new Cleanscape Software International's Flint based F95 parser
      whereas f90parse invokes the older Mutek Solution's F90 parser. Please
      refer to PDT's README file for a listing of f90parse and f95parse
      commandline options. </p><p>In case there are any errors in parsing the source code, a
      fall-back rule is introduced to keep the original compilation rule in
      place. </p><pre class="screen">
COMP_RULE= -$(PDTPARSE $&lt; $(FFLAGS) -Mpdt_modules; \
	    $(TAUINSTR) $*.pdb $&lt; -o $*.inst.f90 -f select.dat; \
	    $(F90) $(FFLAGS) -c $*.inst.f90 -o $@; \
		if [ ! -f $@ ] ; then \
      		   echo "Error in compiling $*.f90: \
                         trying without PDT" \	
	    $(F90) $(FFLAGS) -c $&lt; -o $@; \
		fi ; \
		rm -f $*.pdb; 
</pre><p>The - before </p><pre class="screen">$(PDTPARSE)</pre><p> allows make to
      proceed when there is an error from any command in the rule. The
      -Mpdt_modules option reads and writes the .mod module files in a
      directory called pdt_modules (which should be created prior to invoking
      make) if you're using f90parse. It is not required for f95parse.
      f95parse can also parse multiple F90 files together when these are 
      specified on the command line. The -o&lt;file.pdb&gt; option should be used
      for specifying the merged PDB file name if more than one file is parsed
      at a time. Once a PDB file is generated, it is processed by the next
      stage in the instrumentation process using tau_instrumentor. The -f
      select.dat specifies a selective instrumentation list where the user can
      specify which routines and/or files should be excluded from 
      instrumentation. An optional -g &lt;groupname&gt; argument to tau_instrumentor
      puts all routines in a given file in a named profile group. Groups can
      be used to enable or disable the performance instrumentation for a group
      of logically related routines. The user introduces the compilation rule
      as below:</p><pre class="screen">
app: $(OBJS)  
	$(LINKER) $(LDFLAGS) $(OBJS) Do app
.f90.o: 
	$(COMP_RULE)
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TAU_PDT_Opari"></a>3.4.&nbsp;Using TAU with PDT and Opari</h2></div></div></div><p>The following example shows the use of PDT and Opari for
      OpenMP instrumentation in a Makefile. </p><pre class="screen">
TAUROOTDIR	= /usr/local/tau-2.x
include $(TAUROOTDIR)/include/Makefile
CXX		= $(TAU_CXX) 
CC		= $(TAU_CC) 
F90		= $(TAU_F90) 
PDTCPARSE       = $(PDTDIR)/$(PDTARCHDIR)/bin/cparse
PDTF90PARSE     = $(PDTDIR)/$(PDTARCHDIR)/bin/f90parse
TAUINSTR        = $(TAUROOTDIR)/$(CONFIG_ARCH)/bin/tau_instrumentor
OPARI_TOOL	= $(OPARIDIR)/tool/opari
CFLAGS 		= $(TAU_INCLUDE) $(TAU_DEFS) 
FFLAGS        	= 
LIBS            =  $(TAU_LIBS)  $(TAU_FORTRANLIBS)  $(LEXTRA1)
#LIBS            = $(TAU_DISABLE)  $(TAU_FORTRANLIBS)

LDFLAGS	      	= $(USER_OPT) 
MAKEFILE      	= Makefile
TARGET	      	= mandel
##############################################

install: 	$(TARGET)
$(TARGET):	ppm.o $(TARGET).o mytimer.o opari.tab.o
	@echo "********************************************"
	@echo "LINKING: "
	$(TAU_LINKER) $(LDFLAGS) $(TARGET).o ppm.o mytimer.o \
        opari.tab.o -o $@ $(LIBS)

$(TARGET).o : $(TARGET).f90 ppm.o 
	@echo "*******************************************"
	@echo "Creating $(TARGET).o:"
	$(RM) opari.rc
	$(OPARI_TOOL) -nosrc -table opari.tab.c $*.f90 $*.pomp.f90
	$(PDTF90PARSE) $*.pomp.f90 -MPDT_MODULES
	$(TAUINSTR) $*.pomp.pdb $*.pomp.f90 -o $*.inst.f90
	$(F90) $(FFLAGS) -c $*.inst.f90 -o $@

ppm.o : ppm.f90
	@echo "********************************************"
	@echo "Creating ppm.o: "
	$(PDTF90PARSE) $&lt;
	if [ -d PDT_MODULES ] ; then true; \
	  else mkdir PDT_MODULES ; fi
	if [ ! -f PPM.mod ] ; then true ; \
	  else mv PPM.mod PDT_MODULES ; fi 
	   
	$(TAUINSTR) $*.pdb $&lt; -o $*.inst.f90
	$(F90) $(FFLAGS) -c $*.inst.f90 -o $@

opari.tab.o: $(TARGET).o
		@echo "*****************************************"
		@echo "Creating opari.tab.o:"
	$(CC) $(CFLAGS) -c opari.tab.c

mytimer.o : mytimer.c
	@echo "*************************************"
@echo "Creating mytimer.o:"	$(PDTCPARSE) $&lt;

	$(TAUINSTR) $*.pdb $&lt; -o $*.inst.c
	$(CC) $(CFLAGS) -c $*.inst.c -o $@
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Selctive Instrumentation"></a>3.5.&nbsp;Selective Instrumentation</h2></div></div></div><p>When all routines in a source file are instrumented,
      frequently executing lightweight routines may cause an instrumentation
      overhead that distorts the performance data. To reduce the
      instrumentation overhead, the user can select routines that should not
      be instrumented and specify this in the selective instrumentation file
      that can be specified as a commandline argument to tau_instrumentor (-f
      &lt;file&gt; ). The format of this file is shown below:</p><pre class="screen">

BEGIN_INCLUDE_LIST
main
foo
f12
END_INCLUDE_LIST

</pre><p>instruments main, foo and f12 routines only.</p><pre class="screen">
BEGIN_EXCLUDE_LIST
domain
f1
f2
f4
END_EXCLUDE_LIST
</pre><p>excludes routines domain, f1, f2 and f4 from instrumentation.</p><pre class="screen">

BEGIN_FILE_INCLUDE_LIST
Main.f90
Foo?.f
END_FILE_INCLUDE_LIST
</pre><p>specifies that main.f90 and foo?.f files (foo3.f, foo9.f) are instrumented.</p><pre class="screen">
BEGIN_FILE_EXCLUDE_LIST
*.cpp
bar.f90
END_FILE_EXCLUDE_LIST
</pre><p>excludes all files with that end in a .cpp suffix, and
      bar.f90 from instrumentation. The user should specify either an exclude
      list or an include list, but not both. Sometimes, it is difficult to
      build this selective instrumentation file manually. The tool tau_reduce
      may be used to construct this file automatically.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TAU_REDUCE"></a>3.6.&nbsp;TAU_REDUCE: A tool for reducing instrumentation overhead</h2></div></div></div><p>When all routines in a source file are instrumented,
      frequently executing lightweight routines may cause an instrumentation
      overhead that distorts the performance data. To reduce the
      instrumentation overhead, the user can select routines that should not
      be instrumented and specify this in a selective instrumentation file
      that can be specified as a commandline argument to tau_instrumentor or
      tau_run. However, creating lists of routines manually can be tedious. To
      aid the user in identifying which routines should be removed, tau_reduce
      may be used. </p><p>tau_reduce is an application that will apply a set of
      user-defined rules to a pprof dump file in order to create a select file
      that will include an exclude list for selective implementation for TAU.
      The user must specify the name of the pprof dump file that this
      application will use. This is done with the -f filename flag. If no rule
      file is specified, then a single default rule will be applied to the 
      file. This rule is:</p><pre class="screen">
numcalls &gt; 1000000 &amp; usecs/call &lt; 2, 
</pre><p>which will exclude all routines that are called at least
      1,000,000 times and average less then two microseconds per call. If a
      rule file is specified, then this rule is not applied. If no output file
      is specified, then the results will be printed out to the screen.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e976"></a>3.6.1.&nbsp;OPTIONS</h3></div></div></div><p>tau_reduce has the following options available at the command line:</p><div class="itemizedlist"><ul type="disc"><li><p>-f &lt;filename*gt; : specify Filename of pprof dump file (default: temp.out)</p></li><li><p>-p : Print out all routines with their attributes (for debugging)</p></li><li><p>-o &lt;filename&gt; : specify filename for select file Output (default: print  to screen)</p></li><li><p>-r &lt;filename&gt; : specify filename for Rule file</p></li><li><p>-v : Verbose mode (for each rule, print out rule and all routines 	 that it excludes)</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e997"></a>3.6.2.&nbsp;RULES:</h3></div></div></div><p>Users can specify a set of rules for tau_reduce to apply.
        The rules should be specified in a separate file, one rule per line, and
        the file name should be specified with the appropriate option on the
        command line. The grammar for a rule is:</p><pre class="screen">
[GROUPNAME:]FIELD OPERATOR NUMBER. 
</pre><p>The GROUPNAME followed by the colon (:) is optional. If
        included, the rule will only be applied to routines that are a member of
        the group specified. Only one group name can be applied to each rule,
        and a rule must follow a groupname. If only a groupname is given, then
        an unrecognized field error will be returned. If the desired effect is
        to exclude all routines that belong to a certain group, then a trivial
        rule, such as GROUP:numcalls &gt; -1 may be applied. If a groupname is
        given, but the data does not contain any groupname data, then an error
        message will be given, but the rule will still be applied to the date
        ignoring the groupname specification.</p><p>A FIELD is any of the routine attributes listed in the following table:</p><div class="table"><a name="d0e1008"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;TABLE 1. Fields used in specifying rules in tau_reduce</b></p><table summary="TABLE 1. Fields used in specifying rules in tau_reduce" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">ATTRIBUTE NAME</th><th align="left">MEANING</th></tr></thead><tbody><tr><td align="center">numcalls</td><td align="center">Number of times this routine is called</td></tr><tr><td align="center">numsubrs</td><td align="center">Number of subroutines that this routine contains</td></tr><tr><td align="center">percent</td><td align="center">Percent of total implementation time</td></tr><tr><td align="center">cumusec</td><td align="center">Inclusive routine running time, in microseconds</td></tr><tr><td align="center">count</td><td align="center">Exclusive hardware count</td></tr><tr><td align="center">totalcount</td><td align="center">Inclusive hardware count</td></tr><tr><td align="center">stddev</td><td align="center">Standard deviation</td></tr><tr><td align="center">usecs/call</td><td align="center">Microseconds per call</td></tr><tr><td align="center">counts/call</td><td align="center">Hardware counts per call</td></tr></tbody></table></div><p>Some FIELDS are only available for certain files. If
       hardware counters are used, then usec, cumusec, usecs/per call are not
       applicable and a error is reported. The opposite is true if timing data
       is used rather than hardware counters. Also, stddev is only available
       for certain files that contain that data (when TAU is configured with
       -PROFILESTATS). An OPERATOR is any of the following: &lt; (less than), &gt;
       (greater than), or = (equals). A NUMBER is any number. A compound rule
       may be formed by using the &amp; (and) symbol in between two simple rules.
       There is no OR because there is an implied or between two separate
       simple rules, each on a separate line. (i.e. the compound rule
        <code class="literal">usec &lt; 1000</code>  OR  <code class="literal">numcalls = 1</code>  is the
       same as the two simple rules  <code class="literal">usec &lt; 1000</code>  and
        <code class="literal">numcalls = 1</code> </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1080"></a>3.6.3.&nbsp;Examples:</h3></div></div></div><pre class="screen">
#exclude all routines that are members of TAU_USER and have less than 
#1000 microseconds
TAU_USER:usec &lt; 1000     

#exclude all routines that have less than 1000 microseconds and are 
#called only once.
usec &lt; 1000 &amp; numcalls = 1   
			     
#exclude all routines that have less than 1000 usecs per call OR 
#have a percent less than 5
usecs/call &lt; 1000
percent &lt; 5
</pre><p><span class="emphasis"><em>Note:</em></span>Any line in the rule file that
        begins with a # is a comment line. For clarity, blank lines may be
        inserted in between rules and will also be ignored.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="C++MeasurementAPI"></a>3.7.&nbsp;C++ Measurement API</h2></div></div></div><p>The API is a set of macros that can be inserted in the C++
      source code. An extension of the same API is available to instrument C
      and Fortran sources. This is discussed later. </p><p>At the beginning of each instrumented source file, include the following header</p><pre class="screen">
#include &lt;Profile/Profiler.h&gt;
</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1098"></a>3.7.1.&nbsp;TAU_PROFILE(function_name, type, group);</h3></div></div></div><em class="parameter"><code>
Arguments: 
char *function_name or string&amp; function_name
char *type_name or string&amp; type
TauGroup_t group
</code></em><p>With  <code class="literal">TAU_PROFILE</code> , the function
         <code class="literal">function_name</code>  is profiled.  <code class="literal">TAU_PROFILE</code> 
        identifies the function uniquely by the combination of its name and type
        parameters. Each function is also associated with the group specified.
        This information can selectively enable or disable instrumentation in a
        set of profile groups. A function that belongs to the
         <code class="literal">TAU_DEFAULT</code>  group is always profiled. Other user
        defined groups are </p><pre class="screen">TAU_USER, TAU_USER1, TAU_USER2, TAU_USER3,
        TAU_USER4</pre><p>. The top level function in any thread must be
        profiled using the  <code class="literal">TAU_DEFAULT</code>  group. For details on
        using selective instrumentation, please refer to the section Running the
        application in Chapter 4. </p><p>Example:</p><pre class="screen">
int main(int argc, char **argv)
{
TAU_PROFILE(main()","int (int, char **)",TAU_DEFAULT);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1127"></a>3.7.2.&nbsp;string&amp; CT(variable);</h3></div></div></div><em class="parameter"><code>
Arguments: 
&lt;type&gt; variable 
</code></em><p>The  <code class="literal">CT</code>  macro returns the runtime type
        information string of a variable. This is useful in constructing the
        type parameter of the  <code class="literal">TAU_PROFILE</code>  macro. For templates,
        the type information can be constructed using the type of the return and
        the type of each of the arguments (parameters) of the template. The
        example in the following macro will clarify this.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1140"></a>3.7.3.&nbsp;TAU_TYPE_STRING(variable, type_string);</h3></div></div></div><em class="parameter"><code>
Arguments: 
string &amp; variable;
string &amp; type_string;
</code></em><p>This macro assigns the string constructed in type_string to
       the variable. The + operator and the CT macro can be used to construct
       the type string of an object. This is useful in identifying templates
       uniquely, as shown below.</p><p>Example:</p><pre class="screen">

template&lt;class PLayout&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const ParticleBase&lt;PLayout&gt;&amp; P) {
 TAU_TYPE_STRING(taustr, "ostream (ostream, " + CT(P) + " )");
TAU_PROFILE("operator&lt;&lt;()"taustr, TAU_PARTICLE | TAU_IO);
... 
}
</pre><p>When PLayout is instantiated with
       " <code class="literal">UniformCartesian&lt;3U, double&gt;</code> ",this generates the
       unique template name: </p><pre class="screen">

"operator&lt;&lt;() ostream const 
ParticleBase&lt;UniformCartesian&lt;3U, double&gt; &gt; )"
</pre><p>The following example illustrates the usage of the CT macro
       to extract the name of the class associated with the given object using
       CT(*this);</p><pre class="screen">
template&lt;class PLayout&gt;
unsigned ParticleBase&lt;PLayout7&gt;::GetMessage(Message&amp; msg, int node) {
  TAU_TYPE_STRING(taustr, CT(*this) + "unsigned (Message, int)");
  TAU_PROFILE("ParticleBase::GetMessage()", taustr, TAU_PARTICLE);
...
}
</pre><p>When PLayout is instantiated with " <code class="literal">UniformCartesian&lt;3U, double&gt;</code> ",this generates the unique template name:</p><pre class="screen">
"ParticleBase::GetMessage() ParticleBase&lt;UniformCartesian&lt;3U, double&gt; &gt; unsigned (Message, int)"
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1169"></a>3.7.4.&nbsp;TAU_PROFILE_TIMER(timer, name, type, group);</h3></div></div></div><em class="parameter"><code>
Arguments: 
Profiler timer; 
char *name or string&amp; name;
char *type or string&amp; type;
TauGroup_t group;
</code></em><p>With  <code class="literal">TAU_PROFILE_TIMER</code> , a group of one or more statements is profiled. This macro has a timer variable as its first argument, and then strings for name and type, as described earlier. It associates the timer to the profile group specified in the last parameter. </p><pre class="screen">
Example:
template&lt; class T, unsigned Dim &gt;
void BareField&lt;T,Dim&gt;::fillGuardCells(bool reallyFill)
{
  // profiling macros
  TAU_TYPE_STRING(taustr, CT(*this) + " void (bool)" );
  TAU_PROFILE("BareField::fillGuardCells()", taustr, TAU_FIELD);

  TAU_PROFILE_TIMER(sendtimer, "fillGuardCells-send",
                    taustr, TAU_FIELD);
  TAU_PROFILE_TIMER(localstimer, "fillGuardCells-locals",
                    taustr, TAU_FIELD);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1181"></a>3.7.5.&nbsp;TAU_PROFILE_START(timer); </h3></div></div></div><em class="parameter"><code>

Arguments:
Profiler timer;
</code></em><p>The macro  <code class="literal">TAU_PROFILE_START</code>  starts the timer associated with the set of statements that are to be profiled. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1191"></a>3.7.6.&nbsp;TAU_PROFILE_STOP(timer);</h3></div></div></div><em class="parameter"><code>

Arguments:
Profiler timer;
</code></em><p>The macro  <code class="literal">TAU_PROFILE_STOP</code>  stops the timer.</p><p>It is important to note that timers can be nested, but not
      overlapping. TAU detects programming errors that lead to such overlaps
      at runtime, and prints a warning message. </p><p>Example:</p><pre class="screen">

template&lt; class T, unsigned Dim &gt;
void BareField&lt;T,Dim&gt;::fillGuardCells(bool reallyFill)
{
  // profiling macros
  TAU_TYPE_STRING(taustr, CT(*this) + " void (bool)" );
  TAU_PROFILE("BareField::fillGuardCells()", taustr, TAU_FIELD);

  TAU_PROFILE_TIMER(sendtimer, "fillGuardCells-send",
                    taustr, TAU_FIELD);
  TAU_PROFILE_TIMER(localstimer, "fillGuardCells-locals",
                    taustr, TAU_FIELD);
// ...
  TAU_PROFILE_START(sendtimer);
    // set up messages to be sent
    Message** mess = new Message*[nprocs];
    int iproc;
    for (iproc=0; iproc&lt;nprocs; ++iproc) {
      mess[iproc] = NULL;
      recvmsg[iproc] = false; }//... other code
  TAU_PROFILE_STOP(sendtimer);
  ...
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1207"></a>3.7.7.&nbsp;TAU_GLOBAL_TIMER(timer, name, type, group);</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler timer;
string name, type;
TauGroup_t group;
</code></em><p>As  <code class="literal">TAU_PROFILE_TIMER</code>  is used within the
        scope of a block (typically a routine),
         <code class="literal">TAU_GLOBAL_TIMER</code>  can be used across different routines
        in the same file. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1220"></a>3.7.8.&nbsp;TAU_GLOBAL_TIMER_START(timer);</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler timer;
</code></em><p> <code class="literal">TAU_GLOBAL_TIMER_START</code>  starts the timer. The timer in this case is declared in the file scope. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1230"></a>3.7.9.&nbsp;TAU_GLOBAL_TIMER_STOP(timer);</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler timer;
</code></em><p> <code class="literal">TAU_GLOBAL_TIMER_STOP</code>  stops the timer which is declared in the file scope. </p><p>Example:</p><pre class="screen">

TAU_GLOBAL_TIMER(looptimer, "Loops in foo.cpp", " ", TAU_USER);
void foo()
{
TAU_GLOBAL_TIMER_START(looptimer);
for (i=0; i&lt;N; i++) { /* do something */ }
TAU_GLOBAL_TIMER_STOP(looptimer);
}
void bar()
{
TAU_GLOBAL_TIMER_START(looptimer);
for(j=0; j&lt;N; j++) { /* do something */ }
TAU_GLOBAL_TIMER_STOP(looptimer);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1244"></a>3.7.10.&nbsp;TAU_PROFILE_SET_GROUP_NAME(groupname);</h3></div></div></div><em class="parameter"><code>
Arguments:
char *groupname;
</code></em><p> <code class="literal">TAU_PROFILE_SET_GROUP_NAME</code>  macro allows
        the user to change the group name associated with the instrumented
        routine. This macro must be called within the instrumented routine. 
        </p><pre class="screen">

void foo()
{
  TAU_PROFILE("foo()", "void ()", TAU_USER);
  TAU_PROFILE_SET_GROUP_NAME("Particle"); 
  /* gives a more meaningful group name */
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1256"></a>3.7.11.&nbsp;TAU_PROFILE_TIMER_SET_GROUP_NAME(timer, groupname);</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler timer;
char *groupname;
</code></em><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP_NAME</code>  changes the group name associated with a given timer.</p><p>Example:</p><pre class="screen">
void foo()
{
TAU_PROFILE_TIMER(looptimer, "foo: loop1", " ", TAU_USER);
TAU_PROFILE_START(looptimer);
for (int i = 0; i &lt; N; i++) { /* do something */ }
TAU_PROFILE_STOP(looptimer);
TAU_PROFILE_TIMER_SET_GROUP_NAME("Field");
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1270"></a>3.7.12.&nbsp;TAU_PROFILE_STMT(statement); </h3></div></div></div><em class="parameter"><code>
Arguments: 
statement;
</code></em><p> <code class="literal">TAU_PROFILE_STMT</code>  declares a variable
          that is used only during profiling or for execution of a statement that
          takes place only when the instrumentation is active.  When
          instrumentation is inactive (i.e., when profiling and tracing are turned
          off as described in Chapter 2), all macros are defined as null. </p><p>Example:</p><pre class="screen">

TAU_PROFILE_STMT(T obj;); // T is a template parameter)
TAU_TYPE_STRING(str, "void () " + CT(obj) );
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1284"></a>3.7.13.&nbsp;TAU_PROFILE_INIT(argc, argv);</h3></div></div></div><em class="parameter"><code>
Arguments: 
int argc; 
char **argv;
</code></em><p> <code class="literal">TAU_PROFILE_INIT</code>  parses the
          command-line arguments for the names of profile groups that are to be
          selectively enabled for instrumentation. By default, if this macro is
          not used, functions belonging to all profile groups are enabled. </p><p>Example:</p><pre class="screen">
int main(int argc, char **argv){
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  TAU_PROFILE_INIT(argc, argv);
...
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1298"></a>3.7.14.&nbsp;TAU_PROFILE_SET_NODE(myNode); </h3></div></div></div><em class="parameter"><code>
Arguments: 
int myNode;
</code></em><p>The  <code class="literal">TAU_PROFILE_SET_NODE</code>  macro sets the
         node identifier of the executing task for profiling and tracing. Tasks
         are identified using node, context and thread ids. The profile data
         files generated will accordingly be named
         profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1308"></a>3.7.15.&nbsp;TAU_PROFILE_SET_CONTEXT(myContext);</h3></div></div></div><em class="parameter"><code>
Argument: 
int myContext;
</code></em><p> <code class="literal">TAU_PROFILE_SET_CONTEXT</code>  sets the context
         parameter of the executing task for profiling and tracing purposes. This
         is similar to setting the node parameter with
          <code class="literal">TAU_PROFILE_SET_NODE</code> .</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1321"></a>3.7.16.&nbsp;TAU_REGISTER_THREAD();</h3></div></div></div><p>To register a thread with the profiling system, invoke
         the  <code class="literal">TAU_REGISTER_THREAD</code>  macro in the run method of the
         thread prior to executing any other TAU macro. This sets up thread
         identifiers that are later used by the instrumentation system.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1329"></a>3.7.17.&nbsp;TAU_REGISTER_FORK(nodeid, option);</h3></div></div></div><em class="parameter"><code>
Arguments:
int nodeid;
enum TauFork_t  option; 
/* TAU_INCLUDE_PARENT_DATA or TAU_EXCLUDE_PARENT_DATA*/
</code></em><p>To register a child process obtained from the fork()
        syscall, invoke the  <code class="literal">TAU_REGISTER_FORK</code>  macro. It takes 
        two parameters, the first is the node id of the child process (typically
        the process id returned by the fork call or any 0..N-1 range integer).
        The second parameter specifies whether the performance data for the
        child process should be derived from the parent at the time of fork
        ( <code class="literal">TAU_INCLUDE_PARENT_DATA</code> ) or should be independent of
        its parent at the time of fork
        ( <code class="literal">TAU_EXCLUDE_PARENT_DATA</code> ). If the process id is used as
        the node id, before any analysis is done, all profile files should be
        converted to contiguous node numbers (from 0..N-1). It is highly
        recommended to use flat contiguous node numbers in this call for
        profiling and tracing. </p><p>Example:</p><pre class="screen">


   pID = fork();
 if (pID == 0)      {
   printf("Parent : pid returned %d\n", pID)
 }     else { 
// If we'd used the TAU_INCLUDE_PARENT_DATA, we get
//  the performance data from the parent in this process
//  as well.
        TAU_REGISTER_FORK(pID, TAU_EXCLUDE_PARENT_DATA);        
	printf("Child : pid = %d", pID);
  }
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1349"></a>3.7.18.&nbsp;TAU_PROFILE_EXIT(message);</h3></div></div></div><em class="parameter"><code>
Argument: 
const char * message;
</code></em><p> <code class="literal">TAU_PROFILE_EXIT</code>  should be called prior to an error exit from the program so that any profiles or event traces can be dumped to disk before quitting.</p><p>Example</p><pre class="screen">
if ((ret = open(...)) &lt; 0) {
  TAU_PROFILE_EXIT("ERROR in opening a file");
  perror("open() failed");
  exit(1);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1363"></a>3.7.19.&nbsp;TAU_PROFILE_TIMER_SET_NAME(t, newname)</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler timer;
string newname;
</code></em><p> <code class="literal">TAU_PROFILE_TIMER_SET_NAME</code>  macro changes the name associated with a timer to the newname argument. </p><p>Example:</p><pre class="screen">
void foo()
{
TAU_PROFILE_TIMER(timer1, "foo:loop1", " ", TAU_USER);
...
TAU_PROFILE_TIMER_SET_NAME(timer1, "foo:lines 21-34");
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1377"></a>3.7.20.&nbsp;TAU_PROFILE_TIMER_SET_TYPE(t, newtype)</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler t;
string newtype;
</code></em><p>This macro changes the type string associated with the timer. Similar to  <code class="literal">TAU_PROFILE_TIMER_SET_NAME</code> . </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1387"></a>3.7.21.&nbsp;TAU_PROFILE_TIMER_SET_GROUP(t, group)</h3></div></div></div><em class="parameter"><code>
Arguments:
Profiler t;
TauGroup_t group;
</code></em><p> <code class="literal">TAU_PROFILE_TIMER_SET_GROUP</code>  changes the group associated with a timer.</p><p>Example:</p><pre class="screen">
void foo()
{
 TAU_PROFILE_TIMER(t, "foo loop timer", " ", TAU_USER1);
...
 TAU_PROFILE_TIMER_SET_GROUP(t, TAU_USER3);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1401"></a>3.7.22.&nbsp;TAU_DISABLE_INSTRUMENTATION();</h3></div></div></div><p> <code class="literal">TAU_DISABLE_INSTRUMENTATION</code>  macro disables
      all entry/exit instrumentation within all threads of a context. This
      allows the user to selectively enable and disable instrumentation in
      parts of his/her code. It is important to re-enable the instrumentation
      within the same basic block and scope. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1409"></a>3.7.23.&nbsp;TAU_ENABLE_INSTRUMENTATION();</h3></div></div></div><p> <code class="literal">TAU_ENABLE_INSTRUMENTATION</code>  macro re-enables
      all TAU instrumentation. All instances of functions and statements that
      occur between the disable/enable section are ignored by TAU. This allows
      a user to limit the trace size, if the macros are used to disable
      recording of a set of iterations that have the same characteristics as,
      for example, the first recorded instance.</p><p>Example:</p><pre class="screen">
main() { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_ENABLE_INSTRUMENTATION();
  bar(); // recorded
} 
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1421"></a>3.7.24.&nbsp;TAU_ENABLE_GROUP(group);</h3></div></div></div><em class="parameter"><code>
Arguments:
TauGroup_t group;
</code></em><p> <code class="literal">TAU_ENABLE_GROUP</code>  macro turns on instrumentation in all routines associated with the profile group. </p><p>Example</p><pre class="screen">
void foo()
{
  TAU_PROFILE("foo()", " ", TAU_USER);

  ...
  TAU_ENABLE_GROUP(TAU_USER);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1435"></a>3.7.25.&nbsp;TAU_DISABLE_GROUP(group);</h3></div></div></div><em class="parameter"><code>
Arguments:
TauGroup_t group;
</code></em><p> <code class="literal">TAU_DISABLE_GROUP</code>  macro turns off instrumentation in all routines associated with the profile group. </p><p>Examples:</p><pre class="screen">
void foo()
{
  TAU_PROFILE("foo()", " ", TAU_USER);

  ...
  TAU_DISABLE_GROUP(TAU_USER);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1449"></a>3.7.26.&nbsp;TAU_GET_PROFILE_GROUP(groupname);</h3></div></div></div><em class="parameter"><code>
Arguments:
string groupname;
</code></em><p> <code class="literal">TAU_GET_PROFILE_GROUP</code>  allows the user to
        dynamically create groups based on strings, rather than use predefined,
        statically assigned groups such as  <code class="literal">TAU_USER1, TAU_USER2</code> 
        etc. This allows names to be associated in creating unique groups that
        are more meaningful, using names of files or directories for instance.
        </p><p>Example:</p><pre class="screen">
#define PARTICLES TAU_GET_GROUP("PARTICLES")
void foo()
{
  TAU_PROFILE("foo()", " ", PARTICLES);
}
void bar()
{
  TAU_PROFILE("bar()", " ", PARTICLES);
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1466"></a>3.7.27.&nbsp;TAU_ENABLE_GROUP_NAME(groupname);</h3></div></div></div><em class="parameter"><code>
Arguments:
string groupname;
</code></em><p> <code class="literal">TAU_ENABLE_GROUP_NAME</code>  macro can turn on the instrumentation associated with routines based on a dynamic group assigned to them. It is important to note that this and the  <code class="literal">TAU_DISABLE_GROUP_NAME</code>  macros apply to groups created dynamically using  <code class="literal">TAU_GET_PROFILE_GROUP.</code>  </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1482"></a>3.7.28.&nbsp;TAU_DISABLE_GROUP_NAME(groupname);</h3></div></div></div><em class="parameter"><code>
Arguments:
string groupname;
</code></em><p>Similar to  <code class="literal">TAU_ENABLE_GROUP_NAME</code> , this macro turns off the instrumentation in all routines associated with the dynamic group created using  <code class="literal">TAU_GET_PROFILE_GROUP.</code> </p><p>Example:</p><pre class="screen">
#define PARTICLES TAU_GET_PROFILE_GROUP("PARTICLES");
void foo()
{
 TAU_DISABLE_GROUP_NAME("PARTICLES");
  /* after some work */
  TAU_ENABLE_GROUP_NAME("PARTICLES");
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1499"></a>3.7.29.&nbsp;TAU_ENABLE_ALL_GROUPS();</h3></div></div></div><p>This macro turns on instrumentation in all groups</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1504"></a>3.7.30.&nbsp;TAU_DISABLE_ALL_GROUPS();</h3></div></div></div><p>This macro turns off instrumentation in all groups.</p><p>Examples:</p><pre class="screen">
void foo()
{
  TAU_DISABLE_ALL_GROUPS();
  TAU_ENABLE_GROUP_NAME("PARTICLES");
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1513"></a>3.7.31.&nbsp;TAU_REGISTER_EVENT(variable, event_name);</h3></div></div></div><em class="parameter"><code>
Arguments: 
TauUserEvent &amp; variable;
char * event_name;
</code></em><p>TAU can profile user-defined events using  <code class="literal">TAU_REGISTER_EVENT</code> . The meaning of the event is determined by the user. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1523"></a>3.7.32.&nbsp;TAU_EVENT(variable, value);</h3></div></div></div><em class="parameter"><code>
Arguments: TauUserEvent &amp; variable; 
double value;
</code></em><p> <code class="literal">TAU_EVENT</code>  associates a value with some
      user-defined event. When the event is triggered and this macro is
      executed, TAU maintains statistics, such as maximum, minimum values,
      standard deviation, number of samples, etc. for tracking this
      event.</p><p>Example:</p><pre class="screen">
int ArraySend(int arrayid)
{ 
  TAU_REGISTER_EVENT(taumsgsize, \
  "Size of message associated with Arrays");
  int size = GetArraySize(arrayid);
  TAU_EVENT(size); 
// ...
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1537"></a>3.7.33.&nbsp;TAU_REPORT_STATISTICS(); </h3></div></div></div><p> <code class="literal">TAU_REPORT_STATISTICS</code>  prints the aggregate
      statistics of user events across all threads in each node. Typically,
      this should be called just before the main thread exits. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1545"></a>3.7.34.&nbsp;TAU_REPORT_THREAD_STATISTICS();</h3></div></div></div><p> <code class="literal">TAU_REPORT_THREAD_STATISTICS</code>  prints the
      aggregate, as well as per thread user event statistics. Typically, this
      should be called just before the main thread exits. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1553"></a>3.7.35.&nbsp;TAU_TRACE_SENDMSG(tag, destination, length); </h3></div></div></div><em class="parameter"><code>
Arguments: 
int tag; 
int destination;
int length;
</code></em><p> <code class="literal">TAU_TRACE_SENDMSG</code>  traces an inter-process message communication when a tagged message is sent to a destination process. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1563"></a>3.7.36.&nbsp;TAU_TRACE_RECVMSG(tag, source, length); </h3></div></div></div><em class="parameter"><code>
Arguments: 
int tag; 
int source;
int length;
</code></em><p> <code class="literal">TAU_TRACE_RECVMSG</code>  traces a receive operation where tag represents the type of the message received from the source process.</p><p>Example:</p><pre class="screen">
if (pid == 0){
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, \
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, \
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
</pre><p><span class="emphasis"><em>NOTE:</em></span> When TAU is configured to use
        MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
         <code class="literal">TAU_TRACE_RECVMSG</code>  and
         <code class="literal">TAU_TRACE_SENDMSG</code>  macros are not required. The wrapper
        interposition library in </p><pre class="screen">$(TAU_MPI_LIBS)</pre><p> uses these
        macros internally for logging messages. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1590"></a>3.7.37.&nbsp;TAU_DB_DUMP_PREFIX(prefix);</h3></div></div></div><em class="parameter"><code>
Arguments:
char *prefix;
</code></em><p> <code class="literal">TAU_DB_DUMP_PREFIX</code>  macro dumps all
        profile data to disk and records a checkpoint or a snapshot of the
        profile statistics at that instant. The dump files are named
        &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
        "profile", the files are named profile.0.0.0, etc. and may be read by
        paraprof/pprof tools as the application executes.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1600"></a>3.7.38.&nbsp;TAU_DB_DUMP_INCR();</h3></div></div></div><p>This is similar to the TAU_DB_DUMP macro but it produces
        dump files that have a timestamp in their names. This allows the user to
        record timestamped incremental dumps as the application executes.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1605"></a>3.7.39.&nbsp;TAU_GET_FUNC_NAMES(functionList, numFuncs); </h3></div></div></div><em class="parameter"><code>
Arguments:
char **functionList;
int numFuncs;
</code></em><p>This macro fills the funcList argument with the list of
        timer and routine names. It also records the number of routines active
        in the numFuncs argument. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1612"></a>3.7.40.&nbsp;TAU_DUMP_FUNC_NAMES(); </h3></div></div></div><p>This macro writes the names of active functions to a file named dump_functionnames_&lt;node&gt;.&lt;context&gt;.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1617"></a>3.7.41.&nbsp;TAU_GET_COUNTER_NAMES(counterList, numCounters);</h3></div></div></div><em class="parameter"><code>
Arguments:
char **counterList;
int numCounters;
</code></em><p> <code class="literal">TAU_GET_COUNTER_NAMES</code>  returns the list of
        counter names and the number of counters used for measurement. When
        wallclock time is used, the counter name of "default" is
        returned.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1627"></a>3.7.42.&nbsp;TAU_GET_FUNC_VALS(inFuncs, numRoutines, counterExclusiveValues, counterInclusiveValues, numCalls, numSubrs, counterNames, numOfCounters);</h3></div></div></div><p>It gets detailed performance data for the list of
        routines. The user specifies inFuncs and the number of routines; TAU
        then returns the other arguments with the performance data.
        counterExclusiveValues and counterInclusiveValues are two dimensional
        arrays: the first dimension is the routine id and the second is counter
        id. The value is indexed by these two dimensions. numCalls and numSubrs
        (or child routines) are one dimensional arrays. </p><p>Examples:</p><pre class="screen">

  const char **inFuncs;
  /* The first dimension is functions, and the 
     second dimension is counters */
  double **counterExclusiveValues;
  double **counterInclusiveValues;
  int *numOfCalls;
  int *numOfSubRoutines;
  const char **counterNames;
  int numOfCouns;

  TAU_GET_FUNC_NAMES(functionList, numOfFunctions);

  /* We are only interested in the first two routines 
     that are executing in this context. So, we allocate 
     space for two routine names and get the performance 
     data for these two routines at runtime. */
  if(numOfFunctions &gt;=2 ){
    inFuncs = (const char **) malloc(sizeof(const char *) * 2);

    inFuncs[0] = functionList[0];
    inFuncs[1] = functionList[1];

    //Just to show consistency.
    TAU_DB_DUMP();

    TAU_GET_FUNC_VALS(inFuncs, 2,
                      counterExclusiveValues,
                      counterInclusiveValues,
                      numOfCalls,
                      numOfSubRoutines,
                      counterNames,
                      numOfCouns);

    TAU_DUMP_FUNC_VALS_INCR(inFuncs, 2);


  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
  cout &lt;&lt; "The number of counters is: " &lt;&lt; numOfCouns &lt;&lt; endl;
  cout &lt;&lt; "The first counter is: " &lt;&lt; counterNames[0] &lt;&lt; endl;

  cout &lt;&lt; "The Exclusive value of: " &lt;&lt; inFuncs[0]
       &lt;&lt; " is: " &lt;&lt; counterExclusiveValues[0][0] &lt;&lt; endl;
  cout &lt;&lt; "The numOfSubRoutines of: " &lt;&lt; inFuncs[0]
       &lt;&lt; " is: " &lt;&lt; numOfSubRoutines[0]
       &lt;&lt; endl;


  cout &lt;&lt; "The Inclusive value of: " &lt;&lt; inFuncs[1]
       &lt;&lt; " is: " &lt;&lt; counterInclusiveValues[1][0]
       &lt;&lt; endl;
  cout &lt;&lt; "The numOfCalls of: " &lt;&lt; inFuncs[1]
       &lt;&lt; " is: " &lt;&lt; numOfCalls[1]
       &lt;&lt; endl;

  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
  }

  TAU_DB_DUMP_INCR();

</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1636"></a>3.7.43.&nbsp;TAU_DUMP_FUNC_VALS(inFuncs, numFuncs);</h3></div></div></div><em class="parameter"><code>
Arguments:
char **inFuncs;
int numFuncs;
</code></em><p> <code class="literal">TAU_DUMP_FUNC_VALS</code>  writes the data
      associated with the routines listed in inFuncs to disk. The number of
      routines is specified by the user in numFuncs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1646"></a>3.7.44.&nbsp;TAU_DUMP_FUNC_VALS_INCR(inFuncs, numFuncs); </h3></div></div></div><em class="parameter"><code>
Arguments:
char **inFuncs;
int numFuncs;
</code></em><p>Similar to <code class="literal">TAU_DUMP_FUNC_VALS</code>. This macro
     creates an incremental selective dump and dumps the results with a date
     stamp to the filename such as
     sel_dump__Thu-Mar-28-16:30:48-2002__.0.0.0. In this manner the previous
     <code class="literal">TAU_DUMP_FUNC_VALS_INCR(...)</code> are not overwritten
     (unless they occur within a second).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1659"></a>3.7.45.&nbsp;TAU Mapping API</h3></div></div></div><p>TAU allows the user to map performance data of entities from
     one layer to another in multi-layered software. Mapping is used in
     profiling (and tracing) both synchronous and asynchronous models of
     computation. For mapping, the following macros are used. First locate
     and identify the higher-level statement using the
     <code class="literal">TAU_MAPPING</code> macro. Then, associate a function
     identifier with it using the <code class="literal">TAU_MAPPING_OBJECT</code>.
     Associate the high level statement to a FunctionInfo object that will be
     visible to lower level code, using <code class="literal">TAU_MAPPING_LINK</code>,
     and then profile entire blocks using
     <code class="literal">TAU_MAPPING_PROFILE</code>. Independent sets of statements
     can be profiled using <code class="literal">TAU_MAPPING_PROFILE_TIMER,
     TAU_MAPPING_PROFILE_START</code>, and
     <code class="literal">TAU_MAPPING_PROFILE_STOP</code> macros using the
     FunctionInfo object. The TAU <code class="filename">examples/mapping</code> directory has
     two examples (embedded and external) that illustrate the use of this
     mapping API for generating object-oriented profiles.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1685"></a>3.7.46.&nbsp;TAU_MAPPING(statement, key);</h3></div></div></div><em class="parameter"><code>
Arguments: 
statement ; // any C++ statement
TauGroup_t key; // TAU group/unique key associated
</code></em><p><code class="literal">TAU_MAPPING</code> is used to encapsulate the C++
     statement that we want to map to some other layer. The other layer can
     execute synchronously or asynchronously with respect to this statement.
     The key corresponds to a number that the lower layer will use to refer
     to this statement. For example, </p><pre class="screen">

int main()
{
Array &lt;2&gt; A(N, N), B(N, N), C(N,N), D(N, N);
//Original statement:
A = B + C + D;
//Instrumented statement:
TAU_MAPPING(A = B + C + D; , TAU_USER);
... 
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1696"></a>3.7.47.&nbsp;TAU_MAPPING_CREATE(name, type, key, groupname, tid);</h3></div></div></div><em class="parameter"><code>
Arguments: 
char *name, type, groupname;
TauGroup_t key; // TAU group/unique key associated
int tid; // Thread id
</code></em><p><code class="literal">TAU_MAPPING_CREATE</code> is similar to
      <code class="literal">TAU_MAPPING</code> but it requires the name, type and group
      name parameters (as character strings) to be specified. It creates a
      mapping and associates it with the key that is specified. Later, this
      key may be specified to retrieve the FunctionInfo object associated with
      this key for timing purposes. The thread identifier is specified in the
      <code class="literal">tid</code> parameter.</p><p>Example:</p><pre class="screen">

TAU_MAPPING_CREATE("foo()", "void ()", function_id,"USER", tid);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1715"></a>3.7.48.&nbsp;TAU_MAPPING_OBJECT(FuncIdVar);</h3></div></div></div><em class="parameter"><code>
Arguments: FunctionInfo *FuncIdVar;
</code></em><p>To create storage for an identifier associated with a higher
      level statement that is mapped using <code class="literal">TAU_MAPPING</code>, we
      use the <code class="literal">TAU_MAPPING_OBJECT</code> macro. For example, in the
      <code class="literal">TAU_MAPPING</code> example, the array expressions are
      created into objects of a class ExpressionKernel, and each statement is
      an object that is an instance of this class. To embed the identity of
      the statement we store the mapping object in a data field in this class.
      This is shown below:</p><pre class="screen">
 template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
class ExpressionKernel : public Pooma::Iterate_t
{
public:

  typedef ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt; This_t;
  //
  // Construct from an Expr.
  // Build the kernel that will evaluate the expression on the 
  // given domain.
  // Acquire locks on the data referred to by the expression.
  //
  ExpressionKernel(const LHS&amp;,const Op&amp;,const RHS&amp; , \
                   Pooma::Scheduler_t&amp;);


  virtual ~ExpressionKernel();

  //
  // Do the loop.
  //
  virtual void run();

private:

  // The expression we will evaluate.
  LHS lhs_m;
  Op  op_m;
  RHS rhs_m;
  TAU_MAPPING_OBJECT(TauMapFI)
};
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1733"></a>3.7.49.&nbsp;TAU_MAPPING_LINK(FuncIdVar, Key);</h3></div></div></div><em class="parameter"><code>
Arguments: FunctionInfo *FuncIdVar; 
TauGroup_t Key;
</code></em><p><code class="literal">TAU_MAPPING_LINK </code>creates a link between
      the object defined in <code class="literal">TAU_MAPPING_OBJECT</code> (that
      identifies a statement) and the actual higher-level statement that is
      mapped with <code class="literal">TAU_MAPPING</code>. The Key argument represents a
      profile group to which the statement belongs, as specified in the
      <code class="literal">TAU_MAPPING</code> macro argument. For the example of array
      statements, this link should be created in the constructor of the class
      that represents the expression. <code class="literal">TAU_MAPPING_LINK</code>
      should be executed before any measurement takes place. It assigns the
      identifier of the statement to the object to which FuncIdVar refers. For
      example</p><pre class="screen">

//
// Constructor
// Input an expression and record it for later use.
//
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::
ExpressionKernel(const LHS&amp; lhs,const Op&amp; op,const RHS&amp;  rhs, \
                 Pooma::Scheduler_t&amp; scheduler) : Pooma::Iterate_t(scheduler,        forEachTag(MakeExpression&lt;LHS&gt;::make(lhs),  DataBlockTag&lt;CountBlocks&gt;(),SumCombineTag()) +  forEachTag(MakeExpression&lt;RHS&gt;::make(rhs), DataBlockTag&lt;CountBlocks&gt;(), \
                 SumCombineTag()), -1), lhs_m(lhs), op_m(op), rhs_m(rhs)
{
  TAU_MAPPING_LINK(TauMapFI, TAU_USER)
// .. rest of the constructor
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1756"></a>3.7.50.&nbsp;TAU_MAPPING_PROFILE (FuncIdVar);</h3></div></div></div><em class="parameter"><code>
Arguments; FunctionInfo *FuncIdVar;
</code></em><p>The <code class="literal">TAU_MAPPING_PROFILE</code> macro measures the
    time and attributes it to the statement mapped in
    <code class="literal">TAU_MAPPING</code> macro. It takes as its argument the
    identifier of the higher level statement that is stored using
    <code class="literal">TAU_MAPPING_OBJECT</code> and linked to the statement using
    <code class="literal">TAU_MAPPING_LINK</code> macros. 
    <code class="literal">TAU_MAPPING_PROFILE</code> measures the time spent in the
    entire block in which it is invoked. For example, if the time spent in
    the run method of the class does work that must be associated with the
    higher-level array expression, then, we can instrument it as
    follows:</p><pre class="screen">
//
// Evaluate the kernel
// Just tell an InlineEvaluator to do it.
//

template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run()
{
  TAU_MAPPING_PROFILE(TauMapFI)

  // Just evaluate the expression.
  KernelEvaluator&lt;EvalTag&gt;().evalate(lhs_m,op_m,rhs_m);
  // we could release the locks here or in dtor 
}
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1780"></a>3.7.51.&nbsp;TAU_MAPPING_PROFILE_TIMER(timer, FuncIdVar);</h3></div></div></div><em class="parameter"><code>

Arguments: Profiler timer;
FunctionInfo * FuncIdVar;
</code></em><p><code class="literal">TAU_MAPPING_PROFILE_TIMER</code> enables timing
      of individual statements, instead of complete blocks. It will attribute
      the time to a higher-level statement. The second argument is the
      identifier of the statement that is obtained after
      <code class="literal">TAU_MAPPING_OBJECT</code> and
      <code class="literal">TAU_MAPPING_LINK</code> have executed. The timer argument in
      this macro is any variable that is used subsequently to start and stop
      the timer.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1795"></a>3.7.52.&nbsp;TAU_MAPPING_PROFILE_START(timer, tid);</h3></div></div></div><em class="parameter"><code>

Argument: 
Profiler timer;
int tid;
</code></em><p><code class="literal">TAU_MAPPING_PROFILE_START</code> starts the
      timer that is created using
      <code class="literal">TAU_MAPPING_PROFILE_TIMER</code>. This will measure the
      elapsed time in groups of statements, instead of the entire block. A
      corresponding stop statement stops the timer as described next. The
      thread identifier is specified in the tid parameter.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1807"></a>3.7.53.&nbsp;TAU_MAPPING_PROFILE_STOP(tid);</h3></div></div></div><em class="parameter"><code>

Arguments: 
int tid;
TAU_MAPPING_PROFILE_STOP stops the timer associated with the mapped lower-level statements. This is used in conjunction with TAU_MAPPING_PROFILE_TIMER and TAU_MAPPING_PROFILE_START macros. Example:
template&lt;class LHS,class Op,class RHS,class EvalTag&gt;
void
ExpressionKernel&lt;LHS,Op,RHS,EvalTag&gt;::run()
{
  TAU_MAPPING_PROFILE_TIMER(timer, TauMapFI);
  printf("ExpressionKernel::run() this = 4854\n", this);
  // Just evaluate the expression.
  
  TAU_MAPPING_PROFILE_START(timer);
      KernelEvaluator&lt;EvalTag&gt;().evaluate(lhs_m, op_m, rhs_m);
  TAU_MAPPING_PROFILE_STOP();
  // we could release the locks here instead of in the dtor.
}
</code></em><p>This concludes our Mapping section. </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1814"></a>3.8.&nbsp;C Measurement API</h2></div></div></div><p>The API for instrumenting C source code is similar to the C++
    API. The difference is that the <code class="literal">TAU_PROFILE()</code> macro
    is not available for identifying an entire block of code or function.
    Instead, routine transitions are explicitly specified using
    <code class="literal">TAU_PROFILE_TIMER()</code> macro with
    <code class="literal">TAU_PROFILE_START()</code> and
    <code class="literal">TAU_PROFILE_STOP()</code> macros to indicate the entry and
    exit from a routine. Note that, <code class="literal">TAU_TYPE_STRING()</code> and
    CT() macros are not applicable for C. It is important to declare the
    <code class="literal">TAU_PROFILE_TIMER()</code> macro after all the variables
    have been declared in the function and before the execution of the first
    C statement. </p><p>Example:</p><pre class="screen">

int main (int argc, char **argv)
{
  int ret;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", \
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);

  pthread_attr_init(&amp;attr);
  printf("Started Main...\n");
  // other statements
  TAU_PROFILE_STOP(tautimer);
	  return 0;
}
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1841"></a>3.9.&nbsp;Fortran90 Measurement API</h2></div></div></div><p>The Fortran90 TAU API allows source code written in Fortran to
    be instrumented for TAU. This API is comprised of Fortran routines. As
    explained in Chapter 2, the instrumentation can be disabled in the
    program by using the TAU stub makefile variable
    <code class="literal">TAU_DISABLE</code> on the link command line. This points to
    a library that contains empty TAU instrumentation routines.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1849"></a>3.9.1.&nbsp;TAU_PROFILE_INIT()</h3></div></div></div><p><code class="literal">TAU_PROFILE_INIT</code> routine must be called
      before any other TAU instrumentation routines. It is called once, in the
      top level routine (program). It initializes the TAU library.</p><p>Example:</p><pre class="screen">
Example:
      PROGRAM SUM_OF_CUBES
      integer profiler(2)
      save profiler

       call TAU_PROFILE_INIT()
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1860"></a>3.9.2.&nbsp;TAU_PROFILE_TIMER(profiler, name)</h3></div></div></div><em class="parameter"><code>
Arguments:
integer profiler(2)
character name(size)
</code></em><p>To profile a block of Fortran code, such as a function,
      subroutine, loop etc., the user must first declare a profiler, which is
      an integer array of two elements (pointer) with the save attribute, and
      pass it as the first parameter to the
      <code class="literal">TAU_PROFILE_TIMER</code> subroutine. The second parameter
      must contain the name of the routine, which is enclosed in a single
      quote. <code class="literal">TAU_PROFILE_TIMER</code> declares the profiler that
      must be used to profile a block of code. The profiler is used to profile
      the statements using <code class="literal">TAU_PROFILE_START</code> and
      <code class="literal">TAU_PROFILE_STOP</code> as explained later.  Example:</p><pre class="screen">
subroutine bcast_inputs
implicit none
integer profiler(2)
save profiler

include 'mpinpb.h'
include 'applu.incl'

interger IERR

call TAU_PROFILE_TIMER(profiler, 'bcast_inputs')
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1881"></a>3.9.3.&nbsp;TAU_PROFILE_START(profiler)</h3></div></div></div><em class="parameter"><code>
Arguments:
integer profiler(2)
</code></em><p><code class="literal">TAU_PROFILE_START</code> starts the timer for
      profiling a set of statements. The timer (or the profiler) must be
      declared using <code class="literal">TAU_PROFILE_TIMER</code> routine, prior to
      using <code class="literal">TAU_PROFILE_START</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1896"></a>3.9.4.&nbsp;TAU_PROFILE_STOP(profiler)</h3></div></div></div><em class="parameter"><code>
Arguments:
integer profiler(2)
</code></em><p><code class="literal">TAU_PROFILE_STOP</code> stops the timer used to
      profile a set of statements. It is used in conjunction with
      <code class="literal">TAU_PROFILE_TIMER</code> and
      <code class="literal">TAU_PROFILE_START</code> subroutines. </p><p>Example:</p><pre class="screen">
subroutine setbv
implicit none

include 'applu.incl'
c--------------------------------------------------

c   local variables
c--------------------------------------------------    
integer profiler(2)
save profiler
integer i, j, k
integer iglob, jglob

     call TAU_PROFILE_TIMER(profiler, 'setbv')
     call TAU_PROFILE_START(profiler)
c   set the dependent variable values along the top and c   bottom faces
      do j = 1, ny
       jglob = jpt + j
       do i = 1, nx
         iglob = ipt + i
          call exact( iglob, jglob, 1, u( 1, i, j, 1 ) )           
          call exact( iglob, jglob, nz, u( 1, i, j, nz ))
        end do
      end do
      call TAU_PROFILE_STOP(profiler)
      return
      end
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1915"></a>3.9.5.&nbsp;TAU_PROFILE_SET_NODE(myNode)</h3></div></div></div><em class="parameter"><code>
Arguments: 
integer myNode
</code></em><p>The <code class="literal">TAU_PROFILE_SET_NODE</code> macro sets the
      node identifier of the executing task for profiling and tracing. Tasks
      are identified using node, context and thread ids. The profile data
      files generated will accordingly be named
      <code class="literal">profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.</code></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1927"></a>3.9.6.&nbsp;TAU_PROFILE_SET_CONTEXT(myContext)</h3></div></div></div><em class="parameter"><code>
Argument: 
integer myContext
</code></em><p><code class="literal">TAU_PROFILE_SET_CONTEXT</code> sets the context
      parameter of the executing task for profiling and tracing purposes. This
      is similar to setting the node parameter with
      <code class="literal">TAU_PROFILE_SET_NODE</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1939"></a>3.9.7.&nbsp;TAU_PROFILE_REGISTER_THREAD()</h3></div></div></div><p>To register a thread with the profiling system, invoke the
      <code class="literal">TAU_PROFILE_REGISTER_THREAD</code> routine in the run method
      of the thread prior to executing any other TAU routine. This sets up
      thread identifiers that are later used by the instrumentation system.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1947"></a>3.9.8.&nbsp;TAU_DISABLE_INSTRUMENTATION()</h3></div></div></div><p><code class="literal">TAU_DISABLE_INSTRUMENTATION</code> macro
      disables all entry/exit instrumentation within all threads of a context.
      This allows the user to selectively enable and disable instrumentation
      in parts of his/her code. It is important to re-enable the
      instrumentation within the same basic block. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1954"></a>3.9.9.&nbsp;TAU_ENABLE_INSTRUMENTATION()</h3></div></div></div><p><code class="literal">TAU_ENABLE_INSTRUMENTATION</code> macro
      re-enables all TAU instrumentation. All instances of functions and
      statements that occur between the disable/enable section are ignored by
      TAU. This allows a user to limit the trace size, if the macros are used
      to disable recording of a set of iterations that have the same
      characteristics as, for example, the first recorded instance.</p><p>Example:</p><pre class="screen">
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_ENABLE_INSTRUMENTATION()
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1965"></a>3.9.10.&nbsp; TAU_PROFILE_EXIT(message) </h3></div></div></div><em class="parameter"><code>
Argument: 
character message(size)
</code></em><p><code class="literal">TAU_PROFILE_EXIT</code> should be called prior
      to an error exit from the program so that any profiles or event traces
      can be dumped to disk before quitting.</p><p>Example:</p><pre class="screen">
call TAU_PROFILE_EXIT('about called')
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1978"></a>3.9.11.&nbsp;TAU_REGISTER_EVENT(variable, event_name)</h3></div></div></div><em class="parameter"><code>
Arguments: 
int variable(2)
character event_name(size)
</code></em><p>TAU can profile user-defined events using
      <code class="literal">TAU_REGISTER_EVENT</code>. The meaning of the event is
      determined by the user. The first argument to
      <code class="literal">TAU_REGISTER_EVENT</code> is the pointer to an integer
      array. This array is declared with a save attribute as shown
      below.</p><p>Example:</p><pre class="screen">
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1995"></a>3.9.12.&nbsp;TAU_EVENT(variable, value)</h3></div></div></div><em class="parameter"><code>
Arguments: 
integer variable(2)
real value
</code></em><p><code class="literal">TAU_EVENT</code> associates a value with some
      user-defined event. When the event is triggered and this macro is
      executed, TAU maintains statistics, such as maximum, minimum values,
      standard deviation, number of samples, etc. for tracking this
      event.</p><p>Example:</p><pre class="screen">
  call TAU_REGISTER_EVENT(taumsgsize, 'Message size')
  call TAU_EVENT(size)

</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2008"></a>3.9.13.&nbsp;TAU_REPORT_STATISTICS()</h3></div></div></div><p><code class="literal">TAU_REPORT_STATISTICS</code> prints the
      aggregate statistics of user events across all threads in each node.
      Typically, this should be called just before the main thread exits.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2015"></a>3.9.14.&nbsp;TAU_REPORT_THREAD_STATISTICS()</h3></div></div></div><p>TAU_REPORT_THREAD_STATISTICS prints the aggregate, as well
      as per thread user event statistics. Typically, this should be called
      just before the main thread exits. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2020"></a>3.9.15.&nbsp;TAU_TRACE_SENDMSG(tag, destination, length)</h3></div></div></div><em class="parameter"><code>
Arguments: 
integer tag 
integer destination
integer length
</code></em><p>TAU_TRACE_SENDMSG traces an inter-process message
       communication when a tagged message is sent to a destination process.
       </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2027"></a>3.9.16.&nbsp;TAU_TRACE_RECVMSG(tag, source, length)</h3></div></div></div><em class="parameter"><code>
Arguments: 
integer tag
integer source
integer length
</code></em><p><code class="literal">TAU_TRACE_RECVMSG</code> traces a receive
      operation where tag represents the type of the message received from the
      source process.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SectionSummary"></a>3.10.&nbsp;Summary</h2></div></div></div><p>In C++, a single macro <code class="literal">TAU_PROFILE</code>, is
    sufficient to profile a block of statements. In C and Fortran, the user
    must use statement level timers to achieve this, using
    <code class="literal">TAU_PROFILE_TIMER</code>,
    <code class="literal">TAU_PROFILE_START</code> and
    <code class="literal">TAU_PROFILE_STOP</code>. Instrumentation of C++ source code
    can be done manually or by using tau_instrumentor, a tool that can
    automatically insert TAU annotations in the source code. Implementation
    of a Fortran 90 instrumentor is in progress. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Profiling"></a>Chapter&nbsp;4.&nbsp;Profiling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#RunningApplication">4.1. Running the application</a></span></dt><dt><span class="sect1"><a href="#RunningDynInstAIP">4.2. Running an application using DynInstAPI</a></span></dt><dt><span class="sect1"><a href="#PerformanceCounters">4.3. Using Hardware Performance Counters</a></span></dt><dt><span class="sect1"><a href="#MultipleHardwareCounters">4.4. Using Multiple Hardware Counters for Measurement</a></span></dt><dt><span class="sect1"><a href="#RunningJAVA">4.5. Running a JAVA application with TAU</a></span></dt><dt><span class="sect1"><a href="#RunningPython">4.6. Running a Python application with TAU</a></span></dt><dt><span class="sect1"><a href="#pprof">4.7. pprof</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div>This chapter describes running an instrumented application
  and the generation and subsequent analysis of profile data. Profiling
  shows the summary statistics of performance metrics that characterize
  application performance behavior. Examples of performance metrics are
  the CPU time associated with a routine, the count of the secondary data
  cache misses associated with a group of statements, the number of times
  a routine executes, etc. </div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningApplication"></a>4.1.&nbsp;Running the application</h2></div></div></div><p>After instrumentation and compilation are completed, the
    profiled application is run to generate the profile data files. These
    files can be stored in a directory specified by the environment variable
    <code class="literal">PROFILEDIR</code> as explained in Chapter 2. By default, all instrumented
    routines and statements are measured. To selectively measure groups of
    routines and statements, we can use the command-line parameter
    <code class="literal">--profile</code> to specify the statements to be profiled.
    Example: </p><pre class="screen">

% setenv PROFILEDIR /home/sameer/profiledata/experiment55
% mpirun -np 4 matrix 
</pre><p>This profiles all routines</p><pre class="screen">
% mpirun -np 4 matrix --profile io+field+2
</pre><p>The above profiles routines belonging to <code class="literal">TAU_IO, TAU_FIELD and TAU_USER2</code> profile groups. For a detailed list of groups, please refer to <code class="literal">[TAU-PGROUPS-URL]</code></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningDynInstAIP"></a>4.2.&nbsp;Running an application using DynInstAPI</h2></div></div></div><p>Install DynInstAPI package and refer to the installed directory while configuring TAU. Use <code class="literal">tau_run</code>, a tool that instruments the application at runtime.</p><p>The commandline options accepted by tau_run are:</p><pre class="screen">
Usage: tau_run [-Xrun&lt;Taulibrary&gt; ][-v][-o outfile] \
       [-f &lt;instrumentation file&gt; ] &lt;application&gt; [args]
</pre><p>By default, <code class="literal">libTAU</code>. so is loaded by
    tau_run. However, the user can override this and specify another file
    using the -Xrun&lt;Taulibrary&gt;. In this case lib&lt;Taulibrary&gt;.so
    will be loaded using <code class="literal">LD_LIBRARY_PATH</code>. The -f
    &lt;instrumentation file&gt; option can be used to specify an
    exclude/include list of routines and/or files for instrumentation. The
    list of routines to be excluded from instrumentation is specified, one
    per line, enclosed by <code class="literal">BEGIN_EXCLUDE_LIST</code> and
    <code class="literal">END_EXCLUDE_LIST</code>. Instead of specifying which
    routines should be excluded, the user can specify the list of routines
    that are to be instrumented using the include list, one routine name per
    line, enclosed by <code class="literal">BEGIN_INCLUDE_LIST</code> and
    <code class="literal">END_INCLUDE_LIST</code>. Files are specified using the
    <code class="literal">BEGIN_FILE_INCLUDE_LIST/END_FILE_INCLUDE_LIST</code> and
    <code class="literal">BEGIN_FILE_EXCLUDE_LIST/END_FILE_EXCLUDE_LIST</code> tags.
    Wildcards * and ? may be used while specifying file names.</p><p>Example:</p><pre class="screen">

BEGIN_EXCLUDE_LIST
void quicksort(int *, int, int)
void sort_5elements(int *)
void interchange(int *, int *)
END_EXCLUDE_LIST

BEGIN_FILE_EXCLUDE_LIST
*.so
END_FILE_EXCLUDE_LIST
</pre><p>To use <code class="literal">tau_run</code>, TAU is configured with
    DyninstAPI as shown below:</p><pre class="screen">
% configure -dyninst=/usr/local/packages/dyninstAPI
% make install
% cd tau/examples/dyninst
% make install
% tau_run klargest 2500 23
% pprof; paraprof
</pre><p>Support for new platforms and compilers is being added and this DyninstAPI option is experimental for now. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PerformanceCounters"></a>4.3.&nbsp;Using Hardware Performance Counters</h2></div></div></div><p>Performance counters exist on modern microprocessors. These
    count hardware performance events such as cache misses, floating point
    operations, etc. while the program executes on the processor. The
    Performance Data Standard and <code class="literal">API (PAPI, [PAPI-URL])</code>
    and Performance Counter Library <code class="literal">(PCL, [PCL-URL])</code>
    packages provide a uniform interface to access these performance
    counters. TAU can use either <code class="literal">PAPI</code> or
    <code class="literal">PCL</code> to access these hardware performance counters. To
    do so, download and install <code class="literal">PAPI</code> or
    <code class="literal">PCL</code>. Then, configure TAU using the -pcl=&lt;dir&gt;
    or -papi=&lt;dir&gt; configuration command-line option to specify the
    location of <code class="literal">PCL</code> or <code class="literal"> PAPI</code>. Build
    TAU and applications as you normally would (as described in Chapters 2
    and 3). While running the application, set the environment variable
    <code class="literal">PCL_EVENT</code> or <code class="literal">PAPI_EVENT</code>
    respectively, to specify which hardware performance counter TAU should
    use while profiling the application. For example to measure the floating
    point operations in routines using <code class="literal">PCL</code>,</p><pre class="screen">
% ./configure -pcl=/usr/local/packages/pcl-1.2
% setenv PCL_EVENT PCL_FP_INSTR 
% mpirun -np 8 application
</pre><div class="table"><a name="d0e2173"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;TABLE 2. Events measured by setting the enviroment variable PCL_EVENT in TAU</b></p><table summary="TABLE 2. Events measured by setting the enviroment variable PCL_EVENT in TAU" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">PCL_EVENT</th><th align="left">EVENT Measured</th></tr></thead><tbody><tr><td align="left">PCL_L1CACHE_READ</td><td align="left">L1 (Level one) cache reads</td></tr><tr><td align="left">PCL_L1CACHE_WRITE</td><td align="left">L1 cache writes</td></tr><tr><td align="left">PCL_L1CACHE_READWRITE</td><td align="left">L1 cache reads and writes</td></tr><tr><td align="left">PCL_L1CACHE_HIT</td><td align="left">L1 cache hits</td></tr><tr><td align="left">PCL_L1CACHE_MISS</td><td align="left">L1 cache misses</td></tr><tr><td align="left">PCL_L1DCACHE_READ</td><td align="left">L1 data cache reads</td></tr><tr><td align="left">PCL_L1DCACHE_WRITE</td><td align="left">L1 data cache writes</td></tr><tr><td align="left">PCL_L1DCACHE_READWRITE</td><td align="left">L1 data cache reads and writes</td></tr><tr><td align="left">PCL_L1DCACHE_HIT</td><td align="left">L1 data cache hits</td></tr><tr><td align="left">PCL_L1DCACHE_MISS</td><td align="left">L1 data cache misses</td></tr><tr><td align="left">PCL_L1ICACHE_READ</td><td align="left">L1 instruction cache reads</td></tr><tr><td align="left">PCL_L1ICACHE_WRITE</td><td align="left">L1 instruction cache writes</td></tr><tr><td align="left">PCL_L1ICACHE_READWRITE</td><td align="left">L1 instruction cache reads and writes</td></tr><tr><td align="left">PCL_L1ICACHE_HIT</td><td align="left">L1 instruction cache hits</td></tr><tr><td align="left">PCL_L1ICACHE_MISS</td><td align="left">L1 instruction cache misses</td></tr><tr><td align="left">PCL_L2CACHE_READ</td><td align="left">L2 (Level two) cache reads</td></tr><tr><td align="left">PCL_L2CACHE_WRITE</td><td align="left">L2 cache writes</td></tr><tr><td align="left">PCL_L2CACHE_READWRITE</td><td align="left">L2 cache reads and writes</td></tr><tr><td align="left">PCL_L2CACHE_HIT</td><td align="left">L2 cache hits</td></tr><tr><td align="left">PCL_L2CACHE_MISS</td><td align="left">L2 cache misses</td></tr><tr><td align="left">PCL_L2DCACHE_READ</td><td align="left">L2 data cache reads</td></tr><tr><td align="left">PCL_L2DCACHE_WRITE</td><td align="left">L2 data cache writes</td></tr><tr><td align="left">PCL_L2DCACHE_READWRITE</td><td align="left">L2 data cache reads and writes</td></tr><tr><td align="left">PCL_L2DCACHE_HIT</td><td align="left">L2 data cache hits</td></tr><tr><td align="left">PCL_L2DCACHE_MISS</td><td align="left">L2 data cache misses</td></tr><tr><td align="left">PCL_L2ICACHE_READ</td><td align="left">L2 instruction cache reads</td></tr><tr><td align="left">PCL_L2ICACHE_WRITE</td><td align="left">L2 instruction cache writes</td></tr><tr><td align="left">PCL_L2ICACHE_READWRITE</td><td align="left">L2 instruction cache reads and writes</td></tr><tr><td align="left">PCL_L2ICACHE_HIT</td><td align="left">L2 instruction cache hits</td></tr><tr><td align="left">PCL_L2ICACHE_MISS</td><td align="left">L2 instruction cache misses</td></tr><tr><td align="left">PCL_TLB_HIT</td><td align="left">TLB (Translation Lookaside Buffer) hits</td></tr><tr><td align="left">PCL_TLB_MISS</td><td align="left">TLB misses</td></tr><tr><td align="left">PCL_ITLB_HIT</td><td align="left">Instruction TLB hits</td></tr><tr><td align="left">PCL_ITLB_MISS</td><td align="left">Instruction TLB misses</td></tr><tr><td align="left">PCL_DTLB_HIT</td><td align="left">Data TLB hits</td></tr><tr><td align="left">PCL_DTLB_MISS</td><td align="left">Data TLB misses</td></tr><tr><td align="left">PCL_CYCLES</td><td align="left">Cycles</td></tr><tr><td align="left">PCL_ELAPSED_CYCLES</td><td align="left">Cycles elapsed</td></tr><tr><td align="left">PCL_INTEGER_INSTR</td><td align="left">Integer instructions executed</td></tr><tr><td align="left">PCL_FP_INSTR</td><td align="left">Floating point (FP) instructions executed</td></tr><tr><td align="left">PCL_LOAD_INSTR</td><td align="left">Load instructions executed</td></tr><tr><td align="left">PCL_STORE_INSTR</td><td align="left">Store instructions executed</td></tr><tr><td align="left">PCL_LOADSTORE_INSTR</td><td align="left">Loads and stores executed</td></tr><tr><td align="left">PCL_INSTR</td><td align="left">Instructions executed</td></tr><tr><td align="left">PCL_JUMP_SUCCESS</td><td align="left">Successful jumps executed</td></tr><tr><td align="left">PCL_JUMP_UNSUCCESS</td><td align="left">Unsuccessful jumps executed</td></tr><tr><td align="left">PCL_JUMP</td><td align="left">Jumps executed</td></tr><tr><td align="left">PCL_ATOMIC_SUCCESS</td><td align="left">Successful atomic instructions executed</td></tr><tr><td align="left">PCL_ATOMIC_UNSUCCESS</td><td align="left">Unsuccessful atomic instructions executed</td></tr><tr><td align="left">PCL_ATOMIC</td><td align="left">Atomic instructions executed</td></tr><tr><td align="left">PCL_STALL_INTEGER</td><td align="left">Integer stalls</td></tr><tr><td align="left">PCL_STALL_FP</td><td align="left">Floating point stalls</td></tr><tr><td align="left">PCL_STALL_JUMP</td><td align="left">Jump stalls</td></tr><tr><td align="left">PCL_STALL_LOAD</td><td align="left">Load stalls</td></tr><tr><td align="left">PCL_STALL_STORE</td><td align="left">Store Stalls</td></tr><tr><td align="left">PCL_STALL</td><td align="left">Stalls</td></tr><tr><td align="left">PCL_MFLOPS</td><td align="left">Millions of floating point operations/second</td></tr><tr><td align="left">PCL_IPC</td><td align="left">Instructions executed per cycle</td></tr><tr><td align="left">PCL_L1DCACHE_MISSRATE</td><td align="left">Level 1 data cache miss rate</td></tr><tr><td align="left">PCL_L2DCACHE_MISSRATE</td><td align="left">Level 2 data cache miss rate</td></tr><tr><td align="left">PCL_MEM_FP_RATIO</td><td align="left">Ratio of memory accesses to FP operations</td></tr></tbody></table></div><p>To select floating point instructions for profiling using
    <code class="literal">PAPI</code>, you would:</p><pre class="screen">
% configure -papi=/usr/local/packages/papi-2.3
% make clean install
% cd examples/papi
% setenv PAPI_EVENT PAPI_FP_INS
% a.out
</pre><div class="table"><a name="d0e2498"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;TABLE 3.  Events measured by setting the environment variable PAPI_EVENT in TAU</b></p><table summary="TABLE 3.  Events measured by setting the environment variable PAPI_EVENT in TAU" border="1"><colgroup><col align="left" width="50%"><col align="left" width="50%"></colgroup><thead><tr><th align="left">PAPI_EVENT</th><th align="left">EVENT Measured</th></tr></thead><tbody><tr><td align="left">PAPI_L1_DCM</td><td align="left">Level 1 data cache misses</td></tr><tr><td align="left">PAPI_L1_ICM</td><td align="left">Level 1 instruction cache misses</td></tr><tr><td align="left">PAPI_L2_DCM</td><td align="left">Level 2 data cache misses</td></tr><tr><td align="left">PAPI_L2_ICM</td><td align="left">Level 2 instruction cache misses</td></tr><tr><td align="left">PAPI_L3_DCM</td><td align="left">Level 3 data cache misses</td></tr><tr><td align="left">PAPI_L3_ICM</td><td align="left">Level 3 instruction cache misses</td></tr><tr><td align="left">PAPI_L1_TCM</td><td align="left">Level 1 total cache misses</td></tr><tr><td align="left">PAPI_L2_TCM</td><td align="left">Level 2 total cache misses</td></tr><tr><td align="left">PAPI_L3_TCM</td><td align="left">Level 3 total cache misses</td></tr><tr><td align="left">PAPI_CA_SNP</td><td align="left">Snoops</td></tr><tr><td align="left">PAPI_CA_SHR</td><td align="left">Request for access to shared cache line (SMP)</td></tr><tr><td align="left">PAPI_CA_CLN</td><td align="left">Request for access to clean cache line (SMP)</td></tr><tr><td align="left">PAPI_CA_INV</td><td align="left">Cache Line Invalidation (SMP)</td></tr><tr><td align="left">PAPI_CA_ITV</td><td align="left">Cache Line Intervention (SMP)</td></tr><tr><td align="left">PAPI_L3_LDM</td><td align="left">Level 3 load misses</td></tr><tr><td align="left">PAPI_L3_STM</td><td align="left">Level 3 store misses</td></tr><tr><td align="left">PAPI_BRU_IDL</td><td align="left">Cycles branch units are idle</td></tr><tr><td align="left">PAPI_FXU_IDL</td><td align="left">Cycles integer units are idle</td></tr><tr><td align="left">PAPI_FPU_IDL</td><td align="left">Cycles floating point units are idle</td></tr><tr><td align="left">PAPI_LSU_IDL</td><td align="left">Cycles load/store units are idle</td></tr><tr><td align="left">PAPI_TLB_DM</td><td align="left">Data translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_TLB_IM</td><td align="left">Instruction translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_TLB_TL</td><td align="left"> Total translation lookaside buffer misses</td></tr><tr><td align="left">PAPI_L1_LDM</td><td align="left">Level 1 load misses</td></tr><tr><td align="left">PAPI_L1_STM</td><td align="left">Level 1 store misses</td></tr><tr><td align="left">PAPI_L2_LDM</td><td align="left">Level 2 load misses</td></tr><tr><td align="left">PAPI_L2_STM</td><td align="left">Level 2 store misses</td></tr><tr><td align="left">PAPI_BTAC_M</td><td align="left">BTAC miss</td></tr><tr><td align="left">PAPI_PRF_DM</td><td align="left">Prefetch data instruction caused a miss</td></tr><tr><td align="left">PAPI_L3_DCH</td><td align="left">Level 3 Data Cache Hit</td></tr><tr><td align="left">PAPI_TLB_SD</td><td align="left">Translation lookaside buffer shootdowns (SMP)</td></tr><tr><td align="left">PAPI_CSR_FAL</td><td align="left">Failed store conditional instructions</td></tr><tr><td align="left">PAPI_CSR_SUC</td><td align="left">Successful store conditional instructions</td></tr><tr><td align="left">PAPI_CSR_TOT</td><td align="left">Total store conditional instructions</td></tr><tr><td align="left">PAPI_MEM_SCY</td><td align="left">Cycles Stalled Waiting for Memory Access</td></tr><tr><td align="left">PAPI_MEM_RCY</td><td align="left">Cycles Stalled Waiting for Memory Read</td></tr><tr><td align="left">PAPI_MEM_WCY</td><td align="left">Cycles Stalled Waiting for Memory Write</td></tr><tr><td align="left">PAPI_STL_ICY</td><td align="left">Cycles with No Instruction Issue</td></tr><tr><td align="left">PAPI_FUL_ICY</td><td align="left">Cycles with Maximum Instruction Issue</td></tr><tr><td align="left">PAPI_STL_CCY</td><td align="left">Cycles with No Instruction Completion</td></tr><tr><td align="left">PAPI_FUL_CCY</td><td align="left">Cycles with Maximum Instruction Completion</td></tr><tr><td align="left">PAPI_HW_INT</td><td align="left">Hardware interrupts</td></tr><tr><td align="left">PAPI_BR_UCN</td><td align="left">Unconditional branch instructions executed</td></tr><tr><td align="left">PAPI_BR_CN</td><td align="left">Conditional branch instructions executed</td></tr><tr><td align="left">PAPI_BR_TKN</td><td align="left">Conditional branch instructions taken</td></tr><tr><td align="left">PAPI_BR_NTK</td><td align="left">Conditional branch instructions not taken</td></tr><tr><td align="left">PAPI_BR_MSP</td><td align="left">Conditional branch instructions mispredicted</td></tr><tr><td align="left">PAPI_BR_PRC</td><td align="left">Conditional branch instructions correctly predicted</td></tr><tr><td align="left">PAPI_FMA_INS</td><td align="left">FMA instructions completed</td></tr><tr><td align="left">PAPI_TOT_IIS</td><td align="left">Total instructions issued</td></tr><tr><td align="left">PAPI_TOT_INS</td><td align="left">Total instructions executed</td></tr><tr><td align="left">PAPI_INT_INS</td><td align="left">Integer instructions executed</td></tr><tr><td align="left">PAPI_FP_INS</td><td align="left">Floating point instructions executed</td></tr><tr><td align="left">PAPI_LD_INS</td><td align="left">Load instructions executed</td></tr><tr><td align="left">PAPI_SR_INS</td><td align="left">Store instructions executed</td></tr><tr><td align="left">PAPI_BR_INS</td><td align="left">Total branch instructions executed</td></tr><tr><td align="left">PAPI_VEC_INS</td><td align="left">Vector/SIMD instructions executed</td></tr><tr><td align="left">PAPI_FLOPS</td><td align="left">Floating Point Instructions executed per second</td></tr><tr><td align="left">PAPI_RES_STL</td><td align="left">Cycles processor is stalled on resource</td></tr><tr><td align="left">PAPI_FP_STAL</td><td align="left">FP units are stalled</td></tr><tr><td align="left">PAPI_TOT_CYC</td><td align="left">Total cycles</td></tr><tr><td align="left">PAPI_IPS</td><td align="left">Instructions executed per second</td></tr><tr><td align="left">PAPI_LST_INS</td><td align="left">Total load/store instructions executed</td></tr><tr><td align="left">PAPI_SYC_INS</td><td align="left">Synchronization instructions executed</td></tr><tr><td align="left">PAPI_L1_DCH</td><td align="left">L1 D Cache Hit</td></tr><tr><td align="left">PAPI_L2_DCH</td><td align="left">L2 D Cache Hit</td></tr><tr><td align="left">PAPI_L1_DCA</td><td align="left">L1 D Cache Access</td></tr><tr><td align="left">PAPI_L2_DCA</td><td align="left">L2 D Cache Access</td></tr><tr><td align="left">PAPI_L3_DCA</td><td align="left">L3 D Cache Access</td></tr><tr><td align="left">PAPI_L1_DCR</td><td align="left">L1 D Cache Read</td></tr><tr><td align="left">PAPI_L2_DCR</td><td align="left">L2 D Cache Read</td></tr><tr><td align="left">PAPI_L3_DCR</td><td align="left">L3 D Cache Read</td></tr><tr><td align="left">PAPI_L1_DCW</td><td align="left">L1 D Cache Write</td></tr><tr><td align="left">PAPI_L2_DCW</td><td align="left">L2 D Cache Write</td></tr><tr><td align="left">PAPI_L3_DCW</td><td align="left">L3 D Cache Write</td></tr><tr><td align="left">PAPI_L1_ICH</td><td align="left">L1 instruction cache hits</td></tr><tr><td align="left">PAPI_L2_ICH</td><td align="left">L2 instruction cache hits</td></tr><tr><td align="left">PAPI_L3_ICH</td><td align="left">L3 instruction cache hits</td></tr><tr><td align="left">PAPI_L1_ICA</td><td align="left">L1 instruction cache accesses</td></tr><tr><td align="left">PAPI_L2_ICA</td><td align="left">L2 instruction cache accesses</td></tr><tr><td align="left">PAPI_L3_ICA</td><td align="left">L3 instruction cache accesses</td></tr><tr><td align="left">PAPI_L1_ICR</td><td align="left">L1 instruction cache reads</td></tr><tr><td align="left">PAPI_L2_ICR</td><td align="left">L2 instruction cache reads</td></tr><tr><td align="left">PAPI_L3_ICR</td><td align="left">L3 instruction cache reads</td></tr><tr><td align="left">PAPI_L1_ICW</td><td align="left">L1 instruction cache writes</td></tr><tr><td align="left">PAPI_L2_ICW</td><td align="left">L2 instruction cache writes</td></tr><tr><td align="left">PAPI_L3_ICW</td><td align="left">L3 instruction cache writes</td></tr><tr><td align="left">PAPI_L1_TCH</td><td align="left">L1 total cache hits</td></tr><tr><td align="left">PAPI_L2_TCH</td><td align="left">L2 total cache hits</td></tr><tr><td align="left">PAPI_L3_TCH</td><td align="left">L3 total cache hits</td></tr><tr><td align="left">PAPI_L1_TCA</td><td align="left">L1 total cache accesses</td></tr><tr><td align="left">PAPI_L2_TCA</td><td align="left">L2 total cache accesses</td></tr><tr><td align="left">PAPI_L3_TCA</td><td align="left">L3 total cache accesses</td></tr><tr><td align="left">PAPI_L1_TCR</td><td align="left">L1 total cache reads</td></tr><tr><td align="left">PAPI_L2_TCR</td><td align="left">L2 total cache reads</td></tr><tr><td align="left">PAPI_L3_TCR</td><td align="left">L3 total cache reads</td></tr><tr><td align="left">PAPI_L1_TCW</td><td align="left">L1 total cache writes</td></tr><tr><td align="left">PAPI_L2_TCW</td><td align="left">L2 total cache writes</td></tr><tr><td align="left">PAPI_L3_TCW</td><td align="left">L3 total cache writes</td></tr><tr><td align="left">PAPI_FML_INS</td><td align="left">FM ins</td></tr><tr><td align="left">PAPI_FAD_INS</td><td align="left">FA ins</td></tr><tr><td align="left">PAPI_FDV_INS</td><td align="left">FD ins</td></tr><tr><td align="left">PAPI_FSQ_INS</td><td align="left">FSq ins</td></tr><tr><td align="left">PAPI_FNV_INS</td><td align="left">Finv ins</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MultipleHardwareCounters"></a>4.4.&nbsp;Using Multiple Hardware Counters for Measurement</h2></div></div></div><p>TAU can be configured to record more than one hardware
    performance counter, along with time for each timer and routine. To use
    this feature, TAU is configured with the
    <code class="literal">-MULTIPLECOUNTERS</code> option. Example:</p><pre class="screen">

%./configure -MULTIPLECOUNTERS -LINUXTIMERS -CPUTIME \
             -papi=/tools/papi-2.3
</pre><p>LIST OF COUNTERS:</p><p>Set the following values for the COUNTER&lt;1-25&gt; environment variables.</p><div class="itemizedlist"><p>and PAPI/PCL options that can be found in Tables 2 &amp; 3. Example:</p><ul type="disc"><li><code class="literal">GET_TIME_OF_DAY</code>    --- For the default profiling option using gettimeofday()</li><li><code class="literal">SGI_TIMERS</code>         --- For <code class="literal">-SGITIMERS</code> configuration option under IRIX</li><li><code class="literal">CRAY_TIMERS</code>   --- For <code class="literal">-CRAYTIMERS</code> configuration option under Cray X1.</li><li><code class="literal">LINUX_TIMERS</code>       --- For -LINUXTIMERS configuration option under Linux</li><li><code class="literal">CPU_TIME</code>           --- For user+system time from getrusage() call with <code class="literal">-CPUTIME</code></li><li><code class="literal">P_WALL_CLOCK_TIME</code> --- For PAPI's WALLCLOCK time using <code class="literal">-PAPIWALLCLOCK</code></li><li><code class="literal">P_VIRTUAL_TIME</code>     --- For PAPI's process virtual time using <code class="literal">-PAPIVIRTUAL</code></li><li><code class="literal">TAU_MUSE</code> --- For reading counts of
      Linux OS kernel level events when MAGNET/MUSE is installed and -muse
      configuration option is enabled.
      [MUSE-URL].<code class="literal">TAU_MUSE_PACKAGE</code> environment variable has
      to be set to package name (busy_time, count, etc.)</li><li><code class="literal">TAU_MPI_MESSAGE_SIZE</code>  --- For tracking message sizes sent by a node for each routine. </li><li><code class="literal">PCL_FP_INSTR</code>       --- For floating point operations using PCL (-pcl=&lt;dir&gt;)</li><li><code class="literal">PAPI_FP_INS</code>        --- For floating point operations using PAPI (-papi=&lt;dir&gt;)</li></ul></div><p><span class="emphasis"><em>NOTE:</em></span> When
    <code class="literal">-MULTIPLECOUNTERS</code> is used with
    <code class="literal">-TRACE</code> option, the tracing library uses the wallclock
    time from the function specified in the <code class="literal">COUNTER1</code>
    variable. This should typically point to wallclock time routines (such
    as <code class="literal">GET_TIME_OF_DAY or SGI_TIMERS</code> or
    <code class="literal">LINUX_TIMERS</code>).</p><p>Example:</p><pre class="screen">
% setenv COUNTER1   P_WALL_CLOCK_TIME
% setenv COUNTER2 PAPI_L1_DCM
% setenv COUNTER3 PAPI_FP_INS
</pre><p>will produce profile files in directories called <code class="literal">MULT_P_WALL_CLOCK_TIME, MULTI__PAPI_L1_DCM, and MULTI_PAPI_FP_INS.</code></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningJAVA"></a>4.5.&nbsp;Running a JAVA application with TAU</h2></div></div></div><p>Java applications are profiled/traced using the <code class="literal">-XrunTAU</code> command-line parameter as shown below:</p><pre class="screen">
% cd tau/examples/java/pi
% setenv LD_LIBRARY_PATH $LD_LIBRARY_PATH:/home/tau/
solaris2/lib
% java -XrunTAU Pi
</pre><p>Running the application generates profile files with names
    having the form profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.
    These files can be analyzed using pprof or paraprof (see below).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RunningPython"></a>4.6.&nbsp;Running a Python application with TAU</h2></div></div></div><p>TAU can automatically instrument all Python routines when the
    tau python package is imported. To execute the program, tau.run routine
    is invoked with the name of the top level Python code. For e.g.,</p><pre class="screen">
#!/usr/bin/env python

import tau
from time import sleep

def f2():
    print "Inside f2: sleeping for 2 secs..."
    sleep(2)
def f1():
    print "Inside f1, calling f2..."
    f2()

def OurMain():
    f1()

tau.run('OurMain()')
</pre><p>instruments routines <code class="literal">OurMain(), f1() and
    f2()</code> although there are no instrumentation calls in the
    routines. To use this feature, TAU must be configured with the
    -pythoninc=&lt;dir&gt; option (and -pythonlib=&lt;dir&gt; if running
    under IBM). Before running the application, the environment variable
    <code class="literal">PYTHONPATH</code> should be set to include the TAU library
    directory (where tau.py is stored). Manual instrumentation of Python
    sources is also possible using the Python API and the
    <code class="literal">pytau</code> package. For e.g.,</p><pre class="screen">

#!/usr/bin/env python

import pytau
from time import sleep

x = pytau.profileTimer("A Sleep for excl 5 secs")
y = pytau.profileTimer("B Sleep for excl 2 secs")
pytau.start(x)
print "Sleeping for 5 secs ..."
sleep(5)
pytau.start(y)
print "Sleeping for 2 secs ..."
sleep(2)
pytau.stop(y)
pytau.dbDump()
pytau.stop(x)
</pre><p>shows how two timers x and y are created and used. Note,
     multiple timers can be nested, but not overlapping. Overlapping timers
     are detected by TAU at runtime and flagged with a warning (as exclusive
     time is not defined when timers overlap).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pprof"></a>4.7.&nbsp;pprof</h2></div></div></div><p>pprof sorts and displays profile data generated by TAU. To
    view the profile, merely execute pprof in the directory where profile
    files are located (or set the <code class="literal">PROFILEDIR</code> environment
    variable).</p><pre class="screen">
% pprof
</pre><p>Its usage is explained below:</p><pre class="screen">
usage: pprof [-c|-b|-m|-t|-e|-i] [-r] [-s] [-n num] [-f filename] \
       [-l] [node numbers]
  -c : Sort by number of Calls
  -b : Sort by number of suBroutines called by a function
  -m : Sort by Milliseconds (exclusive time total)
  -t : Sort by Total milliseconds (inclusive time total) (DEFAULT)
  -e : Sort by Exclusive time per call (msec/call)
  -i : Sort by Inclusive time per call (total msec/call)
  -v : Sort by standard deViation (excl usec)
  -r : Reverse sorting order
  -s : print only Summary profile information
  -n num : print only first num functions
  -f filename : specify full path and Filename without node ids 
  -l : List all functions and exit 
 node numbers : prints information about all contexts/threads 
 for specified nodes
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Tracing"></a>Chapter&nbsp;5.&nbsp;Tracing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#GeneratingEventTraces">5.1. Generating Event Traces</a></span></dt><dt><span class="sect1"><a href="#Vampir">5.2. Vampir: Visualizing TAU traces</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div><p>Typically, profiling shows the distribution of execution
  time across routines. It can show the code locations associated with
  specific bottlenecks, but it does not show the temporal aspect of
  performance variations. Tracing the execution of a parallel program
  shows when and where an event occurred, in terms of the process that
  executed it and the location in the source code. This chapter discusses
  how TAU can be used to generate event traces.</p><p>Figure 1 show the possible interations btween different trace file
  formats.</p><div class="figure"><a name="d0e3190"></a><p class="title"><b>Figure&nbsp;5.1.&nbsp;Performance Data IO Chart</b></p><div><img src="images/TAUChart.gif" alt="Performance Data IO Chart"></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GeneratingEventTraces"></a>5.1.&nbsp;Generating Event Traces</h2></div></div></div><p>TAU must be configured with the <code class="literal">-TRACE</code>
    option to generate event traces. This can be used in conjunction with
    <code class="literal">-PROFILE</code> to generate both profiles and traces. The
    traces are stored in a directory specified by the environment variable
    <code class="literal">TRACEDIR</code>, or the current directory, by default.
    Example:</p><pre class="screen">
% ./configure -SGITIMERS -arch=sgi64 -TRACE  -c++=KCC
% make clean; make install
% setenv TRACEDIR /users/sameer/tracedata/experiment56
% mpirun -np 4 matrix
</pre><p>This generates files named</p><pre class="screen">
tautrace.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.trc and events.&lt;node&gt;.edf 
</pre><p>Using the utility tau_merge, these traces are then merged as shown below:</p><pre class="screen">
% tau_merge 
usage: tau_merge [-a] [-r] inputtraces* (outputtrace|-)
Note: tau_merge assumes edf files are named 
      events.&lt;nodeid&gt;.edf, and generates a merged edf file tau.edf
% tau_merge tautrace*.trc matrix.trc
</pre><p>This generates matrix.trc as the merged trace file and tau.edf as the merged event description file.</p><p>To convert merged or per-thread traces to another trace format, the utility tau_convert is used as shown below:</p><pre class="screen">
% tau_convert
usage: tau_convert [-alog | -SDDF | -dump | -paraver [-t] | -pv | 
       -vampir [-longsymbolbugfix] [-compact] [-user|-class|-all] 
       [-nocomm]] inputtrc edffile [outputtrc]
 Note: -vampir option assumes multiple threads/node
 Note: -t option used in conjunction with -paraver option assumes 
       multiple threads/node
</pre><p>To view the dump of the trace in text form, use</p><pre class="screen">
% tau_convert -dump matrix.trc tau.edf 
</pre><p>tau_convert can also be used to convert traces to the Vampir
    trace format <code class="literal">[VAMPIR-URL]</code>. For single-threaded
    applications (such as the MPI application above), the
    <code class="literal">-pv</code> option is used to generate Vampir traces as
    follows:</p><pre class="screen">
% tau_convert -pv matrix.trc tau.edf matrix.pv
% vampir matrix.pv &amp;
</pre><p>To convert TAU traces to <code class="literal">SDDF</code> or
    <code class="literal">ALOG</code> trace formats, <code class="literal">-SDDF</code> and
    <code class="literal">-alog</code> options may be used. When multiple threads are
    used on a node (as with <code class="literal">-jdk, -pthread or
    -tulipthread</code> options during configure), the
    <code class="literal">-vampir</code> option is used to convert the traces to the
    vampir trace format, as shown below:</p><pre class="screen">

% tau_convert -vampir smartsapp.trc tau.edf smartsapp.pv
% vampir smartsapp.pv &amp;
</pre><p>To convert to the Paraver trace format, use the
    <code class="literal">-paraver</code> option for single threaded programs and
    <code class="literal">-paraver -t</code> option for multi-threaded programs.
    </p><p><span class="emphasis"><em>NOTE:</em></span> To ensure that inter-process
    communication events are recorded in the traces, in addition to the
    routine transitions, it is necessary to insert
    <code class="literal">TAU_TRACE_SENDMSG</code> and
    <code class="literal">TAU_TRACE_RECVMSG</code> macro calls in the source code
    during instrumentation. This is not needed when the TAU MPI Wrapper
    library is used. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Vampir"></a>5.2.&nbsp;Vampir: Visualizing TAU traces</h2></div></div></div><p>Vampir is a robust parallel trace visualization tool sold by
    Pallas GmbH <code class="literal">[PALLAS-URL]</code>. It provides a convenient
    way to graphically analyze the performance characteristics of a parallel
    application. A variety of graphical displays present important aspects
    of the application runtime behavior:</p><div class="itemizedlist"><ul type="disc"><li>detailed timeline views of events and communication</li><li>statistical analysis of program execution</li><li>statistical analysis of communication operations</li><li>system snapshot and animation</li><li>dynamic calling tree</li></ul></div><p>When interprocess communication is recorded, it shows up as
    directed line-segments connecting the sending and receiving processes.
    The details of a message can be obtained by clicking on it.</p><p>In Figure 15, "Scheduling work packets in SMARTS," on
    page 106, we show how Vampir can be used to display scheduling of work
    packets or iterates in the Shared Memory Asynchronous Runtime System
    (SMARTS) [SMARTS-URL]</p><p>In the next figure, we see the symbol legend and the dynamic call tree views provided by Vampir.</p><p>Vampir has been used to compare the scheduling policies of the SMARTS package.</p><p>The following figures illustrate the use of Vampir with Java
    applications. After converting the traces and invoking Vampir, choose
    appropriate colors for groups of methods using
    Preferences-&gt;Colors-&gt;Activities menu in Vampir.</p><p>Clicking on a process(thread) selects it. Then the user can
    see the dynamic call tree of the process by choosing the Process
    Displays-&gt;Call Tree menu item as shown below.</p><p>Vampir has a rich set of global displays. By choosing the
    Global Displays -&gt;Parallelism View the user can see how many threads
    participate in an activity belonging to a group at any point in time.
    All timeline displays support a zoom option where the user can zoom into
    or out of a section of the trace.</p><p>By choosing other global displays such as Summary chart or
    Activity chart, the user can see a global summary of the time spent in
    different groups of methods as shown in the following figure.</p><p>Hybrid execution models can be traced in TAU by enabling
    support for the appropriate message passing model and thread package.
    One example of such a mixed model program is shown in the following
    figure. It shows a trace of an OpenMP+MPI (OpenMPI) program that uses
    OpenMP threads for loop-level parallelism and MPI for inter-context
    message communication. The figure shows a timeline display. </p><p>Another example of mixed model programming is shown below. It
    shows an mpiJava <code class="literal">[MPIJAVA-URL]</code> program that uses the
    message passing interface (MPI) for inter-node communication and uses
    Java threads within each node for computation. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="PerformanceDatabase"></a>Chapter&nbsp;6.&nbsp;Performance Database</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Prerequisites">6.1. Prerequisites</a></span></dt><dt><span class="sect1"><a href="#Installation">6.2. Installation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3338">6.2.1. Create a database</a></span></dt><dt><span class="sect2"><a href="#d0e3354">6.2.2. Build PerfDB</a></span></dt><dt><span class="sect2"><a href="#d0e3361">6.2.3. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e3370">6.2.4. Loading database schema</a></span></dt><dt><span class="sect2"><a href="#d0e3377">6.2.5. Loading application data</a></span></dt><dt><span class="sect2"><a href="#d0e3388">6.2.6. Loading experiment data</a></span></dt><dt><span class="sect2"><a href="#d0e3406">6.2.7. Translating TAU profiles</a></span></dt><dt><span class="sect2"><a href="#d0e3423">6.2.8. Loading translated trial data</a></span></dt></dl></dd></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div>PerfDB is a performance database tool related to the TAU
  framework. The PerfDB database is designed to store and provide access
  to TAU profile data. A number of utility programs have been written in
  Java to load the data into PerfDB and to query the data. With PerfDB,
  users can perform performance analyses such as regression analysis,
  scalability analysis across multiple trials, and so on. An unlimited
  number of comparative analyses are available through the PerfDB toolkit.
  Work is being done to provide the user with standard analysis tools, and
  an API has been developed to access the data with standard Java
  classes.</div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Prerequisites"></a>6.1.&nbsp;Prerequisites</h2></div></div></div><div class="orderedlist"><ol type="1"><li>PostgreSQL 7.0 (or an equivalent DBMS) PerfDB requires a
      DataBase Management System (DBMS). It has been tested with both
      PostgreSQL and MySQL databases. The default database is PostgreSQL
      (http://www.postgresql.org).</li><li>Java 1.4 The PerfDB utilities and API are written in Java.</li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Installation"></a>6.2.&nbsp;Installation</h2></div></div></div><p>PerfDB is installed as part of the standard TAU release. Shell
    scripts are installed in the TAU bin directory to run the configuration
    and loading utilities. It is assumed that the user has installed TAU and
    run TAU's configure and 'make install'.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3338"></a>6.2.1.&nbsp;Create a database</h3></div></div></div><p>Once a DBMS is installed, a database needs to be created.
      This database can be called anything the user likes -
      <code class="literal">perfdb</code> is the default. If the DBMS is PostgreSQL, the
      command from the shell prompt is:</p><pre class="screen">
% createdb perfdb
</pre><p>If the user is in psql, the command is:</p><pre class="screen">
psql=# create database perfdb
</pre><p>Other DBMS are similar.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3354"></a>6.2.2.&nbsp;Build PerfDB</h3></div></div></div><p>Change directory to the $TAUROOT/tools/src/perfdb directory, and issue the command:</p><pre class="screen">
% make
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3361"></a>6.2.3.&nbsp;Configuration</h3></div></div></div><p>PerfDB needs to be configured for the first time use. To configure PerfDB, run the command (assuming $TAUROOT/$arch/bin is in your path):</p><pre class="screen">
% perfdb_configure
</pre><p>The configure program will prompt the user for several
      values. The default values in all cases will work for 99.9% of users.
      Unless you need to specify something other than the default values (for
      example, if you are using MySQL instead of PostgreSQL, you need to
      specify a different JDBC .jar file, driver name, and database vendor).
      The only value for which there is no default is the database username.
      Enter the name of a database user which has administrative access.
      Because the utilities use the 'COPY'command with PostgreSQL, the user
      requires administrative access. Once the configuration program collects
      the information, it prompts for the user's database password, and
      connects to the database to test the configuration. If the configuration
      is valid, the database schema is loaded into the database.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3370"></a>6.2.4.&nbsp;Loading database schema</h3></div></div></div><p>If the configuration ended successfully, then the database
      schema was loaded at the end of the configuration process. If problems
      occurred, then it may be necessary to load the database schema later. If
      that is the case, then the program to load the schema is:</p><pre class="screen">
%  perfdb_loadschema
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3377"></a>6.2.5.&nbsp;Loading application data</h3></div></div></div><p>To load application data, simply run the perfdb_loadapp
      program which takes a parameter &lt;-x | --xmlfile&gt; filename : the
      name of the application data file. </p><p>The xmlfile passed in is the application data file. A sample application data file is $TAUROOT/tools/src/perfdb/data/App_Info.xml. For e.g.,</p><pre class="screen">
% perfdb_loadapp -x App_Info.xml
</pre><p>The application loader will load the application, and return the ID of the application in the database.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3388"></a>6.2.6.&nbsp;Loading experiment data</h3></div></div></div><p>To load experiment data, simply run the <code class="literal">perfdb_loadexp</code> program. It takes two parameters:</p><p>&lt;-x | --xmlfile&gt; filename: the name of the experiment data file.</p><p>&lt;-a | --applicationid&gt; value: the value of the application ID</p><p>The xmlfile passed in is the experiment data file. A sample experiment data file is $TAUROOT/tools/src/perfdb/data/Exp_Info.xml. For e.g.,</p><pre class="screen">
% perfdb_loadexp -x Exp_Info.xml - a 1
</pre><p>The experiment loader will load the experiment, and return the ID of the experiment in the database.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3406"></a>6.2.7.&nbsp;Translating TAU profiles</h3></div></div></div><p>TAU data needs to be translated to XML in order to be loaded
      into the database. This is a simple operation, performed with the
      perfdb_translate program. There are several parameters for
      perfdb_translate:</p><p>&lt;-s | --sourcefile&gt; filename: the name of the TAU pprof dump format data file (created by pprof -d)</p><p>&lt;-d | --destinationfile&gt; filename: the name of the XML output file</p><p>&lt;-a | --applicationid&gt; value: the value of the application ID</p><p>&lt;-e | --experimentid&gt; value: the value of the experiment ID</p><p>For Example:</p><pre class="screen">
% pprof -d &gt; pprof.dat
% perfdb_translate -s pprof.dat -d pprof.xml -a 1 -e 1
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3423"></a>6.2.8.&nbsp;Loading translated trial data</h3></div></div></div><p>Once the data has been translated, it can be loaded into the
      database. The data is loaded by running the perfdb_loadtrial command. It
      takes the following parameters:</p><p>&lt;-x | --xmlfile&gt; filename: the name of the translated trial data file</p><p>&lt; -t | --trialid&gt; value: the value of an existing trial ID</p><p>&lt;-p | --problemfile&gt; filename: the name of a problem definition file</p><p>&lt;-p | --problemfile&gt; filename: the name of a problem definition file</p><p>perfdb_loadtrial can be run two ways. When creating a new
      trial, the user calls perfdb_loadtrial with an optional problem
      definition file. The problem definition file is a user-defined XML file
      that describes the trial data. An example problem definition file is in
      the data directory. For e.g.,</p><pre class="screen">
% perfdb_loadtrial -x pprof.xml -p sample_problem.xml
</pre><p>If the user is adding trial data to an existing trial (due to multiple metrics recorded during the run with TAU), then the problem file is omitted, and the trial ID is passed in:</p><pre class="screen">
% perfdb_loadtrial -t 1
</pre><p>Once the data has been loaded into the database, analysis can be performed. See the <code class="literal">${TAUROOT}/tools/src/dms/README</code> file for more details.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ChapterSummery"></a>Chapter&nbsp;7.&nbsp;Summary</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SoftwareAvalible">7.1. Software Availability</a></span></dt><dt><span class="sect1"><a href="#Credits">7.2. Acknowledgments</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"></div>The TAU performance framework and toolkit is an ongoing
  research and development project. The TAU Portable Profiling and Tracing
  Toolkit described in this document represents functionality present in
  the current software release. All available software should be
  considered research software available to the community under the BSD
  style license.</div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SoftwareAvalible"></a>7.1.&nbsp;Software Availability</h2></div></div></div><p>TAU Portable Profiling and Tracing Toolkit may be downloaded as
	 freeware from the following website <a href="http://www.cs.uoregon.edu/research/tau" target="_top">TAU</a>:</p><pre class="screen">
http://www.cs.uoregon.edu/research/tau
</pre><p>For more information, please refer to the documentation section at the above URL. Bug reports and comments may be sent to:</p><pre class="screen">
tau-bugs@cs.uoregon.edu
</pre><p>Technical papers about TAU can be downloaded from the TAU Publications
	 homepage at <a href="http://www.cs.uoregon.edu/research/tau/pubs.php" target="_top">TAU-PUBS</a></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Credits"></a>7.2.&nbsp;Acknowledgments</h2></div></div></div><p>The TAU development team wishes to thank the U.S. Government,
    Department of Energy for their support of the TAU project under the
    DOE-2000, DOE MICS office contract, University of Utah ASCI subcontract,
    and ASCI Level 3 grants. </p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="References"></a>Appendix&nbsp;A.&nbsp;References</h2></div></div></div><p>URL's</p><p><a href="http://www.cs.uoregon.edu/research/paracomp/tau" target="_top">TAU-URL</a></p><p><a href="http://www.cs.uoregon.edu/research/paracomp/tau/papers.html" target="_top">TAU-PUBS-URL</a></p><p><a href="http://www.acl.lanl.gov/tau/docs/selective.html" target="_top">TAU-PGROUPS-URL</a></p><p><a href="http://www.kai.com" target="_top">KAI-URL</a></p><p><a href="http://www.gnu.org" target="_top">GNU-URL</a></p><p><a href="http://www.pgroup.com" target="_top">PGI-URL</a></p><p><a href="http://www.tools.fujitsu.com/linux/index.shtml" target="_top">FUJITSU-URL</a></p><p><a href="http://www.scriptics.com" target="_top">TCLTK-URL</a></p><p><a href="http://www.nas.nasa.gov/Software/NPB/" target="_top">NPB-URL</a></p><p><a href="http://www.cs.umd.edu/projects/dyninstAPI/" target="_top">DYNINST-URL</a></p><p><a href="http://www.cs.umd.edu/projects/dyninstAPI/" target="_top">DYNINST-URL</a></p><p><a href="http://www.cs.wisc.edu/~paradyn/" target="_top">PARADYN-URL</a></p><p><a href="http://icl.cs.utk.edu/projects/papi/" target="_top">PAPI-URL</a></p><p><a href="http://www.fz-juelich.de/zam/PCL/" target="_top">PCL-URL</a></p><p><a href="http://www.csi.uoregon.edu/projects/parp/" target="_top">PARP-URL</a></p><p><a href="http://www.pallas.de/pages/vampir.htm" target="_top">VAMPIR-URL</a></p><p><a href="http://www.pallas.de" target="_top">PALLAS-URL</a></p><p><a href="http://www.acl.lanl.gov/pooma" target="_top">POOMA-URL</a></p><p><a href="http://www.acl.lanl.gov/smarts" target="_top">SMARTS-URL</a></p><p><a href="http://www.acl.lanl.gov/tulip" target="_top">TULIP-URL</a></p><p><a href="http://www.acl.lanl.gov/software/" target="_top">ACL-SW-URL</a></p><p><a href="http://www.openmp.org" target="_top">OPENMP-URL</a></p><p><a href="http://public.lanl.gov/radiant/" target="_top">MUSE-URL</a></p><p><a href="http://www.fz-juelich.de/zam/kojak/opari" target="_top">OPARI-URL]</a></p><p><a href="http://www.fz-juelich.de/zam/kojak" target="_top">EPILOG-URL</a></p><p><a href="http://www.acl.lanl.gov/pdtoolkit" target="_top">PDT-URL</a></p><p><a href="http://www-unix.mcs.anl.gov/mpi/" target="_top">MPI-URL</a></p><p><a href="http://www.npac.syr.edu/projects/pcrc/HPJava/mpiJava.html" target="_top">MPIJAVA-URL</a></p></div></div>
       </div>
       <?php include("../../footer.php") ?>
    </body></html>
