<?xml version="1.0"?>
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "../tools/docbook-xml-4.4/docbookx.dtd"> 
<reference>
	
  <title>TAU Instrumentation API</title>
  
  <partintro>


  <simplesect>
    <title>Introduction</title>

    <itemizedlist>
      
      <listitem><para><emphasis role="bold">C++</emphasis></para>
        <para>The C++ API is a set of macros that can be inserted in the C++
	source code. An extension of the same API is available to instrument C
	and Fortran sources.</para>
	
	<para>At the beginning of each instrumented source file, include the
	following header</para>
	
	<screen>
#include &lt;TAU.h&gt;
	</screen>

      </listitem>


      <listitem><para><emphasis role="bold">C</emphasis></para>
      <para>The API for instrumenting C source code is similar to the C++
        API. The primary difference is that the <literal>TAU_PROFILE()</literal> macro
	is not available for identifying an entire block of code or function.
	Instead, routine transitions are explicitly specified using
	<literal>TAU_PROFILE_TIMER()</literal> macro with
	<literal>TAU_PROFILE_START()</literal> and
	<literal>TAU_PROFILE_STOP()</literal> macros to indicate the entry and
	exit from a routine. Note that, <literal>TAU_TYPE_STRING()</literal> and
	CT() macros are not applicable for C. It is important to declare the
	<literal>TAU_PROFILE_TIMER()</literal> macro after all the variables
	have been declared in the function and before the execution of the first
        C statement. 
      </para>
    
		
      <para>Example:</para>
		
      <screen>

#include &lt;TAU.h&gt;

int main (int argc, char **argv) {
  int ret;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  pthread_attr_init(&amp;attr);
  printf("Started Main...\n");
  // other statements
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
      </screen>
	
      </listitem>

      <!-- Fortran Intro -->

      <listitem><para><emphasis role="bold">Fortran 77/90/95</emphasis></para>

       <para>The Fortran90 TAU API allows source code written in Fortran to
       be instrumented for TAU. This API is comprised of Fortran routines. As
       explained in Chapter 2, the instrumentation can be disabled in the
       program by using the TAU stub makefile variable
       <literal>TAU_DISABLE</literal> on the link command line. This points to
       a library that contains empty TAU instrumentation routines.</para>

      </listitem>
    </itemizedlist>


      
<!-- basic timer interface -->


  </simplesect>



  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"  href="../newguide/timers.xml" />




  </partintro>
  
<refentry id="TAU_START">
  <refmeta>
    <refentrytitle>TAU_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_START</refname>
  <refpurpose>Starts a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_START</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_START</function></funcdef>
      <paramdef>character <parameter>name</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Starts the timer given by <parameter>name</parameter></para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  
	call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />,
      <xref linkend="TAU_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_STOP">
  <refmeta>
    <refentrytitle>TAU_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_STOP</refname>
  <refpurpose>Stops a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STOP</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STOP</function></funcdef>
      <paramdef>character <parameter>name</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Stops the timer given by <parameter>timer</parameter>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_START("t1");
  ...
  TAU_STOP("t2");
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine F1()
  character(13) cvar

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_START(cvar)
  ...
  call TAU_STOP(cvar)
end
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />,
      <xref linkend="TAU_START" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE">
  <refmeta><refentrytitle>TAU_PROFILE</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILE</refname>
  <refpurpose>Profile a C++ function</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcprototype>
      <funcdef><function>TAU_PROFILE</function></funcdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><function>TAU_PROFILE</function> profiles a function.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    <screen>
int foo(char *str) {
  TAU_PROFILE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para><xref linkend="TAU_PROFILE_TIMER" /></para>
  </refsect1>

</refentry>

<refentry id="TAU_DYNAMIC_PROFILE">
  <refmeta><refentrytitle>TAU_DYNAMIC_PROFILE</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_PROFILE</refname>
  <refpurpose>dynamic_profile a c++ function</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PROFILE</function></funcdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>taugroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_DYNAMIC_PROFILE</function> profiles a function dynamically
    creating a separate profile for each time the function is called.  this macro
    defines the function and takes care of the timer start and stop as well.
    the timer will stop when the macro goes out of scope (as in c++
    destruction).</para>
  </refsect1>
  
  <refsect1><title>example</title>
    <screen>
int foo(char *str) {
  tau_dynamic_profile("foo","int (char *)",tau_default);
  ...
}
    </screen>
  </refsect1>


<!--   <refsect1> -->
<!--     <title>see also</title> -->
<!--     <para><xref linkend="TAU_DYNAMIC_PROFILE_TIMER_START" /></para> -->
<!--     <para><xref linkend="TAU_DYNAMIC_PROFILE_TIMER_STOP" /></para> -->
<!--   </refsect1> -->

</refentry>

<refentry id="TAU_PROFILE_CREATE_DYNAMIC">
  <refmeta><refentrytitle>TAU_PROFILE_CREATE_DYNAMIC</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILE_CREATE_DYNAMIC</refname>
  <refpurpose>Creates a dynamic timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILE_CREATE_DYNAMIC</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
        <paramdef>taugroup_t <parameter>group</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  
    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_CREATE_DYNAMIC</function></funcdef>
      <paramdef>integer <parameter>timer</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILE_CREATE_DYNAMIC</function> creates a dynamic
    timer the name of the timer should be different for each execution.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
    <screen>
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
</screen>
      <para>><emphasis role="bold">Fortran:</emphasis></para> 
      <screen>
 subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
</screen>   
  </refsect1>


  <refsect1>
    <title>see also</title>
    <para><xref linkend="TAU_DYNAMIC_TIMER_START" /></para>
    <para><xref linkend="TAU_DYNAMIC_TIMER_STOP" /></para>
  </refsect1>

</refentry>

<refentry id="TAU_CREATE_DYNAMIC_AUTO">
  <refmeta><refentrytitle>TAU_CREATE_DYNAMIC_AUTO</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_CREATE_DYNAMIC_AUTO</refname>
  <refpurpose>Creates a dynamic timer for C/C++</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis>
    <funcprototype>
        <funcdef><function>TAU_CREATE_DYNAMIC_AUTO</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
        <paramdef>taugroup_t <parameter>group</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_CREATE_DYNAMIC_AUTO</function> creates a dynamic
    timer automatically incrementing the name each time the timer is executed.</para>
  </refsect1>
  
  <refsect1><title>example</title>
    <screen>
int tau_ret_val;
TAU_PROFILE_CREATE_DYNAMIC_AUTO(tautimer, "int foo1(int) C [{foo.c} {22,1}-{29,1}]", " ",TAU_USER);
TAU_PROFILE_START(tautimer);
{
printf("inside foo1: calling bar: x = %d\n", x);
printf("before calling bar in foo1\n");
bar(x-1); /* 26 */
printf("after calling bar in foo1\n");
{ tau_ret_val =  x; TAU_PROFILE_STOP(tautimer); return (tau_ret_val); }</screen>
  </refsect1>


  <refsect1>
    <title>see also</title>
    <para><xref linkend="TAU_PROFILE_CREATE_DYNAMIC" /></para>
    <para><xref linkend="TAU_DYNAMIC_TIMER_START" /></para>
    <para><xref linkend="TAU_DYNAMIC_TIMER_STOP" /></para>
  </refsect1>

</refentry>
<refentry id="TAU_PROFILE_DYNAMIC_ITER">
  <refmeta><refentrytitle>TAU_PROFILE_DYNAMIC_ITER</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILE_DYNAMIC_ITER</refname>
  <refpurpose>Creates a dynamic timer in Fortran.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
  
    <funcsynopsis>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_DYNAMIC_ITER</function></funcdef>
      <paramdef>integer <parameter>iterator</parameter></paramdef>
      <paramdef>integer <parameter>timer</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILE_DYNAMIC_ITER</function> creates a dynamic
    timer the name of the timer is appended by the iterator.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <screen>
  integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PROFILE_DYNAMIC_ITER(tau_iter, profiler, '               &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PROFILE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</screen>   
  </refsect1>


  <refsect1>
    <title>see also</title>
    <para><xref linkend="TAU_DYNAMIC_TIMER_START" /></para>
    <para><xref linkend="TAU_DYNAMIC_TIMER_STOP" /></para>
  </refsect1>

</refentry>
<refentry id="TAU_PHASE_DYNAMIC_ITER">
  <refmeta><refentrytitle>TAU_PHASE_DYNAMIC_ITER</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PHASE_DYNAMIC_ITER</refname>
  <refpurpose>Creates a dynamic phase in Fortran.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
  
    <funcsynopsis>
    <funcprototype>
      <funcdef><function>TAU_PHASE_DYNAMIC_ITER</function></funcdef>
      <paramdef>integer <parameter>iterator</parameter></paramdef>
      <paramdef>integer <parameter>timer</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PHASE_DYNAMIC_ITER</function> creates a dynamic
    phase the name of which is appended by the iterator.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <screen>
          integer tau_iter / 0 /
  save tau_iter
  tau_iter = tau_iter + 1
  call TAU_PHASE_DYNAMIC_ITER(tau_iter, profiler, '                 &amp;
 &amp;FOO1 [{foo.f90} {16,18}]')
  call TAU_PHASE_START(profiler)
  print *, "inside foo1: calling bar, x = ", x
  call bar(x-1)
  print *, "after calling bar"
  call TAU_PROFILE_STOP(profiler)</screen>
  </refsect1>


  <refsect1>
    <title>see also</title>
    <para><xref linkend="TAU_DYNAMIC_TIMER_START" /></para>
    <para><xref linkend="TAU_DYNAMIC_TIMER_STOP" /></para>
  </refsect1>

</refentry>
<refentry id="TAU_PROFILE_TIMER">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv>
    <refname>TAU_PROFILE_TIMER</refname>
    <refpurpose>Defines a static timer.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <para>With <literal>TAU_PROFILE_TIMER</literal>, a group of one or more
    statements is profiled. This macro has a timer variable as its first
    argument, and then strings for name and type, as described earlier. It
    associates the timer to the profile group specified in the last
    parameter. </para>
    
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <para>To profile a block of Fortran code, such as a function, subroutine,
    loop etc., the user must first declare a profiler, which is an integer array
    of two elements (pointer) with the save attribute, and pass it as the first
    parameter to the <literal>TAU_PROFILE_TIMER</literal> subroutine. The second
    parameter must contain the name of the routine, which is enclosed in a single
    quote. <literal>TAU_PROFILE_TIMER</literal> declares the profiler that must
    be used to profile a block of code. The profiler is used to profile the
    statements using <literal>TAU_PROFILE_START</literal> and
    <literal>TAU_PROFILE_STOP</literal> as explained later.
    </para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
<screen>
template&lt; class T, unsigned Dim &gt;
void BareField&lt;T,Dim&gt;::fillGuardCells(bool reallyFill)
{y
 // profiling macros
 TAU_TYPE_STRING(taustr, CT(*this) + " void (bool)" );
 TAU_PROFILE("BareField::fillGuardCells()", taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(sendtimer, "fillGuardCells-send", 
                   taustr, TAU_FIELD);
 TAU_PROFILE_TIMER(localstimer, "fillGuardCells-locals",
                   taustr, TAU_FIELD);
 ...
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine bcast_inputs
implicit none
integer profiler(2)
save profiler
					
include 'mpinpb.h'
include 'applu.incl'
					
interger IERR
					
call TAU_PROFILE_TIMER(profiler, 'bcast_inputs')
  </screen>

  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER_DYNAMIC" />,
      <xref linkend="TAU_PROFILE_START" />, 
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_PROFILE_START">
  <refmeta>
    <refentrytitle>TAU_PROFILE_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PROFILE_START</refname>
  <refpurpose>Starts a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_START</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_START</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Starts the timer given by <parameter>timer</parameter></para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE_STOP">
  <refmeta>
    <refentrytitle>TAU_PROFILE_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PROFILE_STOP</refname>
  <refpurpose>Stops a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_STOP</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_STOP</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Stops the timer given by <parameter>timer</parameter>. It is
    important to note that timers can be nested, but not overlapping. TAU
    detects programming errors that lead to such overlaps at runtime, and
    prints a warning message.</para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_PROFILE_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine F1()
  integer profiler(2) / 0, 0 /
  save    profiler

  call TAU_PROFILE_TIMER(profiler,'f1()')
  call TAU_PROFILE_START(profiler)
  ...
  call TAU_PROFILE_STOP(profiler)
end
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_START" />
    </para>
  </refsect1>

</refentry>
<refentry id="TAU_STATIC_TIMER_START">
  <refmeta>
    <refentrytitle>TAU_STATIC_TIMER_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_STATIC_TIMER_START</refname>
  <refpurpose>Starts a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_TIMER_START</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_TIMER_START</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Starts a static timer defined by <xref linkend="TAU_PROFILE" />.</para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />,
      <xref linkend="TAU_STATIC_PHASE_START" />,
      <xref linkend="TAU_STATIC_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_STATIC_TIMER_STOP">
  <refmeta>
    <refentrytitle>TAU_STATIC_TIMER_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_STATIC_TIMER_STOP</refname>
  <refpurpose>Starts a timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_TIMER_STOP</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_TIMER_STOP</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Starts a static timer defined by <xref linkend="TAU_PROFILE" />.</para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_TIMER_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_TIMER_STOP("foo_bar");</screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
call TAU_PROFILE_START(profiler)
print *, "inside foo: calling bar, x = ", x
  call TAU_STATIC_TIMER_START("foo_bar");
    call bar(x-1)
  print *, "after calling bar"
    call TAU_STATIC_TIMER_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />,
      <xref linkend="TAU_STATIC_PHASE_START" />,
      <xref linkend="TAU_STATIC_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DYNAMIC_TIMER_START">
  <refmeta>
    <refentrytitle>TAU_DYNAMIC_TIMER_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_TIMER_START</refname>
  <refpurpose>Starts a dynamic timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_TIMER_START</function></funcdef>
      <paramdef>String <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_TIMER_START</function></funcdef>
      <paramdef>integer <parameter>iteration</parameter></paramdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Starts a new dynamic timer concating the iterator to the end of the
    name.</para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_DYNAMIC_TIMER_STOP">
  <refmeta>
    <refentrytitle>TAU_DYNAMIC_TIMER_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_TIMER_STOP</refname>
  <refpurpose>Starts a dynamic timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_TIMER_STOP</function></funcdef>
      <paramdef>String <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_TIMER_STOP</function></funcdef>
      <paramdef>integer <parameter>iteration</parameter></paramdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1>
    <title>Description</title>
    <para>Stops a new dynamic timer concating the iterator to the end of the
    name.<parameter>timer</parameter></para>
  </refsect1>

  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int foo(int a) {
  TAU_PROFILE_TIMER(timer, "foo", "int (int)", TAU_USER);
  TAU_DYNAMIC_TIMER_START(timer);
  ...
  TAU_PROFILE_STOP(timer);
  return a;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
  integer tau_iteration / 0 /
      save tau_iteration
      call TAU_PROFILE_TIMER(profiler, 'FOO1 [{foo.f90} {16,18}]')
      call TAU_PROFILE_START(profiler)
      print *, "inside foo1: calling bar, x = ", x
      tau_iteration = tau_iteration + 1
  call TAU_DYNAMIC_TIMER_START(tau_iteration,"foo1_bar");
        call bar(x-1)
      print *, "after calling bar"
       call TAU_DYNAMIC_TIMER_STOP(tau_iteration,"foo1_bar");
  call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>




  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_PROFILE_TIMER_DYNAMIC">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER_DYNAMIC</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PROFILE_TIMER_DYNAMIC</refname>
  <refpurpose>Defines a dynamic timer.</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_DYNAMIC</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_DYNAMIC</function></funcdef>
      <paramdef>integer <parameter>profiler</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_PROFILE_TIMER_DYNAMIC</literal> operates similar to
  <literal>TAU_PROFILE_TIMER</literal> except that the timer is created each
  time the statement is invoked.  This way, the name of the timer can be
  different for each execution.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PROFILE_TIMER_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PROFILE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PROFILE_STOP(timer);
  }
  return 0;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PROFILE_TIMER_DYNAMIC(profiler, cvar)
  call TAU_PROFILE_START(profiler)

  call F1()
  call TAU_PROFILE_STOP(profiler)
  return
end
  </screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_START" />,
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>


</refentry>


<refentry id="TAU_PROFILE_DECLARE_TIMER">
  <refmeta>
    <refentrytitle>TAU_PROFILE_DECLARE_TIMER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PROFILE_DECLARE_TIMER</refname>
  <refpurpose>Declares a timer for C</refpurpose></refnamediv>
  
  <refsynopsisdiv>

    <funcsynopsis><funcsynopsisinfo>C:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_DECLARE_TIMER</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

  </refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para>Because C89 does not allow mixed code and declarations,
    <literal>TAU_PROFILE_TIMER</literal> can only be used once in a function.  To
    declare two timers in a C function, use
    <literal>TAU_PROFILE_DECLARE_TIMER</literal> and
    <literal>TAU_PROFILE_CREATE_TIMER</literal>.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C :</emphasis></para>
    <screen>int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}
    </screen>


  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_CREATE_TIMER" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE_CREATE_TIMER">
  <refmeta><refentrytitle>TAU_PROFILE_CREATE_TIMER</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILE_CREATE_TIMER</refname>
  <refpurpose>Creates a timer for C</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_CREATE_TIMER</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para>Because C89 does not allow mixed code and declarations,
  <literal>TAU_PROFILE_TIMER</literal> can only be used once in a function.  To
  declare two timers in a C function, use
  <literal>TAU_PROFILE_DECLARE_TIMER</literal> and
  <literal>TAU_PROFILE_CREATE_TIMER</literal>.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C :</emphasis></para>
    <screen>int f1(void) {
  TAU_PROFILE_DECLARE_TIMER(t1);
  TAU_PROFILE_DECLARE_TIMER(t2);

  TAU_PROFILE_CREATE_TIMER(t1, "timer1", "", TAU_USER);
  TAU_PROFILE_CREATE_TIMER(t2, "timer2", "", TAU_USER);

  TAU_PROFILE_START(t1);
  ...
  TAU_PROFILE_START(t2);
  ...
  TAU_PROFILE_STOP(t2);
  TAU_PROFILE_STOP(t1);
  return 0;
}</screen>


  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_DECLARE_TIMER" />,
      <xref linkend="TAU_PROFILE_START" />,
      <xref linkend="TAU_PROFILE_STOP" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_GLOBAL_TIMER">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_TIMER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_TIMER</refname>
  <refpurpose>Declares a global timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GLOBAL_TIMER</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para>As <literal>TAU_PROFILE_TIMER</literal> is used within the scope of a
    block (typically a routine), <literal>TAU_GLOBAL_TIMER</literal> can be used
    across different routines. </para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_TIMER_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_TIMER_START" />,
      <xref linkend="TAU_GLOBAL_TIMER_STOP" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_GLOBAL_TIMER_EXTERNAL">
  <refmeta><refentrytitle>TAU_GLOBAL_TIMER_EXTERNAL</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_TIMER_EXTERNAL</refname>
  <refpurpose>Declares a global timer from an external compilation unit</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>

    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_TIMER_EXTERNAL</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>


  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_TIMER_EXTERNAL</literal> allows you to access a
    timer defined in another compilation unit.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_TIMER" />,
      <xref linkend="TAU_GLOBAL_TIMER_START" />,
      <xref linkend="TAU_GLOBAL_TIMER_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_GLOBAL_TIMER_START">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_TIMER_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_TIMER_START</refname>
  <refpurpose>Starts a global timer</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_TIMER_START</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_TIMER_START</literal> starts a global timer.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_TIMER" />,
      <xref linkend="TAU_GLOBAL_TIMER_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_TIMER_STOP" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_GLOBAL_TIMER_STOP">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_TIMER_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_TIMER_STOP</refname>
  <refpurpose>Stops a global timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_TIMER_STOP</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_TIMER_STOP</literal> stops a global timer.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_TIMER(globalTimer, "global timer", "", TAU_USER);

/* f2.c */

TAU_GLOBAL_TIMER_EXTERNAL(globalTimer);
int foo(void) {
  TAU_GLOBAL_TIMER_START(globalTimer);
  /* ... */
  TAU_GLOBAL_TIMER_STOP();
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_TIMER" />,
      <xref linkend="TAU_GLOBAL_TIMER_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_TIMER_START" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_PHASE">
  <refmeta>
    <refentrytitle>TAU_PHASE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PHASE</refname>
  <refpurpose>Profile a C++ function as a phase</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcprototype>
      <funcdef><function>TAU_PHASE</function></funcdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><function>TAU_PHASE</function> profiles a function as a phase.  This macro
    defines the function and takes care of the timer start and stop as well.
    The timer will stop when the macro goes out of scope (as in C++
    destruction).</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    <screen>
int foo(char *str) {
  TAU_PHASE(foo","int (char *)",TAU_DEFAULT);
  ...
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_CREATE_STATIC" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_DYNAMIC_PHASE">
  <refmeta>
    <refentrytitle>TAU_DYNAMIC_PHASE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_PHASE</refname>
  <refpurpose>Defines a dynamic phase.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE</function></funcdef>
      <paramdef>integer <parameter>phase</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_DYNAMIC_PHASE</literal> creates a dynamic phase.
  The name of the timer can be different for each execution.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_DYNAMIC_PHASE(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_DYNAMIC_PHASE(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_DYNAMIC_PHASE_START" />,
      <xref linkend="TAU_DYNAMIC_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>
<refentry id="TAU_PHASE_CREATE_DYNAMIC">
  <refmeta>
    <refentrytitle>TAU_PHASE_CREATE_DYNAMIC</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PHASE_CREATE_DYNAMIC</refname>
  <refpurpose>Defines a dynamic phase.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_CREATE_DYNAMIC</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_CREATE_DYNAMIC</function></funcdef>
      <paramdef>integer <parameter>phase</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_PHASE_CREATE_DYNAMIC</literal> creates a dynamic phase.
  The name of the timer can be different for each execution.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  int i;
  TAU_PROFILE_TIMER(t,"main()", "", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_START(t);

  for (i=0; i&amp;5; i++) {
    char buf[32];
    sprintf(buf, "Iteration %d", i);

    TAU_PHASE_CREATE_DYNAMIC(timer, buf, "", TAU_USER);
    TAU_PHASE_START(timer);
    printf("Iteration %d\n", i);
    f1();

    TAU_PHASE_STOP(timer);
  }
  return 0;
}
    </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>subroutine ITERATION(val)
  integer val
  character(13) cvar
  integer profiler(2) / 0, 0 /
  save profiler

  print *, "Iteration ", val

  write (cvar,'(a9,i2)') 'Iteration', val
  call TAU_PHASE_CREATE_DYNAMIC(profiler, cvar)
  call TAU_PHASE_START(profiler)

  call F1()
  call TAU_PHASE_STOP(profiler)
  return
end
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_START" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>











<refentry id="TAU_PHASE_CREATE_STATIC">
  <refmeta>
    <refentrytitle>TAU_PHASE_CREATE_STATIC</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PHASE_CREATE_STATIC</refname>
  <refpurpose>Defines a static phase.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_CREATE_STATIC</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_CREATE_STATIC</function></funcdef>
      <paramdef>integer <parameter>phase</parameter>(2)</paramdef>
      <paramdef>character <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_PHASE_CREATE_STATIC</literal> creates a static phase.
  Static phases (and timers) are more efficient than dynamic ones because the
  function registration only takes place once.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</screen>
      <para>><emphasis role="bold">Python:</emphasis></para> 
<screen>
import pytau
ptr = pytau.phase("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_START" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>











<refentry id="TAU_PHASE_START">
  <refmeta>
    <refentrytitle>TAU_PHASE_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PHASE_START</refname>
  <refpurpose>Enters a phase.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_START</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_START</function></funcdef>
      <paramdef>integer <parameter>phase</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_PHASE_START</literal> enters a phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_PHASE_STOP">
  <refmeta>
    <refentrytitle>TAU_PHASE_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PHASE_STOP</refname>
  <refpurpose>Exits a phase.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_STOP</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PHASE_STOP</function></funcdef>
      <paramdef>integer <parameter>phase</parameter>(2)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_PHASE_STOP</literal> exits a phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>int f2(void)
{
  TAU_PHASE_CREATE_STATIC(t2,"IO Phase", "", TAU_USER);
  TAU_PHASE_START(t2);
  input();
  output();
  TAU_PHASE_STOP(t2);
  return 0;
}</screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>subroutine F2()

  integer phase(2) / 0, 0 /
  save    phase

  call TAU_PHASE_CREATE_STATIC(phase,'IO Phase')
  call TAU_PHASE_START(phase)

  call INPUT()
  call OUTPUT()

  call TAU_PHASE_STOP(phase)
end</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_START" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_DYNAMIC_PHASE_START">
  <refmeta>
    <refentrytitle>TAU_DYNAMIC_PHASE_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_PHASE_START</refname>
  <refpurpose>Enters a DYNAMIC_PHASE.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE_START</function></funcdef>
      <paramdef>string <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE_START</function></funcdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_DYNAMIC_PHASE_START</literal> enters a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DYNAMIC_PHASE_STOP">
  <refmeta>
    <refentrytitle>TAU_DYNAMIC_PHASE_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_DYNAMIC_PHASE_STOP</refname>
  <refpurpose>Enters a DYNAMIC_PHASE.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE_STOP</function></funcdef>
      <paramdef>string <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DYNAMIC_PHASE_STOP</function></funcdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_DYNAMIC_PHASE_STOP</literal> leaves a DYNAMIC phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_DYNAMIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_DYNAMIC_PHASE_STOP("foo_bar");
return x;
  </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_DYNAMIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_DYNAMIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>
<refentry id="TAU_STATIC_PHASE_START">
  <refmeta>
    <refentrytitle>TAU_STATIC_PHASE_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_STATIC_PHASE_START</refname>
  <refpurpose>Enters a STATIC_PHASE.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_PHASE_START</function></funcdef>
      <paramdef>string <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_PHASE_START</function></funcdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_STATIC_PHASE_START</literal> enters a static phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_STATIC_PHASE_STOP">
  <refmeta>
    <refentrytitle>TAU_STATIC_PHASE_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_STATIC_PHASE_STOP</refname>
  <refpurpose>Enters a STATIC_PHASE.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_PHASE_STOP</function></funcdef>
      <paramdef>string <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_STATIC_PHASE_STOP</function></funcdef>
      <paramdef>char <parameter>name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>Description</title>

  <para><literal>TAU_STATIC_PHASE_STOP</literal> leaves a static phase.  Phases can be
  nested, but not overlapped.</para>

  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("int foo(int) [{foo.cpp} {13,1}-{20,1}]", " ", TAU_USER);

printf("inside foo: calling bar: x = %d\n", x);
printf("before calling bar in foo\n");
TAU_STATIC_PHASE_START("foo_bar");
bar(x-1); /* 17 */
printf("after calling bar in foo\n");
TAU_STATIC_PHASE_STOP("foo_bar");
return x;
  </screen>

  <para><emphasis role="bold">Fortran :</emphasis></para>
  <screen>
    call TAU_PROFILE_TIMER(profiler, 'FOO [{foo.f90} {8,18}]')
    call TAU_PROFILE_START(profiler)
    print *, "inside foo: calling bar, x = ", x
     call TAU_STATIC_PHASE_START("foo_bar");
      call bar(x-1)
    print *, "after calling bar"
     call TAU_STATIC_PHASE_STOP("foo_bar");
call TAU_PROFILE_STOP(profiler)
  </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PHASE_CREATE_STATIC" />,
      <xref linkend="TAU_PHASE_CREATE_DYNAMIC" />,
      <xref linkend="TAU_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>
















<refentry id="TAU_GLOBAL_PHASE">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_PHASE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_PHASE</refname>
  <refpurpose>Declares a global phase</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>

    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_PHASE</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
      <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>


  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para>Declares a global phase to be used in multiple compilation units.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    
    
    <screen>/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_PHASE_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_PHASE_START" />,
      <xref linkend="TAU_GLOBAL_PHASE_STOP" />
    </para>
</refsect1>


</refentry>


<refentry id="TAU_GLOBAL_PHASE_EXTERNAL">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_PHASE_EXTERNAL</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_PHASE_EXTERNAL</refname>
  <refpurpose>Declares a global phase from an external compilation unit</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>

    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_PHASE_EXTERNAL</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
    </funcprototype>


  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_PHASE_EXTERNAL</literal> allows you to access a
    phase defined in another compilation unit.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_PHASE" />,
      <xref linkend="TAU_GLOBAL_PHASE_START" />,
      <xref linkend="TAU_GLOBAL_PHASE_STOP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_GLOBAL_PHASE_START">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_PHASE_START</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_PHASE_START</refname>
  <refpurpose>Starts a global phase</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_PHASE_START</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
    </funcprototype>
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_PHASE_START</literal> starts a global phase.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_START(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_PHASE" />,
      <xref linkend="TAU_GLOBAL_PHASE_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_PHASE_STOP" />
    </para>
</refsect1>

</refentry>

<refentry id="TAU_GLOBAL_PHASE_STOP">
  <refmeta>
    <refentrytitle>TAU_GLOBAL_PHASE_STOP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_GLOBAL_PHASE_STOP</refname>
  <refpurpose>Stops a global phase</refpurpose></refnamediv>
  
  <refsynopsisdiv><funcsynopsis>
    <funcsynopsisinfo>C/C++:</funcsynopsisinfo>

    <funcprototype>
      <funcdef><function>TAU_GLOBAL_PHASE_STOP</function></funcdef>
      <paramdef>Phase <parameter>phase</parameter></paramdef>
    </funcprototype>
  </funcsynopsis></refsynopsisdiv>
  
  <refsect1><title>Description</title>
    <para><literal>TAU_GLOBAL_PHASE_STOP</literal> stops a global phase.</para>
  </refsect1>
  
  <refsect1>
    <title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>/* f1.c */

TAU_GLOBAL_PHASE(globalPhase, "global phase", "", TAU_USER);

/* f2.c */

int bar(void) {
  TAU_GLOBAL_PHASE_STOP(globalPhase);
  /* ... */
  TAU_GLOBAL_PHASE_STOP(globalPhase);
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GLOBAL_PHASE" />,
      <xref linkend="TAU_GLOBAL_PHASE_EXTERNAL" />,
      <xref linkend="TAU_GLOBAL_PHASE_START" />
    </para>
  </refsect1>

</refentry>













<!--
*******************************************************************************
*******************************************************************************
*******************************************************************************
*******************************************************************************

process/thread management

*******************************************************************************
*******************************************************************************
*******************************************************************************
-->




<refentry id="TAU_PROFILE_EXIT">

  <refmeta>
    <refentrytitle>TAU_PROFILE_EXIT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_PROFILE_EXIT</refname>
  <refpurpose>Alerts the profiling system to an exit call</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_EXIT</function></funcdef>
      <paramdef>const char * <parameter>message</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_EXIT</function></funcdef>
      <paramdef>character <parameter>message</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_EXIT</literal> should be called prior to an
    error exit from the program so that any profiles or event traces can be
    dumped to disk before quitting.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
if ((ret = open(...)) &lt; 0) {
  TAU_PROFILE_EXIT("ERROR in opening a file");
  perror("open() failed");
  exit(1);
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_PROFILE_EXIT('abort called')
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />
    </para>
  </refsect1>

</refentry>






<refentry id="TAU_REGISTER_THREAD">
  <refmeta>
    <refentrytitle>TAU_REGISTER_THREAD</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_REGISTER_THREAD</refname>
  <refpurpose>Register a thread with the profiling system</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_THREAD</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_THREAD</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>To register a thread with the profiling system, invoke the
    <literal>TAU_REGISTER_THREAD</literal> macro in the run method of the
    thread prior to executing any other TAU macro. This sets up thread
    identifiers that are later used by the instrumentation system.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void * threaded_func(void *data) {
  TAU_REGISTER_THREAD();
  { /**** NOTE WE START ANOTHER BLOCK IN THREAD */
    TAU_PROFILE_TIMER(tautimer, "threaded_func()", "int ()", 
                      TAU_DEFAULT);
    TAU_PROFILE_START(tautimer);
    work(); /* work done by this thread */
    TAU_PROFILE_STOP(tautimer);
  }
  return NULL;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_REGISTER_THREAD()
    </screen>
  </refsect1>


  <refsect1>
    <title>Caveat</title>
    <para>PDT based tau_instrumentor does not insert <literal>TAU_REGISTER_THREAD</literal> calls,
    they must be inserted manually</para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE_GET_NODE">
  <refmeta>
    <refentrytitle>TAU_PROFILE_GET_NODE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_GET_NODE</refname>
  <refpurpose>Returns the measurement system's node id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_NODE</function></funcdef>
      <paramdef>int <parameter>node</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_NODE</function></funcdef>
      <paramdef>integer <parameter>node</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_GET_NODE</literal> gives the node id for the
		processes in which it is called. When using MPI node id is the same as MPI
		rank.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
	int nodeid;
  TAU_PROFILE_GET_NODE(nodeid);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
      INTEGER :: N
      call TAU_PROFILE_GET_NODE(N)
      END PROGRAM SUM_OF_CUBES
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.setNode(0)
		</screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_GET_CONTEXT" />
    </para>
  </refsect1>

</refentry>





<refentry id="TAU_PROFILE_GET_CONTEXT">
  <refmeta>
    <refentrytitle>TAU_PROFILE_GET_CONTEXT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_GET_CONTEXT</refname>
  <refpurpose>Gives the measurement system's context id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_CONTEXT</function></funcdef>
      <paramdef>int <parameter>context</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_CONTEXT</function></funcdef>
      <paramdef>integer <parameter>context</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_GET_CONTEXT</literal> gives the context id for the
		processes in which it is called.
		</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_CONTEXT(i);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
      INTEGER :: C 
        call TAU_PROFILE_GET_CONTEXT(C)
      END PROGRAM SUM_OF_CUBES
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SET_CONTEXT" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_PROFILE_SET_THREAD">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SET_THREAD</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SET_THREAD</refname>
  <refpurpose>Informs the measurement system of the THREAD id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_THREAD</function></funcdef>
      <paramdef>int <parameter>THREAD</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_THREAD</function></funcdef>
      <paramdef>integer <parameter>THREAD</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>TAU_PROFILE_SET_THREAD</literal> macro sets the thread
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;THREAD&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <literal>TAU_PROFILE_SET_THREAD</literal> when you
		configued with a threading package (including OpenMP).</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_THREAD(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_THREAD(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.setThread(0)
		</screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SET_NODE" />
      <xref linkend="TAU_PROFILE_SET_CONTEXT" />
    </para>
  </refsect1>

</refentry>
<refentry id="TAU_PROFILE_GET_THREAD">
  <refmeta>
    <refentrytitle>TAU_PROFILE_GET_THREAD</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_GET_THREAD</refname>
  <refpurpose>Gives the measurement system's thread id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_THREAD</function></funcdef>
      <paramdef>int <parameter>thread</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_GET_THREAD</function></funcdef>
      <paramdef>integer <parameter>THREAD</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_GET_THREAD</literal> gives the thread id for the
		processes in which it is called.
		</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
  int i;
  TAU_PROFILE_GET_THREAD(i);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
      INTEGER :: T
        call TAU_PROFILE_GET_THREAD(T)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      END PROGRAM SUM_OF_CUBES
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau
pytau.getThread(i)
		</screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_GET_NODE" />
      <xref linkend="TAU_PROFILE_GET_CONTEXT" />
    </para>
  </refsect1>

</refentry>





<refentry id="TAU_PROFILE_SET_NODE">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SET_NODE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SET_NODE</refname>
  <refpurpose>Informs the measurement system of the node id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_NODE</function></funcdef>
      <paramdef>int <parameter>node</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_NODE</function></funcdef>
      <paramdef>integer <parameter>node</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>TAU_PROFILE_SET_NODE</literal> macro sets the node
    identifier of the executing task for profiling and tracing. Tasks are
    identified using node, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <literal>TAU_PROFILE_SET_NODE</literal> when using the
    TAU MPI wrapper library.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)", 
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.setNode(0)
		</screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SET_CONTEXT" />
    </para>
  </refsect1>

</refentry>





<refentry id="TAU_PROFILE_SET_CONTEXT">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SET_CONTEXT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SET_CONTEXT</refname>
  <refpurpose>Informs the measurement system of the context id</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_CONTEXT</function></funcdef>
      <paramdef>int <parameter>context</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_CONTEXT</function></funcdef>
      <paramdef>integer <parameter>context</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>TAU_PROFILE_SET_CONTEXT</literal> macro sets the context
    identifier of the executing task for profiling and tracing. Tasks are
    identified using context, context and thread ids. The profile data files
    generated will accordingly be named
    profile.&lt;context&gt;.&lt;context&gt;.&lt;thread&gt;.  Note that it is not
    necessary to call <literal>TAU_PROFILE_SET_CONTEXT</literal> when using the
    TAU MPI wrapper library.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main (int argc, char **argv) {
  int ret, i;
  pthread_attr_t  attr;
  pthread_t       tid;
  TAU_PROFILE_TIMER(tautimer,"main()", "int (int, char **)",
                    TAU_DEFAULT);
  TAU_PROFILE_START(tautimer);
  TAU_PROFILE_INIT(argc, argv);
  TAU_PROFILE_SET_NODE(0);
  TAU_PROFILE_SET_CONTEXT(1);
  /* ... */
  TAU_PROFILE_STOP(tautimer);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
     PROGRAM SUM_OF_CUBES
       integer profiler(2) / 0, 0 /
        save profiler
      INTEGER :: H, T, U
        call TAU_PROFILE_INIT()
        call TAU_PROFILE_TIMER(profiler, 'PROGRAM SUM_OF_CUBES')
        call TAU_PROFILE_START(profiler)
        call TAU_PROFILE_SET_NODE(0)
        call TAU_PROFILE_SET_CONTEXT(1)
      ! This program prints all 3-digit numbers that
      ! equal the sum of the cubes of their digits.
      DO H = 1, 9
        DO T = 0, 9
          DO U = 0, 9
          IF (100*H + 10*T + U == H**3 + T**3 + U**3) THEN
             PRINT "(3I1)", H, T, U
          ENDIF
          END DO
        END DO
      END DO
      call TAU_PROFILE_STOP(profiler)
      END PROGRAM SUM_OF_CUBES
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SET_NODE" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_REGISTER_FORK">
  <refmeta>
    <refentrytitle>TAU_REGISTER_FORK</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  
  <refnamediv><refname>TAU_REGISTER_FORK</refname>
  <refpurpose>Informs the measurement system that a fork has taken place</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_FORK</function></funcdef>
      <paramdef>int <parameter>pid</parameter></paramdef>
      <paramdef>enum TauFork_t <parameter>option</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
  <para>To register a child process obtained from the fork()
    syscall, invoke the  <literal>TAU_REGISTER_FORK</literal>  macro. It takes 
    two parameters, the first is the node id of the child process (typically
    the process id returned by the fork call or any 0..N-1 range integer).
    The second parameter specifies whether the performance data for the
    child process should be derived from the parent at the time of fork
    ( <literal>TAU_INCLUDE_PARENT_DATA</literal> ) or should be independent of
    its parent at the time of fork
    ( <literal>TAU_EXCLUDE_PARENT_DATA</literal> ). If the process id is used as
    the node id, before any analysis is done, all profile files should be
    converted to contiguous node numbers (from 0..N-1). It is highly
    recommended to use flat contiguous node numbers in this call for
    profiling and tracing. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
pID = fork();
if (pID == 0) {
  printf("Parent : pid returned %d\n", pID)
}  else { 
  // If we'd used the TAU_INCLUDE_PARENT_DATA, we get
  // the performance data from the parent in this process
  // as well.
  TAU_REGISTER_FORK(pID, TAU_EXCLUDE_PARENT_DATA);        
  printf("Child : pid = %d", pID);
}
    </screen>

  </refsect1>
</refentry>



<refentry id="TAU_REGISTER_EVENT">
  <refmeta>
    <refentrytitle>TAU_REGISTER_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_REGISTER_EVENT</refname>
  <refpurpose>Registers a user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>variable</parameter></paramdef>
      <paramdef>char *<parameter>event_name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_EVENT</function></funcdef>
      <paramdef>int <parameter>variable</parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>TAU can profile user-defined events using
    <literal>TAU_REGISTER_EVENT</literal>. The meaning of the event is
    determined by the user. The first argument to
    <literal>TAU_REGISTER_EVENT</literal> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_REPORT_STATISTICS" />,
      <xref linkend="TAU_REPORT_THREAD_STATISTICS" />,
      <xref linkend="TAU_GET_EVENT_NAMES" />,
      <xref linkend="TAU_GET_EVENT_VALS" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_PROFILER_REGISTER_EVENT">
  <refmeta>
    <refentrytitle>TAU_PROFILER_REGISTER_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILER_REGISTER_EVENT</refname>
  <refpurpose>Registers a user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILER_REGISTER_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>variable</parameter></paramdef>
      <paramdef>void *<parameter>event</parameter></paramdef>
      <paramdef>char *<parameter>event_name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILER_REGISTER_EVENT</function></funcdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>TAU can profile user-defined events using
    <literal>TAU_PROFILER_REGISTER_EVENT</literal>. The meaning of the event is
    determined by the user. The first argument to
    <literal>TAU_PROFILER_REGISTER_EVENT</literal> is the pointer to an integer
    array. This array is declared with a save attribute as shown below.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  void *ue1;
	TAU_PROFILER_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer eventid(2)
save eventid
call TAU_PROFILER_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_REPORT_STATISTICS" />,
      <xref linkend="TAU_REPORT_THREAD_STATISTICS" />,
      <xref linkend="TAU_GET_EVENT_NAMES" />,
      <xref linkend="TAU_GET_EVENT_VALS" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_TRIGGER_EVENT">
  <refmeta>
    <refentrytitle>TAU_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRIGGER_EVENT</refname>
  <refpurpose>Triggers a user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_EVENT</function></funcdef>
      <paramdef>const char * <parameter>name</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_EVENT</function></funcdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>


  <refsect1><title>Description</title>
    <para>Triggers an named event with the given value</para>
  </refsect1>

  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count);
  return 0;
}
		</screen>
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_EVENT(count, 'Error in Iteration')
    </screen>

  </refsect1>
</refentry>


<refentry id="TAU_TRIGGER_EVENT_THREAD">
  <refmeta>
    <refentrytitle>TAU_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRIGGER_EVENT_THREAD</refname>
  <refpurpose>Triggers a user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_EVENT_THREAD</function></funcdef>
      <paramdef>const char * <parameter>name</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
      <paramdef>int <parameter>thread</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_EVENT_THREAD</function></funcdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>


  <refsect1><title>Description</title>
    <para>Triggers an named event with the given value on a given thead or task.</para>
  </refsect1>

  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_TRIGGER_EVENT("Error in Iteration", count * count, workTask);
  return 0;
}
		</screen>
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_EVENT(count, workTask, 'Error in Iteration')
    </screen>

  </refsect1>
</refentry>

<refentry id="TAU_EVENT">
  <refmeta>
    <refentrytitle>TAU_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT</refname>
  <refpurpose>Triggers a user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>variable</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT</function></funcdef>
      <paramdef>integer <parameter>variable</parameter>(2)</paramdef>
      <paramdef>real <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>


  <refsect1><title>Description</title>
    <para>Triggers an event that was registered with
    <literal>TAU_REGISTER_EVENT</literal>.</para>
  </refsect1>

  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT(ue1, count * count);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT(eventid, count)
    </screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_EVENT_THREAD">
  <refmeta>
    <refentrytitle>TAU_EVENT_THREAD</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_THREAD</refname>
  <refpurpose>Triggers a user event on a given thread</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_THREAD</function></funcdef>
      <paramdef>TauUserEVENT_THREAD <parameter>variable</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
      <paramdef>int <parameter>thread id</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_THREAD</function></funcdef>
      <paramdef>integer <parameter>variable</parameter>(2)</paramdef>
      <paramdef>real <parameter>value</parameter></paramdef>
      <paramdef>integer <parameter>thread id</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>


  <refsect1><title>Description</title>
    <para>Triggers an event that was registered with
    <literal>TAU_REGISTER_EVENT</literal> on a given thread.</para>
  </refsect1>

  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_REGISTER_EVENT(ue1, "UserSquare Event");
  TAU_EVENT_THREAD(ue1, count * count, threadid);
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer eventid(2)
save eventid
call TAU_REGISTER_EVENT(eventid, 'Error in Iteration')
call TAU_EVENT_THREAD(eventid, count, threadid)
    </screen>
  </refsect1>



  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>
</refentry>



<refentry id="TAU_REGISTER_CONTEXT_EVENT">
  <refmeta>
    <refentrytitle>TAU_REGISTER_CONTEXT_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_REGISTER_CONTEXT_EVENT</refname>
  <refpurpose>Registers a context event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_CONTEXT_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>variable</parameter></paramdef>
      <paramdef>char *<parameter>event_name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REGISTER_CONTEXT_EVENT</function></funcdef>
      <paramdef>int <parameter>variable</parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Creates a context event with name. A context event appends the 
     names of routines executing on the callstack to the name specified by
     the user. Whenver a context event is triggered, the callstack is 
     examined to determine the context of execution. Starting from the parent
     function where the event is triggered, TAU walks up the callstack to a 
     depth specified by the user in the environment variable 
     <literal>TAU_CALLPATH_DEPTH </literal>. If this environment variable is 
     not specified, TAU uses 2 as the default depth. For e.g., if the user 
     registers a context event with the name "memory used" and specifies 3 as 
     the callpath depth, and if the event is triggered in two locations 
     (in routine a, when it was called by b, when it was called by c, and in 
     routine h, when it was called by g, when it was called by i), then, we'd 
     see the user defined event information for 
     "memory used: c() => b() => a()" and "memory used: i() => g() => h()".
 
      </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
subroutine foo(id)
  integer id
       
  integer profiler(2) / 0, 0 /
  integer maev(2) / 0, 0 /
  integer mdev(2) / 0, 0 /
  save profiler, maev, mdev

  integer :: ierr
  integer :: h, t, u
  INTEGER, ALLOCATABLE :: STORAGEARY(:)
  DOUBLEPRECISION   edata

  call TAU_PROFILE_TIMER(profiler, 'FOO')
  call TAU_PROFILE_START(profiler)
  call TAU_PROFILE_SET_NODE(0)

  call TAU_REGISTER_CONTEXT_EVENT(maev, "STORAGEARY Alloc [cubes.f:20]")
  call TAU_REGISTER_CONTEXT_EVENT(mdev, "STORAGEARY Dealloc [cubes.f:37]")

  allocate(STORAGEARY(1:999), STAT=IERR)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(maev, edata)
  ...
  deallocate(STORAGEARY)
  edata = SIZE(STORAGEARY)*sizeof(INTEGER)
  call TAU_CONTEXT_EVENT(mdev, edata)
  call TAU_PROFILE_STOP(profiler)
  end subroutine foo
     </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_CONTEXT_EVENT" />,
      <xref linkend="TAU_ENABLE_CONTEXT_EVENT" />,
      <xref linkend="TAU_DISABLE_CONTEXT_EVENT" />,
      <xref linkend="TAU_REGISTER_EVENT" />,
      <xref linkend="TAU_REPORT_STATISTICS" />,
      <xref linkend="TAU_REPORT_THREAD_STATISTICS" />,
      <xref linkend="TAU_GET_EVENT_NAMES" />,
      <xref linkend="TAU_GET_EVENT_VALS" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_CONTEXT_EVENT">
  <refmeta>
    <refentrytitle>TAU_CONTEXT_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_CONTEXT_EVENT</refname>
  <refpurpose>Triggers a context event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_CONTEXT_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>variable</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_CONTEXT_EVENT</function></funcdef>
      <paramdef>integer <parameter>variable</parameter>(2)</paramdef>
      <paramdef>real <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Triggers a context event. A context event associates the name with 
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <literal> TAU_CALLPATH_DEPTH</literal>. If this variable is not 
          specified, TAU uses a default depth of 2. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer memevent(2) / 0, 0 /
save memevent
call TAU_REGISTER_CONTEXT_EVENT(memevent, "STORAGEARY mem allocated')
call TAU_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER))
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_TRIGGER_CONTEXT_EVENT">
  <refmeta>
    <refentrytitle>TAU_TRIGGER_CONTEXT_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRIGGER_CONTEXT_EVENT</refname>
  <refpurpose>Triggers a context event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_CONTEXT_EVENT</function></funcdef>
      <paramdef>const char * <parameter>name</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_CONTEXT_EVENT</function></funcdef>
      <paramdef>real <parameter>value</parameter></paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <literal> TAU_CALLPATH_DEPTH</literal>. If this variable is not 
          specified, TAU uses a default depth of 2. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int f2(void)
{
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
/*
  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
*/
  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_TRIGGER_CONTEXT_EVENT("Iteration count", 232+count);
  sleep(2);
  f3();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
integer memevent(2) / 0, 0 /
save memevent
call TAU_TRIGGER_CONTEXT_EVENT(memevent, SIZEOF(STORAGEARY)*sizeof(INTEGER), "STORAGEARY mem allocated")
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_TRIGGER_CONTEXT_EVENT_THREAD">
  <refmeta>
    <refentrytitle>TAU_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRIGGER_CONTEXT_EVENT_THREAD</refname>
  <refpurpose>Triggers a context user event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_CONTEXT_EVENT_THREAD</function></funcdef>
      <paramdef>const char * <parameter>name</parameter></paramdef>
      <paramdef>double <parameter>value</parameter></paramdef>
      <paramdef>int <parameter>thread</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRIGGER_CONTEXT_EVENT_THREAD</function></funcdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>int <parameter>integer </parameter>(2)</paramdef>
      <paramdef>character <parameter>event_name</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>


  <refsect1><title>Description</title>
    <para>Triggers an event with a name and
          the list of routines along the callstack. A context event tracks 
          information like a user defined event and TAU records the maxima, 
          minima, mean, std. deviation and the number of samples for each 
          context event. A context event helps distinguish the data supplied 
          by the user based on the location where an event occurs and the 
          sequence of actions (routine/timer invocations) that preceeded the 
          event. The depth of the the callstack embedded in the context 
          event's name is specified by the user in the environment variable 
          <literal> TAU_CALLPATH_DEPTH</literal>. If this variable is not 
          specified, TAU uses a default depth of 2. </para>
  </refsect1>

  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int user_square(int count) {
  TAU_TRIGGER_CONTEXT_EVENT_THREAD("Error in Iteration", count * count, workTask);
  return 0;
}
		</screen>
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRIGGER_CONTEXT_EVENT_THREAD(count, workTask, 'Error in Iteration')
    </screen>

  </refsect1>
</refentry>


<refentry id="TAU_ENABLE_CONTEXT_EVENT">
  <refmeta>
    <refentrytitle>TAU_ENABLE_CONTEXT_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_CONTEXT_EVENT</refname>
  <refpurpose>Enable a context event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_CONTEXT_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Enables a context event.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_DISABLE_CONTEXT_EVENT" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_DISABLE_CONTEXT_EVENT">
  <refmeta>
    <refentrytitle>TAU_DISABLE_CONTEXT_EVENT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_CONTEXT_EVENT</refname>
  <refpurpose>Disable a context event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_CONTEXT_EVENT</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables a context event.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int f2(void) {
  static int count = 0;
  count ++;
  TAU_PROFILE("f2()", "(sleeps 2 sec, calls f3)", TAU_USER);
  TAU_REGISTER_CONTEXT_EVENT(event, "Iteration count");

  if (count == 2)
    TAU_DISABLE_CONTEXT_EVENT(event);
  else
    TAU_ENABLE_CONTEXT_EVENT(event);

  printf("Inside f2: sleeps 2 sec, calls f3\n");

  TAU_CONTEXT_EVENT(event, 232+count);
  sleep(2);
  f3();
  return 0;
}
    </screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_ENABLE_CONTEXT_EVENT" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_EVENT_SET_NAME">
  <refmeta>
    <refentrytitle>TAU_EVENT_SET_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_SET_NAME</refname>
  <refpurpose>Sets the name of an event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_SET_NAME</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
      <paramdef>const char *<parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Changes the name of an event.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_EVENT_SET_NAME(event, "new name");
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_EVENT_DISABLE_MAX">
  <refmeta>
    <refentrytitle>TAU_EVENT_DISABLE_MAX</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_DISABLE_MAX</refname>
  <refpurpose>Disables tracking of maximum statistic for a given event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_DISABLE_MAX</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables tracking of maximum statistic for a given event</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_EVENT_DISABLE_MAX(event);
    </screen>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_EVENT_DISABLE_MEAN">
  <refmeta>
    <refentrytitle>TAU_EVENT_DISABLE_MEAN</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_DISABLE_MEAN</refname>
  <refpurpose>Disables tracking of mean statistic for a given event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_DISABLE_MEAN</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables tracking of mean statistic for a given event</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_EVENT_DISABLE_MEAN(event);
    </screen>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_EVENT_DISABLE_MIN">
  <refmeta>
    <refentrytitle>TAU_EVENT_DISABLE_MIN</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_DISABLE_MIN</refname>
  <refpurpose>Disables tracking of minimum statistic for a given event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_DISABLE_MIN</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables tracking of minimum statistic for a given event</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_EVENT_DISABLE_MIN(event);
    </screen>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_EVENT_DISABLE_STDDEV">
  <refmeta>
    <refentrytitle>TAU_EVENT_DISABLE_STDDEV</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_EVENT_DISABLE_STDDEV</refname>
  <refpurpose>Disables tracking of standard deviation statistic for a given event</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_EVENT_DISABLE_STDDEV</function></funcdef>
      <paramdef>TauUserEvent <parameter>event</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables tracking of standard deviation statistic for a given event</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_EVENT_DISABLE_STDDEV(event);
    </screen>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />
    </para>
  </refsect1>

</refentry>






<refentry id="TAU_REPORT_STATISTICS">
  <refmeta>
    <refentrytitle>TAU_REPORT_STATISTICS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_REPORT_STATISTICS</refname>
  <refpurpose>Outputs statistics</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REPORT_STATISTICS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REPORT_STATISTICS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
   <para> <literal>TAU_REPORT_STATISTICS</literal>  prints the aggregate
    statistics of user events across all threads in each node. Typically,
    this should be called just before the main thread exits. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_REPORT_STATISTICS();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_REPORT_STATISTICS()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_REPORT_THREAD_STATISTICS" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_REPORT_THREAD_STATISTICS">
  <refmeta>
    <refentrytitle>TAU_REPORT_THREAD_STATISTICS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_REPORT_THREAD_STATISTICS</refname>
  <refpurpose>Outputs statistics, plus thread statistics</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REPORT_THREAD_STATISTICS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_REPORT_THREAD_STATISTICS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_REPORT_THREAD_STATISTICS</literal> prints the
    aggregate, as well as per thread user event statistics.  Typically, this
    should be called just before the main thread exits. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_REPORT_THREAD_STATISTICS();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_REPORT_THREAD_STATISTICS()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_REPORT_STATISTICS" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_ENABLE_INSTRUMENTATION">
  <refmeta>
    <refentrytitle>TAU_ENABLE_INSTRUMENTATION</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_INSTRUMENTATION</refname>
  <refpurpose>Enables instrumentation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_INSTRUMENTATION</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_INSTRUMENTATION</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_ENABLE_INSTRUMENTATION</literal>  macro re-enables
    all TAU instrumentation. All instances of functions and statements that
    occur between the disable/enable section are ignored by TAU. This allows
    a user to limit the trace size, if the macros are used to disable
    recording of a set of iterations that have the same characteristics as,
    for example, the first recorded instance.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_ENABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_ENABLE_INSTRUMENTATION()
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DISABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_ENABLE_GROUP" />,
      <xref linkend="TAU_DISABLE_GROUP" />,
      <xref linkend="TAU_INIT" />,
      <xref linkend="TAU_PROFILE_INIT" />
    </para>
  </refsect1>

</refentry>








<refentry id="TAU_DISABLE_INSTRUMENTATION">
  <refmeta>
    <refentrytitle>TAU_DISABLE_INSTRUMENTATION</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_INSTRUMENTATION</refname>
  <refpurpose>Disables instrumentation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_INSTRUMENTATION</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_INSTRUMENTATION</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_DISABLE_INSTRUMENTATION</literal>  macro disables
    all entry/exit instrumentation within all threads of a context. This
    allows the user to selectively enable and disable instrumentation in
    parts of his/her code. It is important to re-enable the instrumentation
    within the same basic block and scope. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) { 
  foo();
  TAU_DISABLE_INSTRUMENTATION();
  for (int i =0; i &lt; N; i++) { 
    bar();  // not recorded
  }
  TAU_DISABLE_INSTRUMENTATION();
  bar(); // recorded
} 
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_INSTRUMENTATION()
...
call TAU_DISABLE_INSTRUMENTATION()
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.enableInstrumentation()
...
pytau.disableInstrumentation()
		</screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_ENABLE_GROUP" />,
      <xref linkend="TAU_DISABLE_GROUP" />,
      <xref linkend="TAU_INIT" />,
      <xref linkend="TAU_PROFILE_INIT" />
    </para>
  </refsect1>


</refentry>









<refentry id="TAU_ENABLE_GROUP">
  <refmeta>
    <refentrytitle>TAU_ENABLE_GROUP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_GROUP</refname>
  <refpurpose>Enables tracking of a given group</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_GROUP</function></funcdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_GROUP</function></funcdef>
      <paramdef>integer <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Enables the instrumentation for a given group.  By default, it is already on.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_ENABLE_GROUP(TAU_USER);
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
  include 'Profile/TauFAPI.h'
  call TAU_ENABLE_GROUP(TAU_USER)
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.enableGroup(TAU_USER)
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_DISABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_DISABLE_GROUP" />,
      <xref linkend="TAU_INIT" />,
      <xref linkend="TAU_PROFILE_INIT" />
    </para>
  </refsect1>

</refentry>






<refentry id="TAU_DISABLE_GROUP">
  <refmeta>
    <refentrytitle>TAU_DISABLE_GROUP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_GROUP</refname>
  <refpurpose>Disables tracking of a given group</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_GROUP</function></funcdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_GROUP</function></funcdef>
      <paramdef>integer <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables the instrumentation for a given group.  By default, it is on.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE("foo()", " ", TAU_USER);
  ...
  TAU_DISABLE_GROUP(TAU_USER);
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
  include 'Profile/TauFAPI.h'
  call TAU_DISABLE_GROUP(TAU_USER)
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.disableGroup(TAU_USER)
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_DISABLE_INSTRUMENTATION" />,
      <xref linkend="TAU_ENABLE_GROUP" />,
      <xref linkend="TAU_INIT" />,
      <xref linkend="TAU_PROFILE_INIT" />
    </para>
  </refsect1>

</refentry>






<refentry id="TAU_PROFILE_TIMER_SET_GROUP">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER_SET_GROUP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_TIMER_SET_GROUP</refname>
  <refpurpose>Change the group of a timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_SET_GROUP</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>TauGroup_t <parameter>group</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_TIMER_SET_GROUP</literal> changes the group
    associated with a timer.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE_TIMER(t, "foo loop timer", " ", TAU_USER1);
  ...
  TAU_PROFILE_TIMER_SET_GROUP(t, TAU_USER3);
}
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_TIMER_SET_GROUP_NAME" />
    </para>
  </refsect1>
</refentry>





<refentry id="TAU_PROFILE_TIMER_SET_GROUP_NAME">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER_SET_GROUP_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_TIMER_SET_GROUP_NAME</refname>
  <refpurpose>Changes the group name for a timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_SET_GROUP_NAME</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>char *<parameter>groupname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_TIMER_SET_GROUP_NAME</literal> changes the
    group name associated with a given timer.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE_TIMER(looptimer, "foo: loop1", " ", TAU_USER);
  TAU_PROFILE_START(looptimer);
  for (int i = 0; i &lt; N; i++) { /* do something */ }
  TAU_PROFILE_STOP(looptimer);
  TAU_PROFILE_TIMER_SET_GROUP_NAME("Field");
}
    </screen>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_PROFILE_TIMER_SET_GROUP" />
    </para>
  </refsect1>
</refentry>




<refentry id="TAU_PROFILE_TIMER_SET_NAME">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER_SET_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_TIMER_SET_NAME</refname>
  <refpurpose>Changes the name of a timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_SET_NAME</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>string <parameter>newname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_TIMER_SET_NAME</literal> macro changes the name
    associated with a timer to the newname argument. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo:loop1", " ", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_NAME(timer1, "foo:lines 21-34");
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />
    </para>
  </refsect1>


</refentry>



<refentry id="TAU_PROFILE_TIMER_SET_TYPE">
  <refmeta>
    <refentrytitle>TAU_PROFILE_TIMER_SET_TYPE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_TIMER_SET_TYPE</refname>
  <refpurpose>Changes the type of a timer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_TIMER_SET_TYPE</function></funcdef>
      <paramdef>Profiler <parameter>timer</parameter></paramdef>
      <paramdef>string <parameter>newname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_TIMER_SET_TYPE</literal> macro changes the type
    associated with a timer to the newname argument. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE_TIMER(timer1, "foo", "int", TAU_USER);
  ...
  TAU_PROFILE_TIMER_SET_TYPE(timer1, "long");
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE_SET_GROUP_NAME">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SET_GROUP_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SET_GROUP_NAME</refname>
  <refpurpose>Changes the group name of a profiled section</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SET_GROUP_NAME</function></funcdef>
      <paramdef>char *<parameter>groupname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_PROFILE_SET_GROUP_NAME</literal>  macro allows
    the user to change the group name associated with the instrumented
    routine. This macro must be called within the instrumented routine. 
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_PROFILE("foo()", "void ()", TAU_USER);
  TAU_PROFILE_SET_GROUP_NAME("Particle"); 
  /* gives a more meaningful group name */
}
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_INIT">
  <refmeta>
    <refentrytitle>TAU_INIT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_INIT</refname>
  <refpurpose>Processes command-line arguments for selective instrumentation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_INIT</function></funcdef>
      <paramdef>int *<parameter>argc</parameter></paramdef>
      <paramdef>char ***<parameter>argv</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_INIT</literal> parses and removes the command-line
    arguments for the names of profile groups that are to be selectively
    enabled for instrumentation. By default, if this macro is not used,
    functions belonging to all profile groups are
    enabled. <literal>TAU_INIT</literal> differs from
    <literal>TAU_PROFILE_INIT</literal> only in the argument types.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
  
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_GROUP_12);
  TAU_INIT(&amp;argc, &amp;argv);
  ...
}

% ./a.out --profile 12+14
    </screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_INIT" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_PROFILE_INIT">
  <refmeta>
    <refentrytitle>TAU_PROFILE_INIT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_INIT</refname>
  <refpurpose>Processes command-line arguments for selective instrumentation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_INIT</function></funcdef>
      <paramdef>int <parameter>argc</parameter></paramdef>
      <paramdef>char **<parameter>argv</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_INIT</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_INIT</literal> parses the
    command-line arguments for the names of profile groups that are to be
    selectively enabled for instrumentation. By default, if this macro is not
    used, functions belonging to all profile groups are
    enabled. <literal>TAU_INIT</literal> differs from
    <literal>TAU_PROFILE_INIT</literal> only in the argument types.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
  
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  TAU_PROFILE("main()", "int (int, char **)", TAU_DEFAULT);
  TAU_PROFILE_INIT(argc, argv);
  ...
}

% ./a.out --profile 12+14
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>

    <screen>
PROGRAM SUM_OF_CUBES
  integer profiler(2)
  save profiler
      
  call TAU_PROFILE_INIT()
  ...
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_INIT" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_GET_PROFILE_GROUP">
  <refmeta>
    <refentrytitle>TAU_GET_PROFILE_GROUP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_PROFILE_GROUP</refname>
  <refpurpose>Creates groups based on names</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_PROFILE_GROUP</function></funcdef>
      <paramdef>char *<parameter>groupname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_GET_PROFILE_GROUP</literal>  allows the user to
    dynamically create groups based on strings, rather than use predefined,
    statically assigned groups such as  <literal>TAU_USER1, TAU_USER2</literal> 
    etc. This allows names to be associated in creating unique groups that
    are more meaningful, using names of files or directories for instance.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
#define PARTICLES TAU_GET_PROFILE_GROUP("PARTICLES")

void foo() {
  TAU_PROFILE("foo()", " ", PARTICLES);
}

void bar() {
  TAU_PROFILE("bar()", " ", PARTICLES);
}
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.getProfileGroup("PARTICLES")
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_GROUP_NAME" />,
      <xref linkend="TAU_DISABLE_GROUP_NAME" />,
      <xref linkend="TAU_ENABLE_ALL_GROUPS" />,
      <xref linkend="TAU_DISABLE_ALL_GROUPS" />
    </para>
  </refsect1>

</refentry>





<refentry id="TAU_ENABLE_GROUP_NAME">
  <refmeta>
    <refentrytitle>TAU_ENABLE_GROUP_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_GROUP_NAME</refname>
  <refpurpose>Enables a group based on name</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_GROUP_NAME</function></funcdef>
      <paramdef>char *<parameter>groupname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_GROUP_NAME</function></funcdef>
      <paramdef>character <parameter>groupname</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_ENABLE_GROUP_NAME</literal> macro can turn on the
    instrumentation associated with routines based on a dynamic group assigned
    to them. It is important to note that this and the
    <literal>TAU_DISABLE_GROUP_NAME</literal> macros apply to groups created
    dynamically using <literal>TAU_GET_PROFILE_GROUP.</literal> </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE>DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.enableGroupName("DTM")
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_PROFILE_GROUP" />,
      <xref linkend="TAU_DISABLE_GROUP_NAME" />,
      <xref linkend="TAU_ENABLE_ALL_GROUPS" />,
      <xref linkend="TAU_DISABLE_ALL_GROUPS" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_DISABLE_GROUP_NAME">
  <refmeta>
    <refentrytitle>TAU_DISABLE_GROUP_NAME</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_GROUP_NAME</refname>
  <refpurpose>Disables a group based on name</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_GROUP_NAME</function></funcdef>
      <paramdef>char *<parameter>groupname</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_GROUP_NAME</function></funcdef>
      <paramdef>character <parameter>groupname</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Similar to <literal>TAU_ENABLE_GROUP_NAME</literal> , this macro
    turns off the instrumentation in all routines associated with the dynamic
    group created using the tau_instrumentor -g &lt;group_name&gt; argument. 
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
/* tau_instrumentor was invoked with -g DTM for a set of files */
TAU_DISABLE_GROUP_NAME("DTM"); 
dtm_routines();
/* disable and then re-enable the group with the name DTM */
TAU_ENABLE_GROUP_NAME("DTM");
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
! tau_instrumentor was invoked with -g DTM for this file 
    call TAU_PROFILE_TIMER(profiler, "ITERATE>DTM")

    call TAU_DISABLE_GROUP_NAME("DTM")
! Disable, then re-enable DTM group
    call TAU_ENABLE_GROUP_NAME("DTM")
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.disableGroupName("DTM")
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_PROFILE_GROUP" />,
      <xref linkend="TAU_ENABLE_GROUP_NAME" />,
      <xref linkend="TAU_ENABLE_ALL_GROUPS" />,
      <xref linkend="TAU_DISABLE_ALL_GROUPS" />
    </para>
  </refsect1>

</refentry>




<refentry id="TAU_ENABLE_ALL_GROUPS">
  <refmeta>
    <refentrytitle>TAU_ENABLE_ALL_GROUPS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_ALL_GROUPS</refname>
  <refpurpose>Enables instrumentation in all groups</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_ALL_GROUPS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_ALL_GROUPS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This macro turns on instrumentation in all groups</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_ENABLE_ALL_GROUPS();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_ENABLE_ALL_GROUPS();
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.enableAllGroups()
     </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_PROFILE_GROUP" />,
      <xref linkend="TAU_ENABLE_GROUP_NAME" />,
      <xref linkend="TAU_DISABLE_GROUP_NAME" />,
      <xref linkend="TAU_DISABLE_ALL_GROUPS" />
    </para>
  </refsect1>
  
</refentry>



<refentry id="TAU_DISABLE_ALL_GROUPS">
  <refmeta>
    <refentrytitle>TAU_DISABLE_ALL_GROUPS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_ALL_GROUPS</refname>
  <refpurpose>Disables instrumentation in all groups</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_ALL_GROUPS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_ALL_GROUPS</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This macro turns off instrumentation in all groups.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
void foo() {
  TAU_DISABLE_ALL_GROUPS();
  TAU_ENABLE_GROUP_NAME("PARTICLES");
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_ALL_GROUPS();
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.disableAllGroups()
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_PROFILE_GROUP" />,
      <xref linkend="TAU_ENABLE_GROUP_NAME" />,
      <xref linkend="TAU_DISABLE_GROUP_NAME" />,
      <xref linkend="TAU_ENABLE_ALL_GROUPS" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_GET_EVENT_NAMES">
  <refmeta>
    <refentrytitle>TAU_GET_EVENT_NAMES</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_EVENT_NAMES</refname>
  <refpurpose>Gets the registered user events.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_EVENT_NAMES</function></funcdef>
      <paramdef>const char ***<parameter>eventList</parameter></paramdef>
      <paramdef>int *<parameter>numEvents</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Retrieves user event names for all user-defined events</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
const char **eventList;
int numEvents;

TAU_GET_EVENT_NAMES(eventList, numEvents);

cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_GET_EVENT_VALS" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_GET_EVENT_VALS">
  <refmeta>
    <refentrytitle>TAU_GET_EVENT_VALS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_EVENT_VALS</refname>
  <refpurpose>Gets user event data for given user events.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_EVENT_VALS</function></funcdef>
      <paramdef>const char **<parameter>inUserEvents</parameter></paramdef>
      <paramdef>int <parameter>numUserEvents</parameter></paramdef>
      <paramdef>int **<parameter>numEvents</parameter></paramdef>
      <paramdef>double **<parameter>max</parameter></paramdef>
      <paramdef>double **<parameter>min</parameter></paramdef>
      <paramdef>double **<parameter>mean</parameter></paramdef>
      <paramdef>double **<parameter>sumSqe</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Retrieves user defined event data for the specified user defined events. The list of events are specified by the first parameter (eventList) and the user specifies the number of events in the second parameter (numUserEvents). TAU returns the number of times the event was invoked in the numUserEvents. The max, min, mean values are returned in the following parameters. TAU computes the sum of squares of the given event and returns this value in the next argument (sumSqe). </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
  const char **eventList;
  int numEvents;

  TAU_GET_EVENT_NAMES(eventList, numEvents);

  cout &lt;&lt; "numEvents: " &lt;&lt; numEvents &lt;&lt; endl;

  if (numEvents > 0) {
    int *numSamples;
    double *max;
    double *min;
    double *mean;
    double *sumSqr;

    TAU_GET_EVENT_VALS(eventList, numEvents, numSamples, 
      max, min, mean, sumSqr);
    for (int i=0; i&lt;numEvents; i++) {
      cout &lt;&lt; "-------------------\n";
      cout &lt;&lt; "User Event:        " &lt;&lt; eventList[i] &lt;&lt; endl;
      cout &lt;&lt; "Number of Samples: " &lt;&lt; numSamples[i] &lt;&lt; endl;
      cout &lt;&lt; "Maximum Value:     " &lt;&lt; max[i] &lt;&lt; endl;
      cout &lt;&lt; "Minimum Value:     " &lt;&lt; min[i] &lt;&lt; endl;
      cout &lt;&lt; "Mean Value:        " &lt;&lt; mean[i] &lt;&lt; endl;
      cout &lt;&lt; "Sum Squared:       " &lt;&lt; sumSqr[i] &lt;&lt; endl;
    }
  }
}

    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_REGISTER_EVENT" />,
      <xref linkend="TAU_REGISTER_CONTEXT_EVENT" />,
      <xref linkend="TAU_GET_EVENT_NAMES" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_GET_COUNTER_NAMES">
  <refmeta>
    <refentrytitle>TAU_GET_COUNTER_NAMES</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_COUNTER_NAMES</refname>
  <refpurpose>Gets the counter names</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_COUNTER_NAMES</function></funcdef>
      <paramdef>char **<parameter>counterList</parameter></paramdef>
      <paramdef>int <parameter>numCounters</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_GET_COUNTER_NAMES</literal> returns the list of counter
    names and the number of counters used for measurement. When wallclock time
    is used, the counter name of "default" is returned.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int numOfCounters;
const char ** counterList;

TAU_GET_COUNTER_NAMES(counterList, numOfCounters);

for(int j=0;j&lt;numOfCounters;j++){ 
  cout &lt;&lt; "The counter names so far are: " &lt;&lt; counterList[j] &lt;&lt; endl;
}
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.getCounterNames(counterList, numOfCounters);
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_FUNC_NAMES" />,
      <xref linkend="TAU_GET_FUNC_VALS" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_GET_FUNC_NAMES">
  <refmeta>
    <refentrytitle>TAU_GET_FUNC_NAMES</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_FUNC_NAMES</refname>
  <refpurpose>Gets the function names</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_FUNC_NAMES</function></funcdef>
      <paramdef>char **<parameter>functionList</parameter></paramdef>
      <paramdef>int <parameter>numFuncs</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This macro fills the funcList argument with the list of
    timer and routine names. It also records the number of routines active
    in the numFuncs argument. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
  const char ** functionList;
  int numOfFunctions;

  TAU_GET_FUNC_NAMES(functionList, numOfFunctions);

  for(int i=0;i&lt;numOfFunctions;i++){
    cout &lt;&lt; "This function names so far are: " &lt;&lt; functionList[i] &lt;&lt; endl;
  }

    </screen>
		<para><emphasis role="role">Python:</emphasis></para>
    <screen>
import pytau

pytau.getFuncNames(functionList, numOfFunctions)
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_COUNTER_NAMES" />,
      <xref linkend="TAU_GET_FUNC_VALS" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_GET_FUNC_VALS">
  <refmeta>
    <refentrytitle>TAU_GET_FUNC_VALS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_GET_FUNC_VALS</refname>
  <refpurpose>Gets detailed performance data for given functions</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_GET_FUNC_VALS</function></funcdef>
      <paramdef>const char **<parameter>inFuncs</parameter></paramdef>
      <paramdef>int <parameter>numOfFuncs</parameter></paramdef>
      <paramdef>double ***<parameter>counterExclusiveValues</parameter></paramdef>
      <paramdef>double ***<parameter>counterInclusiveValues</parameter></paramdef>
      <paramdef>int **<parameter>numOfCalls</parameter></paramdef>
      <paramdef>int **<parameter>numOfSubRoutines</parameter></paramdef>
      <paramdef>const char ***<parameter>counterNames</parameter></paramdef>
      <paramdef>int *<parameter>numOfCounters</parameter></paramdef>
      <paramdef>int <parameter>tid</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>It gets detailed performance data for the list of
    routines. The user specifies inFuncs and the number of routines; TAU
    then returns the other arguments with the performance data.
    counterExclusiveValues and counterInclusiveValues are two dimensional
    arrays: the first dimension is the routine id and the second is counter
    id. The value is indexed by these two dimensions. numCalls and numSubrs
    (or child routines) are one dimensional arrays. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
const char **inFuncs;
/* The first dimension is functions, and the 
second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;
      
TAU_GET_FUNC_NAMES(functionList, numOfFunctions);
      
/* We are only interested in the first two routines 
that are executing in this context. So, we allocate 
space for two routine names and get the performance 
data for these two routines at runtime. */
if (numOfFunctions &gt;=2 ) {
  inFuncs = (const char **) malloc(sizeof(const char *) * 2);
      
  inFuncs[0] = functionList[0];
  inFuncs[1] = functionList[1];
      
  //Just to show consistency.
  TAU_DB_DUMP();
      
  TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);
      
  TAU_DUMP_FUNC_VALS_INCR(inFuncs, 2);
      
      
  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
  cout &lt;&lt; "The number of counters is: " &lt;&lt; numOfCouns &lt;&lt; endl;
  cout &lt;&lt; "The first counter is: " &lt;&lt; counterNames[0] &lt;&lt; endl;
      
  cout &lt;&lt; "The Exclusive value of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; counterExclusiveValues[0][0] &lt;&lt; endl;
  cout &lt;&lt; "The numOfSubRoutines of: " &lt;&lt; inFuncs[0]
  &lt;&lt; " is: " &lt;&lt; numOfSubRoutines[0]
  &lt;&lt; endl;
      
      
  cout &lt;&lt; "The Inclusive value of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; counterInclusiveValues[1][0]
  &lt;&lt; endl;
  cout &lt;&lt; "The numOfCalls of: " &lt;&lt; inFuncs[1]
  &lt;&lt; " is: " &lt;&lt; numOfCalls[1]
  &lt;&lt; endl;

  cout &lt;&lt; "@@@@@@@@@@@@@@@" &lt;&lt; endl;
}
      
TAU_DB_DUMP_INCR();
    </screen>
		<para>Python:</para>
		<screen>
import pytau

pytau.dumpFuncVals("foo", "bar", "bar2")
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_GET_COUNTER_NAMES" />,
      <xref linkend="TAU_GET_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_ENABLE_TRACKING_MEMORY">
  <refmeta>
    <refentrytitle>TAU_ENABLE_TRACKING_MEMORY</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_TRACKING_MEMORY</refname>
  <refpurpose>Enables memory tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Enables tracking of the heap memory utilization in the program. TAU takes a sample of the heap memory utilized (as reported by the mallinfo system call) and associates it with a single global user defined event. An interrupt is generated every 10 seconds and the value of the heap memory used is recorded in the user defined event. The inter-interrupt interval (default of 10 seconds) may be set by the user using the call <literal>TAU_SET_INTERRUPT_INTERVAL</literal>.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_ENABLE_TRACKING_MEMORY();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_ENABLE_TRACKING_MEMORY()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.enableTrackingMemory()
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_TRACK_MEMORY_HERE" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DISABLE_TRACKING_MEMORY">
  <refmeta>
    <refentrytitle>TAU_DISABLE_TRACKING_MEMORY</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_TRACKING_MEMORY</refname>
  <refpurpose>Disables memory tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Disables tracking of heap memory utilization. This call may be used in sections of code where TAU should not interrupt the execution to periodically track the heap memory utilization.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DISABLE_TRACKING_MEMORY();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_TRACKING_MEMORY()
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.disableTrackingMemory()

		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_TRACK_MEMORY_HERE" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_TRACK_POWER">
  <refmeta>
    <refentrytitle>TAU_TRACK_POWER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_POWER</refname>
  <refpurpose>Initializes POWER tracking system</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>For power profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_POWER_HERE() calls in the source code and the
    power event is triggered at those locations, and 2) the user enables
    tracking POWER by calling TAU_TRACK_POWER() and an interrupt is generated
    every 10 seconds and the POWER event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of power events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_POWER() or TAU_DISABLE_TRACKING_()
    respectively.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_TRACK_POWER();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACK_POWER()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.trackPower()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_TRACKING_POWER" />,
      <xref linkend="TAU_DISABLE_TRACKING_POWER" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_POWER_HERE" />,
      <xref linkend="TAU_TRACK_POWER" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_TRACK_POWER_HERE">
  <refmeta>
    <refentrytitle>TAU_TRACK_POWER_HERE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_POWER_HERE</refname>
  <refpurpose>Triggers power tracking at a given execution point</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_POWER_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_POWER_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Triggers power tracking at a given execution point</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_POWER_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_POWER_HERE();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap POWER 
! utilization at this point, invoke the following call:
call TAU_TRACK_POWER_HERE()

    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.trackPowerHere()
		</screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_POWER" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_ENABLE_TRACKING_POWER">
  <refmeta>
    <refentrytitle>TAU_ENABLE_TRACKING_POWER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_TRACKING_POWER</refname>
  <refpurpose>Enables power headroom tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>
      <literal>TAU_ENABLE_TRACKING_POWER()</literal> enables power 
      tracking after a
      <literal>TAU_DISABLE_TRACKING_POWER()</literal>.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DISABLE_TRACKING_POWER();
/* do some work */
...
/* re-enable tracking POWER */
TAU_ENABLE_TRACKING_POWER();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_ENABLE_TRACKING_POWER();
    </screen>
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
import pytau

pytau.enableTrackingPowerHeadroom()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_POWER" />,
      <xref linkend="TAU_DISABLE_TRACKING_POWER" />,
      <xref linkend="TAU_TRACK_POWER_HERE" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_DISABLE_TRACKING_POWER">
  <refmeta>
    <refentrytitle>TAU_DISABLE_TRACKING_POWER</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_TRACKING_POWER</refname>
  <refpurpose>Disables power headroom tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_POWER</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>
      <literal>TAU_DISABLE_TRACKING_POWER()</literal> disables
      power tracking.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DISABLE_TRACKING_POWER();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_TRACKING_POWER()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.disableTrackingPowerHeadroom()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_POWER" />,
      <xref linkend="TAU_ENABLE_TRACKING_POWER" />,
      <xref linkend="TAU_TRACK_POWER_HERE" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_TRACK_MEMORY">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY</refname>
  <refpurpose>Initializes memory tracking system</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>For memory profiling, there are two modes of operation: 1) the user
    explicitly inserts TAU_TRACK_MEMORY_HERE() calls in the source code and the
    memory event is triggered at those locations, and 2) the user enables
    tracking memory by calling TAU_TRACK_MEMORY() and an interrupt is generated
    every 10 seconds and the memory event is triggered with the current
    value. Also, this interrupt interval can be changed by calling
    TAU_SET_INTERRUPT_INTERVAL(value). The tracking of memory events in both
    cases can be explictly enabled or disabled by calling the macros
    TAU_ENABLE_TRACKING_MEMORY() or TAU_DISABLE_TRACKING_MEMORY()
    respectively.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_TRACK_MEMORY();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACK_MEMORY()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.trackMemory()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_MEMORY_HERE" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_TRACK_MEMORY_HERE">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY_HERE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY_HERE</refname>
  <refpurpose>Triggers memory tracking at a given execution point</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Triggers memory tracking at a given execution point</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_HERE();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)

! if we wish to record a sample of the heap memory 
! utilization at this point, invoke the following call:
call TAU_TRACK_MEMORY_HERE()

    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.trackMemoryHere()
		</screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_TRACK_MEMORY_FOOTPRINT">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY_FOOTPRINT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY_FOOTPRINT</refname>
  <refpurpose>Initializes memory footprint tracking system</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_FOOTPRINT</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_FOOTPRINT</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Similar to TAU_TRACK_MEMORY but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</para>

  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_TRACK_MEMORY_FOOTPRINT();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACK_MEMORY_FOOTPRINT()
    </screen>
    
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_ENABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_MEMORY_HERE" />,
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_TRACK_MEMORY_FOOTPRINT_HERE" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_TRACK_MEMORY_FOOTPRINT_HERE">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY_FOOTPRINT_HERE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY_FOOTPRINT_HERE</refname>
  <refpurpose>Triggers memory footprint tracking at a given execution point</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_FOOTPRINT_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_FOOTPRINT_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Similar to TAU_TRACK_MEMORY_HERE but uses the Virtual Memory Resident Set Size (VmRSS) and High Water Mark (VmHWM) to produce an interval event and an atomic event respectively.</para>

  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
int main(int argc, char **argv) {
  TAU_PROFILE("main()", " ", TAU_DEFAULT);
  TAU_PROFILE_SET_NODE(0);

  TAU_TRACK_MEMORY_FOOTPRINT_HERE();

  int *x = new int[5*1024*1024];
  TAU_TRACK_MEMORY_FOOTPRINT_HERE();
  return 0;
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)


call TAU_TRACK_MEMORY_FOOTPRINT_HERE()

    </screen>
		
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY_FOOTPRINT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_ENABLE_TRACKING_MEMORY_HEADROOM">
  <refmeta>
    <refentrytitle>TAU_ENABLE_TRACKING_MEMORY_HEADROOM</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_TRACKING_MEMORY_HEADROOM</refname>
  <refpurpose>Enables memory headroom tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>
      <literal>TAU_ENABLE_TRACKING_MEMORY_HEADROOM()</literal> enables memory
      headroom tracking after a
      <literal>TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</literal>.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
/* do some work */
...
/* re-enable tracking memory headroom */
TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_ENABLE_TRACKING_MEMORY_HEADROOM();
    </screen>
    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
import pytau

pytau.enableTrackingMemoryHeadroom()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />,
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY_HEADROOM" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM_HERE" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_DISABLE_TRACKING_MEMORY_HEADROOM">
  <refmeta>
    <refentrytitle>TAU_DISABLE_TRACKING_MEMORY_HEADROOM</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DISABLE_TRACKING_MEMORY_HEADROOM</refname>
  <refpurpose>Disables memory headroom tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DISABLE_TRACKING_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>
      <literal>TAU_DISABLE_TRACKING_MEMORY_HEADROOM()</literal> disables memory
      headroom tracking.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DISABLE_TRACKING_MEMORY_HEADROOM();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DISABLE_TRACKING_MEMORY_HEADROOM()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.disableTrackingMemoryHeadroom()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />,
      <xref linkend="TAU_ENABLE_TRACKING_MEMORY_HEADROOM" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM_HERE" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_TRACK_MEMORY_HEADROOM">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY_HEADROOM</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY_HEADROOM</refname>
  <refpurpose>Track the headroom (amount of memory for a process to grow) by periodically interrupting the program</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HEADROOM</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Tracks the amount of memory available for the process before it runs
    out of free memory on the heap. This call sets up a signal handler that is
    invoked every 10 seconds by an interrupt (this interval may be altered by
    using the <literal>TAU_SET_INTERRUPT_INTERVAL</literal> call). Inside the
    interrupt handler, TAU evaluates how much memory it can allocate and
    associates it with the callstack using the TAU context events (See <xref
    linkend="TAU_REGISTER_CONTEXT_EVENT"/>). The user can vary the size of the
    callstack by setting the environment variable
    <literal>TAU_CALLPATH_DEPTH</literal> (default is 2). This call is useful
    on machines like IBM BG/L where no virtual memory (or paging using the swap
    space) is present. The amount of heap memory available to the program is
    limited by the amount of available physical memory. TAU executes a series
    of malloc calls with a granularity of 1MB and determines the amount of
    memory available for the program to grow.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_TRACK_MEMORY_HEADROOM();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACK_MEMORY_HEADROOM()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.trackMemoryHeadroom()
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_ENABLE_TRACKING_MEMORY_HEADROOM" />,
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY_HEADROOM" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM_HERE" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_TRACK_MEMORY_HEADROOM_HERE">
  <refmeta>
    <refentrytitle>TAU_TRACK_MEMORY_HEADROOM_HERE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACK_MEMORY_HEADROOM_HERE</refname>
  <refpurpose>Takes a sample of the amount of memory available at a given point.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HEADROOM_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACK_MEMORY_HEADROOM_HERE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Instead of relying on a periodic interrupt to track the amount of memory available to grow, this call may be used to take a sample at a given location in the source code. Context events are used to track the amount of memory headroom.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
ary = new double [1024*1024*50];
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
INTEGER, ALLOCATABLE :: STORAGEARY(:)
allocate(STORAGEARY(1:999), STAT=IERR)
TAU_TRACK_MEMORY_HEADROOM_HERE();
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.trackMemoryHeadroomHere()
		</screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_SET_INTERRUPT_INTERVAL">
  <refmeta>
    <refentrytitle>TAU_SET_INTERRUPT_INTERVAL</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_SET_INTERRUPT_INTERVAL</refname>
  <refpurpose>Change the inter-interrupt interval for tracking memory and headroom</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_SET_INTERRUPT_INTERVAL</function></funcdef>
      <paramdef>int <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_SET_INTERRUPT_INTERVAL</function></funcdef>
      <paramdef>integer <parameter>value</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Set the interrupt interval for tracking memory and headroom (See <xref linkend="TAU_TRACK_MEMORY"/> and <xref linkend="TAU_TRACK_MEMORY_HEADROOM"/>). By default an inter-interrupt interval of 10 seconds is used in TAU. This call allows the user to set it to a different value specified by the argument value.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_SET_INTERRUPT_INTERVAL(2)
/* invokes the interrupt handler for memory every 2s */
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_SET_INTERRUPT_INTERVAL(2)
    </screen>
		<para><emphasis role="bold">Python: </emphasis></para>
		<screen>
import pytau

pytau.setInterruptTnterval(2)
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_TRACK_MEMORY_HEADROOM" />
    </para>
  </refsect1>

</refentry>
<!--
<refentry id="TAU_ENABLE_TRACKING_MUSE_EVENTS">
  <refmeta>
    <refentrytitle>TAU_ENABLE_TRACKING_MEMORY</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_ENABLE_TRACKING_MEMORY</refname>
  <refpurpose>Enables memory tracking</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_ENABLE_TRACKING_MEMORY</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Enables tracking of the heap memory utilization in the program. TAU takes a sample of the heap memory utilized (as reported by the mallinfo system call) and associates it with a single global user defined event. An interrupt is generated every 10 seconds and the value of the heap memory used is recorded in the user defined event. The inter-interrupt interval (default of 10 seconds) may be set by the user using the call <literal>TAU_SET_INTERRUPT_INTERVAL</literal>.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_ENABLE_TRACKING_MEMORY();      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_ENABLE_TRACKING_MEMORY()
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.enableTrackingMemory()
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DISABLE_TRACKING_MEMORY" />,
      <xref linkend="TAU_SET_INTERRUPT_INTERVAL" />,
      <xref linkend="TAU_TRACK_MEMORY" />,
      <xref linkend="TAU_TRACK_MEMORY_HERE" />
    </para>
  </refsect1>

</refentry>
-->


<refentry id="CT">
  <refmeta>
    <refentrytitle>CT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>CT</refname>
  <refpurpose>Returns the type information for a variable</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>CT</function></funcdef>
      <paramdef>&lt;type&gt; <parameter>variable</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>CT</literal> macro returns the runtime type
    information string of a variable. This is useful in constructing the
    type parameter of the  <literal>TAU_PROFILE</literal>  macro. For templates,
    the type information can be constructed using the type of the return and
    the type of each of the arguments (parameters) of the template. The
    example in the following macro will clarify this.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE("foo::memberfunc()", CT(*this), TAU_DEFAULT);
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE" />,
      <xref linkend="TAU_PROFILE_TIMER" />,
      <xref linkend="TAU_TYPE_STRING" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_TYPE_STRING">
  <refmeta>
    <refentrytitle>TAU_TYPE_STRING</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TYPE_STRING</refname>
  <refpurpose>Creates a type string</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TYPE_STRING</function></funcdef>
      <paramdef>string &amp;<parameter>variable</parameter></paramdef>
      <paramdef>string &amp;<parameter>type_string</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This macro assigns the string constructed in type_string to
    the variable. The + operator and the CT macro can be used to construct
    the type string of an object. This is useful in identifying templates
    uniquely, as shown below.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C++ :</emphasis></para>

    <screen>
template&lt;class PLayout&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const ParticleBase&lt;PLayout&gt;&amp; P) {
  TAU_TYPE_STRING(taustr, "ostream (ostream, " + CT(P) + " )");
  TAU_PROFILE("operator&lt;&lt;()"taustr, TAU_PARTICLE | TAU_IO);
  ... 
}
    </screen>
    
    <para>When PLayout is instantiated with
    " <literal>UniformCartesian&lt;3U, double&gt;</literal> ",this generates the
    unique template name: </para>
    
    <screen>
operator&lt;&lt;() ostream const 
ParticleBase&lt;UniformCartesian&lt;3U, double&gt; &gt; )
    </screen>
    
    <para>The following example illustrates the usage of the CT macro
    to extract the name of the class associated with the given object using
    CT(*this);</para>
    
    <screen>
template&lt;class PLayout&gt;
unsigned ParticleBase&lt;PLayout7&gt;::GetMessage(Message&amp; msg, int node) {
  TAU_TYPE_STRING(taustr, CT(*this) + "unsigned (Message, int)");
  TAU_PROFILE("ParticleBase::GetMessage()", taustr, TAU_PARTICLE);
  ...
}
    </screen>
    
    <para>When PLayout is instantiated with " <literal>UniformCartesian&lt;3U,
    double&gt;</literal> ",this generates the unique template name:</para>
    
    <screen>
ParticleBase::GetMessage() ParticleBase&lt;UniformCartesian&lt;3U, 
double&gt; &gt; unsigned (Message, int)
    </screen>

  </refsect1>


  <refsect1>
    <title>See Also</title>
<para>
    <xref linkend="CT" />,
    <xref linkend="TAU_PROFILE" />,
    <xref linkend="TAU_PROFILE_TIMER" />
  </para>
</refsect1>

</refentry>



<refentry id="TAU_DB_DUMP">
  <refmeta>
    <refentrytitle>TAU_DB_DUMP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_DUMP</refname>
  <refpurpose>Dumps the profile database to disk</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Dumps the profile database to disk.  The format of the files is the
    same as regular profiles, they are simply prefixed with "dump" instead of
    "profile".</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_DUMP();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DB_DUMP()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP_PREFIX" />,
      <xref linkend="TAU_DB_DUMP_INCR" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />,
      <xref linkend="TAU_DUMP_FUNC_VALS_INCR" />,
      <xref linkend="TAU_DB_PURGE" />,
      <xref linkend="TAU_PROFILE_EXIT" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_DB_MERGED_DUMP">
  <refmeta>
    <refentrytitle>TAU_DB_MERGED_DUMP</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_MERGED_DUMP</refname>
  <refpurpose>Dumps the profile database to disk</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_MERGED_DUMP</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_MERGED_DUMP</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Dumps the profile database to disk.  The format of the files is the
    same as merged profiles: tauprofile.xml </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_MERGED_DUMP();
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DB_MERGED_DUMP()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP_PREFIX" />,
      <xref linkend="TAU_DB_DUMP_INCR" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />,
      <xref linkend="TAU_DUMP_FUNC_VALS_INCR" />,
      <xref linkend="TAU_DB_PURGE" />,
      <xref linkend="TAU_PROFILE_EXIT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DB_DUMP_INCR">
  <refmeta>
    <refentrytitle>TAU_DB_DUMP_INCR</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_DUMP_INCR</refname>
  <refpurpose>Dumps profile database into timestamped profiles on disk</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP_INCR</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This is similar to the TAU_DB_DUMP macro but it produces
    dump files that have a timestamp in their names. This allows the user to
    record timestamped incremental dumps as the application executes.
    </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_DUMP_INCR();
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.dbDumpIncr("prefix")
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />,
      <xref linkend="TAU_DB_DUMP_PREFIX" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />,
      <xref linkend="TAU_DUMP_FUNC_VALS_INCR" />,
      <xref linkend="TAU_DB_PURGE" />,
      <xref linkend="TAU_PROFILE_EXIT" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DB_DUMP_PREFIX">
  <refmeta>
    <refentrytitle>TAU_DB_DUMP_PREFIX</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_DUMP_PREFIX</refname>
  <refpurpose>Dumps the profile database into profile files with a given prefix</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP_PREFIX</function></funcdef>
      <paramdef>char *<parameter>prefix</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP_PREFIX</function></funcdef>
      <paramdef>character <parameter>prefix</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>TAU_DB_DUMP_PREFIX</literal> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_DUMP_PREFIX("prefix");      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DB_DUMP_PREFIX("prefix")
    </screen>
    <para><emphasis role="bold">Python :</emphasis></para>
    <screen>
import pytau

pytau.dbDump("prefix")
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_DB_DUMP_PREFIX_TASK">
  <refmeta>
    <refentrytitle>TAU_DB_DUMP_PREFIX_TASK</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_DUMP_PREFIX_TASK</refname>
  <refpurpose>Dumps the profile database into profile files with a given task</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP_PREFIX_TASK</function></funcdef>
      <paramdef>char *<parameter>PREFIX_TASK</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_DUMP_PREFIX_TASK</function></funcdef>
      <paramdef>character <parameter>prefix</parameter>(size)</paramdef>
      <paramdef>integer <parameter>task</parameter>(size)</paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>The <literal>TAU_DB_DUMP_PREFIX_TASK</literal> macro dumps all profile
    data to disk and records a checkpoint or a snapshot of the profile
    statistics on a
		particular task at that instant. The dump files are named
    &lt;prefix&gt;.&lt;node&gt;.&lt;context&gt;.&lt;thread&gt;. If prefix is
    "profile", the files are named profile.0.0.0, etc. and may be read by
    paraprof/pprof tools as the application executes.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid);      
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_DB_DUMP_PREFIX_TASK("PREFIX", taskid)
    </screen>
    <para><emphasis role="bold">Python :</emphasis></para>
    <screen>
import pytau

pytau.dbDump("PREFIX", taskid)
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP_PREFIX" />
    </para>
  </refsect1>

</refentry>



<refentry id="TAU_DB_PURGE">
  <refmeta>
    <refentrytitle>TAU_DB_PURGE</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DB_PURGE</refname>
  <refpurpose>Purges the performance data.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DB_PURGE</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Purges the performance data collected so far.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DB_PURGE();
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DUMP_FUNC_NAMES">
  <refmeta>
    <refentrytitle>TAU_DUMP_FUNC_NAMES</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DUMP_FUNC_NAMES</refname>
  <refpurpose>Dumps function names to disk</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DUMP_FUNC_NAMES</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>This macro writes the names of active functions to a file named dump_functionnames_&lt;node&gt;.&lt;context&gt;.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_DUMP_FUNC_NAMES();
    </screen>
    <para><emphasis role="bold">Python:</emphasis></para>
    <screen>
import pytau

pytau.dumpFuncNames()
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />,
      <xref linkend="TAU_DUMP_FUNC_VALS_INCR" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DUMP_FUNC_VALS">
  <refmeta>
    <refentrytitle>TAU_DUMP_FUNC_VALS</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DUMP_FUNC_VALS</refname>
  <refpurpose>Dumps performance data for given functions to disk.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DUMP_FUNC_VALS</function></funcdef>
      <paramdef>char **<parameter>inFuncs</parameter></paramdef>
      <paramdef>int <parameter>numFuncs</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_DUMP_FUNC_VALS</literal>  writes the data
    associated with the routines listed in inFuncs to disk. The number of
    routines is specified by the user in numFuncs.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>

    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS_INCR" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_DUMP_FUNC_VALS_INCR">
  <refmeta>
    <refentrytitle>TAU_DUMP_FUNC_VALS_INCR</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_DUMP_FUNC_VALS_INCR</refname>
  <refpurpose>Dumps function values with a timestamp</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_DUMP_FUNC_VALS_INCR</function></funcdef>
      <paramdef>char **<parameter>inFuncs</parameter></paramdef>
      <paramdef>int <parameter>numFuncs</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Similar to <literal>TAU_DUMP_FUNC_VALS</literal>. This macro
    creates an incremental selective dump and dumps the results with a date
    stamp to the filename such as
    sel_dump__Thu-Mar-28-16:30:48-2002__.0.0.0. In this manner the previous
    <literal>TAU_DUMP_FUNC_VALS_INCR(...)</literal> are not overwritten
    (unless they occur within a second).</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
const char **inFuncs;
/* The first dimension is functions, and the second dimension is counters */
double **counterExclusiveValues;
double **counterInclusiveValues;
int *numOfCalls;
int *numOfSubRoutines;
const char **counterNames;
int numOfCouns;

TAU_GET_FUNC_VALS(inFuncs, 2,
  counterExclusiveValues,
  counterInclusiveValues,
  numOfCalls,
  numOfSubRoutines,
  counterNames,
  numOfCouns);

TAU_DUMP_FUNC_VALS(inFuncs, 2);
    </screen>
		<para><emphasis role="bold">Python:</emphasis></para>
		<screen>
import pytau

pytau.dumpFuncValsIncr("foo", "bar", "bar2")
		</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_DB_DUMP" />,
      <xref linkend="TAU_DUMP_FUNC_NAMES" />,
      <xref linkend="TAU_DUMP_FUNC_VALS" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_PROFILE_STMT">
  <refmeta>
    <refentrytitle>TAU_PROFILE_STMT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_STMT</refname>
  <refpurpose>Executes a statement only when TAU is used.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_STMT</function></funcdef>
      <paramdef>statement <parameter>statement</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_STMT</literal> executes a statement, or declares
    a variable that is used only during profiling or for execution of a
    statement that takes place only when the instrumentation is active.  When
    instrumentation is inactive (i.e., when profiling and tracing are turned
    off as described in Chapter 2), all macros are defined as null. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE_STMT(T obj;); // T is a template parameter)
TAU_TYPE_STRING(str, "void () " + CT(obj) );
    </screen>
  </refsect1>
</refentry>



<refentry id="TAU_PROFILE_CALLSTACK">
  <refmeta>
    <refentrytitle>TAU_PROFILE_CALLSTACK</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_CALLSTACK</refname>
  <refpurpose>Generates a callstack trace at a given location.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_CALLSTACK</function></funcdef>
      <void/>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>When TAU is configured with <literal>-PROFILECALLSTACK</literal>
    configuration option, and this call is invoked, a callpath trace is
    generated. A GUI for viewing this trace is included in TAU's utils/csUI
    directory. This option is deprecated.</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
TAU_PROFILE_CALLSTACK();
    </screen>
  </refsect1>
</refentry>

<refentry id="TAU_TRACE_RECVMSG">
  <refmeta>
    <refentrytitle>TAU_TRACE_RECVMSG</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACE_RECVMSG</refname>
  <refpurpose>Traces a receive operation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACE_RECVMSG</function></funcdef>
      <paramdef>int <parameter>tag</parameter></paramdef>
      <paramdef>int <parameter>source</parameter></paramdef>
      <paramdef>int <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACE_RECVMSG</function></funcdef>
      <paramdef>integer <parameter>tag</parameter></paramdef>
      <paramdef>integer <parameter>source</parameter></paramdef>
      <paramdef>integer <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para> <literal>TAU_TRACE_RECVMSG</literal>  traces a receive operation where tag represents the type of the message received from the source process.</para>

    <para><emphasis>NOTE:</emphasis> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <literal>TAU_TRACE_RECVMSG</literal>  and
    <literal>TAU_TRACE_SENDMSG</literal>  macros are not required. The wrapper
    interposition library in <screen>$(TAU_MPI_LIBS)</screen> uses these
    macros internally for logging messages. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </screen>
  </refsect1>


  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACE_SENDMSG" />
    </para>
  </refsect1>

</refentry>


<refentry id="TAU_TRACE_SENDMSG">
  <refmeta>
    <refentrytitle>TAU_TRACE_SENDMSG</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_TRACE_SENDMSG</refname>
  <refpurpose>Traces a receive operation</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACE_SENDMSG</function></funcdef>
      <paramdef>int <parameter>tag</parameter></paramdef>
      <paramdef>int <parameter>source</parameter></paramdef>
      <paramdef>int <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_TRACE_SENDMSG</function></funcdef>
      <paramdef>integer <parameter>tag</parameter></paramdef>
      <paramdef>integer <parameter>source</parameter></paramdef>
      <paramdef>integer <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_TRACE_SENDMSG</literal> traces an inter-process message communication when a tagged message is sent to a destination process. </para>

    <para><emphasis>NOTE:</emphasis> When TAU is configured to use
    MPI (-mpiinc=&lt;dir&gt; -mpilib=&lt;dir&gt;), the
    <literal>TAU_TRACE_SENDMSG</literal>  and
    <literal>TAU_TRACE_SENDMSG</literal>  macros are not required. The wrapper
    interposition library in <screen>$(TAU_MPI_LIBS)</screen> uses these
    macros internally for logging messages. </para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
if (pid == 0) {
  TAU_TRACE_SENDMSG(currCol, sender, ncols * sizeof(T));
  MPI_Send(vctr2, ncols * sizeof(T), MPI_BYTE, sender, 
           currCol, MPI_COMM_WORLD);
} else {
  MPI_Recv(&amp;ans, sizeof(T), MPI_BYTE, MPI_ANY_SOURCE, 
           MPI_ANY_TAG,MPI_COMM_WORLD, &amp;stat);
  MPI_Get_count(&amp;stat, MPI_BYTE, &amp;recvcount);
  TAU_TRACE_RECVMSG(stat.MPI_TAG, stat.MPI_SOURCE, recvcount);
}
    </screen>

    <para><emphasis role="bold">Fortran :</emphasis></para>
    <screen>
call TAU_TRACE_RECVMSG(tag, source, length)
call TAU_TRACE_SENDMSG(tag, destination, length)
    </screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_TRACE_RECVMSG" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_PROFILE_PARAM1L">
  <refmeta>
    <refentrytitle>TAU_PROFILE_PARAM1L</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_PARAM1L</refname>
  <refpurpose>Creates a snapshot of the current apllication profile</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_PARAM1L</function></funcdef>
      <paramdef>long <parameter>number</parameter></paramdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_PARAM1L</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
      <paramdef>integer <parameter>number</parameter></paramdef>
      <paramdef>integer <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Track the a given numerial parameter to a function and records each
		value as a seperate event. <literal>number</literal> is the parameter to be
		tracked. <literal>name</literal> is the name of this event.</para>

  </refsect1>

	<refsect1><title>Example</title>
		<para><emphasis role='bold'>C/C++:</emphasis><screen>
int f1(int x)
{
  TAU_PROFILE("f1()", "", TAU_USER);
  TAU_PROFILE_PARAM1L((long) x, "x");
	...
</screen></para>
		<para><emphasis role='bold'>Fortran:</emphasis><screen>
 subroutine ITERATION(val)
  integer val
  integer profiler(2) / 0, 0 /
  save profiler

  call TAU_PROFILE_TIMER(profiler, 'INTERATION')
  call TAU_PROFILE_START(profiler)

 	call TAU_PROFILE_PARAM1L('value', val, 4) 

	....

	call TAU_PROFILE_STOP(profiler)
  return
end
</screen></para>
	</refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_TIMER_DYNAMIC" />
    </para>
  </refsect1>

</refentry>
<refentry id="TAU_PROFILE_SNAPSHOT">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SNAPSHOT</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SNAPSHOT</refname>
  <refpurpose>Creates a snapshot of the current apllication profile</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SNAPSHOT</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SNAPSHOT</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
      <paramdef>integer <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para><literal>TAU_PROFILE_SNAPSHOT</literal> writes a snapshot profile
    representing the program's execution up to this point. These file are
    written the system as snapshot.[node].[context].[thread] format. They can be
    merged by appending one to another. Uploading a snapshot to a PerfDMF
    database or packing them into a PPK file will condense them to a single
    profile (the last one).
    </para>

  </refsect1>

	<refsect1><title>Examples</title>
	   <para>C/C++:<screen>
TAU_PROFILE_SNAPSHOT(name);
</screen></para>
	   <para>Fortran:<screen>
TAU_PROFILE_SNAPSHOT(name, length);
</screen></para>
	   <para>Python:<screen>
import pytau;

pytau.snapshot("name")
</screen></para>
  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SNAPSHOT_1L" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_PROFILE_SNAPSHOT_1L">
  <refmeta>
    <refentrytitle>TAU_PROFILE_SNAPSHOT_1L</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv><refname>TAU_PROFILE_SNAPSHOT_1L</refname>
  <refpurpose>Creates a snapshot of the current apllication profile</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SNAPSHOT_1L</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
      <paramdef>int <parameter>number</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_PROFILE_SNAPSHOT_1L</function></funcdef>
      <paramdef>char* <parameter>name</parameter></paramdef>
      <paramdef>integer <parameter>number</parameter></paramdef>
      <paramdef>integer <parameter>length</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>Calls <literal>TAU_PROFILE_SNAPSHOT</literal> giving it the as a name
    the name with a number appended.</para>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILE_SNAPSHOT" />
    </para>
  </refsect1>

</refentry>

<refentry id="TAU_PROFILER_CREATE">
  <refmeta><refentrytitle>TAU_PROFILER_CREATE</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_CREATE</refname>
  <refpurpose>Creates a profiler object referenced as a standard pointer</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_CREATE</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>function_name</parameter></paramdef>
        <paramdef>char* or string&amp; <parameter>type</parameter></paramdef>
        <paramdef>taugroup_t <parameter>group</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_CREATE</function> creates a
    timer the that can be controlled by the Timer pointer object.</para>
		<para>The TAU_PROFILER_* API is intended for applications to easily layer
		their legacy timing measurements APIs on top of TAU, Unlike other TAU API
		calls (TAU_PROFILE_TIMER) that are statically expanded in the source code,
		these calls allocate TAU entities on the heap. So the pointer to the TAU
		timer may be used as a handle to access the TAU performance data.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</screen>
      <para>><emphasis role="bold">Python:</emphasis></para> 
<screen>
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_CREATE_TASK">
  <refmeta><refentrytitle>TAU_CREATE_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_CREATE_TASK</refname>
  <refpurpose>Creates a task id.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_CREATE_TASK</function></funcdef>
        <paramdef>Integer <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
  <para><function>TAU_CREATE_TASK</function> creates a task with id 'taskid'
	this task is an independent event stream for which Profiler objects can be
	started and stop on. TAU will increment the taskids as needed an write out
	profiles and traces from the task as if they were thread.
	</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</screen>

  </refsect1>
  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_START_TASK" />
      <xref linkend="TAU_PROFILER_STOP_TASK" />
      <xref linkend="TAU_PROFILER_GET_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO_TASK" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_START">
  <refmeta><refentrytitle>TAU_PROFILER_START</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_START</refname>
  <refpurpose>starts a profiler object created by <xref linkend="TAU_PROFILER_CREATE" /></refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_START</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_START</function>starts a profiler
    timer by passing the pointer created by the <xref linkend="TAU_PROFILER_CREATE" />.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</screen>
      <para>><emphasis role="bold">Python:</emphasis></para> 
<screen>
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_START_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_START_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_START_TASK</refname>
  <refpurpose>Starts a profiler object created by <xref
	linkend="TAU_PROFILER_CREATE" /> on a given task.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_START_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_START_TASK</function>starts a profiler timer on
		a task by passing the pointer created by the <xref
		linkend="TAU_PROFILER_CREATE" /> and a task created by <xref
		linkend="TAU_CREATE_TASK" /> on a given task.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_STOP">
  <refmeta><refentrytitle>TAU_PROFILER_STOP</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_STOP</refname>
  <refpurpose>stops a profiler object created by <xref linkend="TAU_PROFILER_CREATE" /></refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_STOP</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_STOP</function>stops a profiler
    timer by passing the pointer created by the <xref linkend="TAU_PROFILER_CREATE" />.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr); 
</screen>
      <para>><emphasis role="bold">Python:</emphasis></para> 
<screen>
import pytau
ptr = pytau.profileTimer("foo")

pytau.start(ptr)
foo(2)
pytau.stop(ptr) 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_STOP_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_STOP_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_STOP_TASK</refname>
  <refpurpose>Stops a profiler object on a task</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_STOP_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_STOP_TASK</function>STOPs a profiler timer on a
		task by passing the pointer created by the <xref
		linkend="TAU_PROFILER_CREATE" /> and a task created by <xref linkend="TAU_CREATE_TASK" />.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr,taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr,taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_CALLS">
  <refmeta><refentrytitle>TAU_PROFILER_GET_CALLS</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_CALLS</refname>
  <refpurpose>Gets the number of times this timer, created by <xref
	linkend="TAU_PROFILER_CREATE" />, is started.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_CALLS</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>long&amp; <parameter>calls</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_CALLS</function> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS(ptr, &amp;calls); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_CALLS_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_GET_CALLS_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_CALLS_TASK</refname>
  <refpurpose>Gets the number of times this timer, created by <xref
	linkend="TAU_PROFILER_CREATE" />, is started on a given task.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_CALLS_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>long&amp; <parameter>calls</parameter></paramdef>
        <paramdef>int <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_CALLS_TASK</function> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed) on a given task.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long calls;
TAU_PROFILER_GET_CALLS_TASK(ptr, &amp;calls, taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_CREATE_TASK" />
      <xref linkend="TAU_PROFILER_START_TASK" />
      <xref linkend="TAU_PROFILER_STOP_TASK" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO_TASK" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_CHILD_CALLS">
  <refmeta><refentrytitle>TAU_PROFILER_GET_CHILD_CALLS</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_CHILD_CALLS</refname>
  <refpurpose>Gets the number of calls made while this timer was running</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_CHILD_CALLS</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>long&amp; <parameter>calls</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_CHILD_CALLS</function>
    Gets the number of timers started while <literal>timer</literal> was
		running. This is non-recursive, only timers started directly count.</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

long calls;
TAU_PROFILER_GET_CHILD_CALLS(ptr, &amp;calls); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>
<refentry id="TAU_PROFILER_GET_CHILD_CALLS_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_GET_CHILD_CALLS_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_CHILD_CALLS_TASK</refname>
  <refpurpose>Gets the number of child call for this timer, created by <xref
	linkend="TAU_PROFILER_CREATE" />, is started on a task.</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_CHILD_CALLS_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>long&amp; <parameter>child_calls</parameter></paramdef>
        <paramdef>int <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_CHILD_CALLS_TASK</function> returns the number of
    times this timer is started (ie. The number of times the section of code
		being profiled was executed).</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
long child_calls;
TAU_PROFILER_GET_CHILD_CALLS_TASK(ptr, &amp;child_calls, taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_CREATE_TASK" />
      <xref linkend="TAU_PROFILER_START_TASK" />
      <xref linkend="TAU_PROFILER_STOP_TASK" />
      <xref linkend="TAU_PROFILER_GET_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO_TASK" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_INCLUSIVE_VALUES">
  <refmeta><refentrytitle>TAU_PROFILER_GET_INCLUSIVE_VALUES</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_INCLUSIVE_VALUES</refname>
  <refpurpose>Returns the inclusive amount of a metric spend by this timer.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_INCLUSIVE_VALUES</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>double&amp; <parameter>incl</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_INCLUSIVE_VALUES</function>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer.)
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES(ptr, &amp;incl); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>
<refentry id="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</refname>
  <refpurpose>Returns the inclusive amount of a metric spend by this timer on a
	given task.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>double&amp; <parameter>incl</parameter></paramdef>
        <paramdef>int <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK</function>
    Returns the inclusive amount of a metric spend while this timer
	was running (and any subsequent timers called from this timer) on a given
	task.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double incl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK(ptr, &amp;incl, taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_CREATE_TASK" />
      <xref linkend="TAU_PROFILER_START_TASK" />
      <xref linkend="TAU_PROFILER_STOP_TASK" />
      <xref linkend="TAU_PROFILER_GET_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO_TASK" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_EXCLUSIVE_VALUES">
  <refmeta><refentrytitle>TAU_PROFILER_GET_EXCLUSIVE_VALUES</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_EXCLUSIVE_VALUES</refname>
  <refpurpose>Returns the exclusive amount of a metric spend by this timer.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_EXCLUSIVE_VALUES</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>double&amp; <parameter>excl</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_EXCLUSIVE_VALUES</function>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running.)
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES(ptr, &amp;excl); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</refname>
  <refpurpose>Returns the exclusive amount of a metric spend by this timer on a
	given task.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</function></funcdef>
        <paramdef>Timer <parameter>timer</parameter></paramdef>
        <paramdef>double&amp; <parameter>excl</parameter></paramdef>
        <paramdef>int <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK</function>
    Returns the exclusive amount of the metric spend while this timer
	was running (and while no other subsequent timers was running) on a given
	task.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

double excl[TAU_MAX_COUNTERS];
TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK(ptr, &amp;excl, taskid); 
</screen>
  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_COUNTER_INFO" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_COUNTER_INFO">
  <refmeta><refentrytitle>TAU_PROFILER_GET_COUNTER_INFO</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_COUNTER_INFO</refname>
  <refpurpose>Returns information about all the timers created.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_COUNTER_INFO</function></funcdef>
        <paramdef>const char * <parameter>counters</parameter></paramdef>
        <paramdef>int &amp;<parameter>num_counters</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_COUNTER_INFO</function>
		  Gets the number of counters created and an array of the counters
			containing information about the counters.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);

TAU_PROFILER_START(ptr);
foo(2);
TAU_PROFILER_STOP(ptr);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO(&amp;counters, &amp;numcounters);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf(">>>");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_PROFILER_CREATE" />
      <xref linkend="TAU_PROFILER_START" />
      <xref linkend="TAU_PROFILER_STOP" />
      <xref linkend="TAU_PROFILER_GET_CALLS" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_PROFILER_GET_COUNTER_INFO_TASK">
  <refmeta><refentrytitle>TAU_PROFILER_GET_COUNTER_INFO_TASK</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_PROFILER_GET_COUNTER_INFO_TASK</refname>
  <refpurpose>Returns information about all the timers created on a task. 
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_PROFILER_GET_COUNTER_INFO_TASK</function></funcdef>
        <paramdef>const char * <parameter>counters</parameter></paramdef>
        <paramdef>int &amp;<parameter>num_counters</parameter></paramdef>
        <paramdef>int <parameter>taskid</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_PROFILER_GET_COUNTER_INFO_TASK</function>
		  Gets the number of counters created and an array of the counters
			containing information about the counters on a given task.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
void *ptr;
int taskid;
TAU_PROFILER_CREATE(ptr, "foo","", TAU_USER);
TAU_CREATE_TASK(taskid);
TAU_PROFILER_START_TASK(ptr, taskid);
foo(2);
TAU_PROFILER_STOP_TASK(ptr, taskid);

const char **counters;
int numcounters;

TAU_PROFILER_GET_COUNTER_INFO_TASK(&amp;counters, &amp;numcounters, taskid);
printf("numcounters = %d\n", numcounters);
for (j = 0; j &lt; numcounters ; j++) 
{
	printf(">>>");
	printf("counter [%d] = %s\n", j, counters[j]);
}
</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
      <xref linkend="TAU_CREATE_TASK" />
      <xref linkend="TAU_PROFILER_START_TASK" />
      <xref linkend="TAU_PROFILER_STOP_TASK" />
      <xref linkend="TAU_PROFILER_GET_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_CHILD_CALLS_TASK" />
      <xref linkend="TAU_PROFILER_GET_INCLUSIVE_VALUES_TASK" />
      <xref linkend="TAU_PROFILER_GET_EXCLUSIVE_VALUES_TASK" />
    </para>
  </refsect1>
</refentry>

<refentry id="TAU_QUERY_DECLARE_EVENT">
  <refmeta><refentrytitle>TAU_QUERY_DECLARE_EVENT</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_QUERY_DECLARE_EVENT</refname>
  <refpurpose>Returns a event handle.
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_QUERY_DECLARE_EVENT</function></funcdef>
        <paramdef>void * <parameter>event</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_QUERY_DECLARE_EVENT</function>
			Creates a event handle for querying TAU events.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
<xref linkend="TAU_QUERY_DECLARE_EVENT" />
<xref linkend="TAU_QUERY_GET_CURRENT_EVENT" />
<xref linkend="TAU_QUERY_GET_EVENT_NAME" />
<xref linkend="TAU_QUERY_GET_PARENT_EVENT" />
    </para>
  </refsect1>
</refentry>
<refentry id="TAU_QUERY_GET_CURRENT_EVENT">
  <refmeta><refentrytitle>TAU_QUERY_GET_CURRENT_EVENT</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_QUERY_GET_CURRENT_EVENT</refname>
  <refpurpose>set event to be the current TAU event. 
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_QUERY_GET_CURRENT_EVENT</function></funcdef>
        <paramdef>void * <parameter>event</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_QUERY_GET_CURRENT_EVENT</function>
			Set event to be the current TAU event in the context in which this call is
			made.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
<xref linkend="TAU_QUERY_DECLARE_EVENT" />
<xref linkend="TAU_QUERY_GET_CURRENT_EVENT" />
<xref linkend="TAU_QUERY_GET_EVENT_NAME" />
<xref linkend="TAU_QUERY_GET_PARENT_EVENT" />
    </para>
  </refsect1>
</refentry>
<refentry id="TAU_QUERY_GET_EVENT_NAME">
  <refmeta><refentrytitle>TAU_QUERY_GET_EVENT_NAME</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_QUERY_GET_EVENT_NAME</refname>
  <refpurpose>Gets the name of a given event. 
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_QUERY_GET_EVENT_NAME</function></funcdef>
        <paramdef>void * <parameter>event</parameter></paramdef>
        <paramdef>char * <parameter>str</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_QUERY_GET_EVENT_NAME</function>
			Set str to be the event name to the given event name.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_CURRENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("current event is: %d.\n", str);

</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
<xref linkend="TAU_QUERY_DECLARE_EVENT" />
<xref linkend="TAU_QUERY_GET_CURRENT_EVENT" />
<xref linkend="TAU_QUERY_GET_EVENT_NAME" />
<xref linkend="TAU_QUERY_GET_PARENT_EVENT" />
    </para>
  </refsect1>
</refentry>
<refentry id="TAU_QUERY_GET_PARENT_EVENT">
  <refmeta><refentrytitle>TAU_QUERY_GET_PARENT_EVENT</refentrytitle></refmeta>
  
  <refnamediv><refname>TAU_QUERY_GET_PARENT_EVENT</refname>
  <refpurpose>gets the parent of the current event. 
	</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo> 
      <funcprototype>
        <funcdef><function>TAU_QUERY_GET_PARENT_EVENT</function></funcdef>
        <paramdef>void * <parameter>event</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  
  <refsect1><title>description</title>
    <para><function>TAU_QUERY_GET_PARENT_EVENT</function>
			Set event to be the parent  event to the current event.
		</para>
  </refsect1>
  
  <refsect1><title>example</title>
      <para>><emphasis role="bold">C/C++:</emphasis></para> 
<screen>
char[100] str;
TAU_QUERY_DECLARE_EVENT(event);
TAU_QUERY_GET_PARENT_EVENT(event);
TAU_QUERY_GET_EVENT_NAME(event, str);

printf("parent event is: %d.\n", str);

</screen>

  </refsect1>

  <refsect1>
    <title>See Also</title>
    <para>
<xref linkend="TAU_QUERY_DECLARE_EVENT" />
<xref linkend="TAU_QUERY_GET_CURRENT_EVENT" />
<xref linkend="TAU_QUERY_GET_EVENT_NAME" />
<xref linkend="TAU_QUERY_GET_PARENT_EVENT" />
    </para>
  </refsect1>
</refentry>
<!--


<refentry id="TAU_?">
<refmeta>
<refentrytitle>TAU_?</refentrytitle>
<manvolnum>3</manvolnum>
</refmeta>
  <refnamediv><refname>TAU_?</refname>
  <refpurpose>?</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_?</function></funcdef>
      <paramdef>? <parameter>?</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>?</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
?
    </screen>
  </refsect1>
</refentry>



<refentry id="TAU_?"><refmeta><refentrytitle>TAU_?</refentrytitle></refmeta>
  <refnamediv><refname>TAU_?</refname>
  <refpurpose>?</refpurpose></refnamediv>
  
  <refsynopsisdiv>
    <funcsynopsis><funcsynopsisinfo>C/C++:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_?</function></funcdef>
      <paramdef>? <parameter>?</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>

    <funcsynopsis><funcsynopsisinfo>Fortran:</funcsynopsisinfo>
    <funcprototype>
      <funcdef><function>TAU_?</function></funcdef>
      <paramdef>? <parameter>?</parameter></paramdef>
    </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  
  <refsect1><title>Description</title>
    <para>?</para>
  </refsect1>
  
  <refsect1><title>Example</title>
    
    <para><emphasis role="bold">C/C++ :</emphasis></para>
    <screen>
    </screen>

  </refsect1>
</refentry>


-->






<!-- ********************* -->

</reference>

